[
  {
    "function_name": "ocfs2_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.h",
    "lines": "58-75",
    "snippet": "static inline int ocfs2_read_block(struct ocfs2_caching_info *ci, u64 off,\n\t\t\t\t   struct buffer_head **bh,\n\t\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint status = 0;\n\n\tif (bh == NULL) {\n\t\tprintk(\"ocfs2: bh == NULL\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_blocks(ci, off, 1, bh, 0, validate);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "ci",
            "off",
            "1",
            "bh",
            "0",
            "validate"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ocfs2: bh == NULL\\n\""
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline int ocfs2_read_block(struct ocfs2_caching_info *ci, u64 off,\n\t\t\t\t   struct buffer_head **bh,\n\t\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint status = 0;\n\n\tif (bh == NULL) {\n\t\tprintk(\"ocfs2: bh == NULL\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_blocks(ci, off, 1, bh, 0, validate);\n\nbail:\n\treturn status;\n}"
  }
]