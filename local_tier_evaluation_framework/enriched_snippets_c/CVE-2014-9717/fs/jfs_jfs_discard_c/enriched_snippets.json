[
  {
    "function_name": "jfs_ioc_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_discard.c",
    "lines": "80-121",
    "snippet": "int jfs_ioc_trim(struct inode *ip, struct fstrim_range *range)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tint agno, agno_end;\n\tu64 start, end, minlen;\n\tu64 trimmed = 0;\n\n\t/**\n\t * convert byte values to block size of filesystem:\n\t * start:\tFirst Byte to trim\n\t * len:\t\tnumber of Bytes to trim from start\n\t * minlen:\tminimum extent length in Bytes\n\t */\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\tif (minlen == 0)\n\t\tminlen = 1;\n\n\tif (minlen > bmp->db_agsize ||\n\t    start >= bmp->db_mapsize ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tif (end >= bmp->db_mapsize)\n\t\tend = bmp->db_mapsize - 1;\n\n\t/**\n\t * we trim all ag's within the range\n\t */\n\tagno = BLKTOAG(start, JFS_SBI(ip->i_sb));\n\tagno_end = BLKTOAG(end, JFS_SBI(ip->i_sb));\n\twhile (agno <= agno_end) {\n\t\ttrimmed += dbDiscardAG(ip, agno, minlen);\n\t\tagno++;\n\t}\n\trange->len = trimmed << sb->s_blocksize_bits;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_discard.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbDiscardAG",
          "args": [
            "ip",
            "agno",
            "minlen"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "dbDiscardAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1619-1697",
          "snippet": "s64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc(sizeof(struct range2trim) * range_cnt, GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1 << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindBits(u32 word, int l2nb);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbGetL2AGSize(s64 nblocks);\n\ns64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc(sizeof(struct range2trim) * range_cnt, GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1 << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "end",
            "JFS_SBI(ip->i_sb)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "start",
            "JFS_SBI(ip->i_sb)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_discard.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint jfs_ioc_trim(struct inode *ip, struct fstrim_range *range)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tint agno, agno_end;\n\tu64 start, end, minlen;\n\tu64 trimmed = 0;\n\n\t/**\n\t * convert byte values to block size of filesystem:\n\t * start:\tFirst Byte to trim\n\t * len:\t\tnumber of Bytes to trim from start\n\t * minlen:\tminimum extent length in Bytes\n\t */\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\tif (minlen == 0)\n\t\tminlen = 1;\n\n\tif (minlen > bmp->db_agsize ||\n\t    start >= bmp->db_mapsize ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tif (end >= bmp->db_mapsize)\n\t\tend = bmp->db_mapsize - 1;\n\n\t/**\n\t * we trim all ag's within the range\n\t */\n\tagno = BLKTOAG(start, JFS_SBI(ip->i_sb));\n\tagno_end = BLKTOAG(end, JFS_SBI(ip->i_sb));\n\twhile (agno <= agno_end) {\n\t\ttrimmed += dbDiscardAG(ip, agno, minlen);\n\t\tagno++;\n\t}\n\trange->len = trimmed << sb->s_blocksize_bits;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_issue_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_discard.c",
    "lines": "45-64",
    "snippet": "void jfs_issue_discard(struct inode *ip, u64 blkno, u64 nblocks)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint r = 0;\n\n\tr = sb_issue_discard(sb, blkno, nblocks, GFP_NOFS, 0);\n\tif (unlikely(r != 0)) {\n\t\tjfs_err(\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\",\n\t\t\tsb, (unsigned long long)blkno,\n\t\t\t(unsigned long long)nblocks, r);\n\t}\n\n\tjfs_info(\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\",\n\t\tsb, (unsigned long long)blkno,\n\t\t(unsigned long long)nblocks, r);\n\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_discard.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\"",
            "sb",
            "(unsigned long long)blkno",
            "(unsigned long long)nblocks",
            "r"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\"",
            "sb",
            "(unsigned long long)blkno",
            "(unsigned long long)nblocks",
            "r"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r != 0"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "blkno",
            "nblocks",
            "GFP_NOFS",
            "0"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_discard.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid jfs_issue_discard(struct inode *ip, u64 blkno, u64 nblocks)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint r = 0;\n\n\tr = sb_issue_discard(sb, blkno, nblocks, GFP_NOFS, 0);\n\tif (unlikely(r != 0)) {\n\t\tjfs_err(\"JFS: sb_issue_discard\" \\\n\t\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d => failed!\\n\",\n\t\t\tsb, (unsigned long long)blkno,\n\t\t\t(unsigned long long)nblocks, r);\n\t}\n\n\tjfs_info(\"JFS: sb_issue_discard\" \\\n\t\t\"(%p, %llu, %llu, GFP_NOFS, 0) = %d\\n\",\n\t\tsb, (unsigned long long)blkno,\n\t\t(unsigned long long)nblocks, r);\n\n\treturn;\n}"
  }
]