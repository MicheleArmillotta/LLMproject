[
  {
    "function_name": "cifs_add_pending_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "634-641",
    "snippet": "void\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&cifs_file_list_lock);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_add_pending_open_locked",
          "args": [
            "fid",
            "tlink",
            "open"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_pending_open_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "621-632",
          "snippet": "void\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n#ifdef CONFIG_CIFS_SMB2\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n#ifdef CONFIG_CIFS_SMB2\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&cifs_file_list_lock);\n}"
  },
  {
    "function_name": "cifs_add_pending_open_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "621-632",
    "snippet": "void\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n#ifdef CONFIG_CIFS_SMB2\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&open->olist",
            "&tlink_tcon(tlink)->pending_opens"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "open->lease_key",
            "fid->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n#ifdef CONFIG_CIFS_SMB2\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}"
  },
  {
    "function_name": "cifs_del_pending_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "613-619",
    "snippet": "void\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&open->olist"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}"
  },
  {
    "function_name": "backup_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "598-611",
    "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "cifs_sb->mnt_backupgid"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cifs_sb->mnt_backupuid",
            "current_fsuid()"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "cifs_done_oplock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "592-596",
    "snippet": "void cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cinode->flags",
            "CIFS_INODE_PENDING_OPLOCK_BREAK"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CIFS_INODE_PENDING_OPLOCK_BREAK",
            "&cinode->flags"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}"
  },
  {
    "function_name": "cifs_put_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "581-590",
    "snippet": "void cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cinode->writers_lock"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cinode->flags",
            "CIFS_INODE_PENDING_WRITERS"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CIFS_INODE_PENDING_WRITERS",
            "&cinode->flags"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cinode->writers_lock"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}"
  },
  {
    "function_name": "cifs_get_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "553-579",
    "snippet": "int cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t/* Check to see if we have started servicing an oplock break */\n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cinode->writers_lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cinode->flags",
            "CIFS_INODE_PENDING_WRITERS"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CIFS_INODE_PENDING_WRITERS",
            "&cinode->flags"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CIFS_INODE_PENDING_OPLOCK_BREAK",
            "&cinode->flags"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CIFS_INODE_PENDING_WRITERS",
            "&cinode->flags"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cinode->writers_lock"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&cinode->flags",
            "CIFS_INODE_PENDING_OPLOCK_BREAK",
            "TASK_KILLABLE"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nint cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t/* Check to see if we have started servicing an oplock break */\n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_set_oplock_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "533-547",
    "snippet": "void cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Level II Oplock granted on inode %p\\n\"",
            "&cinode->vfs_inode"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Exclusive Oplock granted on inode %p\\n\"",
            "&cinode->vfs_inode"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}"
  },
  {
    "function_name": "cifs_autodisable_serverino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "523-531",
    "snippet": "void\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\",\n\t\t\t cifs_sb_master_tcon(cifs_sb)->treeName);\n\t}\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\"",
            "cifs_sb_master_tcon(cifs_sb)->treeName"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\",\n\t\t\t cifs_sb_master_tcon(cifs_sb)->treeName);\n\t}\n}"
  },
  {
    "function_name": "dump_smb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "513-521",
    "snippet": "void\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_DEBUG",
            "\"\"",
            "DUMP_PREFIX_NONE",
            "8",
            "2",
            "buf",
            "smb_buf_length",
            "true"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}"
  },
  {
    "function_name": "is_valid_oplock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "396-511",
    "snippet": "bool\nis_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)\n{\n\tstruct smb_hdr *buf = (struct smb_hdr *)buffer;\n\tstruct smb_com_lock_req *pSMB = (struct smb_com_lock_req *)buf;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *pCifsInode;\n\tstruct cifsFileInfo *netfile;\n\n\tcifs_dbg(FYI, \"Checking for oplock break or dnotify response\\n\");\n\tif ((pSMB->hdr.Command == SMB_COM_NT_TRANSACT) &&\n\t   (pSMB->hdr.Flags & SMBFLG_RESPONSE)) {\n\t\tstruct smb_com_transaction_change_notify_rsp *pSMBr =\n\t\t\t(struct smb_com_transaction_change_notify_rsp *)buf;\n\t\tstruct file_notify_information *pnotify;\n\t\t__u32 data_offset = 0;\n\t\tif (get_bcc(buf) > sizeof(struct file_notify_information)) {\n\t\t\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\n\t\t\tpnotify = (struct file_notify_information *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\t\tcifs_dbg(FYI, \"dnotify on %s Action: 0x%x\\n\",\n\t\t\t\t pnotify->FileName, pnotify->Action);\n\t\t\t/*   cifs_dump_mem(\"Rcvd notify Data: \",buf,\n\t\t\t\tsizeof(struct smb_hdr)+60); */\n\t\t\treturn true;\n\t\t}\n\t\tif (pSMBr->hdr.Status.CifsError) {\n\t\t\tcifs_dbg(FYI, \"notify err 0x%x\\n\",\n\t\t\t\t pSMBr->hdr.Status.CifsError);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tif (pSMB->hdr.Command != SMB_COM_LOCKING_ANDX)\n\t\treturn false;\n\tif (pSMB->hdr.Flags & SMBFLG_RESPONSE) {\n\t\t/* no sense logging error on invalid handle on oplock\n\t\t   break - harmless race between close request and oplock\n\t\t   break response is expected from time to time writing out\n\t\t   large dirty files cached on the client */\n\t\tif ((NT_STATUS_INVALID_HANDLE) ==\n\t\t   le32_to_cpu(pSMB->hdr.Status.CifsError)) {\n\t\t\tcifs_dbg(FYI, \"invalid handle on oplock break\\n\");\n\t\t\treturn true;\n\t\t} else if (ERRbadfid ==\n\t\t   le16_to_cpu(pSMB->hdr.Status.DosError.Error)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false; /* on valid oplock brk we get \"request\" */\n\t\t}\n\t}\n\tif (pSMB->hdr.WordCount != 8)\n\t\treturn false;\n\n\tcifs_dbg(FYI, \"oplock type 0x%x level 0x%x\\n\",\n\t\t pSMB->LockType, pSMB->OplockLevel);\n\tif (!(pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE))\n\t\treturn false;\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &srv->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tlist_for_each(tmp1, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\n\t\t\tif (tcon->tid != buf->Tid)\n\t\t\t\tcontinue;\n\n\t\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &tcon->openFileList) {\n\t\t\t\tnetfile = list_entry(tmp2, struct cifsFileInfo,\n\t\t\t\t\t\t     tlist);\n\t\t\t\tif (pSMB->Fid != netfile->fid.netfid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcifs_dbg(FYI, \"file id match, oplock break\\n\");\n\t\t\t\tpCifsInode = CIFS_I(netfile->dentry->d_inode);\n\n\t\t\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t\t\t&pCifsInode->flags);\n\n\t\t\t\t/*\n\t\t\t\t * Set flag if the server downgrades the oplock\n\t\t\t\t * to L2 else clear.\n\t\t\t\t */\n\t\t\t\tif (pSMB->OplockLevel)\n\t\t\t\t\tset_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &pCifsInode->flags);\n\t\t\t\telse\n\t\t\t\t\tclear_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &pCifsInode->flags);\n\n\t\t\t\tqueue_work(cifsiod_wq,\n\t\t\t\t\t   &netfile->oplock_break);\n\t\t\t\tnetfile->oplock_break_cancelled = false;\n\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tcifs_dbg(FYI, \"No matching file for oplock break\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"Can not process oplock break for non-existent connection\\n\");\n\treturn true;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Can not process oplock break for non-existent connection\\n\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"No matching file for oplock break\\n\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&netfile->oplock_break"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2",
            "&pCifsInode->flags"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2",
            "&pCifsInode->flags"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "netfile->dentry->d_inode"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"file id match, oplock break\\n\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp2",
            "structcifsFileInfo",
            "tlist"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp2",
            "&tcon->openFileList"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_oplock_brks"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp1",
            "structcifs_tcon",
            "tcon_list"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp1",
            "&ses->tcon_list"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structcifs_ses",
            "smb_ses_list"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&srv->smb_ses_list"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"oplock type 0x%x level 0x%x\\n\"",
            "pSMB->LockType",
            "pSMB->OplockLevel"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pSMB->hdr.Status.DosError.Error"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"invalid handle on oplock break\\n\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pSMB->hdr.Status.CifsError"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"notify err 0x%x\\n\"",
            "pSMBr->hdr.Status.CifsError"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"dnotify on %s Action: 0x%x\\n\"",
            "pnotify->FileName",
            "pnotify->Action"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "buf"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Checking for oplock break or dnotify response\\n\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nis_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)\n{\n\tstruct smb_hdr *buf = (struct smb_hdr *)buffer;\n\tstruct smb_com_lock_req *pSMB = (struct smb_com_lock_req *)buf;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *pCifsInode;\n\tstruct cifsFileInfo *netfile;\n\n\tcifs_dbg(FYI, \"Checking for oplock break or dnotify response\\n\");\n\tif ((pSMB->hdr.Command == SMB_COM_NT_TRANSACT) &&\n\t   (pSMB->hdr.Flags & SMBFLG_RESPONSE)) {\n\t\tstruct smb_com_transaction_change_notify_rsp *pSMBr =\n\t\t\t(struct smb_com_transaction_change_notify_rsp *)buf;\n\t\tstruct file_notify_information *pnotify;\n\t\t__u32 data_offset = 0;\n\t\tif (get_bcc(buf) > sizeof(struct file_notify_information)) {\n\t\t\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\n\t\t\tpnotify = (struct file_notify_information *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\t\tcifs_dbg(FYI, \"dnotify on %s Action: 0x%x\\n\",\n\t\t\t\t pnotify->FileName, pnotify->Action);\n\t\t\t/*   cifs_dump_mem(\"Rcvd notify Data: \",buf,\n\t\t\t\tsizeof(struct smb_hdr)+60); */\n\t\t\treturn true;\n\t\t}\n\t\tif (pSMBr->hdr.Status.CifsError) {\n\t\t\tcifs_dbg(FYI, \"notify err 0x%x\\n\",\n\t\t\t\t pSMBr->hdr.Status.CifsError);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tif (pSMB->hdr.Command != SMB_COM_LOCKING_ANDX)\n\t\treturn false;\n\tif (pSMB->hdr.Flags & SMBFLG_RESPONSE) {\n\t\t/* no sense logging error on invalid handle on oplock\n\t\t   break - harmless race between close request and oplock\n\t\t   break response is expected from time to time writing out\n\t\t   large dirty files cached on the client */\n\t\tif ((NT_STATUS_INVALID_HANDLE) ==\n\t\t   le32_to_cpu(pSMB->hdr.Status.CifsError)) {\n\t\t\tcifs_dbg(FYI, \"invalid handle on oplock break\\n\");\n\t\t\treturn true;\n\t\t} else if (ERRbadfid ==\n\t\t   le16_to_cpu(pSMB->hdr.Status.DosError.Error)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false; /* on valid oplock brk we get \"request\" */\n\t\t}\n\t}\n\tif (pSMB->hdr.WordCount != 8)\n\t\treturn false;\n\n\tcifs_dbg(FYI, \"oplock type 0x%x level 0x%x\\n\",\n\t\t pSMB->LockType, pSMB->OplockLevel);\n\tif (!(pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE))\n\t\treturn false;\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &srv->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tlist_for_each(tmp1, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\n\t\t\tif (tcon->tid != buf->Tid)\n\t\t\t\tcontinue;\n\n\t\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &tcon->openFileList) {\n\t\t\t\tnetfile = list_entry(tmp2, struct cifsFileInfo,\n\t\t\t\t\t\t     tlist);\n\t\t\t\tif (pSMB->Fid != netfile->fid.netfid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcifs_dbg(FYI, \"file id match, oplock break\\n\");\n\t\t\t\tpCifsInode = CIFS_I(netfile->dentry->d_inode);\n\n\t\t\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t\t\t&pCifsInode->flags);\n\n\t\t\t\t/*\n\t\t\t\t * Set flag if the server downgrades the oplock\n\t\t\t\t * to L2 else clear.\n\t\t\t\t */\n\t\t\t\tif (pSMB->OplockLevel)\n\t\t\t\t\tset_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &pCifsInode->flags);\n\t\t\t\telse\n\t\t\t\t\tclear_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &pCifsInode->flags);\n\n\t\t\t\tqueue_work(cifsiod_wq,\n\t\t\t\t\t   &netfile->oplock_break);\n\t\t\t\tnetfile->oplock_break_cancelled = false;\n\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tcifs_dbg(FYI, \"No matching file for oplock break\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"Can not process oplock break for non-existent connection\\n\");\n\treturn true;\n}"
  },
  {
    "function_name": "checkSMB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "312-394",
    "snippet": "int\ncheckSMB(char *buf, unsigned int total_read)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;  /* calculated length */\n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t/* is this frame too small to even get to a BCC? */\n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t/* it's an error return */\n\t\t\tsmb->WordCount = 0;\n\t\t\t/* some error cases do not return wct and bcc */\n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t/* Need to work around a bug in two servers here */\n\t\t\t/* First, check if the part of bcc they sent was zero */\n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t/* some servers return only half of bcc\n\t\t\t\t * on simple responses (wct, bcc both zero)\n\t\t\t\t * in particular have seen this on\n\t\t\t\t * ulogoffX and FindClose. This leaves\n\t\t\t\t * one byte of bcc potentially unitialized\n\t\t\t\t */\n\t\t\t\t/* zero rest of bcc */\n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\t/* otherwise, there is enough to get to the BCC */\n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t/* check if bcc wrapped around for large read responses */\n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t/* check if lengths match mod 64K */\n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0; /* bcc wrapped */\n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t/*\n\t\t\t * Some servers (Windows XP in particular) send more\n\t\t\t * data than the lengths in the SMB packet would\n\t\t\t * indicate on certain calls (byte range locks and\n\t\t\t * trans2 find first calls in particular). While the\n\t\t\t * client can handle such a frame by ignoring the\n\t\t\t * trailing data, we choose limit the amount of extra\n\t\t\t * data to 512 bytes.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\"",
            "rfclen",
            "mid"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"RFC1001 size %u smaller than SMB for mid=%u\\n\"",
            "rfclen",
            "mid"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Calculated size %u vs length %u mismatch for mid=%u\\n\"",
            "clc_len",
            "4 + rfclen",
            "mid"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mid",
          "args": [
            "smb"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "681-685",
          "snippet": "static inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Length read does not match RFC1001 length %d\\n\"",
            "rfclen"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smbCalcSize",
          "args": [
            "smb"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "smbCalcSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "905-911",
          "snippet": "unsigned int\nsmbCalcSize(void *buf)\n{\n\tstruct smb_hdr *ptr = (struct smb_hdr *)buf;\n\treturn (sizeof(struct smb_hdr) + (2 * ptr->WordCount) +\n\t\t2 /* size of the bcc field */ + get_bcc(ptr));\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nunsigned int\nsmbCalcSize(void *buf)\n{\n\tstruct smb_hdr *ptr = (struct smb_hdr *)buf;\n\treturn (sizeof(struct smb_hdr) + (2 * ptr->WordCount) +\n\t\t2 /* size of the bcc field */ + get_bcc(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_smb_hdr",
          "args": [
            "smb"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "check_smb_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "289-310",
          "snippet": "static int\ncheck_smb_hdr(struct smb_hdr *smb)\n{\n\t/* does it have the right SMB \"signature\" ? */\n\tif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\n\t\tcifs_dbg(VFS, \"Bad protocol string signature header 0x%x\\n\",\n\t\t\t *(unsigned int *)smb->Protocol);\n\t\treturn 1;\n\t}\n\n\t/* if it's a response then accept */\n\tif (smb->Flags & SMBFLG_RESPONSE)\n\t\treturn 0;\n\n\t/* only one valid case where server sends us request */\n\tif (smb->Command == SMB_COM_LOCKING_ANDX)\n\t\treturn 0;\n\n\tcifs_dbg(VFS, \"Server sent request, not response. mid=%u\\n\",\n\t\t get_mid(smb));\n\treturn 1;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nstatic int\ncheck_smb_hdr(struct smb_hdr *smb)\n{\n\t/* does it have the right SMB \"signature\" ? */\n\tif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\n\t\tcifs_dbg(VFS, \"Bad protocol string signature header 0x%x\\n\",\n\t\t\t *(unsigned int *)smb->Protocol);\n\t\treturn 1;\n\t}\n\n\t/* if it's a response then accept */\n\tif (smb->Flags & SMBFLG_RESPONSE)\n\t\treturn 0;\n\n\t/* only one valid case where server sends us request */\n\tif (smb->Command == SMB_COM_LOCKING_ANDX)\n\t\treturn 0;\n\n\tcifs_dbg(VFS, \"Server sent request, not response. mid=%u\\n\",\n\t\t get_mid(smb));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Length less than smb header size\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"rcvd invalid byte count (bcc)\\n\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\"",
            "total_read",
            "rfclen"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "smb->smb_buf_length"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nint\ncheckSMB(char *buf, unsigned int total_read)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;  /* calculated length */\n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t/* is this frame too small to even get to a BCC? */\n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t/* it's an error return */\n\t\t\tsmb->WordCount = 0;\n\t\t\t/* some error cases do not return wct and bcc */\n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t/* Need to work around a bug in two servers here */\n\t\t\t/* First, check if the part of bcc they sent was zero */\n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t/* some servers return only half of bcc\n\t\t\t\t * on simple responses (wct, bcc both zero)\n\t\t\t\t * in particular have seen this on\n\t\t\t\t * ulogoffX and FindClose. This leaves\n\t\t\t\t * one byte of bcc potentially unitialized\n\t\t\t\t */\n\t\t\t\t/* zero rest of bcc */\n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\t/* otherwise, there is enough to get to the BCC */\n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t/* check if bcc wrapped around for large read responses */\n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t/* check if lengths match mod 64K */\n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0; /* bcc wrapped */\n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t/*\n\t\t\t * Some servers (Windows XP in particular) send more\n\t\t\t * data than the lengths in the SMB packet would\n\t\t\t * indicate on certain calls (byte range locks and\n\t\t\t * trans2 find first calls in particular). While the\n\t\t\t * client can handle such a frame by ignoring the\n\t\t\t * trailing data, we choose limit the amount of extra\n\t\t\t * data to 512 bytes.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_smb_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "289-310",
    "snippet": "static int\ncheck_smb_hdr(struct smb_hdr *smb)\n{\n\t/* does it have the right SMB \"signature\" ? */\n\tif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\n\t\tcifs_dbg(VFS, \"Bad protocol string signature header 0x%x\\n\",\n\t\t\t *(unsigned int *)smb->Protocol);\n\t\treturn 1;\n\t}\n\n\t/* if it's a response then accept */\n\tif (smb->Flags & SMBFLG_RESPONSE)\n\t\treturn 0;\n\n\t/* only one valid case where server sends us request */\n\tif (smb->Command == SMB_COM_LOCKING_ANDX)\n\t\treturn 0;\n\n\tcifs_dbg(VFS, \"Server sent request, not response. mid=%u\\n\",\n\t\t get_mid(smb));\n\treturn 1;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Server sent request, not response. mid=%u\\n\"",
            "get_mid(smb)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mid",
          "args": [
            "smb"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "get_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "681-685",
          "snippet": "static inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Bad protocol string signature header 0x%x\\n\"",
            "*(unsigned int *)smb->Protocol"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0x424d53ff"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nstatic int\ncheck_smb_hdr(struct smb_hdr *smb)\n{\n\t/* does it have the right SMB \"signature\" ? */\n\tif (*(__le32 *) smb->Protocol != cpu_to_le32(0x424d53ff)) {\n\t\tcifs_dbg(VFS, \"Bad protocol string signature header 0x%x\\n\",\n\t\t\t *(unsigned int *)smb->Protocol);\n\t\treturn 1;\n\t}\n\n\t/* if it's a response then accept */\n\tif (smb->Flags & SMBFLG_RESPONSE)\n\t\treturn 0;\n\n\t/* only one valid case where server sends us request */\n\tif (smb->Command == SMB_COM_LOCKING_ANDX)\n\t\treturn 0;\n\n\tcifs_dbg(VFS, \"Server sent request, not response. mid=%u\\n\",\n\t\t get_mid(smb));\n\treturn 1;\n}"
  },
  {
    "function_name": "header_assemble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "240-287",
    "snippet": "void\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "treeCon->ses->server"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)(current->tgid >> 16)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "current->tgid >> 16"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(__u16)current->tgid"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2/* for bcc field itself */"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "temp",
            "0",
            "256"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nheader_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,\n\t\tconst struct cifs_tcon *treeCon, int word_count\n\t\t/* length of fixed section (word count) in two byte units  */)\n{\n\tchar *temp = (char *) buffer;\n\n\tmemset(temp, 0, 256); /* bigger than MAX_CIFS_HDR_SIZE */\n\n\tbuffer->smb_buf_length = cpu_to_be32(\n\t    (2 * word_count) + sizeof(struct smb_hdr) -\n\t    4 /*  RFC 1001 length field does not count */  +\n\t    2 /* for bcc field itself */) ;\n\n\tbuffer->Protocol[0] = 0xFF;\n\tbuffer->Protocol[1] = 'S';\n\tbuffer->Protocol[2] = 'M';\n\tbuffer->Protocol[3] = 'B';\n\tbuffer->Command = smb_command;\n\tbuffer->Flags = 0x00;\t/* case sensitive */\n\tbuffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;\n\tbuffer->Pid = cpu_to_le16((__u16)current->tgid);\n\tbuffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));\n\tif (treeCon) {\n\t\tbuffer->Tid = treeCon->tid;\n\t\tif (treeCon->ses) {\n\t\t\tif (treeCon->ses->capabilities & CAP_UNICODE)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\t\t\tif (treeCon->ses->capabilities & CAP_STATUS32)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t\t\t/* Uid is not converted */\n\t\t\tbuffer->Uid = treeCon->ses->Suid;\n\t\t\tbuffer->Mid = get_next_mid(treeCon->ses->server);\n\t\t}\n\t\tif (treeCon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\t\tbuffer->Flags2 |= SMBFLG2_DFS;\n\t\tif (treeCon->nocase)\n\t\t\tbuffer->Flags  |= SMBFLG_CASELESS;\n\t\tif ((treeCon->ses) && (treeCon->ses->server))\n\t\t\tif (treeCon->ses->server->sign)\n\t\t\t\tbuffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n/*  endian conversion of flags is now done just before sending */\n\tbuffer->WordCount = (char) word_count;\n\treturn;\n}"
  },
  {
    "function_name": "free_rsp_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "229-236",
    "snippet": "void\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "rsp"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "rsp"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nfree_rsp_buf(int resp_buftype, void *rsp)\n{\n\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(rsp);\n\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(rsp);\n}"
  },
  {
    "function_name": "cifs_small_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "215-227",
    "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_sm_req_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&smBufAllocCount"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "buf_to_free",
            "cifs_sm_req_poolp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Null buffer passed to cifs_small_buf_release\\n\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
  },
  {
    "function_name": "cifs_small_buf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "193-213",
    "snippet": "struct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_sm_req_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&totSmBufAllocCount"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&smBufAllocCount"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "cifs_sm_req_poolp",
            "GFP_NOFS"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nstruct smb_hdr *\ncifs_small_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\n/* We could use negotiated size instead of max_msgsize -\n   but it may be more efficient to always alloc same size\n   albeit slightly larger than necessary and maxbuffersize\n   defaults to this and can not be bigger */\n\tret_buf = mempool_alloc(cifs_sm_req_poolp, GFP_NOFS);\n\tif (ret_buf) {\n\t/* No need to clear memory here, cleared in header assemble */\n\t/*\tmemset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/\n\t\tatomic_inc(&smBufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totSmBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\t}\n\treturn ret_buf;\n}"
  },
  {
    "function_name": "cifs_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "180-191",
    "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_req_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bufAllocCount"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "buf_to_free",
            "cifs_req_poolp"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
  },
  {
    "function_name": "cifs_buf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "146-178",
    "snippet": "struct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_req_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&totBufAllocCount"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bufAllocCount"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret_buf",
            "0",
            "buf_size + 3"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "cifs_req_poolp",
            "GFP_NOFS"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_hdr *\ncifs_buf_get(void)\n{\n\tstruct smb_hdr *ret_buf = NULL;\n\tsize_t buf_size = sizeof(struct smb_hdr);\n\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 header is bigger than CIFS one - no problems to clean some\n\t * more bytes for CIFS.\n\t */\n\tbuf_size = sizeof(struct smb2_hdr);\n#endif\n\t/*\n\t * We could use negotiated size instead of max_msgsize -\n\t * but it may be more efficient to always alloc same size\n\t * albeit slightly larger than necessary and maxbuffersize\n\t * defaults to this and can not be bigger.\n\t */\n\tret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);\n\n\t/* clear the first few header bytes */\n\t/* for most paths, more is cleared in header_assemble */\n\tif (ret_buf) {\n\t\tmemset(ret_buf, 0, buf_size + 3);\n\t\tatomic_inc(&bufAllocCount);\n#ifdef CONFIG_CIFS_STATS2\n\t\tatomic_inc(&totBufAllocCount);\n#endif /* CONFIG_CIFS_STATS2 */\n\t}\n\n\treturn ret_buf;\n}"
  },
  {
    "function_name": "tconInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "130-144",
    "snippet": "void\ntconInfoFree(struct cifs_tcon *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(buf_to_free->nativeFileSystem);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->password"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf_to_free->password",
            "0",
            "strlen(buf_to_free->password)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf_to_free->password"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->nativeFileSystem"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&tconInfoAllocCount"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Null buffer passed to tconInfoFree\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ntconInfoFree(struct cifs_tcon *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to tconInfoFree\\n\");\n\t\treturn;\n\t}\n\tatomic_dec(&tconInfoAllocCount);\n\tkfree(buf_to_free->nativeFileSystem);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free);\n}"
  },
  {
    "function_name": "tconInfoAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "112-128",
    "snippet": "struct cifs_tcon *\ntconInfoAlloc(void)\n{\n\tstruct cifs_tcon *ret_buf;\n\tret_buf = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&tconInfoAllocCount);\n\t\tret_buf->tidStatus = CifsNew;\n\t\t++ret_buf->tc_count;\n\t\tINIT_LIST_HEAD(&ret_buf->openFileList);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n#ifdef CONFIG_CIFS_STATS\n\t\tspin_lock_init(&ret_buf->stat_lock);\n#endif\n\t}\n\treturn ret_buf;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ret_buf->stat_lock"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret_buf->tcon_list"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret_buf->openFileList"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tconInfoAllocCount"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifs_tcon)",
            "GFP_KERNEL"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nstruct cifs_tcon *\ntconInfoAlloc(void)\n{\n\tstruct cifs_tcon *ret_buf;\n\tret_buf = kzalloc(sizeof(struct cifs_tcon), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&tconInfoAllocCount);\n\t\tret_buf->tidStatus = CifsNew;\n\t\t++ret_buf->tc_count;\n\t\tINIT_LIST_HEAD(&ret_buf->openFileList);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n#ifdef CONFIG_CIFS_STATS\n\t\tspin_lock_init(&ret_buf->stat_lock);\n#endif\n\t}\n\treturn ret_buf;\n}"
  },
  {
    "function_name": "sesInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "90-110",
    "snippet": "void\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree(buf_to_free->auth_key.response);\n\tkfree(buf_to_free);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->auth_key.response"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->domainName"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->user_name"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->password"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf_to_free->password",
            "0",
            "strlen(buf_to_free->password)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf_to_free->password"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->serverNOS"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->serverDomain"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_to_free->serverOS"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sesInfoAllocCount"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Null buffer passed to sesInfoFree\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\nsesInfoFree(struct cifs_ses *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to sesInfoFree\\n\");\n\t\treturn;\n\t}\n\n\tatomic_dec(&sesInfoAllocCount);\n\tkfree(buf_to_free->serverOS);\n\tkfree(buf_to_free->serverDomain);\n\tkfree(buf_to_free->serverNOS);\n\tif (buf_to_free->password) {\n\t\tmemset(buf_to_free->password, 0, strlen(buf_to_free->password));\n\t\tkfree(buf_to_free->password);\n\t}\n\tkfree(buf_to_free->user_name);\n\tkfree(buf_to_free->domainName);\n\tkfree(buf_to_free->auth_key.response);\n\tkfree(buf_to_free);\n}"
  },
  {
    "function_name": "sesInfoAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "73-88",
    "snippet": "struct cifs_ses *\nsesInfoAlloc(void)\n{\n\tstruct cifs_ses *ret_buf;\n\n\tret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&sesInfoAllocCount);\n\t\tret_buf->status = CifsNew;\n\t\t++ret_buf->ses_count;\n\t\tINIT_LIST_HEAD(&ret_buf->smb_ses_list);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n\t\tmutex_init(&ret_buf->session_mutex);\n\t}\n\treturn ret_buf;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ret_buf->session_mutex"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret_buf->tcon_list"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret_buf->smb_ses_list"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sesInfoAllocCount"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifs_ses)",
            "GFP_KERNEL"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nstruct cifs_ses *\nsesInfoAlloc(void)\n{\n\tstruct cifs_ses *ret_buf;\n\n\tret_buf = kzalloc(sizeof(struct cifs_ses), GFP_KERNEL);\n\tif (ret_buf) {\n\t\tatomic_inc(&sesInfoAllocCount);\n\t\tret_buf->status = CifsNew;\n\t\t++ret_buf->ses_count;\n\t\tINIT_LIST_HEAD(&ret_buf->smb_ses_list);\n\t\tINIT_LIST_HEAD(&ret_buf->tcon_list);\n\t\tmutex_init(&ret_buf->session_mutex);\n\t}\n\treturn ret_buf;\n}"
  },
  {
    "function_name": "_free_xid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "63-71",
    "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
  },
  {
    "function_name": "_get_xid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
    "lines": "45-61",
    "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"nterr.h\"",
      "#include \"smberr.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"warning: more than 65000 requests active\\n\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
  }
]