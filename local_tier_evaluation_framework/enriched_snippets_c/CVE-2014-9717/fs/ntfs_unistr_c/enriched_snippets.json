[
  {
    "function_name": "ntfs_ucstonls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "336-398",
    "snippet": "int ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t/* We don't trust outside sources. */\n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t/* Grow in multiples of 64 bytes. */\n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t} /* No memory so goto conversion_error; */\n\t\t\t} /* wc < 0, real error. */\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t} /* else (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to allocate name!\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\"",
            "nls->charset"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Received NULL pointer.\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tc",
            "ns",
            "ns_len"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(ns_len + 64) &\n\t\t\t\t\t\t~63",
            "GFP_NOFS"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nls->uni2char",
          "args": [
            "le16_to_cpu(ins[i])",
            "ns + o",
            "ns_len - o"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ins[i]"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t/* We don't trust outside sources. */\n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t/* Grow in multiples of 64 bytes. */\n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t} /* No memory so goto conversion_error; */\n\t\t\t} /* wc < 0, real error. */\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t} /* else (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ntfs_nlstoucs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "259-309",
    "snippet": "int ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,\n\t\tconst int ins_len, ntfschar **outs)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tntfschar *ucs;\n\twchar_t wc;\n\tint i, o, wc_len;\n\n\t/* We do not trust outside sources. */\n\tif (likely(ins)) {\n\t\tucs = kmem_cache_alloc(ntfs_name_cache, GFP_NOFS);\n\t\tif (likely(ucs)) {\n\t\t\tfor (i = o = 0; i < ins_len; i += wc_len) {\n\t\t\t\twc_len = nls->char2uni(ins + i, ins_len - i,\n\t\t\t\t\t\t&wc);\n\t\t\t\tif (likely(wc_len >= 0 &&\n\t\t\t\t\t\to < NTFS_MAX_NAME_LEN)) {\n\t\t\t\t\tif (likely(wc)) {\n\t\t\t\t\t\tucs[o++] = cpu_to_le16(wc);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} /* else if (!wc) */\n\t\t\t\t\tbreak;\n\t\t\t\t} /* else if (wc_len < 0 ||\n\t\t\t\t\t\to >= NTFS_MAX_NAME_LEN) */\n\t\t\t\tgoto name_err;\n\t\t\t}\n\t\t\tucs[o] = 0;\n\t\t\t*outs = ucs;\n\t\t\treturn o;\n\t\t} /* else if (!ucs) */\n\t\tntfs_error(vol->sb, \"Failed to allocate buffer for converted \"\n\t\t\t\t\"name from ntfs_name_cache.\");\n\t\treturn -ENOMEM;\n\t} /* else if (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nname_err:\n\tkmem_cache_free(ntfs_name_cache, ucs);\n\tif (wc_len < 0) {\n\t\tntfs_error(vol->sb, \"Name using character set %s contains \"\n\t\t\t\t\"characters that cannot be converted to \"\n\t\t\t\t\"Unicode.\", nls->charset);\n\t\ti = -EILSEQ;\n\t} else /* if (o >= NTFS_MAX_NAME_LEN) */ {\n\t\tntfs_error(vol->sb, \"Name is too long (maximum length for a \"\n\t\t\t\t\"name on NTFS is %d Unicode characters.\",\n\t\t\t\tNTFS_MAX_NAME_LEN);\n\t\ti = -ENAMETOOLONG;\n\t}\n\treturn i;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Name is too long (maximum length for a \"\n\t\t\t\t\"name on NTFS is %d Unicode characters.\"",
            "NTFS_MAX_NAME_LEN"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ntfs_name_cache",
            "ucs"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Received NULL pointer.\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to allocate buffer for converted \"\n\t\t\t\t\"name from ntfs_name_cache.\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "wc"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "wc"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "wc_len >= 0 &&\n\t\t\t\t\t\to < NTFS_MAX_NAME_LEN"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls->char2uni",
          "args": [
            "ins + i",
            "ins_len - i",
            "&wc"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ucs"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ntfs_name_cache",
            "GFP_NOFS"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ins"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,\n\t\tconst int ins_len, ntfschar **outs)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tntfschar *ucs;\n\twchar_t wc;\n\tint i, o, wc_len;\n\n\t/* We do not trust outside sources. */\n\tif (likely(ins)) {\n\t\tucs = kmem_cache_alloc(ntfs_name_cache, GFP_NOFS);\n\t\tif (likely(ucs)) {\n\t\t\tfor (i = o = 0; i < ins_len; i += wc_len) {\n\t\t\t\twc_len = nls->char2uni(ins + i, ins_len - i,\n\t\t\t\t\t\t&wc);\n\t\t\t\tif (likely(wc_len >= 0 &&\n\t\t\t\t\t\to < NTFS_MAX_NAME_LEN)) {\n\t\t\t\t\tif (likely(wc)) {\n\t\t\t\t\t\tucs[o++] = cpu_to_le16(wc);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} /* else if (!wc) */\n\t\t\t\t\tbreak;\n\t\t\t\t} /* else if (wc_len < 0 ||\n\t\t\t\t\t\to >= NTFS_MAX_NAME_LEN) */\n\t\t\t\tgoto name_err;\n\t\t\t}\n\t\t\tucs[o] = 0;\n\t\t\t*outs = ucs;\n\t\t\treturn o;\n\t\t} /* else if (!ucs) */\n\t\tntfs_error(vol->sb, \"Failed to allocate buffer for converted \"\n\t\t\t\t\"name from ntfs_name_cache.\");\n\t\treturn -ENOMEM;\n\t} /* else if (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nname_err:\n\tkmem_cache_free(ntfs_name_cache, ucs);\n\tif (wc_len < 0) {\n\t\tntfs_error(vol->sb, \"Name using character set %s contains \"\n\t\t\t\t\"characters that cannot be converted to \"\n\t\t\t\t\"Unicode.\", nls->charset);\n\t\ti = -EILSEQ;\n\t} else /* if (o >= NTFS_MAX_NAME_LEN) */ {\n\t\tntfs_error(vol->sb, \"Name is too long (maximum length for a \"\n\t\t\t\t\"name on NTFS is %d Unicode characters.\",\n\t\t\t\tNTFS_MAX_NAME_LEN);\n\t\ti = -ENAMETOOLONG;\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "ntfs_file_compare_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "224-234",
    "snippet": "int ntfs_file_compare_values(FILE_NAME_ATTR *file_name_attr1,\n\t\tFILE_NAME_ATTR *file_name_attr2,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\treturn ntfs_collate_names((ntfschar*)&file_name_attr1->file_name,\n\t\t\tfile_name_attr1->file_name_length,\n\t\t\t(ntfschar*)&file_name_attr2->file_name,\n\t\t\tfile_name_attr2->file_name_length,\n\t\t\terr_val, ic, upcase, upcase_len);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_collate_names",
          "args": [
            "(ntfschar*)&file_name_attr1->file_name",
            "file_name_attr1->file_name_length",
            "(ntfschar*)&file_name_attr2->file_name",
            "file_name_attr2->file_name_length",
            "err_val",
            "ic",
            "upcase",
            "upcase_len"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_collate_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "97-133",
          "snippet": "int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_file_compare_values(FILE_NAME_ATTR *file_name_attr1,\n\t\tFILE_NAME_ATTR *file_name_attr2,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\treturn ntfs_collate_names((ntfschar*)&file_name_attr1->file_name,\n\t\t\tfile_name_attr1->file_name_length,\n\t\t\t(ntfschar*)&file_name_attr2->file_name,\n\t\t\tfile_name_attr2->file_name_length,\n\t\t\terr_val, ic, upcase, upcase_len);\n}"
  },
  {
    "function_name": "ntfs_file_upcase_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "217-222",
    "snippet": "void ntfs_file_upcase_value(FILE_NAME_ATTR *file_name_attr,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tntfs_upcase_name((ntfschar*)&file_name_attr->file_name,\n\t\t\tfile_name_attr->file_name_length, upcase, upcase_len);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_upcase_name",
          "args": [
            "(ntfschar*)&file_name_attr->file_name",
            "file_name_attr->file_name_length",
            "upcase",
            "upcase_len"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_upcase_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "206-215",
          "snippet": "void ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,\n\t\tconst u32 upcase_len)\n{\n\tu32 i;\n\tu16 u;\n\n\tfor (i = 0; i < name_len; i++)\n\t\tif ((u = le16_to_cpu(name[i])) < upcase_len)\n\t\t\tname[i] = upcase[u];\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nvoid ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,\n\t\tconst u32 upcase_len)\n{\n\tu32 i;\n\tu16 u;\n\n\tfor (i = 0; i < name_len; i++)\n\t\tif ((u = le16_to_cpu(name[i])) < upcase_len)\n\t\t\tname[i] = upcase[u];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nvoid ntfs_file_upcase_value(FILE_NAME_ATTR *file_name_attr,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tntfs_upcase_name((ntfschar*)&file_name_attr->file_name,\n\t\t\tfile_name_attr->file_name_length, upcase, upcase_len);\n}"
  },
  {
    "function_name": "ntfs_upcase_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "206-215",
    "snippet": "void ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,\n\t\tconst u32 upcase_len)\n{\n\tu32 i;\n\tu16 u;\n\n\tfor (i = 0; i < name_len; i++)\n\t\tif ((u = le16_to_cpu(name[i])) < upcase_len)\n\t\t\tname[i] = upcase[u];\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "name[i]"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nvoid ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,\n\t\tconst u32 upcase_len)\n{\n\tu32 i;\n\tu16 u;\n\n\tfor (i = 0; i < name_len; i++)\n\t\tif ((u = le16_to_cpu(name[i])) < upcase_len)\n\t\t\tname[i] = upcase[u];\n}"
  },
  {
    "function_name": "ntfs_ucsncasecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "185-204",
    "snippet": "int ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tsize_t i;\n\tu16 c1, c2;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif ((c1 = le16_to_cpu(s1[i])) < upcase_size)\n\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\tif ((c2 = le16_to_cpu(s2[i])) < upcase_size)\n\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "upcase[c2]"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tsize_t i;\n\tu16 c1, c2;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif ((c1 = le16_to_cpu(s1[i])) < upcase_size)\n\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\tif ((c2 = le16_to_cpu(s2[i])) < upcase_size)\n\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_ucsncmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "149-165",
    "snippet": "int ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)\n{\n\tu16 c1, c2;\n\tsize_t i;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tc1 = le16_to_cpu(s1[i]);\n\t\tc2 = le16_to_cpu(s2[i]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "s2[i]"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)\n{\n\tu16 c1, c2;\n\tsize_t i;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tc1 = le16_to_cpu(s1[i]);\n\t\tc2 = le16_to_cpu(s2[i]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_collate_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "97-133",
    "snippet": "int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "*name1"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}"
  },
  {
    "function_name": "ntfs_are_names_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
    "lines": "68-77",
    "snippet": "bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"types.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_ucsncasecmp",
          "args": [
            "s1",
            "s2",
            "s1_len",
            "upcase",
            "upcase_size"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ucsncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "185-204",
          "snippet": "int ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tsize_t i;\n\tu16 c1, c2;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif ((c1 = le16_to_cpu(s1[i])) < upcase_size)\n\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\tif ((c2 = le16_to_cpu(s2[i])) < upcase_size)\n\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tsize_t i;\n\tu16 c1, c2;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif ((c1 = le16_to_cpu(s1[i])) < upcase_size)\n\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\tif ((c2 = le16_to_cpu(s2[i])) < upcase_size)\n\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_ucsncmp",
          "args": [
            "s1",
            "s2",
            "s1_len"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ucsncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "149-165",
          "snippet": "int ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)\n{\n\tu16 c1, c2;\n\tsize_t i;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tc1 = le16_to_cpu(s1[i]);\n\t\tc2 = le16_to_cpu(s2[i]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)\n{\n\tu16 c1, c2;\n\tsize_t i;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tc1 = le16_to_cpu(s1[i]);\n\t\tc2 = le16_to_cpu(s2[i]);\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nbool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}"
  }
]