[
  {
    "function_name": "ext4_inode_to_goal_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "843-882",
    "snippet": "ext4_fsblk_t ext4_inode_to_goal_block(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_group_t block_group;\n\text4_grpblk_t colour;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(inode->i_sb));\n\text4_fsblk_t bg_start;\n\text4_fsblk_t last_block;\n\n\tblock_group = ei->i_block_group;\n\tif (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) {\n\t\t/*\n\t\t * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\n\t\t * block groups per flexgroup, reserve the first block\n\t\t * group for directories and special files.  Regular\n\t\t * files will start at the second block group.  This\n\t\t * tends to speed up directory access and improves\n\t\t * fsck times.\n\t\t */\n\t\tblock_group &= ~(flex_size-1);\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tblock_group++;\n\t}\n\tbg_start = ext4_group_first_block_no(inode->i_sb, block_group);\n\tlast_block = ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es) - 1;\n\n\t/*\n\t * If we are doing delayed allocation, we don't need take\n\t * colour into account.\n\t */\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\treturn bg_start;\n\n\tif (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)\n\t\tcolour = (current->pid % 16) *\n\t\t\t(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\telse\n\t\tcolour = (current->pid % 16) * ((last_block - bg_start) / 16);\n\treturn bg_start + colour;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DELALLOC"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "EXT4_SB(inode->i_sb)->s_es"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "inode->i_sb",
            "block_group"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_bg_size",
          "args": [
            "EXT4_SB(inode->i_sb)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\next4_fsblk_t ext4_inode_to_goal_block(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_group_t block_group;\n\text4_grpblk_t colour;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(inode->i_sb));\n\text4_fsblk_t bg_start;\n\text4_fsblk_t last_block;\n\n\tblock_group = ei->i_block_group;\n\tif (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) {\n\t\t/*\n\t\t * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\n\t\t * block groups per flexgroup, reserve the first block\n\t\t * group for directories and special files.  Regular\n\t\t * files will start at the second block group.  This\n\t\t * tends to speed up directory access and improves\n\t\t * fsck times.\n\t\t */\n\t\tblock_group &= ~(flex_size-1);\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tblock_group++;\n\t}\n\tbg_start = ext4_group_first_block_no(inode->i_sb, block_group);\n\tlast_block = ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es) - 1;\n\n\t/*\n\t * If we are doing delayed allocation, we don't need take\n\t * colour into account.\n\t */\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\treturn bg_start;\n\n\tif (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)\n\t\tcolour = (current->pid % 16) *\n\t\t\t(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\telse\n\t\tcolour = (current->pid % 16) * ((last_block - bg_start) / 16);\n\treturn bg_start + colour;\n}"
  },
  {
    "function_name": "ext4_num_base_meta_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "815-835",
    "snippet": "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t     ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t/* Check for superblock and gdt backups in this group */\n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else { /* For META_BG_BLOCK_GROUPS */\n\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t}\n\treturn EXT4_NUM_B2C(sbi, num);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "num"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "797-809",
          "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbi->s_es->s_reserved_gdt_blocks"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_first_meta_bg"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t     ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t/* Check for superblock and gdt backups in this group */\n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else { /* For META_BG_BLOCK_GROUPS */\n\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t}\n\treturn EXT4_NUM_B2C(sbi, num);\n}"
  },
  {
    "function_name": "ext4_bg_num_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "797-809",
    "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb_meta",
          "args": [
            "sb",
            "group"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "764-774",
          "snippet": "static unsigned long ext4_bg_num_gdb_meta(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t first = metagroup * EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t last = first + EXT4_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned long ext4_bg_num_gdb_meta(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t first = metagroup * EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t last = first + EXT4_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb_nometa",
          "args": [
            "sb",
            "group"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb_nometa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "776-786",
          "snippet": "static unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tif (!ext4_bg_has_super(sb, group))\n\t\treturn 0;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG))\n\t\treturn le32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\telse\n\t\treturn EXT4_SB(sb)->s_gdb_count;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tif (!ext4_bg_has_super(sb, group))\n\t\treturn 0;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG))\n\t\treturn le32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\telse\n\t\treturn EXT4_SB(sb)->s_gdb_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_meta_bg"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
  },
  {
    "function_name": "ext4_bg_num_gdb_nometa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "776-786",
    "snippet": "static unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tif (!ext4_bg_has_super(sb, group))\n\t\treturn 0;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG))\n\t\treturn le32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\telse\n\t\treturn EXT4_SB(sb)->s_gdb_count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_meta_bg"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tif (!ext4_bg_has_super(sb, group))\n\t\treturn 0;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG))\n\t\treturn le32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\telse\n\t\treturn EXT4_SB(sb)->s_gdb_count;\n}"
  },
  {
    "function_name": "ext4_bg_num_gdb_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "764-774",
    "snippet": "static unsigned long ext4_bg_num_gdb_meta(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t first = metagroup * EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t last = first + EXT4_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned long ext4_bg_num_gdb_meta(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t first = metagroup * EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t last = first + EXT4_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_bg_has_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "740-762",
    "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_root",
          "args": [
            "group",
            "7"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "test_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "719-730",
          "snippet": "static inline int test_root(ext4_group_t a, int b)\n{\n\twhile (1) {\n\t\tif (a < b)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif ((a % b) != 0)\n\t\t\treturn 0;\n\t\ta = a / b;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic inline int test_root(ext4_group_t a, int b)\n{\n\twhile (1) {\n\t\tif (a < b)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif ((a % b) != 0)\n\t\t\treturn 0;\n\t\ta = a / b;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_backup_bgs[1]"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_SPARSE_SUPER2"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "test_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "719-730",
    "snippet": "static inline int test_root(ext4_group_t a, int b)\n{\n\twhile (1) {\n\t\tif (a < b)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif ((a % b) != 0)\n\t\t\treturn 0;\n\t\ta = a / b;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic inline int test_root(ext4_group_t a, int b)\n{\n\twhile (1) {\n\t\tif (a < b)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif ((a % b) != 0)\n\t\t\treturn 0;\n\t\ta = a / b;\n\t}\n}"
  },
  {
    "function_name": "ext4_count_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "658-717",
    "snippet": "ext4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "i"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\"",
            "EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es))",
            "desc_count",
            "bitmap_count"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "EXT4_SB(sb)",
            "ext4_free_blocks_count(es)"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count",
          "args": [
            "es"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_count_free",
          "args": [
            "bitmap_bh->b_data",
            "EXT4_CLUSTERS_PER_GROUP(sb) / 8"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "14-17",
          "snippet": "unsigned int ext4_count_free(char *bitmap, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(bitmap, numchars);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nunsigned int ext4_count_free(char *bitmap, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(bitmap, numchars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "i"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "i"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}"
  },
  {
    "function_name": "ext4_new_meta_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "622-650",
    "snippet": "ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t/* Fill with neighbour allocated blocks */\n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t/*\n\t * Account for the allocated meta blocks.  We will never\n\t * fail EDQUOT for metdata, but we do account for it.\n\t */\n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_alloc_block_nofail",
          "args": [
            "inode",
            "EXT4_C2B(EXT4_SB(inode->i_sb), ar.len)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "ar.len"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT4_I(inode)->i_block_reservation_lock"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&EXT4_I(inode)->i_block_reservation_lock"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_new_blocks",
          "args": [
            "handle",
            "&ar",
            "errp"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_new_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4390-4531",
          "snippet": "ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tint freed;\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (IS_NOQUOTA(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\tif (*errp)\n\t\t\tgoto discard_and_exit;\n\n\t\t/* as we've just preallocated more space than\n\t\t * user requested originally, we store allocated\n\t\t * space in a special descriptor */\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t    ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\t\t*errp = ext4_mb_new_preallocation(ac);\n\t\tif (*errp) {\n\t\tdiscard_and_exit:\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp == -EAGAIN) {\n\t\t\t/*\n\t\t\t * drop the reference that we took\n\t\t\t * in ext4_mb_use_best_found\n\t\t\t */\n\t\t\text4_mb_release_context(ac);\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tgoto repeat;\n\t\t} else if (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tfreed  = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\t\tif (freed)\n\t\t\tgoto repeat;\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_ac_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_ac_cachep;\n\next4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tint freed;\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (IS_NOQUOTA(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\tif (*errp)\n\t\t\tgoto discard_and_exit;\n\n\t\t/* as we've just preallocated more space than\n\t\t * user requested originally, we store allocated\n\t\t * space in a special descriptor */\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t    ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\t\t*errp = ext4_mb_new_preallocation(ac);\n\t\tif (*errp) {\n\t\tdiscard_and_exit:\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp == -EAGAIN) {\n\t\t\t/*\n\t\t\t * drop the reference that we took\n\t\t\t * in ext4_mb_use_best_found\n\t\t\t */\n\t\t\text4_mb_release_context(ac);\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tgoto repeat;\n\t\t} else if (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tfreed  = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\t\tif (freed)\n\t\t\tgoto repeat;\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ar",
            "0",
            "sizeof(ar)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t/* Fill with neighbour allocated blocks */\n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t/*\n\t * Account for the allocated meta blocks.  We will never\n\t * fail EDQUOT for metdata, but we do account for it.\n\t */\n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_should_retry_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "598-608",
    "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_force_commit_nested",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_force_commit_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "595-601",
          "snippet": "int jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"%s: retrying operation after ENOSPC\\n\"",
            "sb->s_id"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_free_clusters",
          "args": [
            "EXT4_SB(sb)",
            "1",
            "0"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "528-574",
          "snippet": "static int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t/*\n\t * r_blocks_count should always be multiple of the cluster ratio so\n\t * we are safe to do a plane bit shift only.\n\t */\n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t/* Check whether we have space after accounting for current\n\t * dirty clusters & root reserved clusters.\n\t */\n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t/* Hm, nope.  Are (enough) root reserved clusters available? */\n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t/* No free blocks. Let's see if we can dip into reserved pool */\n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t/*\n\t * r_blocks_count should always be multiple of the cluster ratio so\n\t * we are safe to do a plane bit shift only.\n\t */\n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t/* Check whether we have space after accounting for current\n\t * dirty clusters & root reserved clusters.\n\t */\n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t/* Hm, nope.  Are (enough) root reserved clusters available? */\n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t/* No free blocks. Let's see if we can dip into reserved pool */\n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
  },
  {
    "function_name": "ext4_claim_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "576-584",
    "snippet": "int ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_dirtyclusters_counter",
            "nclusters"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_free_clusters",
          "args": [
            "sbi",
            "nclusters",
            "flags"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "528-574",
          "snippet": "static int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t/*\n\t * r_blocks_count should always be multiple of the cluster ratio so\n\t * we are safe to do a plane bit shift only.\n\t */\n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t/* Check whether we have space after accounting for current\n\t * dirty clusters & root reserved clusters.\n\t */\n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t/* Hm, nope.  Are (enough) root reserved clusters available? */\n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t/* No free blocks. Let's see if we can dip into reserved pool */\n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t/*\n\t * r_blocks_count should always be multiple of the cluster ratio so\n\t * we are safe to do a plane bit shift only.\n\t */\n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t/* Check whether we have space after accounting for current\n\t * dirty clusters & root reserved clusters.\n\t */\n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t/* Hm, nope.  Are (enough) root reserved clusters available? */\n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t/* No free blocks. Let's see if we can dip into reserved pool */\n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "ext4_has_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "528-574",
    "snippet": "static int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t/*\n\t * r_blocks_count should always be multiple of the cluster ratio so\n\t * we are safe to do a plane bit shift only.\n\t */\n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t/* Check whether we have space after accounting for current\n\t * dirty clusters & root reserved clusters.\n\t */\n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t/* Hm, nope.  Are (enough) root reserved clusters available? */\n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t/* No free blocks. Let's see if we can dip into reserved pool */\n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "sbi->s_resgid"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "sbi->s_resgid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "sbi->s_resuid",
            "current_fsuid()"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "dcc"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "fcc"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count",
          "args": [
            "sbi->s_es"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&sbi->s_resv_clusters"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "dcc"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "fcc"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t/*\n\t * r_blocks_count should always be multiple of the cluster ratio so\n\t * we are safe to do a plane bit shift only.\n\t */\n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t/* Check whether we have space after accounting for current\n\t * dirty clusters & root reserved clusters.\n\t */\n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t/* Hm, nope.  Are (enough) root reserved clusters available? */\n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t/* No free blocks. Let's see if we can dip into reserved pool */\n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_read_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "504-517",
    "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_wait_block_bitmap",
          "args": [
            "sb",
            "block_group",
            "bh"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_wait_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "480-502",
          "snippet": "int ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn 1;\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error(sb, \"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, (unsigned long long) bh->b_blocknr);\n\t\treturn 1;\n\t}\n\tclear_buffer_new(bh);\n\t/* Panic or remount fs read-only if block bitmap is invalid */\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\t/* ...but check for error just in case errors=continue. */\n\treturn !buffer_verified(bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nint ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn 1;\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error(sb, \"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, (unsigned long long) bh->b_blocknr);\n\t\treturn 1;\n\t}\n\tclear_buffer_new(bh);\n\t/* Panic or remount fs read-only if block bitmap is invalid */\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\t/* ...but check for error just in case errors=continue. */\n\treturn !buffer_verified(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap_nowait",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "412-477",
          "snippet": "struct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tint err;\n\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err)\n\t\t\text4_error(sb, \"Checksum bad for grp %u\", block_group);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (buffer_verified(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tint err;\n\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err)\n\t\t\text4_error(sb, \"Checksum bad for grp %u\", block_group);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (buffer_verified(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
  },
  {
    "function_name": "ext4_wait_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "480-502",
    "snippet": "int ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn 1;\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error(sb, \"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, (unsigned long long) bh->b_blocknr);\n\t\treturn 1;\n\t}\n\tclear_buffer_new(bh);\n\t/* Panic or remount fs read-only if block bitmap is invalid */\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\t/* ...but check for error just in case errors=continue. */\n\treturn !buffer_verified(bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_validate_block_bitmap",
          "args": [
            "sb",
            "desc",
            "block_group",
            "bh"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_validate_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "364-400",
          "snippet": "static void ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t       struct ext4_group_desc *desc,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (buffer_verified(bh))\n\t\treturn;\n\n\text4_lock_group(sb, block_group);\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tset_buffer_verified(bh);\n\text4_unlock_group(sb, block_group);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic void ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t       struct ext4_group_desc *desc,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (buffer_verified(bh))\n\t\treturn;\n\n\text4_lock_group(sb, block_group);\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tset_buffer_verified(bh);\n\text4_unlock_group(sb, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\"",
            "block_group",
            "(unsigned long long) bh->b_blocknr"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nint ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn 1;\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error(sb, \"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, (unsigned long long) bh->b_blocknr);\n\t\treturn 1;\n\t}\n\tclear_buffer_new(bh);\n\t/* Panic or remount fs read-only if block bitmap is invalid */\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\t/* ...but check for error just in case errors=continue. */\n\treturn !buffer_verified(bh);\n}"
  },
  {
    "function_name": "ext4_read_block_bitmap_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "412-477",
    "snippet": "struct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tint err;\n\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err)\n\t\t\text4_error(sb, \"Checksum bad for grp %u\", block_group);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (buffer_verified(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_validate_block_bitmap",
          "args": [
            "sb",
            "desc",
            "block_group",
            "bh"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_validate_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "364-400",
          "snippet": "static void ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t       struct ext4_group_desc *desc,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (buffer_verified(bh))\n\t\treturn;\n\n\text4_lock_group(sb, block_group);\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tset_buffer_verified(bh);\n\text4_unlock_group(sb, block_group);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic void ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t       struct ext4_group_desc *desc,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (buffer_verified(bh))\n\t\treturn;\n\n\text4_lock_group(sb, block_group);\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tset_buffer_verified(bh);\n\text4_unlock_group(sb, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "bh"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_read_block_bitmap_load",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bitmap_uptodate",
          "args": [
            "bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "set_bitmap_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2816-2819",
          "snippet": "static inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define BH_BITMAP_UPTODATE BH_JBDPrivateStart"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define BH_BITMAP_UPTODATE BH_JBDPrivateStart\n\nstatic inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Checksum bad for grp %u\"",
            "block_group"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_init_block_bitmap",
          "args": [
            "sb",
            "bh",
            "block_group",
            "desc"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "179-246",
          "snippet": "static int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tstruct ext4_group_info *grp;\n\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\n\t/* If checksum is bad mark all blocks used to prevent allocation\n\t * essentially implementing a per-group read-only flag. */\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\tgrp = ext4_get_group_info(sb, block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\tif (!EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {\n\t\t\tint count;\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t\tset_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn -EIO;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\n\tstart = ext4_group_first_block_no(sb, block_group);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflex_bg = 1;\n\n\t/* Set bits for block and inode bitmaps, and inode table */\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\n\t/*\n\t * Also if the number of blocks within the group is less than\n\t * the blocksize * 8 ( which is the size of bitmap ), set rest\n\t * of the block bitmap to 1\n\t */\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tstruct ext4_group_info *grp;\n\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\n\t/* If checksum is bad mark all blocks used to prevent allocation\n\t * essentially implementing a per-group read-only flag. */\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\tgrp = ext4_get_group_info(sb, block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\tif (!EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {\n\t\t\tint count;\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t\tset_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn -EIO;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\n\tstart = ext4_group_first_block_no(sb, block_group);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflex_bg = 1;\n\n\t/* Set bits for block and inode bitmaps, and inode table */\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\n\t/*\n\t * Also if the number of blocks within the group is less than\n\t * the blocksize * 8 ( which is the size of bitmap ), set rest\n\t * of the block bitmap to 1\n\t */\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_BG_BLOCK_UNINIT"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\"",
            "block_group",
            "bitmap_blk"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "bitmap_blk"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "desc"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tint err;\n\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err)\n\t\t\text4_error(sb, \"Checksum bad for grp %u\", block_group);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (buffer_verified(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext4_validate_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "364-400",
    "snippet": "static void ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t       struct ext4_group_desc *desc,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (buffer_verified(bh))\n\t\treturn;\n\n\text4_lock_group(sb, block_group);\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tset_buffer_verified(bh);\n\text4_unlock_group(sb, block_group);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT",
            "&grp->bb_state"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeclusters_counter",
            "grp->bb_free"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"bg %u: bad block bitmap checksum\"",
            "block_group"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_csum_verify",
          "args": [
            "sb",
            "block_group",
            "desc",
            "bh"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "57-81",
          "snippet": "int ext4_block_bitmap_csum_verify(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh)\n{\n\t__u32 hi;\n\t__u32 provided, calculated;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(gdp->bg_block_bitmap_csum_lo);\n\tcalculated = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END) {\n\t\thi = le16_to_cpu(gdp->bg_block_bitmap_csum_hi);\n\t\tprovided |= (hi << 16);\n\t} else\n\t\tcalculated &= 0xFFFF;\n\n\tif (provided == calculated)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nint ext4_block_bitmap_csum_verify(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh)\n{\n\t__u32 hi;\n\t__u32 provided, calculated;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(gdp->bg_block_bitmap_csum_lo);\n\tcalculated = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END) {\n\t\thi = le16_to_cpu(gdp->bg_block_bitmap_csum_hi);\n\t\tprovided |= (hi << 16);\n\t} else\n\t\tcalculated &= 0xFFFF;\n\n\tif (provided == calculated)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeclusters_counter",
            "grp->bb_free"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"bg %u: block %llu: invalid block bitmap\"",
            "block_group",
            "blk"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blk != 0"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_valid_block_bitmap",
          "args": [
            "sb",
            "desc",
            "block_group",
            "bh"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_valid_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "315-362",
          "snippet": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic void ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t       struct ext4_group_desc *desc,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (buffer_verified(bh))\n\t\treturn;\n\n\text4_lock_group(sb, block_group);\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,\n\t\t\tdesc, bh))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn;\n\t}\n\tset_buffer_verified(bh);\n\text4_unlock_group(sb, block_group);\n}"
  },
  {
    "function_name": "ext4_valid_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "315-362",
    "snippet": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "offset + EXT4_SB(sb)->s_itb_per_group"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "EXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group)",
            "EXT4_B2C(sbi, offset)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "offset"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "offset + EXT4_SB(sb)->s_itb_per_group"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "desc"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_bit",
          "args": [
            "EXT4_B2C(sbi, offset)",
            "bh->b_data"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "offset"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "desc"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_bit",
          "args": [
            "EXT4_B2C(sbi, offset)",
            "bh->b_data"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "offset"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "desc"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FLEX_BG"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + EXT4_SB(sb)->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_get_group_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "277-309",
    "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\"",
            "block_group",
            "group_desc",
            "offset"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "456-491",
          "snippet": "void __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tes = EXT4_SB(inode->i_sb)->s_es;\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = d_path(&(file->f_path), pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tes = EXT4_SB(inode->i_sb)->s_es;\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = d_path(&(file->f_path), pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\"",
            "block_group",
            "ngroups"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
  },
  {
    "function_name": "ext4_free_clusters_after_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "251-257",
    "snippet": "unsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) - \n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_num_overhead_clusters",
          "args": [
            "sb",
            "block_group",
            "gdp"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_num_overhead_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "86-157",
          "snippet": "static unsigned ext4_num_overhead_clusters(struct super_block *sb,\n\t\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned num_clusters;\n\tint block_cluster = -1, inode_cluster = -1, itbl_cluster = -1, i, c;\n\text4_fsblk_t start = ext4_group_first_block_no(sb, block_group);\n\text4_fsblk_t itbl_blk;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/* This is the number of clusters used by the superblock,\n\t * block group descriptors, and reserved block group\n\t * descriptor blocks */\n\tnum_clusters = ext4_num_base_meta_clusters(sb, block_group);\n\n\t/*\n\t * For the allocation bitmaps and inode table, we first need\n\t * to check to see if the block is in the block group.  If it\n\t * is, then check to see if the cluster is already accounted\n\t * for in the clusters used for the base metadata cluster, or\n\t * if we can increment the base metadata cluster to include\n\t * that block.  Otherwise, we will have to track the cluster\n\t * used for the allocation bitmap or inode table explicitly.\n\t * Normally all of these blocks are contiguous, so the special\n\t * case handling shouldn't be necessary except for *very*\n\t * unusual file system layouts.\n\t */\n\tif (ext4_block_in_group(sb, ext4_block_bitmap(sb, gdp), block_group)) {\n\t\tblock_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_block_bitmap(sb, gdp) - start);\n\t\tif (block_cluster < num_clusters)\n\t\t\tblock_cluster = -1;\n\t\telse if (block_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tblock_cluster = -1;\n\t\t}\n\t}\n\n\tif (ext4_block_in_group(sb, ext4_inode_bitmap(sb, gdp), block_group)) {\n\t\tinode_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_inode_bitmap(sb, gdp) - start);\n\t\tif (inode_cluster < num_clusters)\n\t\t\tinode_cluster = -1;\n\t\telse if (inode_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tinode_cluster = -1;\n\t\t}\n\t}\n\n\titbl_blk = ext4_inode_table(sb, gdp);\n\tfor (i = 0; i < sbi->s_itb_per_group; i++) {\n\t\tif (ext4_block_in_group(sb, itbl_blk + i, block_group)) {\n\t\t\tc = EXT4_B2C(sbi, itbl_blk + i - start);\n\t\t\tif ((c < num_clusters) || (c == inode_cluster) ||\n\t\t\t    (c == block_cluster) || (c == itbl_cluster))\n\t\t\t\tcontinue;\n\t\t\tif (c == num_clusters) {\n\t\t\t\tnum_clusters++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnum_clusters++;\n\t\t\titbl_cluster = c;\n\t\t}\n\t}\n\n\tif (block_cluster != -1)\n\t\tnum_clusters++;\n\tif (inode_cluster != -1)\n\t\tnum_clusters++;\n\n\treturn num_clusters;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned ext4_num_overhead_clusters(struct super_block *sb,\n\t\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned num_clusters;\n\tint block_cluster = -1, inode_cluster = -1, itbl_cluster = -1, i, c;\n\text4_fsblk_t start = ext4_group_first_block_no(sb, block_group);\n\text4_fsblk_t itbl_blk;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/* This is the number of clusters used by the superblock,\n\t * block group descriptors, and reserved block group\n\t * descriptor blocks */\n\tnum_clusters = ext4_num_base_meta_clusters(sb, block_group);\n\n\t/*\n\t * For the allocation bitmaps and inode table, we first need\n\t * to check to see if the block is in the block group.  If it\n\t * is, then check to see if the cluster is already accounted\n\t * for in the clusters used for the base metadata cluster, or\n\t * if we can increment the base metadata cluster to include\n\t * that block.  Otherwise, we will have to track the cluster\n\t * used for the allocation bitmap or inode table explicitly.\n\t * Normally all of these blocks are contiguous, so the special\n\t * case handling shouldn't be necessary except for *very*\n\t * unusual file system layouts.\n\t */\n\tif (ext4_block_in_group(sb, ext4_block_bitmap(sb, gdp), block_group)) {\n\t\tblock_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_block_bitmap(sb, gdp) - start);\n\t\tif (block_cluster < num_clusters)\n\t\t\tblock_cluster = -1;\n\t\telse if (block_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tblock_cluster = -1;\n\t\t}\n\t}\n\n\tif (ext4_block_in_group(sb, ext4_inode_bitmap(sb, gdp), block_group)) {\n\t\tinode_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_inode_bitmap(sb, gdp) - start);\n\t\tif (inode_cluster < num_clusters)\n\t\t\tinode_cluster = -1;\n\t\telse if (inode_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tinode_cluster = -1;\n\t\t}\n\t}\n\n\titbl_blk = ext4_inode_table(sb, gdp);\n\tfor (i = 0; i < sbi->s_itb_per_group; i++) {\n\t\tif (ext4_block_in_group(sb, itbl_blk + i, block_group)) {\n\t\t\tc = EXT4_B2C(sbi, itbl_blk + i - start);\n\t\t\tif ((c < num_clusters) || (c == inode_cluster) ||\n\t\t\t    (c == block_cluster) || (c == itbl_cluster))\n\t\t\t\tcontinue;\n\t\t\tif (c == num_clusters) {\n\t\t\t\tnum_clusters++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnum_clusters++;\n\t\t\titbl_cluster = c;\n\t\t}\n\t}\n\n\tif (block_cluster != -1)\n\t\tnum_clusters++;\n\tif (inode_cluster != -1)\n\t\tnum_clusters++;\n\n\treturn num_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_clusters_in_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "num_clusters_in_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "159-176",
          "snippet": "static unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t/*\n\t\t * Even though mke2fs always initializes the first and\n\t\t * last group, just in case some other tool was used,\n\t\t * we need to make sure we calculate the right free\n\t\t * blocks.\n\t\t */\n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t/*\n\t\t * Even though mke2fs always initializes the first and\n\t\t * last group, just in case some other tool was used,\n\t\t * we need to make sure we calculate the right free\n\t\t * blocks.\n\t\t */\n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nunsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) - \n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}"
  },
  {
    "function_name": "ext4_init_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "179-246",
    "snippet": "static int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tstruct ext4_group_info *grp;\n\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\n\t/* If checksum is bad mark all blocks used to prevent allocation\n\t * essentially implementing a per-group read-only flag. */\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\tgrp = ext4_get_group_info(sb, block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\tif (!EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {\n\t\t\tint count;\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t\tset_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn -EIO;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\n\tstart = ext4_group_first_block_no(sb, block_group);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflex_bg = 1;\n\n\t/* Set bits for block and inode bitmaps, and inode table */\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\n\t/*\n\t * Also if the number of blocks within the group is less than\n\t * the blocksize * 8 ( which is the size of bitmap ), set rest\n\t * of the block bitmap to 1\n\t */\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_set",
          "args": [
            "sb",
            "block_group",
            "gdp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_csum_set",
          "args": [
            "sb",
            "block_group",
            "gdp",
            "bh"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "83-98",
          "snippet": "void ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_bitmap_end",
          "args": [
            "num_clusters_in_group(sb, block_group)",
            "sb->s_blocksize * 8",
            "bh->b_data"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_bitmap_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "53-65",
          "snippet": "void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text4_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text4_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text4_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text4_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_clusters_in_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "num_clusters_in_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "159-176",
          "snippet": "static unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t/*\n\t\t * Even though mke2fs always initializes the first and\n\t\t * last group, just in case some other tool was used,\n\t\t * we need to make sure we calculate the right free\n\t\t * blocks.\n\t\t */\n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t/*\n\t\t * Even though mke2fs always initializes the first and\n\t\t * last group, just in case some other tool was used,\n\t\t * we need to make sure we calculate the right free\n\t\t * blocks.\n\t\t */\n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "EXT4_B2C(sbi, tmp - start)",
            "bh->b_data"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "tmp - start"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_in_group",
          "args": [
            "sb",
            "tmp",
            "block_group"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_in_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "73-81",
          "snippet": "static inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "EXT4_B2C(sbi, tmp - start)",
            "bh->b_data"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "tmp - start"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "EXT4_B2C(sbi, tmp - start)",
            "bh->b_data"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "tmp - start"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FLEX_BG"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_num_base_meta_clusters",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_num_base_meta_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "815-835",
          "snippet": "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t     ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t/* Check for superblock and gdt backups in this group */\n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else { /* For META_BG_BLOCK_GROUPS */\n\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t}\n\treturn EXT4_NUM_B2C(sbi, num);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t     ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t/* Check for superblock and gdt backups in this group */\n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else { /* For META_BG_BLOCK_GROUPS */\n\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t}\n\treturn EXT4_NUM_B2C(sbi, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT",
            "&grp->bb_state"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeinodes_counter",
            "count"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_inodes_count",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_inodes_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "211-217",
          "snippet": "__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_IBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeclusters_counter",
            "grp->bb_free"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_verify",
          "args": [
            "sb",
            "block_group",
            "gdp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2039-2048",
          "snippet": "int ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(EXT4_SB(sb),\n\t\t\t\t\t\t      block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "buffer_locked(bh)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\tint flex_bg = 0;\n\tstruct ext4_group_info *grp;\n\n\tJ_ASSERT_BH(bh, buffer_locked(bh));\n\n\t/* If checksum is bad mark all blocks used to prevent allocation\n\t * essentially implementing a per-group read-only flag. */\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\tgrp = ext4_get_group_info(sb, block_group);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\tif (!EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {\n\t\t\tint count;\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t\tset_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t\treturn -EIO;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\n\tstart = ext4_group_first_block_no(sb, block_group);\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflex_bg = 1;\n\n\t/* Set bits for block and inode bitmaps, and inode table */\n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (!flex_bg || ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\n\t/*\n\t * Also if the number of blocks within the group is less than\n\t * the blocksize * 8 ( which is the size of bitmap ), set rest\n\t * of the block bitmap to 1\n\t */\n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\treturn 0;\n}"
  },
  {
    "function_name": "num_clusters_in_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "159-176",
    "snippet": "static unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t/*\n\t\t * Even though mke2fs always initializes the first and\n\t\t * last group, just in case some other tool was used,\n\t\t * we need to make sure we calculate the right free\n\t\t * blocks.\n\t\t */\n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "EXT4_SB(sb)",
            "blocks"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "EXT4_SB(sb)->s_es"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t/*\n\t\t * Even though mke2fs always initializes the first and\n\t\t * last group, just in case some other tool was used,\n\t\t * we need to make sure we calculate the right free\n\t\t * blocks.\n\t\t */\n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}"
  },
  {
    "function_name": "ext4_num_overhead_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "86-157",
    "snippet": "static unsigned ext4_num_overhead_clusters(struct super_block *sb,\n\t\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned num_clusters;\n\tint block_cluster = -1, inode_cluster = -1, itbl_cluster = -1, i, c;\n\text4_fsblk_t start = ext4_group_first_block_no(sb, block_group);\n\text4_fsblk_t itbl_blk;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/* This is the number of clusters used by the superblock,\n\t * block group descriptors, and reserved block group\n\t * descriptor blocks */\n\tnum_clusters = ext4_num_base_meta_clusters(sb, block_group);\n\n\t/*\n\t * For the allocation bitmaps and inode table, we first need\n\t * to check to see if the block is in the block group.  If it\n\t * is, then check to see if the cluster is already accounted\n\t * for in the clusters used for the base metadata cluster, or\n\t * if we can increment the base metadata cluster to include\n\t * that block.  Otherwise, we will have to track the cluster\n\t * used for the allocation bitmap or inode table explicitly.\n\t * Normally all of these blocks are contiguous, so the special\n\t * case handling shouldn't be necessary except for *very*\n\t * unusual file system layouts.\n\t */\n\tif (ext4_block_in_group(sb, ext4_block_bitmap(sb, gdp), block_group)) {\n\t\tblock_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_block_bitmap(sb, gdp) - start);\n\t\tif (block_cluster < num_clusters)\n\t\t\tblock_cluster = -1;\n\t\telse if (block_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tblock_cluster = -1;\n\t\t}\n\t}\n\n\tif (ext4_block_in_group(sb, ext4_inode_bitmap(sb, gdp), block_group)) {\n\t\tinode_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_inode_bitmap(sb, gdp) - start);\n\t\tif (inode_cluster < num_clusters)\n\t\t\tinode_cluster = -1;\n\t\telse if (inode_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tinode_cluster = -1;\n\t\t}\n\t}\n\n\titbl_blk = ext4_inode_table(sb, gdp);\n\tfor (i = 0; i < sbi->s_itb_per_group; i++) {\n\t\tif (ext4_block_in_group(sb, itbl_blk + i, block_group)) {\n\t\t\tc = EXT4_B2C(sbi, itbl_blk + i - start);\n\t\t\tif ((c < num_clusters) || (c == inode_cluster) ||\n\t\t\t    (c == block_cluster) || (c == itbl_cluster))\n\t\t\t\tcontinue;\n\t\t\tif (c == num_clusters) {\n\t\t\t\tnum_clusters++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnum_clusters++;\n\t\t\titbl_cluster = c;\n\t\t}\n\t}\n\n\tif (block_cluster != -1)\n\t\tnum_clusters++;\n\tif (inode_cluster != -1)\n\t\tnum_clusters++;\n\n\treturn num_clusters;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "itbl_blk + i - start"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_in_group",
          "args": [
            "sb",
            "itbl_blk + i",
            "block_group"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_in_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "73-81",
          "snippet": "static inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "ext4_inode_bitmap(sb, gdp) - start"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_B2C",
          "args": [
            "sbi",
            "ext4_block_bitmap(sb, gdp) - start"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_num_base_meta_clusters",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_num_base_meta_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "815-835",
          "snippet": "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t     ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t/* Check for superblock and gdt backups in this group */\n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else { /* For META_BG_BLOCK_GROUPS */\n\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t}\n\treturn EXT4_NUM_B2C(sbi, num);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t     ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t/* Check for superblock and gdt backups in this group */\n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else { /* For META_BG_BLOCK_GROUPS */\n\t\tnum += ext4_bg_num_gdb(sb, block_group);\n\t}\n\treturn EXT4_NUM_B2C(sbi, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic unsigned ext4_num_overhead_clusters(struct super_block *sb,\n\t\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned num_clusters;\n\tint block_cluster = -1, inode_cluster = -1, itbl_cluster = -1, i, c;\n\text4_fsblk_t start = ext4_group_first_block_no(sb, block_group);\n\text4_fsblk_t itbl_blk;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/* This is the number of clusters used by the superblock,\n\t * block group descriptors, and reserved block group\n\t * descriptor blocks */\n\tnum_clusters = ext4_num_base_meta_clusters(sb, block_group);\n\n\t/*\n\t * For the allocation bitmaps and inode table, we first need\n\t * to check to see if the block is in the block group.  If it\n\t * is, then check to see if the cluster is already accounted\n\t * for in the clusters used for the base metadata cluster, or\n\t * if we can increment the base metadata cluster to include\n\t * that block.  Otherwise, we will have to track the cluster\n\t * used for the allocation bitmap or inode table explicitly.\n\t * Normally all of these blocks are contiguous, so the special\n\t * case handling shouldn't be necessary except for *very*\n\t * unusual file system layouts.\n\t */\n\tif (ext4_block_in_group(sb, ext4_block_bitmap(sb, gdp), block_group)) {\n\t\tblock_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_block_bitmap(sb, gdp) - start);\n\t\tif (block_cluster < num_clusters)\n\t\t\tblock_cluster = -1;\n\t\telse if (block_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tblock_cluster = -1;\n\t\t}\n\t}\n\n\tif (ext4_block_in_group(sb, ext4_inode_bitmap(sb, gdp), block_group)) {\n\t\tinode_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_inode_bitmap(sb, gdp) - start);\n\t\tif (inode_cluster < num_clusters)\n\t\t\tinode_cluster = -1;\n\t\telse if (inode_cluster == num_clusters) {\n\t\t\tnum_clusters++;\n\t\t\tinode_cluster = -1;\n\t\t}\n\t}\n\n\titbl_blk = ext4_inode_table(sb, gdp);\n\tfor (i = 0; i < sbi->s_itb_per_group; i++) {\n\t\tif (ext4_block_in_group(sb, itbl_blk + i, block_group)) {\n\t\t\tc = EXT4_B2C(sbi, itbl_blk + i - start);\n\t\t\tif ((c < num_clusters) || (c == inode_cluster) ||\n\t\t\t    (c == block_cluster) || (c == itbl_cluster))\n\t\t\t\tcontinue;\n\t\t\tif (c == num_clusters) {\n\t\t\t\tnum_clusters++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnum_clusters++;\n\t\t\titbl_cluster = c;\n\t\t}\n\t}\n\n\tif (block_cluster != -1)\n\t\tnum_clusters++;\n\tif (inode_cluster != -1)\n\t\tnum_clusters++;\n\n\treturn num_clusters;\n}"
  },
  {
    "function_name": "ext4_block_in_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "73-81",
    "snippet": "static inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "block"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstatic inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}"
  },
  {
    "function_name": "ext4_get_group_no_and_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "53-67",
    "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "blocknr",
            "EXT4_BLOCKS_PER_GROUP(sb)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
  },
  {
    "function_name": "ext4_get_group_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
    "lines": "35-47",
    "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include \"ext4.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "block",
            "&group",
            "NULL"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTER_BITS",
          "args": [
            "sb"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_data_block"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt2",
          "args": [
            "sb",
            "STD_GROUP_SIZE"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
  }
]