[
  {
    "function_name": "efs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/dir.c",
    "lines": "22-102",
    "snippet": "static int efs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tefs_block_t\t\tblock;\n\tint\t\t\tslot;\n\n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\t/* work out where this entry can be found */\n\tblock = ctx->pos >> EFS_DIRBSIZE_BITS;\n\n\t/* each block contains at most 256 slots */\n\tslot  = ctx->pos & 0xff;\n\n\t/* look at all blocks */\n\twhile (block < inode->i_blocks) {\n\t\tstruct efs_dir\t\t*dirblock;\n\t\tstruct buffer_head *bh;\n\n\t\t/* read the dir block */\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\tbreak;\n\t\t}\n\n\t\tdirblock = (struct efs_dir *) bh->b_data; \n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (; slot < dirblock->slots; slot++) {\n\t\t\tstruct efs_dentry *dirslot;\n\t\t\tefs_ino_t inodenum;\n\t\t\tconst char *nameptr;\n\t\t\tint namelen;\n\n\t\t\tif (dirblock->space[slot] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\t\t\tpr_debug(\"%s(): block %d slot %d/%d: inode %u, name \\\"%s\\\", namelen %u\\n\",\n\t\t\t\t __func__, block, slot, dirblock->slots-1,\n\t\t\t\t inodenum, nameptr, namelen);\n\t\t\tif (!namelen)\n\t\t\t\tcontinue;\n\t\t\t/* found the next entry */\n\t\t\tctx->pos = (block << EFS_DIRBSIZE_BITS) | slot;\n\n\t\t\t/* sanity check */\n\t\t\tif (nameptr - (char *) dirblock + namelen > EFS_DIRBSIZE) {\n\t\t\t\tpr_warn(\"directory entry %d exceeds directory block\\n\",\n\t\t\t\t\tslot);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* copy filename and data in dirslot */\n\t\t\tif (!dir_emit(ctx, nameptr, namelen, inodenum, DT_UNKNOWN)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\n\t\tslot = 0;\n\t\tblock++;\n\t}\n\tctx->pos = (block << EFS_DIRBSIZE_BITS) | slot;\n\treturn 0;\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int efs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "nameptr",
            "namelen",
            "inodenum",
            "DT_UNKNOWN"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"directory entry %d exceeds directory block\\n\"",
            "slot"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(): block %d slot %d/%d: inode %u, name \\\"%s\\\", namelen %u\\n\"",
            "__func__",
            "block",
            "slot",
            "dirblock->slots-1",
            "inodenum",
            "nameptr",
            "namelen"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dirslot->inode"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EFS_SLOTAT",
          "args": [
            "dirblock",
            "slot"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): invalid directory block\\n\"",
            "__func__"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dirblock->magic"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): failed to read dir block %d\\n\"",
            "__func__",
            "block"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "efs_bmap(inode, block)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_bmap",
          "args": [
            "inode",
            "block"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "efs_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/file.c",
          "lines": "36-56",
          "snippet": "int efs_bmap(struct inode *inode, efs_block_t block) {\n\n\tif (block < 0) {\n\t\tpr_warn(\"%s(): block < 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/* are we about to read past the end of a file ? */\n\tif (!(block < inode->i_blocks)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn efs_map_block(inode, block);\n}",
          "includes": [
            "#include \"efs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"efs.h\"\n#include <linux/buffer_head.h>\n\nint efs_bmap(struct inode *inode, efs_block_t block) {\n\n\tif (block < 0) {\n\t\tpr_warn(\"%s(): block < 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/* are we about to read past the end of a file ? */\n\tif (!(block < inode->i_blocks)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn efs_map_block(inode, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\"",
            "__func__"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/buffer_head.h>\n\nstatic int efs_readdir(struct file *, struct dir_context *);\n\nstatic int efs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tefs_block_t\t\tblock;\n\tint\t\t\tslot;\n\n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\t/* work out where this entry can be found */\n\tblock = ctx->pos >> EFS_DIRBSIZE_BITS;\n\n\t/* each block contains at most 256 slots */\n\tslot  = ctx->pos & 0xff;\n\n\t/* look at all blocks */\n\twhile (block < inode->i_blocks) {\n\t\tstruct efs_dir\t\t*dirblock;\n\t\tstruct buffer_head *bh;\n\n\t\t/* read the dir block */\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\tbreak;\n\t\t}\n\n\t\tdirblock = (struct efs_dir *) bh->b_data; \n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (; slot < dirblock->slots; slot++) {\n\t\t\tstruct efs_dentry *dirslot;\n\t\t\tefs_ino_t inodenum;\n\t\t\tconst char *nameptr;\n\t\t\tint namelen;\n\n\t\t\tif (dirblock->space[slot] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\t\t\tpr_debug(\"%s(): block %d slot %d/%d: inode %u, name \\\"%s\\\", namelen %u\\n\",\n\t\t\t\t __func__, block, slot, dirblock->slots-1,\n\t\t\t\t inodenum, nameptr, namelen);\n\t\t\tif (!namelen)\n\t\t\t\tcontinue;\n\t\t\t/* found the next entry */\n\t\t\tctx->pos = (block << EFS_DIRBSIZE_BITS) | slot;\n\n\t\t\t/* sanity check */\n\t\t\tif (nameptr - (char *) dirblock + namelen > EFS_DIRBSIZE) {\n\t\t\t\tpr_warn(\"directory entry %d exceeds directory block\\n\",\n\t\t\t\t\tslot);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* copy filename and data in dirslot */\n\t\t\tif (!dir_emit(ctx, nameptr, namelen, inodenum, DT_UNKNOWN)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\n\t\tslot = 0;\n\t\tblock++;\n\t}\n\tctx->pos = (block << EFS_DIRBSIZE_BITS) | slot;\n\treturn 0;\n}"
  }
]