[
  {
    "function_name": "nfs_sillyrename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "512-604",
    "snippet": "int\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t/*\n\t * We don't allow a dentry to be silly-renamed twice.\n\t */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(dentry->d_inode);\n\n\t/* Return delegation in anticipation of the rename */\n\tNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t/*\n\t\t * N.B. Better to return EBUSY here ... it could be\n\t\t * dangerous to delete the file while it's in use.\n\t\t */\n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (sdentry->d_inode != NULL); /* need negative lookup */\n\n\t/* queue unlink first. Can't do this from rpc_release as it\n\t * has to allocate memory\n\t */\n\terror = nfs_async_unlink(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/* populate unlinkdata with the right dname */\n\terror = nfs_copy_dname(sdentry,\n\t\t\t\t(struct nfs_unlinkdata *)dentry->d_fsdata);\n\tif (error) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* run the rename task, undo unlink if it fails */\n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* wait for the RPC task to complete, unless a SIGKILL intervenes */\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t/* The rename succeeded */\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t/* The result of the rename is unknown. Play it safe by\n\t\t * forcing a new lookup */\n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tdput(sdentry);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)",
      "#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)",
      "#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)",
      "#define SILLYNAME_PREFIX \".nfs\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sdentry"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_put_task",
          "args": [
            "task"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "sdentry"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "dentry",
            "sdentry"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wait_for_completion_task",
          "args": [
            "task"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_cancel_async_unlink",
          "args": [
            "dentry"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cancel_async_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "320-334",
          "snippet": "static void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_async_rename",
          "args": [
            "dir",
            "dir",
            "dentry",
            "sdentry",
            "nfs_complete_sillyrename"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_async_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "403-460",
          "snippet": "struct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstruct rpc_task *task = ERR_CAST(data->cred);\n\t\tkfree(data);\n\t\treturn task;\n\t}\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t/* set up nfs_renamedata */\n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t/* set up nfs_renameargs */\n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t/* set up nfs_renameres */\n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\n\n\treturn rpc_run_task(&task_setup_data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};\n\nstruct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstruct rpc_task *task = ERR_CAST(data->cred);\n\t\tkfree(data);\n\t\treturn task;\n\t}\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t/* set up nfs_renamedata */\n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t/* set up nfs_renameargs */\n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t/* set up nfs_renameres */\n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\n\n\treturn rpc_run_task(&task_setup_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_copy_dname",
          "args": [
            "sdentry",
            "(struct nfs_unlinkdata *)dentry->d_fsdata"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_copy_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "45-56",
          "snippet": "static int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tchar\t\t*str;\n\tint\t\tlen = dentry->d_name.len;\n\n\tstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\tdata->args.name.len = len;\n\tdata->args.name.name = str;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tchar\t\t*str;\n\tint\t\tlen = dentry->d_name.len;\n\n\tstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\tdata->args.name.len = len;\n\tdata->args.name.name = str;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_async_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_async_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "251-291",
          "snippet": "static int\nnfs_async_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs_unlinkdata *data;\n\tint status = -ENOMEM;\n\tvoid *devname_garbage = NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstatus = PTR_ERR(data->cred);\n\t\tgoto out_free;\n\t}\n\tdata->res.dir_attr = &data->dir_attr;\n\n\tstatus = -EBUSY;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out_unlock;\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tdevname_garbage = dentry->d_fsdata;\n\tdentry->d_fsdata = data;\n\tspin_unlock(&dentry->d_lock);\n\t/*\n\t * If we'd displaced old cached devname, free it.  At that\n\t * point dentry is definitely not a root, so we won't need\n\t * that anymore.\n\t */\n\tkfree(devname_garbage);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\tput_rpccred(data->cred);\nout_free:\n\tkfree(data);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int\nnfs_async_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs_unlinkdata *data;\n\tint status = -ENOMEM;\n\tvoid *devname_garbage = NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstatus = PTR_ERR(data->cred);\n\t\tgoto out_free;\n\t}\n\tdata->res.dir_attr = &data->dir_attr;\n\n\tstatus = -EBUSY;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out_unlock;\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tdevname_garbage = dentry->d_fsdata;\n\tdentry->d_fsdata = data;\n\tspin_unlock(&dentry->d_lock);\n\t/*\n\t * If we'd displaced old cached devname, free it.  At that\n\t * point dentry is definitely not a root, so we won't need\n\t * that anymore.\n\t */\n\tkfree(devname_garbage);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\tput_rpccred(data->cred);\nout_free:\n\tkfree(data);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdentry"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "silly",
            "dentry->d_parent",
            "slen"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: trying to rename %pd to %s\\n\"",
            "dentry",
            "silly"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "silly",
            "sizeof(silly)",
            "SILLYNAME_PREFIX \"%0*llx%0*x\"",
            "SILLYNAME_FILEID_LEN",
            "fileid",
            "SILLYNAME_COUNTER_LEN",
            "sillycounter"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dentry->d_inode"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dentry->d_inode"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "dentry->d_inode"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "dir",
            "NFSIOS_SILLYRENAME"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: silly-rename(%pd2, ct=%d)\\n\"",
            "dentry",
            "d_count(dentry)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "dentry"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)\n#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)\n#define SILLYNAME_PREFIX \".nfs\"\n\nint\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t/*\n\t * We don't allow a dentry to be silly-renamed twice.\n\t */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(dentry->d_inode);\n\n\t/* Return delegation in anticipation of the rename */\n\tNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t/*\n\t\t * N.B. Better to return EBUSY here ... it could be\n\t\t * dangerous to delete the file while it's in use.\n\t\t */\n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (sdentry->d_inode != NULL); /* need negative lookup */\n\n\t/* queue unlink first. Can't do this from rpc_release as it\n\t * has to allocate memory\n\t */\n\terror = nfs_async_unlink(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/* populate unlinkdata with the right dname */\n\terror = nfs_copy_dname(sdentry,\n\t\t\t\t(struct nfs_unlinkdata *)dentry->d_fsdata);\n\tif (error) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* run the rename task, undo unlink if it fails */\n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* wait for the RPC task to complete, unless a SIGKILL intervenes */\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t/* The rename succeeded */\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t/* The result of the rename is unknown. Play it safe by\n\t\t * forcing a new lookup */\n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tdput(sdentry);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_complete_sillyrename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "466-481",
    "snippet": "static void\nnfs_complete_sillyrename(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tstruct dentry *dentry = data->old_dentry;\n\n\tif (task->tk_status != 0) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\treturn;\n\t}\n\n\t/*\n\t * vfs_unlink and the like do not issue this when a file is\n\t * sillyrenamed, so do it here.\n\t */\n\tfsnotify_nameremove(dentry, 0);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_nameremove",
          "args": [
            "dentry",
            "0"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_cancel_async_unlink",
          "args": [
            "dentry"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cancel_async_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "320-334",
          "snippet": "static void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_complete_sillyrename(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tstruct dentry *dentry = data->old_dentry;\n\n\tif (task->tk_status != 0) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\treturn;\n\t}\n\n\t/*\n\t * vfs_unlink and the like do not issue this when a file is\n\t * sillyrenamed, so do it here.\n\t */\n\tfsnotify_nameremove(dentry, 0);\n}"
  },
  {
    "function_name": "nfs_async_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "403-460",
    "snippet": "struct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstruct rpc_task *task = ERR_CAST(data->cred);\n\t\tkfree(data);\n\t\treturn task;\n\t}\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t/* set up nfs_renamedata */\n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t/* set up nfs_renameargs */\n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t/* set up nfs_renameres */\n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\n\n\treturn rpc_run_task(&task_setup_data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_run_task",
          "args": [
            "&task_setup_data"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "&msg",
            "old_dir"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->old_dir"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sb_active",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sb_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "407-416",
          "snippet": "bool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nbool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "new_dir"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "old_dir"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fattr_init",
          "args": [
            "&data->new_fattr"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1286-1293",
          "snippet": "void nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "new_dentry"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "new_dir"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "data->cred"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data->cred"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_lookup_cred",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "old_dir"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};\n\nstruct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstruct rpc_task *task = ERR_CAST(data->cred);\n\t\tkfree(data);\n\t\treturn task;\n\t}\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t/* set up nfs_renamedata */\n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t/* set up nfs_renameargs */\n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t/* set up nfs_renameres */\n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\n\n\treturn rpc_run_task(&task_setup_data);\n}"
  },
  {
    "function_name": "nfs_rename_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "382-386",
    "snippet": "static void nfs_rename_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_renamedata *data = calldata;\n\tNFS_PROTO(data->old_dir)->rename_rpc_prepare(task, data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "data"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->old_dir"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_rename_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_renamedata *data = calldata;\n\tNFS_PROTO(data->old_dir)->rename_rpc_prepare(task, data);\n}"
  },
  {
    "function_name": "nfs_async_rename_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "365-380",
    "snippet": "static void nfs_async_rename_release(void *calldata)\n{\n\tstruct nfs_renamedata\t*data = calldata;\n\tstruct super_block *sb = data->old_dir->i_sb;\n\n\tif (data->old_dentry->d_inode)\n\t\tnfs_mark_for_revalidate(data->old_dentry->d_inode);\n\n\tdput(data->old_dentry);\n\tdput(data->new_dentry);\n\tiput(data->old_dir);\n\tiput(data->new_dir);\n\tnfs_sb_deactive(sb);\n\tput_rpccred(data->cred);\n\tkfree(data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "data->cred"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sb_deactive",
          "args": [
            "sb"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sb_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "419-425",
          "snippet": "void nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "data->new_dir"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "data->new_dentry"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_for_revalidate",
          "args": [
            "data->old_dentry->d_inode"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_async_rename_release(void *calldata)\n{\n\tstruct nfs_renamedata\t*data = calldata;\n\tstruct super_block *sb = data->old_dir->i_sb;\n\n\tif (data->old_dentry->d_inode)\n\t\tnfs_mark_for_revalidate(data->old_dentry->d_inode);\n\n\tdput(data->old_dentry);\n\tdput(data->new_dentry);\n\tiput(data->old_dir);\n\tiput(data->new_dir);\n\tnfs_sb_deactive(sb);\n\tput_rpccred(data->cred);\n\tkfree(data);\n}"
  },
  {
    "function_name": "nfs_async_rename_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "343-359",
    "snippet": "static void nfs_async_rename_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_renamedata *data = calldata;\n\tstruct inode *old_dir = data->old_dir;\n\tstruct inode *new_dir = data->new_dir;\n\tstruct dentry *old_dentry = data->old_dentry;\n\n\ttrace_nfs_sillyrename_rename(old_dir, old_dentry,\n\t\t\tnew_dir, data->new_dentry, task->tk_status);\n\tif (!NFS_PROTO(old_dir)->rename_done(task, old_dir, new_dir)) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\n\tif (data->complete)\n\t\tdata->complete(task, data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->complete",
          "args": [
            "task",
            "data"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "old_dir",
            "new_dir"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "old_dir"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_sillyrename_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "data->new_dentry",
            "task->tk_status"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_async_rename_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_renamedata *data = calldata;\n\tstruct inode *old_dir = data->old_dir;\n\tstruct inode *new_dir = data->new_dir;\n\tstruct dentry *old_dentry = data->old_dentry;\n\n\ttrace_nfs_sillyrename_rename(old_dir, old_dentry,\n\t\t\tnew_dir, data->new_dentry, task->tk_status);\n\tif (!NFS_PROTO(old_dir)->rename_done(task, old_dir, new_dir)) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\n\tif (data->complete)\n\t\tdata->complete(task, data);\n}"
  },
  {
    "function_name": "nfs_cancel_async_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "320-334",
    "snippet": "static void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_free_unlinkdata",
          "args": [
            "data"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_free_unlinkdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "30-37",
          "snippet": "static void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_cancel_async_unlink(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tstruct nfs_unlinkdata *data = dentry->d_fsdata;\n\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdentry->d_fsdata = NULL;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tnfs_free_unlinkdata(data);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n}"
  },
  {
    "function_name": "nfs_complete_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "302-317",
    "snippet": "void\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\n{\n\tstruct nfs_unlinkdata\t*data = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdata = dentry->d_fsdata;\n\t\tdentry->d_fsdata = NULL;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\tif (data != NULL && (NFS_STALE(inode) || !nfs_call_unlink(dentry, data)))\n\t\tnfs_free_unlinkdata(data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_free_unlinkdata",
          "args": [
            "data"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_free_unlinkdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "30-37",
          "snippet": "static void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_call_unlink",
          "args": [
            "dentry",
            "data"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_call_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "183-209",
          "snippet": "static int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint ret = 0;\n\n\n\tparent = dget_parent(dentry);\n\tif (parent == NULL)\n\t\tgoto out_free;\n\tdir = parent->d_inode;\n\t/* Non-exclusive lock protects against concurrent lookup() calls */\n\tspin_lock(&dir->i_lock);\n\tif (atomic_inc_not_zero(&NFS_I(dir)->silly_count) == 0) {\n\t\t/* Deferred delete */\n\t\thlist_add_head(&data->list, &NFS_I(dir)->silly_list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tret = 1;\n\t\tgoto out_dput;\n\t}\n\tspin_unlock(&dir->i_lock);\n\tret = nfs_do_call_unlink(parent, dir, data);\nout_dput:\n\tdput(parent);\nout_free:\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint ret = 0;\n\n\n\tparent = dget_parent(dentry);\n\tif (parent == NULL)\n\t\tgoto out_free;\n\tdir = parent->d_inode;\n\t/* Non-exclusive lock protects against concurrent lookup() calls */\n\tspin_lock(&dir->i_lock);\n\tif (atomic_inc_not_zero(&NFS_I(dir)->silly_count) == 0) {\n\t\t/* Deferred delete */\n\t\thlist_add_head(&data->list, &NFS_I(dir)->silly_list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tret = 1;\n\t\tgoto out_dput;\n\t}\n\tspin_unlock(&dir->i_lock);\n\tret = nfs_do_call_unlink(parent, dir, data);\nout_dput:\n\tdput(parent);\nout_free:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_STALE",
          "args": [
            "inode"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\n{\n\tstruct nfs_unlinkdata\t*data = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdata = dentry->d_fsdata;\n\t\tdentry->d_fsdata = NULL;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\tif (data != NULL && (NFS_STALE(inode) || !nfs_call_unlink(dentry, data)))\n\t\tnfs_free_unlinkdata(data);\n}"
  },
  {
    "function_name": "nfs_async_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "251-291",
    "snippet": "static int\nnfs_async_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs_unlinkdata *data;\n\tint status = -ENOMEM;\n\tvoid *devname_garbage = NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstatus = PTR_ERR(data->cred);\n\t\tgoto out_free;\n\t}\n\tdata->res.dir_attr = &data->dir_attr;\n\n\tstatus = -EBUSY;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out_unlock;\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tdevname_garbage = dentry->d_fsdata;\n\tdentry->d_fsdata = data;\n\tspin_unlock(&dentry->d_lock);\n\t/*\n\t * If we'd displaced old cached devname, free it.  At that\n\t * point dentry is definitely not a root, so we won't need\n\t * that anymore.\n\t */\n\tkfree(devname_garbage);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\tput_rpccred(data->cred);\nout_free:\n\tkfree(data);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "data->cred"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devname_garbage"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data->cred"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data->cred"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_lookup_cred",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int\nnfs_async_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs_unlinkdata *data;\n\tint status = -ENOMEM;\n\tvoid *devname_garbage = NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstatus = PTR_ERR(data->cred);\n\t\tgoto out_free;\n\t}\n\tdata->res.dir_attr = &data->dir_attr;\n\n\tstatus = -EBUSY;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out_unlock;\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tdevname_garbage = dentry->d_fsdata;\n\tdentry->d_fsdata = data;\n\tspin_unlock(&dentry->d_lock);\n\t/*\n\t * If we'd displaced old cached devname, free it.  At that\n\t * point dentry is definitely not a root, so we won't need\n\t * that anymore.\n\t */\n\tkfree(devname_garbage);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\tput_rpccred(data->cred);\nout_free:\n\tkfree(data);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_unblock_sillyrename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "225-244",
    "snippet": "void nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_free_unlinkdata",
          "args": [
            "data"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_free_unlinkdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "30-37",
          "snippet": "static void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_call_unlink",
          "args": [
            "dentry",
            "dir",
            "data"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_call_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "117-181",
          "snippet": "static int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tstruct dentry *alias;\n\n\talias = d_lookup(parent, &data->args.name);\n\tif (alias != NULL) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t/*\n\t\t * Hey, we raced with lookup... See if we need to transfer\n\t\t * the sillyrename information to the aliased dentry.\n\t\t */\n\t\tnfs_free_dname(data);\n\t\tret = nfs_copy_dname(alias, data);\n\t\tspin_lock(&alias->d_lock);\n\t\tif (ret == 0 && alias->d_inode != NULL &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tnfs_dec_sillycount(dir);\n\t\tdput(alias);\n\t\t/*\n\t\t * If we'd displaced old cached devname, free it.  At that\n\t\t * point dentry is definitely not a root, so we won't need\n\t\t * that anymore.\n\t\t */\n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dir = igrab(dir);\n\tif (!data->dir) {\n\t\tnfs_dec_sillycount(dir);\n\t\treturn 0;\n\t}\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, dir);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n\treturn 1;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};\n\nstatic int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tstruct dentry *alias;\n\n\talias = d_lookup(parent, &data->args.name);\n\tif (alias != NULL) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t/*\n\t\t * Hey, we raced with lookup... See if we need to transfer\n\t\t * the sillyrename information to the aliased dentry.\n\t\t */\n\t\tnfs_free_dname(data);\n\t\tret = nfs_copy_dname(alias, data);\n\t\tspin_lock(&alias->d_lock);\n\t\tif (ret == 0 && alias->d_inode != NULL &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tnfs_dec_sillycount(dir);\n\t\tdput(alias);\n\t\t/*\n\t\t * If we'd displaced old cached devname, free it.  At that\n\t\t * point dentry is definitely not a root, so we won't need\n\t\t * that anymore.\n\t\t */\n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dir = igrab(dir);\n\tif (!data->dir) {\n\t\tnfs_dec_sillycount(dir);\n\t\treturn 0;\n\t}\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, dir);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&data->list"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "nfsi->silly_list.first",
            "structnfs_unlinkdata",
            "list"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&nfsi->silly_count"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&nfsi->silly_list"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&nfsi->silly_count"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}"
  },
  {
    "function_name": "nfs_block_sillyrename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "218-223",
    "snippet": "void nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "nfsi->waitqueue",
            "atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&nfsi->silly_count",
            "1",
            "0"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}"
  },
  {
    "function_name": "nfs_wait_on_sillyrename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "211-216",
    "snippet": "void nfs_wait_on_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_read(&nfsi->silly_count) <= 1);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "nfsi->waitqueue",
            "atomic_read(&nfsi->silly_count) <= 1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nfsi->silly_count"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_wait_on_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_read(&nfsi->silly_count) <= 1);\n}"
  },
  {
    "function_name": "nfs_call_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "183-209",
    "snippet": "static int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint ret = 0;\n\n\n\tparent = dget_parent(dentry);\n\tif (parent == NULL)\n\t\tgoto out_free;\n\tdir = parent->d_inode;\n\t/* Non-exclusive lock protects against concurrent lookup() calls */\n\tspin_lock(&dir->i_lock);\n\tif (atomic_inc_not_zero(&NFS_I(dir)->silly_count) == 0) {\n\t\t/* Deferred delete */\n\t\thlist_add_head(&data->list, &NFS_I(dir)->silly_list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tret = 1;\n\t\tgoto out_dput;\n\t}\n\tspin_unlock(&dir->i_lock);\n\tret = nfs_do_call_unlink(parent, dir, data);\nout_dput:\n\tdput(parent);\nout_free:\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_call_unlink",
          "args": [
            "parent",
            "dir",
            "data"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_call_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "117-181",
          "snippet": "static int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tstruct dentry *alias;\n\n\talias = d_lookup(parent, &data->args.name);\n\tif (alias != NULL) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t/*\n\t\t * Hey, we raced with lookup... See if we need to transfer\n\t\t * the sillyrename information to the aliased dentry.\n\t\t */\n\t\tnfs_free_dname(data);\n\t\tret = nfs_copy_dname(alias, data);\n\t\tspin_lock(&alias->d_lock);\n\t\tif (ret == 0 && alias->d_inode != NULL &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tnfs_dec_sillycount(dir);\n\t\tdput(alias);\n\t\t/*\n\t\t * If we'd displaced old cached devname, free it.  At that\n\t\t * point dentry is definitely not a root, so we won't need\n\t\t * that anymore.\n\t\t */\n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dir = igrab(dir);\n\tif (!data->dir) {\n\t\tnfs_dec_sillycount(dir);\n\t\treturn 0;\n\t}\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, dir);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n\treturn 1;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};\n\nstatic int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tstruct dentry *alias;\n\n\talias = d_lookup(parent, &data->args.name);\n\tif (alias != NULL) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t/*\n\t\t * Hey, we raced with lookup... See if we need to transfer\n\t\t * the sillyrename information to the aliased dentry.\n\t\t */\n\t\tnfs_free_dname(data);\n\t\tret = nfs_copy_dname(alias, data);\n\t\tspin_lock(&alias->d_lock);\n\t\tif (ret == 0 && alias->d_inode != NULL &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tnfs_dec_sillycount(dir);\n\t\tdput(alias);\n\t\t/*\n\t\t * If we'd displaced old cached devname, free it.  At that\n\t\t * point dentry is definitely not a root, so we won't need\n\t\t * that anymore.\n\t\t */\n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dir = igrab(dir);\n\tif (!data->dir) {\n\t\tnfs_dec_sillycount(dir);\n\t\treturn 0;\n\t}\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, dir);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&data->list",
            "&NFS_I(dir)->silly_list"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&NFS_I(dir)->silly_count"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint ret = 0;\n\n\n\tparent = dget_parent(dentry);\n\tif (parent == NULL)\n\t\tgoto out_free;\n\tdir = parent->d_inode;\n\t/* Non-exclusive lock protects against concurrent lookup() calls */\n\tspin_lock(&dir->i_lock);\n\tif (atomic_inc_not_zero(&NFS_I(dir)->silly_count) == 0) {\n\t\t/* Deferred delete */\n\t\thlist_add_head(&data->list, &NFS_I(dir)->silly_list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tret = 1;\n\t\tgoto out_dput;\n\t}\n\tspin_unlock(&dir->i_lock);\n\tret = nfs_do_call_unlink(parent, dir, data);\nout_dput:\n\tdput(parent);\nout_free:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_do_call_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "117-181",
    "snippet": "static int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tstruct dentry *alias;\n\n\talias = d_lookup(parent, &data->args.name);\n\tif (alias != NULL) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t/*\n\t\t * Hey, we raced with lookup... See if we need to transfer\n\t\t * the sillyrename information to the aliased dentry.\n\t\t */\n\t\tnfs_free_dname(data);\n\t\tret = nfs_copy_dname(alias, data);\n\t\tspin_lock(&alias->d_lock);\n\t\tif (ret == 0 && alias->d_inode != NULL &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tnfs_dec_sillycount(dir);\n\t\tdput(alias);\n\t\t/*\n\t\t * If we'd displaced old cached devname, free it.  At that\n\t\t * point dentry is definitely not a root, so we won't need\n\t\t * that anymore.\n\t\t */\n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dir = igrab(dir);\n\tif (!data->dir) {\n\t\tnfs_dec_sillycount(dir);\n\t\treturn 0;\n\t}\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, dir);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n\treturn 1;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_task_async",
          "args": [
            "task"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_run_task",
          "args": [
            "&task_setup_data"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "dir"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "&msg",
            "dir"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fattr_init",
          "args": [
            "data->res.dir_attr"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1286-1293",
          "snippet": "void nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "dir"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sb_active",
          "args": [
            "dir->i_sb"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sb_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "407-416",
          "snippet": "bool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nbool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_dec_sillycount",
          "args": [
            "dir"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dec_sillycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "65-70",
          "snippet": "static void nfs_dec_sillycount(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tif (atomic_dec_return(&nfsi->silly_count) == 1)\n\t\twake_up(&nfsi->waitqueue);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_dec_sillycount(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tif (atomic_dec_return(&nfsi->silly_count) == 1)\n\t\twake_up(&nfsi->waitqueue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "dir"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_igrab_and_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "517-525",
          "snippet": "static inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devname_garbage"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "alias"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&alias->d_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&alias->d_lock"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_copy_dname",
          "args": [
            "alias",
            "data"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_copy_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "45-56",
          "snippet": "static int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tchar\t\t*str;\n\tint\t\tlen = dentry->d_name.len;\n\n\tstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\tdata->args.name.len = len;\n\tdata->args.name.name = str;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tchar\t\t*str;\n\tint\t\tlen = dentry->d_name.len;\n\n\tstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\tdata->args.name.len = len;\n\tdata->args.name.name = str;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_free_dname",
          "args": [
            "data"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_free_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "58-63",
          "snippet": "static void nfs_free_dname(struct nfs_unlinkdata *data)\n{\n\tkfree(data->args.name.name);\n\tdata->args.name.name = NULL;\n\tdata->args.name.len = 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_free_dname(struct nfs_unlinkdata *data)\n{\n\tkfree(data->args.name.name);\n\tdata->args.name.name = NULL;\n\tdata->args.name.len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&data->args.name"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_unlink_ops = {\n\t.rpc_call_done = nfs_async_unlink_done,\n\t.rpc_release = nfs_async_unlink_release,\n\t.rpc_call_prepare = nfs_unlink_prepare,\n};\n\nstatic int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_unlink_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tstruct dentry *alias;\n\n\talias = d_lookup(parent, &data->args.name);\n\tif (alias != NULL) {\n\t\tint ret;\n\t\tvoid *devname_garbage = NULL;\n\n\t\t/*\n\t\t * Hey, we raced with lookup... See if we need to transfer\n\t\t * the sillyrename information to the aliased dentry.\n\t\t */\n\t\tnfs_free_dname(data);\n\t\tret = nfs_copy_dname(alias, data);\n\t\tspin_lock(&alias->d_lock);\n\t\tif (ret == 0 && alias->d_inode != NULL &&\n\t\t    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\t\tdevname_garbage = alias->d_fsdata;\n\t\t\talias->d_fsdata = data;\n\t\t\talias->d_flags |= DCACHE_NFSFS_RENAMED;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock(&alias->d_lock);\n\t\tnfs_dec_sillycount(dir);\n\t\tdput(alias);\n\t\t/*\n\t\t * If we'd displaced old cached devname, free it.  At that\n\t\t * point dentry is definitely not a root, so we won't need\n\t\t * that anymore.\n\t\t */\n\t\tkfree(devname_garbage);\n\t\treturn ret;\n\t}\n\tdata->dir = igrab(dir);\n\tif (!data->dir) {\n\t\tnfs_dec_sillycount(dir);\n\t\treturn 0;\n\t}\n\tnfs_sb_active(dir->i_sb);\n\tdata->args.fh = NFS_FH(dir);\n\tnfs_fattr_init(data->res.dir_attr);\n\n\tNFS_PROTO(dir)->unlink_setup(&msg, dir);\n\n\ttask_setup_data.rpc_client = NFS_CLIENT(dir);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs_unlink_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "105-109",
    "snippet": "static void nfs_unlink_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_unlinkdata *data = calldata;\n\tNFS_PROTO(data->dir)->unlink_rpc_prepare(task, data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "data"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->dir"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_unlink_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_unlinkdata *data = calldata;\n\tNFS_PROTO(data->dir)->unlink_rpc_prepare(task, data);\n}"
  },
  {
    "function_name": "nfs_async_unlink_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "95-103",
    "snippet": "static void nfs_async_unlink_release(void *calldata)\n{\n\tstruct nfs_unlinkdata\t*data = calldata;\n\tstruct super_block *sb = data->dir->i_sb;\n\n\tnfs_dec_sillycount(data->dir);\n\tnfs_free_unlinkdata(data);\n\tnfs_sb_deactive(sb);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_sb_deactive",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sb_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "419-425",
          "snippet": "void nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_free_unlinkdata",
          "args": [
            "data"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_free_unlinkdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "30-37",
          "snippet": "static void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_dec_sillycount",
          "args": [
            "data->dir"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dec_sillycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "65-70",
          "snippet": "static void nfs_dec_sillycount(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tif (atomic_dec_return(&nfsi->silly_count) == 1)\n\t\twake_up(&nfsi->waitqueue);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_dec_sillycount(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tif (atomic_dec_return(&nfsi->silly_count) == 1)\n\t\twake_up(&nfsi->waitqueue);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_async_unlink_release(void *calldata)\n{\n\tstruct nfs_unlinkdata\t*data = calldata;\n\tstruct super_block *sb = data->dir->i_sb;\n\n\tnfs_dec_sillycount(data->dir);\n\tnfs_free_unlinkdata(data);\n\tnfs_sb_deactive(sb);\n}"
  },
  {
    "function_name": "nfs_async_unlink_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "78-86",
    "snippet": "static void nfs_async_unlink_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_unlinkdata *data = calldata;\n\tstruct inode *dir = data->dir;\n\n\ttrace_nfs_sillyrename_unlink(data, task->tk_status);\n\tif (!NFS_PROTO(dir)->unlink_done(task, dir))\n\t\trpc_restart_call_prepare(task);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "dir"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_sillyrename_unlink",
          "args": [
            "data",
            "task->tk_status"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_async_unlink_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_unlinkdata *data = calldata;\n\tstruct inode *dir = data->dir;\n\n\ttrace_nfs_sillyrename_unlink(data, task->tk_status);\n\tif (!NFS_PROTO(dir)->unlink_done(task, dir))\n\t\trpc_restart_call_prepare(task);\n}"
  },
  {
    "function_name": "nfs_dec_sillycount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "65-70",
    "snippet": "static void nfs_dec_sillycount(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tif (atomic_dec_return(&nfsi->silly_count) == 1)\n\t\twake_up(&nfsi->waitqueue);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&nfsi->waitqueue"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&nfsi->silly_count"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_dec_sillycount(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tif (atomic_dec_return(&nfsi->silly_count) == 1)\n\t\twake_up(&nfsi->waitqueue);\n}"
  },
  {
    "function_name": "nfs_free_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "58-63",
    "snippet": "static void nfs_free_dname(struct nfs_unlinkdata *data)\n{\n\tkfree(data->args.name.name);\n\tdata->args.name.name = NULL;\n\tdata->args.name.len = 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->args.name.name"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void nfs_free_dname(struct nfs_unlinkdata *data)\n{\n\tkfree(data->args.name.name);\n\tdata->args.name.name = NULL;\n\tdata->args.name.len = 0;\n}"
  },
  {
    "function_name": "nfs_copy_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "45-56",
    "snippet": "static int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tchar\t\t*str;\n\tint\t\tlen = dentry->d_name.len;\n\n\tstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\tdata->args.name.len = len;\n\tdata->args.name.name = str;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "dentry->d_name.name",
            "NAME_ALLOC_LEN(len)",
            "GFP_KERNEL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NAME_ALLOC_LEN",
          "args": [
            "len"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\n{\n\tchar\t\t*str;\n\tint\t\tlen = dentry->d_name.len;\n\n\tstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\tdata->args.name.len = len;\n\tdata->args.name.name = str;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_free_unlinkdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
    "lines": "30-37",
    "snippet": "static void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"delegation.h\"",
      "#include \"iostat.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->args.name.name"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "data->cred"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "data->dir"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic void\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\n{\n\tiput(data->dir);\n\tput_rpccred(data->cred);\n\tkfree(data->args.name.name);\n\tkfree(data);\n}"
  }
]