[
  {
    "function_name": "cachefiles_check_in_use",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "962-978",
    "snippet": "int cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "victim"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "victim"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "victim"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_check_active",
          "args": [
            "cache",
            "dir",
            "filename"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "816-897",
          "snippet": "static struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\n\t\t\t\t\t      struct dentry *dir,\n\t\t\t\t\t      char *filename)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *_n;\n\tstruct dentry *victim;\n\tunsigned long start;\n\tint ret;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\t/* look up the victim */\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\n\t//_debug(\"victim -> %p %s\",\n\t//       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* if the object is no longer there then we probably retired the object\n\t * at the netfs's request whilst the cull was in progress\n\t */\n\tif (!victim->d_inode) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(victim);\n\t\t_leave(\" = -ENOENT [absent]\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t/* check to see if we're using this object */\n\tread_lock(&cache->active_lock);\n\n\t_n = cache->active_nodes.rb_node;\n\n\twhile (_n) {\n\t\tobject = rb_entry(_n, struct cachefiles_object, active_node);\n\n\t\tif (object->dentry > victim)\n\t\t\t_n = _n->rb_left;\n\t\telse if (object->dentry < victim)\n\t\t\t_n = _n->rb_right;\n\t\telse\n\t\t\tgoto object_in_use;\n\t}\n\n\tread_unlock(&cache->active_lock);\n\n\t//_leave(\" = %p\", victim);\n\treturn victim;\n\nobject_in_use:\n\tread_unlock(&cache->active_lock);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = -EBUSY [in use]\");\n\treturn ERR_PTR(-EBUSY);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\n\t\t\t\t\t      struct dentry *dir,\n\t\t\t\t\t      char *filename)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *_n;\n\tstruct dentry *victim;\n\tunsigned long start;\n\tint ret;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\t/* look up the victim */\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\n\t//_debug(\"victim -> %p %s\",\n\t//       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* if the object is no longer there then we probably retired the object\n\t * at the netfs's request whilst the cull was in progress\n\t */\n\tif (!victim->d_inode) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(victim);\n\t\t_leave(\" = -ENOENT [absent]\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t/* check to see if we're using this object */\n\tread_lock(&cache->active_lock);\n\n\t_n = cache->active_nodes.rb_node;\n\n\twhile (_n) {\n\t\tobject = rb_entry(_n, struct cachefiles_object, active_node);\n\n\t\tif (object->dentry > victim)\n\t\t\t_n = _n->rb_left;\n\t\telse if (object->dentry < victim)\n\t\t\t_n = _n->rb_right;\n\t\telse\n\t\t\tgoto object_in_use;\n\t}\n\n\tread_unlock(&cache->active_lock);\n\n\t//_leave(\" = %p\", victim);\n\treturn victim;\n\nobject_in_use:\n\tread_unlock(&cache->active_lock);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = -EBUSY [in use]\");\n\treturn ERR_PTR(-EBUSY);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_cull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "903-955",
    "snippet": "int cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\tint ret;\n\n\t_enter(\",%pd/,%s\", dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\t_debug(\"victim -> %p %s\",\n\t       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* okay... the victim is not being used so we can cull it\n\t * - start by marking it as stale\n\t */\n\t_debug(\"victim is cullable\");\n\n\tret = cachefiles_remove_object_xattr(cache, victim);\n\tif (ret < 0)\n\t\tgoto error_unlock;\n\n\t/*  actually remove the victim (drops the dir mutex) */\n\t_debug(\"bury\");\n\n\tret = cachefiles_bury_object(cache, dir, victim, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdput(victim);\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\nerror:\n\tdput(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn -ESTALE;\n\t}\n\n\tif (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Internal error: %d\\n\"",
            "ret"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ESTALE [absent]\""
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "victim"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_bury_object",
          "args": [
            "cache",
            "dir",
            "victim",
            "false"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_bury_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "265-404",
          "snippet": "static int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"bury\""
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_remove_object_xattr",
          "args": [
            "cache",
            "victim"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_remove_object_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
          "lines": "306-324",
          "snippet": "int cachefiles_remove_object_xattr(struct cachefiles_cache *cache,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint ret;\n\n\tret = vfs_removexattr(dentry, cachefiles_xattr_cache);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT || ret == -ENODATA)\n\t\t\tret = 0;\n\t\telse if (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Can't remove xattr from %lu\"\n\t\t\t\t\t    \" (error %d)\",\n\t\t\t\t\t    dentry->d_inode->i_ino, -ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_remove_object_xattr(struct cachefiles_cache *cache,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint ret;\n\n\tret = vfs_removexattr(dentry, cachefiles_xattr_cache);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT || ret == -ENODATA)\n\t\t\tret = 0;\n\t\telse if (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Can't remove xattr from %lu\"\n\t\t\t\t\t    \" (error %d)\",\n\t\t\t\t\t    dentry->d_inode->i_ino, -ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"victim -> %p %s\"",
            "victim",
            "victim->d_inode ? \"positive\" : \"negative\""
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "victim"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "victim"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_check_active",
          "args": [
            "cache",
            "dir",
            "filename"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "816-897",
          "snippet": "static struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\n\t\t\t\t\t      struct dentry *dir,\n\t\t\t\t\t      char *filename)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *_n;\n\tstruct dentry *victim;\n\tunsigned long start;\n\tint ret;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\t/* look up the victim */\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\n\t//_debug(\"victim -> %p %s\",\n\t//       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* if the object is no longer there then we probably retired the object\n\t * at the netfs's request whilst the cull was in progress\n\t */\n\tif (!victim->d_inode) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(victim);\n\t\t_leave(\" = -ENOENT [absent]\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t/* check to see if we're using this object */\n\tread_lock(&cache->active_lock);\n\n\t_n = cache->active_nodes.rb_node;\n\n\twhile (_n) {\n\t\tobject = rb_entry(_n, struct cachefiles_object, active_node);\n\n\t\tif (object->dentry > victim)\n\t\t\t_n = _n->rb_left;\n\t\telse if (object->dentry < victim)\n\t\t\t_n = _n->rb_right;\n\t\telse\n\t\t\tgoto object_in_use;\n\t}\n\n\tread_unlock(&cache->active_lock);\n\n\t//_leave(\" = %p\", victim);\n\treturn victim;\n\nobject_in_use:\n\tread_unlock(&cache->active_lock);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = -EBUSY [in use]\");\n\treturn ERR_PTR(-EBUSY);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\n\t\t\t\t\t      struct dentry *dir,\n\t\t\t\t\t      char *filename)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *_n;\n\tstruct dentry *victim;\n\tunsigned long start;\n\tint ret;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\t/* look up the victim */\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\n\t//_debug(\"victim -> %p %s\",\n\t//       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* if the object is no longer there then we probably retired the object\n\t * at the netfs's request whilst the cull was in progress\n\t */\n\tif (!victim->d_inode) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(victim);\n\t\t_leave(\" = -ENOENT [absent]\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t/* check to see if we're using this object */\n\tread_lock(&cache->active_lock);\n\n\t_n = cache->active_nodes.rb_node;\n\n\twhile (_n) {\n\t\tobject = rb_entry(_n, struct cachefiles_object, active_node);\n\n\t\tif (object->dentry > victim)\n\t\t\t_n = _n->rb_left;\n\t\telse if (object->dentry < victim)\n\t\t\t_n = _n->rb_right;\n\t\telse\n\t\t\tgoto object_in_use;\n\t}\n\n\tread_unlock(&cache->active_lock);\n\n\t//_leave(\" = %p\", victim);\n\treturn victim;\n\nobject_in_use:\n\tread_unlock(&cache->active_lock);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = -EBUSY [in use]\");\n\treturn ERR_PTR(-EBUSY);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%pd/,%s\"",
            "dir",
            "filename"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\tint ret;\n\n\t_enter(\",%pd/,%s\", dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\t_debug(\"victim -> %p %s\",\n\t       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* okay... the victim is not being used so we can cull it\n\t * - start by marking it as stale\n\t */\n\t_debug(\"victim is cullable\");\n\n\tret = cachefiles_remove_object_xattr(cache, victim);\n\tif (ret < 0)\n\t\tgoto error_unlock;\n\n\t/*  actually remove the victim (drops the dir mutex) */\n\t_debug(\"bury\");\n\n\tret = cachefiles_bury_object(cache, dir, victim, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdput(victim);\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\nerror:\n\tdput(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn -ESTALE;\n\t}\n\n\tif (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_check_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "816-897",
    "snippet": "static struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\n\t\t\t\t\t      struct dentry *dir,\n\t\t\t\t\t      char *filename)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *_n;\n\tstruct dentry *victim;\n\tunsigned long start;\n\tint ret;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\t/* look up the victim */\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\n\t//_debug(\"victim -> %p %s\",\n\t//       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* if the object is no longer there then we probably retired the object\n\t * at the netfs's request whilst the cull was in progress\n\t */\n\tif (!victim->d_inode) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(victim);\n\t\t_leave(\" = -ENOENT [absent]\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t/* check to see if we're using this object */\n\tread_lock(&cache->active_lock);\n\n\t_n = cache->active_nodes.rb_node;\n\n\twhile (_n) {\n\t\tobject = rb_entry(_n, struct cachefiles_object, active_node);\n\n\t\tif (object->dentry > victim)\n\t\t\t_n = _n->rb_left;\n\t\telse if (object->dentry < victim)\n\t\t\t_n = _n->rb_right;\n\t\telse\n\t\t\tgoto object_in_use;\n\t}\n\n\tread_unlock(&cache->active_lock);\n\n\t//_leave(\" = %p\", victim);\n\treturn victim;\n\nobject_in_use:\n\tread_unlock(&cache->active_lock);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = -EBUSY [in use]\");\n\treturn ERR_PTR(-EBUSY);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Internal error: %d\\n\"",
            "ret"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Lookup failed\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ESTALE [absent]\""
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "victim"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "victim"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "_n",
            "structcachefiles_object",
            "active_node"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "victim"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_hist",
          "args": [
            "cachefiles_lookup_histogram",
            "start"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "187-194",
          "snippet": "static inline\nvoid cachefiles_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nstatic inline\nvoid cachefiles_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "filename",
            "dir",
            "strlen(filename)"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\n\t\t\t\t\t      struct dentry *dir,\n\t\t\t\t\t      char *filename)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *_n;\n\tstruct dentry *victim;\n\tunsigned long start;\n\tint ret;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\t/* look up the victim */\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\n\t//_debug(\"victim -> %p %s\",\n\t//       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* if the object is no longer there then we probably retired the object\n\t * at the netfs's request whilst the cull was in progress\n\t */\n\tif (!victim->d_inode) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(victim);\n\t\t_leave(\" = -ENOENT [absent]\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t/* check to see if we're using this object */\n\tread_lock(&cache->active_lock);\n\n\t_n = cache->active_nodes.rb_node;\n\n\twhile (_n) {\n\t\tobject = rb_entry(_n, struct cachefiles_object, active_node);\n\n\t\tif (object->dentry > victim)\n\t\t\t_n = _n->rb_left;\n\t\telse if (object->dentry < victim)\n\t\t\t_n = _n->rb_right;\n\t\telse\n\t\t\tgoto object_in_use;\n\t}\n\n\tread_unlock(&cache->active_lock);\n\n\t//_leave(\" = %p\", victim);\n\treturn victim;\n\nobject_in_use:\n\tread_unlock(&cache->active_lock);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = -EBUSY [in use]\");\n\treturn ERR_PTR(-EBUSY);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "cachefiles_get_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "710-808",
    "snippet": "struct dentry *cachefiles_get_directory(struct cachefiles_cache *cache,\n\t\t\t\t\tstruct dentry *dir,\n\t\t\t\t\tconst char *dirname)\n{\n\tstruct dentry *subdir;\n\tunsigned long start;\n\tstruct path path;\n\tint ret;\n\n\t_enter(\",,%s\", dirname);\n\n\t/* search the current directory for the element name */\n\tmutex_lock(&dir->d_inode->i_mutex);\n\n\tstart = jiffies;\n\tsubdir = lookup_one_len(dirname, dir, strlen(dirname));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(subdir)) {\n\t\tif (PTR_ERR(subdir) == -ENOMEM)\n\t\t\tgoto nomem_d_alloc;\n\t\tgoto lookup_error;\n\t}\n\n\t_debug(\"subdir -> %p %s\",\n\t       subdir, subdir->d_inode ? \"positive\" : \"negative\");\n\n\t/* we need to create the subdir if it doesn't exist yet */\n\tif (!subdir->d_inode) {\n\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\n\t\t_debug(\"attempt mkdir\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_mkdir(&path, subdir, 0700);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\t\tret = vfs_mkdir(dir->d_inode, subdir, 0700);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\n\t\tASSERT(subdir->d_inode);\n\n\t\t_debug(\"mkdir -> %p{%p{ino=%lu}}\",\n\t\t       subdir,\n\t\t       subdir->d_inode,\n\t\t       subdir->d_inode->i_ino);\n\t}\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t/* we need to make sure the subdir is a directory */\n\tASSERT(subdir->d_inode);\n\n\tif (!d_can_lookup(subdir)) {\n\t\tpr_err(\"%s is not a directory\\n\", dirname);\n\t\tret = -EIO;\n\t\tgoto check_error;\n\t}\n\n\tret = -EPERM;\n\tif (!subdir->d_inode->i_op->setxattr ||\n\t    !subdir->d_inode->i_op->getxattr ||\n\t    !subdir->d_inode->i_op->lookup ||\n\t    !subdir->d_inode->i_op->mkdir ||\n\t    !subdir->d_inode->i_op->create ||\n\t    (!subdir->d_inode->i_op->rename &&\n\t     !subdir->d_inode->i_op->rename2) ||\n\t    !subdir->d_inode->i_op->rmdir ||\n\t    !subdir->d_inode->i_op->unlink)\n\t\tgoto check_error;\n\n\t_leave(\" = [%lu]\", subdir->d_inode->i_ino);\n\treturn subdir;\n\ncheck_error:\n\tdput(subdir);\n\t_leave(\" = %d [check]\", ret);\n\treturn ERR_PTR(ret);\n\nmkdir_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(subdir);\n\tpr_err(\"mkdir %s failed with error %d\\n\", dirname, ret);\n\treturn ERR_PTR(ret);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(subdir);\n\tpr_err(\"Lookup %s failed with error %d\\n\", dirname, ret);\n\treturn ERR_PTR(ret);\n\nnomem_d_alloc:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\t_leave(\" = -ENOMEM\");\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Lookup %s failed with error %d\\n\"",
            "dirname",
            "ret"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "subdir"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mkdir %s failed with error %d\\n\"",
            "dirname",
            "ret"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "subdir"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [check]\"",
            "ret"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s is not a directory\\n\"",
            "dirname"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "subdir"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "subdir->d_inode"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"mkdir -> %p{%p{ino=%lu}}\"",
            "subdir",
            "subdir->d_inode",
            "subdir->d_inode->i_ino"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "subdir->d_inode"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkdir",
          "args": [
            "dir->d_inode",
            "subdir",
            "0700"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3515-3538",
          "snippet": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_mkdir",
          "args": [
            "&path",
            "subdir",
            "0700"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"attempt mkdir\""
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "1",
            "0"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "subdir"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "subdir"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_hist",
          "args": [
            "cachefiles_lookup_histogram",
            "start"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "187-194",
          "snippet": "static inline\nvoid cachefiles_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nstatic inline\nvoid cachefiles_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dirname",
            "dir",
            "strlen(dirname)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dirname"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%s\"",
            "dirname"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct dentry *cachefiles_get_directory(struct cachefiles_cache *cache,\n\t\t\t\t\tstruct dentry *dir,\n\t\t\t\t\tconst char *dirname)\n{\n\tstruct dentry *subdir;\n\tunsigned long start;\n\tstruct path path;\n\tint ret;\n\n\t_enter(\",,%s\", dirname);\n\n\t/* search the current directory for the element name */\n\tmutex_lock(&dir->d_inode->i_mutex);\n\n\tstart = jiffies;\n\tsubdir = lookup_one_len(dirname, dir, strlen(dirname));\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(subdir)) {\n\t\tif (PTR_ERR(subdir) == -ENOMEM)\n\t\t\tgoto nomem_d_alloc;\n\t\tgoto lookup_error;\n\t}\n\n\t_debug(\"subdir -> %p %s\",\n\t       subdir, subdir->d_inode ? \"positive\" : \"negative\");\n\n\t/* we need to create the subdir if it doesn't exist yet */\n\tif (!subdir->d_inode) {\n\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\n\t\t_debug(\"attempt mkdir\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_mkdir(&path, subdir, 0700);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\t\tret = vfs_mkdir(dir->d_inode, subdir, 0700);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\n\t\tASSERT(subdir->d_inode);\n\n\t\t_debug(\"mkdir -> %p{%p{ino=%lu}}\",\n\t\t       subdir,\n\t\t       subdir->d_inode,\n\t\t       subdir->d_inode->i_ino);\n\t}\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t/* we need to make sure the subdir is a directory */\n\tASSERT(subdir->d_inode);\n\n\tif (!d_can_lookup(subdir)) {\n\t\tpr_err(\"%s is not a directory\\n\", dirname);\n\t\tret = -EIO;\n\t\tgoto check_error;\n\t}\n\n\tret = -EPERM;\n\tif (!subdir->d_inode->i_op->setxattr ||\n\t    !subdir->d_inode->i_op->getxattr ||\n\t    !subdir->d_inode->i_op->lookup ||\n\t    !subdir->d_inode->i_op->mkdir ||\n\t    !subdir->d_inode->i_op->create ||\n\t    (!subdir->d_inode->i_op->rename &&\n\t     !subdir->d_inode->i_op->rename2) ||\n\t    !subdir->d_inode->i_op->rmdir ||\n\t    !subdir->d_inode->i_op->unlink)\n\t\tgoto check_error;\n\n\t_leave(\" = [%lu]\", subdir->d_inode->i_ino);\n\treturn subdir;\n\ncheck_error:\n\tdput(subdir);\n\t_leave(\" = %d [check]\", ret);\n\treturn ERR_PTR(ret);\n\nmkdir_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(subdir);\n\tpr_err(\"mkdir %s failed with error %d\\n\", dirname, ret);\n\treturn ERR_PTR(ret);\n\nlookup_error:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tret = PTR_ERR(subdir);\n\tpr_err(\"Lookup %s failed with error %d\\n\", dirname, ret);\n\treturn ERR_PTR(ret);\n\nnomem_d_alloc:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\t_leave(\" = -ENOMEM\");\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "cachefiles_walk_to_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "455-705",
    "snippet": "int cachefiles_walk_to_object(struct cachefiles_object *parent,\n\t\t\t      struct cachefiles_object *object,\n\t\t\t      const char *key,\n\t\t\t      struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_cache *cache;\n\tstruct dentry *dir, *next = NULL;\n\tstruct path path;\n\tunsigned long start;\n\tconst char *name;\n\tint ret, nlen;\n\n\t_enter(\"OBJ%x{%p},OBJ%x,%s,\",\n\t       parent->fscache.debug_id, parent->dentry,\n\t       object->fscache.debug_id, key);\n\n\tcache = container_of(parent->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\tpath.mnt = cache->mnt;\n\n\tASSERT(parent->dentry);\n\tASSERT(parent->dentry->d_inode);\n\n\tif (!(d_is_dir(parent->dentry))) {\n\t\t// TODO: convert file to dir\n\t\t_leave(\"looking up in none directory\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tdir = dget(parent->dentry);\n\nadvance:\n\t/* attempt to transit the first directory component */\n\tname = key;\n\tnlen = strlen(key);\n\n\t/* key ends in a double NUL */\n\tkey = key + nlen + 1;\n\tif (!*key)\n\t\tkey = NULL;\n\nlookup_again:\n\t/* search the current directory for the element name */\n\t_debug(\"lookup '%s'\", name);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tnext = lookup_one_len(name, dir, nlen);\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(next))\n\t\tgoto lookup_error;\n\n\t_debug(\"next -> %p %s\", next, next->d_inode ? \"positive\" : \"negative\");\n\n\tif (!key)\n\t\tobject->new = !next->d_inode;\n\n\t/* if this element of the path doesn't exist, then the lookup phase\n\t * failed, and we can release any readers in the certain knowledge that\n\t * there's nothing for them to actually read */\n\tif (!next->d_inode)\n\t\tfscache_object_lookup_negative(&object->fscache);\n\n\t/* we need to create the object if it's negative */\n\tif (key || object->type == FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* index objects and intervening tree levels must be subdirs */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mkdir(&path, next, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_mkdir(dir->d_inode, next, 0);\n\t\t\tcachefiles_hist(cachefiles_mkdir_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"mkdir -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next)) {\n\t\t\tpr_err(\"inode %lu is not a directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\n\t} else {\n\t\t/* non-index objects start out life as files */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mknod(&path, next, S_IFREG, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_create(dir->d_inode, next, S_IFREG, true);\n\t\t\tcachefiles_hist(cachefiles_create_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"create -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next) &&\n\t\t\t   !d_is_reg(next)\n\t\t\t   ) {\n\t\t\tpr_err(\"inode %lu is not a file or directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* process the next component */\n\tif (key) {\n\t\t_debug(\"advance\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(dir);\n\t\tdir = next;\n\t\tnext = NULL;\n\t\tgoto advance;\n\t}\n\n\t/* we've found the object we were looking for */\n\tobject->dentry = next;\n\n\t/* if we've found that the terminal object exists, then we need to\n\t * check its attributes and delete it if it's out of date */\n\tif (!object->new) {\n\t\t_debug(\"validate '%pd'\", next);\n\n\t\tret = cachefiles_check_object_xattr(object, auxdata);\n\t\tif (ret == -ESTALE) {\n\t\t\t/* delete the object (the deleter drops the directory\n\t\t\t * mutex) */\n\t\t\tobject->dentry = NULL;\n\n\t\t\tret = cachefiles_bury_object(cache, dir, next, true);\n\t\t\tdput(next);\n\t\t\tnext = NULL;\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto delete_error;\n\n\t\t\t_debug(\"redo lookup\");\n\t\t\tgoto lookup_again;\n\t\t}\n\t}\n\n\t/* note that we're now using this object */\n\tret = cachefiles_mark_object_active(cache, object);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n\tdir = NULL;\n\n\tif (ret == -ETIMEDOUT)\n\t\tgoto mark_active_timed_out;\n\n\t_debug(\"=== OBTAINED_OBJECT ===\");\n\n\tif (object->new) {\n\t\t/* attach data to a newly constructed terminal object */\n\t\tret = cachefiles_set_object_xattr(object, auxdata);\n\t\tif (ret < 0)\n\t\t\tgoto check_error;\n\t} else {\n\t\t/* always update the atime on an object we've just looked up\n\t\t * (this is used to keep track of culling, and atimes are only\n\t\t * updated by read, write and readdir but not lookup or\n\t\t * open) */\n\t\tpath.dentry = next;\n\t\ttouch_atime(&path);\n\t}\n\n\t/* open a file interface onto a data file */\n\tif (object->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\tif (d_is_reg(object->dentry)) {\n\t\t\tconst struct address_space_operations *aops;\n\n\t\t\tret = -EPERM;\n\t\t\taops = object->dentry->d_inode->i_mapping->a_ops;\n\t\t\tif (!aops->bmap)\n\t\t\t\tgoto check_error;\n\n\t\t\tobject->backer = object->dentry;\n\t\t} else {\n\t\t\tBUG(); // TODO: open file in data-class subdir\n\t\t}\n\t}\n\n\tobject->new = 0;\n\tfscache_obtained_object(&object->fscache);\n\n\t_leave(\" = 0 [%lu]\", object->dentry->d_inode->i_ino);\n\treturn 0;\n\ncreate_error:\n\t_debug(\"create error %d\", ret);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Create/mkdir failed\");\n\tgoto error;\n\nmark_active_timed_out:\n\t_debug(\"mark active timed out\");\n\tgoto release_dentry;\n\ncheck_error:\n\t_debug(\"check error %d\", ret);\n\twrite_lock(&cache->active_lock);\n\trb_erase(&object->active_node, &cache->active_nodes);\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\twake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\n\twrite_unlock(&cache->active_lock);\nrelease_dentry:\n\tdput(object->dentry);\n\tobject->dentry = NULL;\n\tgoto error_out;\n\ndelete_error:\n\t_debug(\"delete error %d\", ret);\n\tgoto error_out2;\n\nlookup_error:\n\t_debug(\"lookup error %ld\", PTR_ERR(next));\n\tret = PTR_ERR(next);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\tnext = NULL;\nerror:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(next);\nerror_out2:\n\tdput(dir);\nerror_out:\n\t_leave(\" = error %d\", -ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = error %d\"",
            "-ret"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Lookup failed\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "next"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"lookup error %ld\"",
            "PTR_ERR(next)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "next"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&object->flags",
            "CACHEFILES_OBJECT_ACTIVE"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&object->active_node",
            "&cache->active_nodes"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"mark active timed out\""
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Create/mkdir failed\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_obtained_object",
          "args": [
            "&object->fscache"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_obtained_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "521-547",
          "snippet": "void fscache_obtained_object(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\t/* if we were still looking up, then we must have a positive lookup\n\t * result, in which case there may be data available */\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_positive);\n\n\t\t/* We do (presumably) have data */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t/* Allow write requests to begin stacking up and read requests\n\t\t * to begin shovelling data.\n\t\t */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t} else {\n\t\tfscache_stat(&fscache_n_object_created);\n\t}\n\n\tset_bit(FSCACHE_OBJECT_IS_AVAILABLE, &object->flags);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_obtained_object(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\t/* if we were still looking up, then we must have a positive lookup\n\t * result, in which case there may be data available */\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_positive);\n\n\t\t/* We do (presumably) have data */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t/* Allow write requests to begin stacking up and read requests\n\t\t * to begin shovelling data.\n\t\t */\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t} else {\n\t\tfscache_stat(&fscache_n_object_created);\n\t}\n\n\tset_bit(FSCACHE_OBJECT_IS_AVAILABLE, &object->flags);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "object->dentry"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_atime",
          "args": [
            "&path"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "touch_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1587-1631",
          "snippet": "void touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_set_object_xattr",
          "args": [
            "object",
            "auxdata"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_set_object_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
          "lines": "103-126",
          "snippet": "int cachefiles_set_object_xattr(struct cachefiles_object *object,\n\t\t\t\tstruct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_CREATE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to set xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_set_object_xattr(struct cachefiles_object *object,\n\t\t\t\tstruct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_CREATE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to set xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_mark_object_active",
          "args": [
            "cache",
            "object"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_mark_object_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "146-256",
          "snippet": "static int cachefiles_mark_object_active(struct cachefiles_cache *cache,\n\t\t\t\t\t struct cachefiles_object *object)\n{\n\tstruct cachefiles_object *xobject;\n\tstruct rb_node **_p, *_parent = NULL;\n\tstruct dentry *dentry;\n\n\t_enter(\",%p\", object);\n\ntry_again:\n\twrite_lock(&cache->active_lock);\n\n\tif (test_and_set_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\n\t\tpr_err(\"Error: Object already active\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t\tBUG();\n\t}\n\n\tdentry = object->dentry;\n\t_p = &cache->active_nodes.rb_node;\n\twhile (*_p) {\n\t\t_parent = *_p;\n\t\txobject = rb_entry(_parent,\n\t\t\t\t   struct cachefiles_object, active_node);\n\n\t\tASSERT(xobject != object);\n\n\t\tif (xobject->dentry > dentry)\n\t\t\t_p = &(*_p)->rb_left;\n\t\telse if (xobject->dentry < dentry)\n\t\t\t_p = &(*_p)->rb_right;\n\t\telse\n\t\t\tgoto wait_for_old_object;\n\t}\n\n\trb_link_node(&object->active_node, _parent, _p);\n\trb_insert_color(&object->active_node, &cache->active_nodes);\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" = 0\");\n\treturn 0;\n\n\t/* an old object from a previous incarnation is hogging the slot - we\n\t * need to wait for it to be destroyed */\nwait_for_old_object:\n\tif (fscache_object_is_live(&xobject->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Unexpected object collision\\n\");\n\t\tcachefiles_printk_object(object, xobject);\n\t\tBUG();\n\t}\n\tatomic_inc(&xobject->usage);\n\twrite_unlock(&cache->active_lock);\n\n\tif (test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\twait_queue_head_t *wq;\n\n\t\tsigned long timeout = 60 * HZ;\n\t\twait_queue_t wait;\n\t\tbool requeue;\n\n\t\t/* if the object we're waiting for is queued for processing,\n\t\t * then just put ourselves on the queue behind it */\n\t\tif (work_pending(&xobject->fscache.work)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x immediately\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\t/* otherwise we sleep until either the object we're waiting for\n\t\t * is done, or the fscache_object is congested */\n\t\twq = bit_waitqueue(&xobject->flags, CACHEFILES_OBJECT_ACTIVE);\n\t\tinit_wait(&wait);\n\t\trequeue = false;\n\t\tdo {\n\t\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\t\tif (!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags))\n\t\t\t\tbreak;\n\n\t\t\trequeue = fscache_object_sleep_till_congested(&timeout);\n\t\t} while (timeout > 0 && !requeue);\n\t\tfinish_wait(wq, &wait);\n\n\t\tif (requeue &&\n\t\t    test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x after wait\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\tif (timeout <= 0) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"Error: Overlong wait for old active object to go away\\n\");\n\t\t\tcachefiles_printk_object(object, xobject);\n\t\t\tgoto requeue;\n\t\t}\n\t}\n\n\tASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags));\n\n\tcache->cache.ops->put_object(&xobject->fscache);\n\tgoto try_again;\n\nrequeue:\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\tcache->cache.ops->put_object(&xobject->fscache);\n\t_leave(\" = -ETIMEDOUT\");\n\treturn -ETIMEDOUT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int cachefiles_mark_object_active(struct cachefiles_cache *cache,\n\t\t\t\t\t struct cachefiles_object *object)\n{\n\tstruct cachefiles_object *xobject;\n\tstruct rb_node **_p, *_parent = NULL;\n\tstruct dentry *dentry;\n\n\t_enter(\",%p\", object);\n\ntry_again:\n\twrite_lock(&cache->active_lock);\n\n\tif (test_and_set_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\n\t\tpr_err(\"Error: Object already active\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t\tBUG();\n\t}\n\n\tdentry = object->dentry;\n\t_p = &cache->active_nodes.rb_node;\n\twhile (*_p) {\n\t\t_parent = *_p;\n\t\txobject = rb_entry(_parent,\n\t\t\t\t   struct cachefiles_object, active_node);\n\n\t\tASSERT(xobject != object);\n\n\t\tif (xobject->dentry > dentry)\n\t\t\t_p = &(*_p)->rb_left;\n\t\telse if (xobject->dentry < dentry)\n\t\t\t_p = &(*_p)->rb_right;\n\t\telse\n\t\t\tgoto wait_for_old_object;\n\t}\n\n\trb_link_node(&object->active_node, _parent, _p);\n\trb_insert_color(&object->active_node, &cache->active_nodes);\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" = 0\");\n\treturn 0;\n\n\t/* an old object from a previous incarnation is hogging the slot - we\n\t * need to wait for it to be destroyed */\nwait_for_old_object:\n\tif (fscache_object_is_live(&xobject->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Unexpected object collision\\n\");\n\t\tcachefiles_printk_object(object, xobject);\n\t\tBUG();\n\t}\n\tatomic_inc(&xobject->usage);\n\twrite_unlock(&cache->active_lock);\n\n\tif (test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\twait_queue_head_t *wq;\n\n\t\tsigned long timeout = 60 * HZ;\n\t\twait_queue_t wait;\n\t\tbool requeue;\n\n\t\t/* if the object we're waiting for is queued for processing,\n\t\t * then just put ourselves on the queue behind it */\n\t\tif (work_pending(&xobject->fscache.work)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x immediately\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\t/* otherwise we sleep until either the object we're waiting for\n\t\t * is done, or the fscache_object is congested */\n\t\twq = bit_waitqueue(&xobject->flags, CACHEFILES_OBJECT_ACTIVE);\n\t\tinit_wait(&wait);\n\t\trequeue = false;\n\t\tdo {\n\t\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\t\tif (!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags))\n\t\t\t\tbreak;\n\n\t\t\trequeue = fscache_object_sleep_till_congested(&timeout);\n\t\t} while (timeout > 0 && !requeue);\n\t\tfinish_wait(wq, &wait);\n\n\t\tif (requeue &&\n\t\t    test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x after wait\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\tif (timeout <= 0) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"Error: Overlong wait for old active object to go away\\n\");\n\t\t\tcachefiles_printk_object(object, xobject);\n\t\t\tgoto requeue;\n\t\t}\n\t}\n\n\tASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags));\n\n\tcache->cache.ops->put_object(&xobject->fscache);\n\tgoto try_again;\n\nrequeue:\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\tcache->cache.ops->put_object(&xobject->fscache);\n\t_leave(\" = -ETIMEDOUT\");\n\treturn -ETIMEDOUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_bury_object",
          "args": [
            "cache",
            "dir",
            "next",
            "true"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_bury_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "265-404",
          "snippet": "static int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_check_object_xattr",
          "args": [
            "object",
            "auxdata"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_object_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
          "lines": "197-301",
          "snippet": "int cachefiles_check_object_xattr(struct cachefiles_object *object,\n\t\t\t\t  struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, cachefiles_gfp);\n\tif (!auxbuf) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the current type label */\n\tret = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxbuf->type, 512 + 1);\n\tif (ret < 0) {\n\t\tif (ret == -ENODATA)\n\t\t\tgoto stale; /* no attribute - power went off\n\t\t\t\t     * mid-cull? */\n\n\t\tif (ret == -ERANGE)\n\t\t\tgoto bad_type_length;\n\n\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\"Can't read xattr on %lu (err %d)\",\n\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\tgoto error;\n\t}\n\n\t/* check the on-disk object */\n\tif (ret < 1)\n\t\tgoto bad_type_length;\n\n\tif (auxbuf->type != auxdata->type)\n\t\tgoto stale;\n\n\tauxbuf->len = ret;\n\n\t/* consult the netfs */\n\tif (object->fscache.cookie->def->check_aux) {\n\t\tenum fscache_checkaux result;\n\t\tunsigned int dlen;\n\n\t\tdlen = auxbuf->len - 1;\n\n\t\t_debug(\"checkaux %s #%u\",\n\t\t       object->fscache.cookie->def->name, dlen);\n\n\t\tresult = fscache_check_aux(&object->fscache,\n\t\t\t\t\t   &auxbuf->data, dlen);\n\n\t\tswitch (result) {\n\t\t\t/* entry okay as is */\n\t\tcase FSCACHE_CHECKAUX_OKAY:\n\t\t\tgoto okay;\n\n\t\t\t/* entry requires update */\n\t\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\t\tbreak;\n\n\t\t\t/* entry requires deletion */\n\t\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\t\tgoto stale;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/* update the current label */\n\t\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t\t   XATTR_REPLACE);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\t\"Can't update xattr on %lu\"\n\t\t\t\t\t\t\" (error %d)\",\n\t\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nokay:\n\tret = 0;\n\nerror:\n\tkfree(auxbuf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nbad_type_length:\n\tpr_err(\"Cache object %lu xattr length incorrect\\n\",\n\t       dentry->d_inode->i_ino);\n\tret = -EIO;\n\tgoto error;\n\nstale:\n\tret = -ESTALE;\n\tgoto error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_check_object_xattr(struct cachefiles_object *object,\n\t\t\t\t  struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, cachefiles_gfp);\n\tif (!auxbuf) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the current type label */\n\tret = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxbuf->type, 512 + 1);\n\tif (ret < 0) {\n\t\tif (ret == -ENODATA)\n\t\t\tgoto stale; /* no attribute - power went off\n\t\t\t\t     * mid-cull? */\n\n\t\tif (ret == -ERANGE)\n\t\t\tgoto bad_type_length;\n\n\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\"Can't read xattr on %lu (err %d)\",\n\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\tgoto error;\n\t}\n\n\t/* check the on-disk object */\n\tif (ret < 1)\n\t\tgoto bad_type_length;\n\n\tif (auxbuf->type != auxdata->type)\n\t\tgoto stale;\n\n\tauxbuf->len = ret;\n\n\t/* consult the netfs */\n\tif (object->fscache.cookie->def->check_aux) {\n\t\tenum fscache_checkaux result;\n\t\tunsigned int dlen;\n\n\t\tdlen = auxbuf->len - 1;\n\n\t\t_debug(\"checkaux %s #%u\",\n\t\t       object->fscache.cookie->def->name, dlen);\n\n\t\tresult = fscache_check_aux(&object->fscache,\n\t\t\t\t\t   &auxbuf->data, dlen);\n\n\t\tswitch (result) {\n\t\t\t/* entry okay as is */\n\t\tcase FSCACHE_CHECKAUX_OKAY:\n\t\t\tgoto okay;\n\n\t\t\t/* entry requires update */\n\t\tcase FSCACHE_CHECKAUX_NEEDS_UPDATE:\n\t\t\tbreak;\n\n\t\t\t/* entry requires deletion */\n\t\tcase FSCACHE_CHECKAUX_OBSOLETE:\n\t\t\tgoto stale;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/* update the current label */\n\t\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t\t   XATTR_REPLACE);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\t\"Can't update xattr on %lu\"\n\t\t\t\t\t\t\" (error %d)\",\n\t\t\t\t\t\tdentry->d_inode->i_ino, -ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nokay:\n\tret = 0;\n\nerror:\n\tkfree(auxbuf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nbad_type_length:\n\tpr_err(\"Cache object %lu xattr length incorrect\\n\",\n\t       dentry->d_inode->i_ino);\n\tret = -EIO;\n\tgoto error;\n\nstale:\n\tret = -ESTALE;\n\tgoto error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inode %lu is not a file or directory\\n\"",
            "next->d_inode->i_ino"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "next"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "next"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"create -> %p{%p{ino=%lu}}\"",
            "next",
            "next->d_inode",
            "next->d_inode->i_ino"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next->d_inode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_hist",
          "args": [
            "cachefiles_create_histogram",
            "start"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "187-194",
          "snippet": "static inline\nvoid cachefiles_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nstatic inline\nvoid cachefiles_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_create",
          "args": [
            "dir->d_inode",
            "next",
            "S_IFREG",
            "true"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2547-2565",
          "snippet": "int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_mknod",
          "args": [
            "&path",
            "next",
            "S_IFREG",
            "0"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "1",
            "0"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inode %lu is not a directory\\n\"",
            "next->d_inode->i_ino"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "next"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next->d_inode"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkdir",
          "args": [
            "dir->d_inode",
            "next",
            "0"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3515-3538",
          "snippet": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_mkdir",
          "args": [
            "&path",
            "next",
            "0"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_lookup_negative",
          "args": [
            "&object->fscache"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_lookup_negative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "488-508",
          "snippet": "void fscache_object_lookup_negative(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_negative);\n\n\t\t/* Allow write requests to begin stacking up and read requests to begin\n\t\t * returning ENODATA.\n\t\t */\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t_debug(\"wake up lookup %p\", &cookie->flags);\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t}\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_object_lookup_negative(struct fscache_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\n\t_enter(\"{OBJ%x,%s}\", object->debug_id, object->state->name);\n\n\tif (!test_and_set_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\tfscache_stat(&fscache_n_object_lookups_negative);\n\n\t\t/* Allow write requests to begin stacking up and read requests to begin\n\t\t * returning ENODATA.\n\t\t */\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t\t_debug(\"wake up lookup %p\", &cookie->flags);\n\t\tclear_bit_unlock(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\n\t}\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "next"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "dir",
            "nlen"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "parent->dentry"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"looking up in none directory\""
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "parent->dentry"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "parent->dentry->d_inode"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "parent->dentry"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "parent->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"OBJ%x{%p},OBJ%x,%s,\"",
            "parent->fscache.debug_id",
            "parent->dentry",
            "object->fscache.debug_id",
            "key"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_walk_to_object(struct cachefiles_object *parent,\n\t\t\t      struct cachefiles_object *object,\n\t\t\t      const char *key,\n\t\t\t      struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_cache *cache;\n\tstruct dentry *dir, *next = NULL;\n\tstruct path path;\n\tunsigned long start;\n\tconst char *name;\n\tint ret, nlen;\n\n\t_enter(\"OBJ%x{%p},OBJ%x,%s,\",\n\t       parent->fscache.debug_id, parent->dentry,\n\t       object->fscache.debug_id, key);\n\n\tcache = container_of(parent->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\tpath.mnt = cache->mnt;\n\n\tASSERT(parent->dentry);\n\tASSERT(parent->dentry->d_inode);\n\n\tif (!(d_is_dir(parent->dentry))) {\n\t\t// TODO: convert file to dir\n\t\t_leave(\"looking up in none directory\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tdir = dget(parent->dentry);\n\nadvance:\n\t/* attempt to transit the first directory component */\n\tname = key;\n\tnlen = strlen(key);\n\n\t/* key ends in a double NUL */\n\tkey = key + nlen + 1;\n\tif (!*key)\n\t\tkey = NULL;\n\nlookup_again:\n\t/* search the current directory for the element name */\n\t_debug(\"lookup '%s'\", name);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tnext = lookup_one_len(name, dir, nlen);\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(next))\n\t\tgoto lookup_error;\n\n\t_debug(\"next -> %p %s\", next, next->d_inode ? \"positive\" : \"negative\");\n\n\tif (!key)\n\t\tobject->new = !next->d_inode;\n\n\t/* if this element of the path doesn't exist, then the lookup phase\n\t * failed, and we can release any readers in the certain knowledge that\n\t * there's nothing for them to actually read */\n\tif (!next->d_inode)\n\t\tfscache_object_lookup_negative(&object->fscache);\n\n\t/* we need to create the object if it's negative */\n\tif (key || object->type == FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* index objects and intervening tree levels must be subdirs */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mkdir(&path, next, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_mkdir(dir->d_inode, next, 0);\n\t\t\tcachefiles_hist(cachefiles_mkdir_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"mkdir -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next)) {\n\t\t\tpr_err(\"inode %lu is not a directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\n\t} else {\n\t\t/* non-index objects start out life as files */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mknod(&path, next, S_IFREG, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_create(dir->d_inode, next, S_IFREG, true);\n\t\t\tcachefiles_hist(cachefiles_create_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"create -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next) &&\n\t\t\t   !d_is_reg(next)\n\t\t\t   ) {\n\t\t\tpr_err(\"inode %lu is not a file or directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* process the next component */\n\tif (key) {\n\t\t_debug(\"advance\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(dir);\n\t\tdir = next;\n\t\tnext = NULL;\n\t\tgoto advance;\n\t}\n\n\t/* we've found the object we were looking for */\n\tobject->dentry = next;\n\n\t/* if we've found that the terminal object exists, then we need to\n\t * check its attributes and delete it if it's out of date */\n\tif (!object->new) {\n\t\t_debug(\"validate '%pd'\", next);\n\n\t\tret = cachefiles_check_object_xattr(object, auxdata);\n\t\tif (ret == -ESTALE) {\n\t\t\t/* delete the object (the deleter drops the directory\n\t\t\t * mutex) */\n\t\t\tobject->dentry = NULL;\n\n\t\t\tret = cachefiles_bury_object(cache, dir, next, true);\n\t\t\tdput(next);\n\t\t\tnext = NULL;\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto delete_error;\n\n\t\t\t_debug(\"redo lookup\");\n\t\t\tgoto lookup_again;\n\t\t}\n\t}\n\n\t/* note that we're now using this object */\n\tret = cachefiles_mark_object_active(cache, object);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n\tdir = NULL;\n\n\tif (ret == -ETIMEDOUT)\n\t\tgoto mark_active_timed_out;\n\n\t_debug(\"=== OBTAINED_OBJECT ===\");\n\n\tif (object->new) {\n\t\t/* attach data to a newly constructed terminal object */\n\t\tret = cachefiles_set_object_xattr(object, auxdata);\n\t\tif (ret < 0)\n\t\t\tgoto check_error;\n\t} else {\n\t\t/* always update the atime on an object we've just looked up\n\t\t * (this is used to keep track of culling, and atimes are only\n\t\t * updated by read, write and readdir but not lookup or\n\t\t * open) */\n\t\tpath.dentry = next;\n\t\ttouch_atime(&path);\n\t}\n\n\t/* open a file interface onto a data file */\n\tif (object->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\tif (d_is_reg(object->dentry)) {\n\t\t\tconst struct address_space_operations *aops;\n\n\t\t\tret = -EPERM;\n\t\t\taops = object->dentry->d_inode->i_mapping->a_ops;\n\t\t\tif (!aops->bmap)\n\t\t\t\tgoto check_error;\n\n\t\t\tobject->backer = object->dentry;\n\t\t} else {\n\t\t\tBUG(); // TODO: open file in data-class subdir\n\t\t}\n\t}\n\n\tobject->new = 0;\n\tfscache_obtained_object(&object->fscache);\n\n\t_leave(\" = 0 [%lu]\", object->dentry->d_inode->i_ino);\n\treturn 0;\n\ncreate_error:\n\t_debug(\"create error %d\", ret);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Create/mkdir failed\");\n\tgoto error;\n\nmark_active_timed_out:\n\t_debug(\"mark active timed out\");\n\tgoto release_dentry;\n\ncheck_error:\n\t_debug(\"check error %d\", ret);\n\twrite_lock(&cache->active_lock);\n\trb_erase(&object->active_node, &cache->active_nodes);\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\twake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\n\twrite_unlock(&cache->active_lock);\nrelease_dentry:\n\tdput(object->dentry);\n\tobject->dentry = NULL;\n\tgoto error_out;\n\ndelete_error:\n\t_debug(\"delete error %d\", ret);\n\tgoto error_out2;\n\nlookup_error:\n\t_debug(\"lookup error %ld\", PTR_ERR(next));\n\tret = PTR_ERR(next);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\tnext = NULL;\nerror:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(next);\nerror_out2:\n\tdput(dir);\nerror_out:\n\t_leave(\" = error %d\", -ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_delete_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "409-449",
    "snippet": "int cachefiles_delete_object(struct cachefiles_cache *cache,\n\t\t\t     struct cachefiles_object *object)\n{\n\tstruct dentry *dir;\n\tint ret;\n\n\t_enter(\",OBJ%x{%p}\", object->fscache.debug_id, object->dentry);\n\n\tASSERT(object->dentry);\n\tASSERT(object->dentry->d_inode);\n\tASSERT(object->dentry->d_parent);\n\n\tdir = dget_parent(object->dentry);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tif (test_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\t/* object allocation for the same key preemptively deleted this\n\t\t * object's file so that it could create its own file */\n\t\t_debug(\"object preemptively buried\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tret = 0;\n\t} else {\n\t\t/* we need to check that our parent is _still_ our parent - it\n\t\t * may have been renamed */\n\t\tif (dir == object->dentry->d_parent) {\n\t\t\tret = cachefiles_bury_object(cache, dir,\n\t\t\t\t\t\t     object->dentry, false);\n\t\t} else {\n\t\t\t/* it got moved, presumably by cachefilesd culling it,\n\t\t\t * so it's no longer in the key path and we can ignore\n\t\t\t * it */\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tdput(dir);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_bury_object",
          "args": [
            "cache",
            "dir",
            "object->dentry",
            "false"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_bury_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "265-404",
          "snippet": "static int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"object preemptively buried\""
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_OBJECT_BURIED",
            "&object->flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "object->dentry"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "object->dentry->d_parent"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "object->dentry->d_inode"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "object->dentry"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",OBJ%x{%p}\"",
            "object->fscache.debug_id",
            "object->dentry"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_delete_object(struct cachefiles_cache *cache,\n\t\t\t     struct cachefiles_object *object)\n{\n\tstruct dentry *dir;\n\tint ret;\n\n\t_enter(\",OBJ%x{%p}\", object->fscache.debug_id, object->dentry);\n\n\tASSERT(object->dentry);\n\tASSERT(object->dentry->d_inode);\n\tASSERT(object->dentry->d_parent);\n\n\tdir = dget_parent(object->dentry);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tif (test_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\t/* object allocation for the same key preemptively deleted this\n\t\t * object's file so that it could create its own file */\n\t\t_debug(\"object preemptively buried\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tret = 0;\n\t} else {\n\t\t/* we need to check that our parent is _still_ our parent - it\n\t\t * may have been renamed */\n\t\tif (dir == object->dentry->d_parent) {\n\t\t\tret = cachefiles_bury_object(cache, dir,\n\t\t\t\t\t\t     object->dentry, false);\n\t\t} else {\n\t\t\t/* it got moved, presumably by cachefilesd culling it,\n\t\t\t * so it's no longer in the key path and we can ignore\n\t\t\t * it */\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tdput(dir);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_bury_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "265-404",
    "snippet": "static int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "grave"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "cache->graveyard",
            "dir"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_mark_object_buried",
          "args": [
            "cache",
            "rep"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_mark_object_buried",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "99-141",
          "snippet": "static void cachefiles_mark_object_buried(struct cachefiles_cache *cache,\n\t\t\t\t\t  struct dentry *dentry)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *p;\n\n\t_enter(\",'%pd'\", dentry);\n\n\twrite_lock(&cache->active_lock);\n\n\tp = cache->active_nodes.rb_node;\n\twhile (p) {\n\t\tobject = rb_entry(p, struct cachefiles_object, active_node);\n\t\tif (object->dentry > dentry)\n\t\t\tp = p->rb_left;\n\t\telse if (object->dentry < dentry)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_dentry;\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [no owner]\");\n\treturn;\n\n\t/* found the dentry for  */\nfound_dentry:\n\tkdebug(\"preemptive burial: OBJ%x [%s] %p\",\n\t       object->fscache.debug_id,\n\t       object->fscache.state->name,\n\t       dentry);\n\n\tif (fscache_object_is_live(&object->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Can't preemptively bury live object\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t} else if (test_and_set_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\tpr_err(\"Error: Object already preemptively buried\\n\");\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [owner marked]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void cachefiles_mark_object_buried(struct cachefiles_cache *cache,\n\t\t\t\t\t  struct dentry *dentry)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *p;\n\n\t_enter(\",'%pd'\", dentry);\n\n\twrite_lock(&cache->active_lock);\n\n\tp = cache->active_nodes.rb_node;\n\twhile (p) {\n\t\tobject = rb_entry(p, struct cachefiles_object, active_node);\n\t\tif (object->dentry > dentry)\n\t\t\tp = p->rb_left;\n\t\telse if (object->dentry < dentry)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_dentry;\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [no owner]\");\n\treturn;\n\n\t/* found the dentry for  */\nfound_dentry:\n\tkdebug(\"preemptive burial: OBJ%x [%s] %p\",\n\t       object->fscache.debug_id,\n\t       object->fscache.state->name,\n\t       dentry);\n\n\tif (fscache_object_is_live(&object->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Can't preemptively bury live object\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t} else if (test_and_set_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\tpr_err(\"Error: Object already preemptively buried\\n\");\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [owner marked]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Rename failed with error %d\"",
            "ret"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_rename",
          "args": [
            "dir->d_inode",
            "rep",
            "cache->graveyard->d_inode",
            "grave",
            "NULL",
            "0"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4106-4237",
          "snippet": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Rename security error %d\"",
            "ret"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_path_rename",
          "args": [
            "&path",
            "rep",
            "&path_to_graveyard",
            "grave",
            "0"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"May not make directory loop\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Mountpoint in graveyard\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "grave"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Lookup error %ld\"",
            "PTR_ERR(grave)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "grave"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "grave"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "grave"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "nbuffer",
            "cache->graveyard",
            "strlen(nbuffer)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nbuffer"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Mountpoint in cache\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "rep"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"May not make directory loop\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Graveyard no longer a directory\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "cache->graveyard"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "nbuffer",
            "\"%08x%08x\"",
            "(uint32_t) get_seconds()",
            "(uint32_t) atomic_inc_return(&cache->gravecounter)"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&cache->gravecounter"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"move stale object to graveyard\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Unlink failed\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_unlink",
          "args": [
            "dir->d_inode",
            "rep",
            "NULL"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3715-3752",
          "snippet": "int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Unlink security error\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_path_unlink",
          "args": [
            "&path",
            "rep"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "rep"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"remove %p from %p\"",
            "rep",
            "dir"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",'%pd','%pd'\"",
            "dir",
            "rep"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  bool preemptive)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\t_debug(\"remove %p from %p\", rep, dir);\n\n\t/* non-directories can just be unlinked */\n\tif (!d_is_dir(rep)) {\n\t\t_debug(\"unlink stale object\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_unlink(&path, rep);\n\t\tif (ret < 0) {\n\t\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\t} else {\n\t\t\tret = vfs_unlink(dir->d_inode, rep, NULL);\n\n\t\t\tif (preemptive)\n\t\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t\t}\n\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* directories have to be moved to the graveyard */\n\t_debug(\"move stale object to graveyard\");\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ntry_again:\n\t/* first step is to make up a grave dentry in the graveyard */\n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) get_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t/* do the multiway lock magic */\n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t/* do some checks before getting the grave dentry */\n\tif (rep->d_parent != dir) {\n\t\t/* the entry was probably culled when we dropped the parent dir\n\t\t * lock */\n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\",\n\t\t\t\t    PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (grave->d_inode) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t/* target should not be an ancestor of source */\n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t/* attempt the rename */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tret = vfs_rename(dir->d_inode, rep,\n\t\t\t\t cache->graveyard->d_inode, grave, NULL, 0);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\n\t\tif (preemptive)\n\t\t\tcachefiles_mark_object_buried(cache, rep);\n\t}\n\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_mark_object_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "146-256",
    "snippet": "static int cachefiles_mark_object_active(struct cachefiles_cache *cache,\n\t\t\t\t\t struct cachefiles_object *object)\n{\n\tstruct cachefiles_object *xobject;\n\tstruct rb_node **_p, *_parent = NULL;\n\tstruct dentry *dentry;\n\n\t_enter(\",%p\", object);\n\ntry_again:\n\twrite_lock(&cache->active_lock);\n\n\tif (test_and_set_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\n\t\tpr_err(\"Error: Object already active\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t\tBUG();\n\t}\n\n\tdentry = object->dentry;\n\t_p = &cache->active_nodes.rb_node;\n\twhile (*_p) {\n\t\t_parent = *_p;\n\t\txobject = rb_entry(_parent,\n\t\t\t\t   struct cachefiles_object, active_node);\n\n\t\tASSERT(xobject != object);\n\n\t\tif (xobject->dentry > dentry)\n\t\t\t_p = &(*_p)->rb_left;\n\t\telse if (xobject->dentry < dentry)\n\t\t\t_p = &(*_p)->rb_right;\n\t\telse\n\t\t\tgoto wait_for_old_object;\n\t}\n\n\trb_link_node(&object->active_node, _parent, _p);\n\trb_insert_color(&object->active_node, &cache->active_nodes);\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" = 0\");\n\treturn 0;\n\n\t/* an old object from a previous incarnation is hogging the slot - we\n\t * need to wait for it to be destroyed */\nwait_for_old_object:\n\tif (fscache_object_is_live(&xobject->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Unexpected object collision\\n\");\n\t\tcachefiles_printk_object(object, xobject);\n\t\tBUG();\n\t}\n\tatomic_inc(&xobject->usage);\n\twrite_unlock(&cache->active_lock);\n\n\tif (test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\twait_queue_head_t *wq;\n\n\t\tsigned long timeout = 60 * HZ;\n\t\twait_queue_t wait;\n\t\tbool requeue;\n\n\t\t/* if the object we're waiting for is queued for processing,\n\t\t * then just put ourselves on the queue behind it */\n\t\tif (work_pending(&xobject->fscache.work)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x immediately\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\t/* otherwise we sleep until either the object we're waiting for\n\t\t * is done, or the fscache_object is congested */\n\t\twq = bit_waitqueue(&xobject->flags, CACHEFILES_OBJECT_ACTIVE);\n\t\tinit_wait(&wait);\n\t\trequeue = false;\n\t\tdo {\n\t\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\t\tif (!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags))\n\t\t\t\tbreak;\n\n\t\t\trequeue = fscache_object_sleep_till_congested(&timeout);\n\t\t} while (timeout > 0 && !requeue);\n\t\tfinish_wait(wq, &wait);\n\n\t\tif (requeue &&\n\t\t    test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x after wait\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\tif (timeout <= 0) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"Error: Overlong wait for old active object to go away\\n\");\n\t\t\tcachefiles_printk_object(object, xobject);\n\t\t\tgoto requeue;\n\t\t}\n\t}\n\n\tASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags));\n\n\tcache->cache.ops->put_object(&xobject->fscache);\n\tgoto try_again;\n\nrequeue:\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\tcache->cache.ops->put_object(&xobject->fscache);\n\t_leave(\" = -ETIMEDOUT\");\n\treturn -ETIMEDOUT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ETIMEDOUT\""
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache->cache.ops->put_object",
          "args": [
            "&xobject->fscache"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache->cache.ops->put_object",
          "args": [
            "&xobject->fscache"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&xobject->flags"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_printk_object",
          "args": [
            "object",
            "xobject"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error: Overlong wait for old active object to go away\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"queue OBJ%x behind OBJ%x after wait\"",
            "object->fscache.debug_id",
            "xobject->fscache.debug_id"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_sleep_till_congested",
          "args": [
            "&timeout"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_sleep_till_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "803-817",
          "snippet": "bool fscache_object_sleep_till_congested(signed long *timeoutp)\n{\n\twait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);\n\tDEFINE_WAIT(wait);\n\n\tif (fscache_object_congested())\n\t\treturn true;\n\n\tadd_wait_queue_exclusive(cong_wq, &wait);\n\tif (!fscache_object_congested())\n\t\t*timeoutp = schedule_timeout(*timeoutp);\n\tfinish_wait(cong_wq, &wait);\n\n\treturn fscache_object_congested();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nbool fscache_object_sleep_till_congested(signed long *timeoutp)\n{\n\twait_queue_head_t *cong_wq = this_cpu_ptr(&fscache_object_cong_wait);\n\tDEFINE_WAIT(wait);\n\n\tif (fscache_object_congested())\n\t\treturn true;\n\n\tadd_wait_queue_exclusive(cong_wq, &wait);\n\tif (!fscache_object_congested())\n\t\t*timeoutp = schedule_timeout(*timeoutp);\n\tfinish_wait(cong_wq, &wait);\n\n\treturn fscache_object_congested();\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "&wait"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&xobject->flags",
            "CACHEFILES_OBJECT_ACTIVE"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "&xobject->fscache.work"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&xobject->usage"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error: Unexpected object collision\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_live",
          "args": [
            "&xobject->fscache"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&object->active_node",
            "&cache->active_nodes"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&object->active_node",
            "_parent",
            "_p"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xobject != object"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "_parent",
            "structcachefiles_object",
            "active_node"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error: Object already active\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%p\"",
            "object"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int cachefiles_mark_object_active(struct cachefiles_cache *cache,\n\t\t\t\t\t struct cachefiles_object *object)\n{\n\tstruct cachefiles_object *xobject;\n\tstruct rb_node **_p, *_parent = NULL;\n\tstruct dentry *dentry;\n\n\t_enter(\",%p\", object);\n\ntry_again:\n\twrite_lock(&cache->active_lock);\n\n\tif (test_and_set_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\n\t\tpr_err(\"Error: Object already active\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t\tBUG();\n\t}\n\n\tdentry = object->dentry;\n\t_p = &cache->active_nodes.rb_node;\n\twhile (*_p) {\n\t\t_parent = *_p;\n\t\txobject = rb_entry(_parent,\n\t\t\t\t   struct cachefiles_object, active_node);\n\n\t\tASSERT(xobject != object);\n\n\t\tif (xobject->dentry > dentry)\n\t\t\t_p = &(*_p)->rb_left;\n\t\telse if (xobject->dentry < dentry)\n\t\t\t_p = &(*_p)->rb_right;\n\t\telse\n\t\t\tgoto wait_for_old_object;\n\t}\n\n\trb_link_node(&object->active_node, _parent, _p);\n\trb_insert_color(&object->active_node, &cache->active_nodes);\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" = 0\");\n\treturn 0;\n\n\t/* an old object from a previous incarnation is hogging the slot - we\n\t * need to wait for it to be destroyed */\nwait_for_old_object:\n\tif (fscache_object_is_live(&xobject->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Unexpected object collision\\n\");\n\t\tcachefiles_printk_object(object, xobject);\n\t\tBUG();\n\t}\n\tatomic_inc(&xobject->usage);\n\twrite_unlock(&cache->active_lock);\n\n\tif (test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\twait_queue_head_t *wq;\n\n\t\tsigned long timeout = 60 * HZ;\n\t\twait_queue_t wait;\n\t\tbool requeue;\n\n\t\t/* if the object we're waiting for is queued for processing,\n\t\t * then just put ourselves on the queue behind it */\n\t\tif (work_pending(&xobject->fscache.work)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x immediately\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\t/* otherwise we sleep until either the object we're waiting for\n\t\t * is done, or the fscache_object is congested */\n\t\twq = bit_waitqueue(&xobject->flags, CACHEFILES_OBJECT_ACTIVE);\n\t\tinit_wait(&wait);\n\t\trequeue = false;\n\t\tdo {\n\t\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\t\tif (!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags))\n\t\t\t\tbreak;\n\n\t\t\trequeue = fscache_object_sleep_till_congested(&timeout);\n\t\t} while (timeout > 0 && !requeue);\n\t\tfinish_wait(wq, &wait);\n\n\t\tif (requeue &&\n\t\t    test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\n\t\t\t_debug(\"queue OBJ%x behind OBJ%x after wait\",\n\t\t\t       object->fscache.debug_id,\n\t\t\t       xobject->fscache.debug_id);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\tif (timeout <= 0) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"Error: Overlong wait for old active object to go away\\n\");\n\t\t\tcachefiles_printk_object(object, xobject);\n\t\t\tgoto requeue;\n\t\t}\n\t}\n\n\tASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags));\n\n\tcache->cache.ops->put_object(&xobject->fscache);\n\tgoto try_again;\n\nrequeue:\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\tcache->cache.ops->put_object(&xobject->fscache);\n\t_leave(\" = -ETIMEDOUT\");\n\treturn -ETIMEDOUT;\n}"
  },
  {
    "function_name": "cachefiles_mark_object_buried",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "99-141",
    "snippet": "static void cachefiles_mark_object_buried(struct cachefiles_cache *cache,\n\t\t\t\t\t  struct dentry *dentry)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *p;\n\n\t_enter(\",'%pd'\", dentry);\n\n\twrite_lock(&cache->active_lock);\n\n\tp = cache->active_nodes.rb_node;\n\twhile (p) {\n\t\tobject = rb_entry(p, struct cachefiles_object, active_node);\n\t\tif (object->dentry > dentry)\n\t\t\tp = p->rb_left;\n\t\telse if (object->dentry < dentry)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_dentry;\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [no owner]\");\n\treturn;\n\n\t/* found the dentry for  */\nfound_dentry:\n\tkdebug(\"preemptive burial: OBJ%x [%s] %p\",\n\t       object->fscache.debug_id,\n\t       object->fscache.state->name,\n\t       dentry);\n\n\tif (fscache_object_is_live(&object->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Can't preemptively bury live object\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t} else if (test_and_set_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\tpr_err(\"Error: Object already preemptively buried\\n\");\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [owner marked]\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [owner marked]\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error: Object already preemptively buried\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CACHEFILES_OBJECT_BURIED",
            "&object->flags"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_printk_object",
          "args": [
            "object",
            "NULL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "80-91",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error: Can't preemptively bury live object\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_live",
          "args": [
            "&object->fscache"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"preemptive burial: OBJ%x [%s] %p\"",
            "object->fscache.debug_id",
            "object->fscache.state->name",
            "dentry"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structcachefiles_object",
            "active_node"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",'%pd'\"",
            "dentry"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void cachefiles_mark_object_buried(struct cachefiles_cache *cache,\n\t\t\t\t\t  struct dentry *dentry)\n{\n\tstruct cachefiles_object *object;\n\tstruct rb_node *p;\n\n\t_enter(\",'%pd'\", dentry);\n\n\twrite_lock(&cache->active_lock);\n\n\tp = cache->active_nodes.rb_node;\n\twhile (p) {\n\t\tobject = rb_entry(p, struct cachefiles_object, active_node);\n\t\tif (object->dentry > dentry)\n\t\t\tp = p->rb_left;\n\t\telse if (object->dentry < dentry)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_dentry;\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [no owner]\");\n\treturn;\n\n\t/* found the dentry for  */\nfound_dentry:\n\tkdebug(\"preemptive burial: OBJ%x [%s] %p\",\n\t       object->fscache.debug_id,\n\t       object->fscache.state->name,\n\t       dentry);\n\n\tif (fscache_object_is_live(&object->fscache)) {\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"Error: Can't preemptively bury live object\\n\");\n\t\tcachefiles_printk_object(object, NULL);\n\t} else if (test_and_set_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\tpr_err(\"Error: Object already preemptively buried\\n\");\n\t}\n\n\twrite_unlock(&cache->active_lock);\n\t_leave(\" [owner marked]\");\n}"
  },
  {
    "function_name": "cachefiles_printk_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "80-91",
    "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CACHEFILES_KEYBUF_SIZE 512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "keybuf"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cachefiles_printk_object",
          "args": [
            "xobject",
            "\"x\"",
            "keybuf"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "CACHEFILES_KEYBUF_SIZE",
            "GFP_NOIO"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tu8 *keybuf;\n\n\tkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\", keybuf);\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\", keybuf);\n\tkfree(keybuf);\n}"
  },
  {
    "function_name": "__cachefiles_printk_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
    "lines": "30-75",
    "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CACHEFILES_KEYBUF_SIZE 512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"'\\n\""
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_kernfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "141-156",
          "snippet": "void pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);",
            "static char kernfs_pr_cont_buf[PATH_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\nstatic char kernfs_pr_cont_buf[PATH_MAX];\n\nvoid pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%02x\"",
            "keybuf[loop]"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%skey=[%u] '\"",
            "prefix",
            "keylen"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->fscache.lock"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%scookie=NULL\\n\"",
            "prefix"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie->def->get_key",
          "args": [
            "cookie->netfs_data",
            "keybuf",
            "CACHEFILES_KEYBUF_SIZE"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\"",
            "prefix",
            "object->fscache.cookie",
            "object->fscache.cookie->parent",
            "object->fscache.cookie->netfs_data",
            "object->fscache.cookie->flags"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->fscache.lock"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%sparent=%p\\n\"",
            "prefix",
            "object->fscache.parent"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%sops=%u inp=%u exc=%u\\n\"",
            "prefix",
            "object->fscache.n_ops",
            "object->fscache.n_in_progress",
            "object->fscache.n_exclusive"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\"",
            "prefix",
            "object->fscache.state->name",
            "object->fscache.flags",
            "work_busy(&object->fscache.work)",
            "object->fscache.events",
            "object->fscache.event_mask"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_busy",
          "args": [
            "&object->fscache.work"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%sobject: OBJ%x\\n\"",
            "prefix",
            "object->fscache.debug_id"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
  }
]