[
  {
    "function_name": "xfs_da_reada_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2626-2660",
    "snippet": "xfs_daddr_t\nxfs_da_reada_buf(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tmappedbno = mapp[0].bm_bn;\n\txfs_buf_readahead_map(dp->i_mount->m_ddev_targp, mapp, nmap, ops);\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\tif (error)\n\t\treturn -1;\n\treturn mappedbno;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mapp"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_readahead_map",
          "args": [
            "dp->i_mount->m_ddev_targp",
            "mapp",
            "nmap",
            "ops"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "671-683",
          "snippet": "void\nxfs_buf_readahead_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (bdi_read_congested(target->bt_bdi))\n\t\treturn;\n\n\txfs_buf_read_map(target, map, nmaps,\n\t\t     XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD, ops);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_readahead_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (bdi_read_congested(target->bt_bdi))\n\t\treturn;\n\n\txfs_buf_read_map(target, map, nmaps,\n\t\t     XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dabuf_map",
          "args": [
            "dp",
            "bno",
            "mappedbno",
            "whichfork",
            "&mapp",
            "&nmap"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dabuf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2447-2524",
          "snippet": "static int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_daddr_t\nxfs_da_reada_buf(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tmappedbno = mapp[0].bm_bn;\n\txfs_buf_readahead_map(dp->i_mount->m_ddev_targp, mapp, nmap, ops);\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\tif (error)\n\t\treturn -1;\n\treturn mappedbno;\n}"
  },
  {
    "function_name": "xfs_da_read_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2577-2621",
    "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mapp"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "bp",
            "XFS_DIR_BTREE_REF"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf_map",
          "args": [
            "dp->i_mount",
            "trans",
            "dp->i_mount->m_ddev_targp",
            "mapp",
            "nmap",
            "0",
            "&bp",
            "ops"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "240-337",
          "snippet": "int\nxfs_trans_read_buf_map(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp = NULL;\n\tstruct xfs_buf_log_item\t*bip;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  If it is already read in we just increment\n\t * the lock recursion count and return the buffer to the caller.\n\t * If the buffer is not yet read in, then we read it in, increment\n\t * the lock recursion count, and return it to the caller.\n\t */\n\tif (tp)\n\t\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(bp->b_transp == tp);\n\t\tASSERT(bp->b_fspriv != NULL);\n\t\tASSERT(!bp->b_error);\n\t\tASSERT(bp->b_flags & XBF_DONE);\n\n\t\t/*\n\t\t * We never locked this buf ourselves, so we shouldn't\n\t\t * brelse it either. Just get out.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbip = bp->b_fspriv;\n\t\tbip->bli_recur++;\n\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\ttrace_xfs_trans_read_buf_recur(bip);\n\t\t*bpp = bp;\n\t\treturn 0;\n\t}\n\n\tbp = xfs_buf_read_map(target, map, nmaps, flags, ops);\n\tif (!bp) {\n\t\tif (!(flags & XBF_TRYLOCK))\n\t\t\treturn -ENOMEM;\n\t\treturn tp ? 0 : -EAGAIN;\n\t}\n\n\t/*\n\t * If we've had a read error, then the contents of the buffer are\n\t * invalid and should not be used. To ensure that a followup read tries\n\t * to pull the buffer from disk again, we clear the XBF_DONE flag and\n\t * mark the buffer stale. This ensures that anyone who has a current\n\t * reference to the buffer will interpret it's contents correctly and\n\t * future cache lookups will also treat it as an empty, uninitialised\n\t * buffer.\n\t */\n\tif (bp->b_error) {\n\t\terror = bp->b_error;\n\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\txfs_buf_stale(bp);\n\n\t\tif (tp && (tp->t_flags & XFS_TRANS_DIRTY))\n\t\t\txfs_force_shutdown(tp->t_mountp, SHUTDOWN_META_IO_ERROR);\n\t\txfs_buf_relse(bp);\n\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\txfs_buf_relse(bp);\n\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\treturn -EIO;\n\t}\n\n\tif (tp) {\n\t\t_xfs_trans_bjoin(tp, bp, 1);\n\t\ttrace_xfs_trans_read_buf(bp->b_fspriv);\n\t}\n\t*bpp = bp;\n\treturn 0;\n\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_read_buf_map(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp = NULL;\n\tstruct xfs_buf_log_item\t*bip;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  If it is already read in we just increment\n\t * the lock recursion count and return the buffer to the caller.\n\t * If the buffer is not yet read in, then we read it in, increment\n\t * the lock recursion count, and return it to the caller.\n\t */\n\tif (tp)\n\t\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(bp->b_transp == tp);\n\t\tASSERT(bp->b_fspriv != NULL);\n\t\tASSERT(!bp->b_error);\n\t\tASSERT(bp->b_flags & XBF_DONE);\n\n\t\t/*\n\t\t * We never locked this buf ourselves, so we shouldn't\n\t\t * brelse it either. Just get out.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbip = bp->b_fspriv;\n\t\tbip->bli_recur++;\n\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\ttrace_xfs_trans_read_buf_recur(bip);\n\t\t*bpp = bp;\n\t\treturn 0;\n\t}\n\n\tbp = xfs_buf_read_map(target, map, nmaps, flags, ops);\n\tif (!bp) {\n\t\tif (!(flags & XBF_TRYLOCK))\n\t\t\treturn -ENOMEM;\n\t\treturn tp ? 0 : -EAGAIN;\n\t}\n\n\t/*\n\t * If we've had a read error, then the contents of the buffer are\n\t * invalid and should not be used. To ensure that a followup read tries\n\t * to pull the buffer from disk again, we clear the XBF_DONE flag and\n\t * mark the buffer stale. This ensures that anyone who has a current\n\t * reference to the buffer will interpret it's contents correctly and\n\t * future cache lookups will also treat it as an empty, uninitialised\n\t * buffer.\n\t */\n\tif (bp->b_error) {\n\t\terror = bp->b_error;\n\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\txfs_buf_stale(bp);\n\n\t\tif (tp && (tp->t_flags & XFS_TRANS_DIRTY))\n\t\t\txfs_force_shutdown(tp->t_mountp, SHUTDOWN_META_IO_ERROR);\n\t\txfs_buf_relse(bp);\n\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\txfs_buf_relse(bp);\n\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\treturn -EIO;\n\t}\n\n\tif (tp) {\n\t\t_xfs_trans_bjoin(tp, bp, 1);\n\t\ttrace_xfs_trans_read_buf(bp->b_fspriv);\n\t}\n\t*bpp = bp;\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dabuf_map",
          "args": [
            "dp",
            "bno",
            "mappedbno",
            "whichfork",
            "&mapp",
            "&nmap"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dabuf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2447-2524",
          "snippet": "static int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_da_get_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2529-2572",
    "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mapp"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "trans",
            "bp"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf_map",
          "args": [
            "trans",
            "dp->i_mount->m_ddev_targp",
            "mapp",
            "nmap",
            "0"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "133-180",
          "snippet": "struct xfs_buf *\nxfs_trans_get_buf_map(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\tif (!tp)\n\t\treturn xfs_buf_get_map(target, map, nmaps, flags);\n\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp != NULL) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tif (XFS_FORCED_SHUTDOWN(tp->t_mountp)) {\n\t\t\txfs_buf_stale(bp);\n\t\t\tXFS_BUF_DONE(bp);\n\t\t}\n\n\t\tASSERT(bp->b_transp == tp);\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_get_buf_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp == NULL) {\n\t\treturn NULL;\n\t}\n\n\tASSERT(!bp->b_error);\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_get_buf(bp->b_fspriv);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstruct xfs_buf *\nxfs_trans_get_buf_map(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\tif (!tp)\n\t\treturn xfs_buf_get_map(target, map, nmaps, flags);\n\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp != NULL) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tif (XFS_FORCED_SHUTDOWN(tp->t_mountp)) {\n\t\t\txfs_buf_stale(bp);\n\t\t\tXFS_BUF_DONE(bp);\n\t\t}\n\n\t\tASSERT(bp->b_transp == tp);\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_get_buf_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp == NULL) {\n\t\treturn NULL;\n\t}\n\n\tASSERT(!bp->b_error);\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_get_buf(bp->b_fspriv);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dabuf_map",
          "args": [
            "dp",
            "bno",
            "mappedbno",
            "whichfork",
            "&mapp",
            "&nmap"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dabuf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2447-2524",
          "snippet": "static int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dabuf_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2447-2524",
    "snippet": "static int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "irecs"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_map_from_irec",
          "args": [
            "mp",
            "map",
            "nmaps",
            "irecs",
            "nirecs"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_map_from_irec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2406-2437",
          "snippet": "static int\nxfs_buf_map_from_irec(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf_map\t**mapp,\n\tint\t\t\t*nmaps,\n\tstruct xfs_bmbt_irec\t*irecs,\n\tint\t\t\tnirecs)\n{\n\tstruct xfs_buf_map\t*map;\n\tint\t\t\ti;\n\n\tASSERT(*nmaps == 1);\n\tASSERT(nirecs >= 1);\n\n\tif (nirecs > 1) {\n\t\tmap = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map),\n\t\t\t\t  KM_SLEEP | KM_NOFS);\n\t\tif (!map)\n\t\t\treturn -ENOMEM;\n\t\t*mapp = map;\n\t}\n\n\t*nmaps = nirecs;\n\tmap = *mapp;\n\tfor (i = 0; i < *nmaps; i++) {\n\t\tASSERT(irecs[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       irecs[i].br_startblock != HOLESTARTBLOCK);\n\t\tmap[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);\n\t\tmap[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_buf_map_from_irec(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf_map\t**mapp,\n\tint\t\t\t*nmaps,\n\tstruct xfs_bmbt_irec\t*irecs,\n\tint\t\t\tnirecs)\n{\n\tstruct xfs_buf_map\t*map;\n\tint\t\t\ti;\n\n\tASSERT(*nmaps == 1);\n\tASSERT(nirecs >= 1);\n\n\tif (nirecs > 1) {\n\t\tmap = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map),\n\t\t\t\t  KM_SLEEP | KM_NOFS);\n\t\tif (!map)\n\t\t\treturn -ENOMEM;\n\t\t*mapp = map;\n\t}\n\n\t*nmaps = nirecs;\n\tmap = *mapp;\n\tfor (i = 0; i < *nmaps; i++) {\n\t\tASSERT(irecs[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       irecs[i].br_startblock != HOLESTARTBLOCK);\n\t\tmap[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);\n\t\tmap[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_do_buf(1)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\"",
            "i",
            "(long long)irecs[i].br_startoff",
            "(long long)irecs[i].br_startblock",
            "(long long)irecs[i].br_blockcount",
            "irecs[i].br_state"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error == -EFSCORRUPTED"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_map_covers_blocks",
          "args": [
            "nirecs",
            "irecs",
            "bno",
            "nfsb"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_map_covers_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2375-2396",
          "snippet": "STATIC int\nxfs_da_map_covers_blocks(\n\tint\t\tnmap,\n\txfs_bmbt_irec_t\t*mapp,\n\txfs_dablk_t\tbno,\n\tint\t\tcount)\n{\n\tint\t\ti;\n\txfs_fileoff_t\toff;\n\n\tfor (i = 0, off = bno; i < nmap; i++) {\n\t\tif (mapp[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    mapp[i].br_startblock == DELAYSTARTBLOCK) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (off != mapp[i].br_startoff) {\n\t\t\treturn 0;\n\t\t}\n\t\toff += mapp[i].br_blockcount;\n\t}\n\treturn off == bno + count;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_da_map_covers_blocks(\n\tint\t\tnmap,\n\txfs_bmbt_irec_t\t*mapp,\n\txfs_dablk_t\tbno,\n\tint\t\tcount)\n{\n\tint\t\ti;\n\txfs_fileoff_t\toff;\n\n\tfor (i = 0, off = bno; i < nmap; i++) {\n\t\tif (mapp[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    mapp[i].br_startblock == DELAYSTARTBLOCK) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (off != mapp[i].br_startoff) {\n\t\t\treturn 0;\n\t\t}\n\t\toff += mapp[i].br_blockcount;\n\t}\n\treturn off == bno + count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DADDR_TO_FSB",
          "args": [
            "mp",
            "mappedbno"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "dp",
            "(xfs_fileoff_t)bno",
            "nfsb",
            "irecs",
            "&nirecs",
            "xfs_bmapi_aflag(whichfork)"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_aflag",
          "args": [
            "whichfork"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_aflag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "122-125",
          "snippet": "static inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */\n\nstatic inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(irec) * nfsb",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmaps == 1"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map && *map"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dabuf_map(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tint\t\t\twhichfork,\n\tstruct xfs_buf_map\t**map,\n\tint\t\t\t*nmaps)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\tnfsb;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\tirec;\n\tstruct xfs_bmbt_irec\t*irecs = &irec;\n\tint\t\t\tnirecs;\n\n\tASSERT(map && *map);\n\tASSERT(*nmaps == 1);\n\n\tif (whichfork == XFS_DATA_FORK)\n\t\tnfsb = mp->m_dir_geo->fsbcount;\n\telse\n\t\tnfsb = mp->m_attr_geo->fsbcount;\n\n\t/*\n\t * Caller doesn't have a mapping.  -2 means don't complain\n\t * if we land in a hole.\n\t */\n\tif (mappedbno == -1 || mappedbno == -2) {\n\t\t/*\n\t\t * Optimize the one-block case.\n\t\t */\n\t\tif (nfsb != 1)\n\t\t\tirecs = kmem_zalloc(sizeof(irec) * nfsb,\n\t\t\t\t\t    KM_SLEEP | KM_NOFS);\n\n\t\tnirecs = nfsb;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)bno, nfsb, irecs,\n\t\t\t\t       &nirecs, xfs_bmapi_aflag(whichfork));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tirecs->br_startblock = XFS_DADDR_TO_FSB(mp, mappedbno);\n\t\tirecs->br_startoff = (xfs_fileoff_t)bno;\n\t\tirecs->br_blockcount = nfsb;\n\t\tirecs->br_state = 0;\n\t\tnirecs = 1;\n\t}\n\n\tif (!xfs_da_map_covers_blocks(nirecs, irecs, bno, nfsb)) {\n\t\terror = mappedbno == -2 ? -1 : -EFSCORRUPTED;\n\t\tif (unlikely(error == -EFSCORRUPTED)) {\n\t\t\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\t\t\tint i;\n\t\t\t\txfs_alert(mp, \"%s: bno %lld dir: inode %lld\",\n\t\t\t\t\t__func__, (long long)bno,\n\t\t\t\t\t(long long)dp->i_ino);\n\t\t\t\tfor (i = 0; i < *nmaps; i++) {\n\t\t\t\t\txfs_alert(mp,\n\"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t(long long)irecs[i].br_startoff,\n\t\t\t\t\t\t(long long)irecs[i].br_startblock,\n\t\t\t\t\t\t(long long)irecs[i].br_blockcount,\n\t\t\t\t\t\tirecs[i].br_state);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_do_buf(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t}\n\t\tgoto out;\n\t}\n\terror = xfs_buf_map_from_irec(mp, map, nmaps, irecs, nirecs);\nout:\n\tif (irecs != &irec)\n\t\tkmem_free(irecs);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_buf_map_from_irec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2406-2437",
    "snippet": "static int\nxfs_buf_map_from_irec(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf_map\t**mapp,\n\tint\t\t\t*nmaps,\n\tstruct xfs_bmbt_irec\t*irecs,\n\tint\t\t\tnirecs)\n{\n\tstruct xfs_buf_map\t*map;\n\tint\t\t\ti;\n\n\tASSERT(*nmaps == 1);\n\tASSERT(nirecs >= 1);\n\n\tif (nirecs > 1) {\n\t\tmap = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map),\n\t\t\t\t  KM_SLEEP | KM_NOFS);\n\t\tif (!map)\n\t\t\treturn -ENOMEM;\n\t\t*mapp = map;\n\t}\n\n\t*nmaps = nirecs;\n\tmap = *mapp;\n\tfor (i = 0; i < *nmaps; i++) {\n\t\tASSERT(irecs[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       irecs[i].br_startblock != HOLESTARTBLOCK);\n\t\tmap[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);\n\t\tmap[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "irecs[i].br_blockcount"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "irecs[i].br_startblock"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irecs[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       irecs[i].br_startblock != HOLESTARTBLOCK"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "nirecs * sizeof(struct xfs_buf_map)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nirecs >= 1"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmaps == 1"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_buf_map_from_irec(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf_map\t**mapp,\n\tint\t\t\t*nmaps,\n\tstruct xfs_bmbt_irec\t*irecs,\n\tint\t\t\tnirecs)\n{\n\tstruct xfs_buf_map\t*map;\n\tint\t\t\ti;\n\n\tASSERT(*nmaps == 1);\n\tASSERT(nirecs >= 1);\n\n\tif (nirecs > 1) {\n\t\tmap = kmem_zalloc(nirecs * sizeof(struct xfs_buf_map),\n\t\t\t\t  KM_SLEEP | KM_NOFS);\n\t\tif (!map)\n\t\t\treturn -ENOMEM;\n\t\t*mapp = map;\n\t}\n\n\t*nmaps = nirecs;\n\tmap = *mapp;\n\tfor (i = 0; i < *nmaps; i++) {\n\t\tASSERT(irecs[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       irecs[i].br_startblock != HOLESTARTBLOCK);\n\t\tmap[i].bm_bn = XFS_FSB_TO_DADDR(mp, irecs[i].br_startblock);\n\t\tmap[i].bm_len = XFS_FSB_TO_BB(mp, irecs[i].br_blockcount);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da_map_covers_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2375-2396",
    "snippet": "STATIC int\nxfs_da_map_covers_blocks(\n\tint\t\tnmap,\n\txfs_bmbt_irec_t\t*mapp,\n\txfs_dablk_t\tbno,\n\tint\t\tcount)\n{\n\tint\t\ti;\n\txfs_fileoff_t\toff;\n\n\tfor (i = 0, off = bno; i < nmap; i++) {\n\t\tif (mapp[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    mapp[i].br_startblock == DELAYSTARTBLOCK) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (off != mapp[i].br_startoff) {\n\t\t\treturn 0;\n\t\t}\n\t\toff += mapp[i].br_blockcount;\n\t}\n\treturn off == bno + count;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_da_map_covers_blocks(\n\tint\t\tnmap,\n\txfs_bmbt_irec_t\t*mapp,\n\txfs_dablk_t\tbno,\n\tint\t\tcount)\n{\n\tint\t\ti;\n\txfs_fileoff_t\toff;\n\n\tfor (i = 0, off = bno; i < nmap; i++) {\n\t\tif (mapp[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    mapp[i].br_startblock == DELAYSTARTBLOCK) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (off != mapp[i].br_startoff) {\n\t\t\treturn 0;\n\t\t}\n\t\toff += mapp[i].br_blockcount;\n\t}\n\treturn off == bno + count;\n}"
  },
  {
    "function_name": "xfs_da_shrink_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2332-2369",
    "snippet": "int\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "dead_buf"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_swap_lastblock",
          "args": [
            "args",
            "&dead_blkno",
            "&dead_buf"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_swap_lastblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2109-2327",
          "snippet": "STATIC int\nxfs_da3_swap_lastblock(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*dead_blknop,\n\tstruct xfs_buf\t\t**dead_bufp)\n{\n\tstruct xfs_da_blkinfo\t*dead_info;\n\tstruct xfs_da_blkinfo\t*sib_info;\n\tstruct xfs_da_intnode\t*par_node;\n\tstruct xfs_da_intnode\t*dead_node;\n\tstruct xfs_dir2_leaf\t*dead_leaf2;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr par_hdr;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp;\n\tstruct xfs_buf\t\t*dead_buf;\n\tstruct xfs_buf\t\t*last_buf;\n\tstruct xfs_buf\t\t*sib_buf;\n\tstruct xfs_buf\t\t*par_buf;\n\txfs_dahash_t\t\tdead_hash;\n\txfs_fileoff_t\t\tlastoff;\n\txfs_dablk_t\t\tdead_blkno;\n\txfs_dablk_t\t\tlast_blkno;\n\txfs_dablk_t\t\tsib_blkno;\n\txfs_dablk_t\t\tpar_blkno;\n\tint\t\t\terror;\n\tint\t\t\tw;\n\tint\t\t\tentno;\n\tint\t\t\tlevel;\n\tint\t\t\tdead_level;\n\n\ttrace_xfs_da_swap_lastblock(args);\n\n\tdead_buf = *dead_bufp;\n\tdead_blkno = *dead_blknop;\n\ttp = args->trans;\n\tdp = args->dp;\n\tw = args->whichfork;\n\tASSERT(w == XFS_DATA_FORK);\n\tmp = dp->i_mount;\n\tlastoff = args->geo->freeblk;\n\terror = xfs_bmap_last_before(tp, dp, &lastoff, w);\n\tif (error)\n\t\treturn error;\n\tif (unlikely(lastoff == 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t/*\n\t * Read the last block in the btree space.\n\t */\n\tlast_blkno = (xfs_dablk_t)lastoff - args->geo->fsbcount;\n\terror = xfs_da3_node_read(tp, dp, last_blkno, -1, &last_buf, w);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Copy the last block into the dead buffer and log it.\n\t */\n\tmemcpy(dead_buf->b_addr, last_buf->b_addr, args->geo->blksize);\n\txfs_trans_log_buf(tp, dead_buf, 0, args->geo->blksize - 1);\n\tdead_info = dead_buf->b_addr;\n\t/*\n\t * Get values from the moved block.\n\t */\n\tif (dead_info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    dead_info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tdead_leaf2 = (xfs_dir2_leaf_t *)dead_info;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, dead_leaf2);\n\t\tents = dp->d_ops->leaf_ents_p(dead_leaf2);\n\t\tdead_level = 0;\n\t\tdead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);\n\t} else {\n\t\tstruct xfs_da3_icnode_hdr deadhdr;\n\n\t\tdead_node = (xfs_da_intnode_t *)dead_info;\n\t\tdp->d_ops->node_hdr_from_disk(&deadhdr, dead_node);\n\t\tbtree = dp->d_ops->node_tree_p(dead_node);\n\t\tdead_level = deadhdr.level;\n\t\tdead_hash = be32_to_cpu(btree[deadhdr.count - 1].hashval);\n\t}\n\tsib_buf = par_buf = NULL;\n\t/*\n\t * If the moved block has a left sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->back))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t    be32_to_cpu(sib_info->forw) != last_blkno ||\n\t\t    sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->forw = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->forw,\n\t\t\t\t\tsizeof(sib_info->forw)));\n\t\tsib_buf = NULL;\n\t}\n\t/*\n\t * If the moved block has a right sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->forw))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t       be32_to_cpu(sib_info->back) != last_blkno ||\n\t\t       sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->back = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->back,\n\t\t\t\t\tsizeof(sib_info->back)));\n\t\tsib_buf = NULL;\n\t}\n\tpar_blkno = args->geo->leafblk;\n\tlevel = -1;\n\t/*\n\t * Walk down the tree looking for the parent of the moved block.\n\t */\n\tfor (;;) {\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (level >= 0 && level != par_hdr.level + 1) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(4)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tlevel = par_hdr.level;\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tfor (entno = 0;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].hashval) < dead_hash;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno == par_hdr.count) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(5)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tpar_blkno = be32_to_cpu(btree[entno].before);\n\t\tif (level == dead_level + 1)\n\t\t\tbreak;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t}\n\t/*\n\t * We're in the right parent block.\n\t * Look for the right entry.\n\t */\n\tfor (;;) {\n\t\tfor (;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].before) != last_blkno;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno < par_hdr.count)\n\t\t\tbreak;\n\t\tpar_blkno = par_hdr.forw;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t\tif (unlikely(par_blkno == 0)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(6)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (par_hdr.level != level) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(7)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tentno = 0;\n\t}\n\t/*\n\t * Update the parent entry pointing to the moved block.\n\t */\n\tbtree[entno].before = cpu_to_be32(dead_blkno);\n\txfs_trans_log_buf(tp, par_buf,\n\t\tXFS_DA_LOGRANGE(par_node, &btree[entno].before,\n\t\t\t\tsizeof(btree[entno].before)));\n\t*dead_blknop = last_blkno;\n\t*dead_bufp = last_buf;\n\treturn 0;\ndone:\n\tif (par_buf)\n\t\txfs_trans_brelse(tp, par_buf);\n\tif (sib_buf)\n\t\txfs_trans_brelse(tp, sib_buf);\n\txfs_trans_brelse(tp, last_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_da3_swap_lastblock(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*dead_blknop,\n\tstruct xfs_buf\t\t**dead_bufp)\n{\n\tstruct xfs_da_blkinfo\t*dead_info;\n\tstruct xfs_da_blkinfo\t*sib_info;\n\tstruct xfs_da_intnode\t*par_node;\n\tstruct xfs_da_intnode\t*dead_node;\n\tstruct xfs_dir2_leaf\t*dead_leaf2;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr par_hdr;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp;\n\tstruct xfs_buf\t\t*dead_buf;\n\tstruct xfs_buf\t\t*last_buf;\n\tstruct xfs_buf\t\t*sib_buf;\n\tstruct xfs_buf\t\t*par_buf;\n\txfs_dahash_t\t\tdead_hash;\n\txfs_fileoff_t\t\tlastoff;\n\txfs_dablk_t\t\tdead_blkno;\n\txfs_dablk_t\t\tlast_blkno;\n\txfs_dablk_t\t\tsib_blkno;\n\txfs_dablk_t\t\tpar_blkno;\n\tint\t\t\terror;\n\tint\t\t\tw;\n\tint\t\t\tentno;\n\tint\t\t\tlevel;\n\tint\t\t\tdead_level;\n\n\ttrace_xfs_da_swap_lastblock(args);\n\n\tdead_buf = *dead_bufp;\n\tdead_blkno = *dead_blknop;\n\ttp = args->trans;\n\tdp = args->dp;\n\tw = args->whichfork;\n\tASSERT(w == XFS_DATA_FORK);\n\tmp = dp->i_mount;\n\tlastoff = args->geo->freeblk;\n\terror = xfs_bmap_last_before(tp, dp, &lastoff, w);\n\tif (error)\n\t\treturn error;\n\tif (unlikely(lastoff == 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t/*\n\t * Read the last block in the btree space.\n\t */\n\tlast_blkno = (xfs_dablk_t)lastoff - args->geo->fsbcount;\n\terror = xfs_da3_node_read(tp, dp, last_blkno, -1, &last_buf, w);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Copy the last block into the dead buffer and log it.\n\t */\n\tmemcpy(dead_buf->b_addr, last_buf->b_addr, args->geo->blksize);\n\txfs_trans_log_buf(tp, dead_buf, 0, args->geo->blksize - 1);\n\tdead_info = dead_buf->b_addr;\n\t/*\n\t * Get values from the moved block.\n\t */\n\tif (dead_info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    dead_info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tdead_leaf2 = (xfs_dir2_leaf_t *)dead_info;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, dead_leaf2);\n\t\tents = dp->d_ops->leaf_ents_p(dead_leaf2);\n\t\tdead_level = 0;\n\t\tdead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);\n\t} else {\n\t\tstruct xfs_da3_icnode_hdr deadhdr;\n\n\t\tdead_node = (xfs_da_intnode_t *)dead_info;\n\t\tdp->d_ops->node_hdr_from_disk(&deadhdr, dead_node);\n\t\tbtree = dp->d_ops->node_tree_p(dead_node);\n\t\tdead_level = deadhdr.level;\n\t\tdead_hash = be32_to_cpu(btree[deadhdr.count - 1].hashval);\n\t}\n\tsib_buf = par_buf = NULL;\n\t/*\n\t * If the moved block has a left sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->back))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t    be32_to_cpu(sib_info->forw) != last_blkno ||\n\t\t    sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->forw = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->forw,\n\t\t\t\t\tsizeof(sib_info->forw)));\n\t\tsib_buf = NULL;\n\t}\n\t/*\n\t * If the moved block has a right sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->forw))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t       be32_to_cpu(sib_info->back) != last_blkno ||\n\t\t       sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->back = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->back,\n\t\t\t\t\tsizeof(sib_info->back)));\n\t\tsib_buf = NULL;\n\t}\n\tpar_blkno = args->geo->leafblk;\n\tlevel = -1;\n\t/*\n\t * Walk down the tree looking for the parent of the moved block.\n\t */\n\tfor (;;) {\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (level >= 0 && level != par_hdr.level + 1) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(4)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tlevel = par_hdr.level;\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tfor (entno = 0;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].hashval) < dead_hash;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno == par_hdr.count) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(5)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tpar_blkno = be32_to_cpu(btree[entno].before);\n\t\tif (level == dead_level + 1)\n\t\t\tbreak;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t}\n\t/*\n\t * We're in the right parent block.\n\t * Look for the right entry.\n\t */\n\tfor (;;) {\n\t\tfor (;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].before) != last_blkno;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno < par_hdr.count)\n\t\t\tbreak;\n\t\tpar_blkno = par_hdr.forw;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t\tif (unlikely(par_blkno == 0)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(6)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (par_hdr.level != level) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(7)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tentno = 0;\n\t}\n\t/*\n\t * Update the parent entry pointing to the moved block.\n\t */\n\tbtree[entno].before = cpu_to_be32(dead_blkno);\n\txfs_trans_log_buf(tp, par_buf,\n\t\tXFS_DA_LOGRANGE(par_node, &btree[entno].before,\n\t\t\t\tsizeof(btree[entno].before)));\n\t*dead_blknop = last_blkno;\n\t*dead_bufp = last_buf;\n\treturn 0;\ndone:\n\tif (par_buf)\n\t\txfs_trans_brelse(tp, par_buf);\n\tif (sib_buf)\n\t\txfs_trans_brelse(tp, sib_buf);\n\txfs_trans_brelse(tp, last_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "tp",
            "dp",
            "dead_blkno",
            "count",
            "xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA",
            "0",
            "args->firstblock",
            "args->flist",
            "&done"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_aflag",
          "args": [
            "w"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_aflag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "122-125",
          "snippet": "static inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */\n\nstatic inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_shrink_inode",
          "args": [
            "args"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_da3_swap_lastblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2109-2327",
    "snippet": "STATIC int\nxfs_da3_swap_lastblock(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*dead_blknop,\n\tstruct xfs_buf\t\t**dead_bufp)\n{\n\tstruct xfs_da_blkinfo\t*dead_info;\n\tstruct xfs_da_blkinfo\t*sib_info;\n\tstruct xfs_da_intnode\t*par_node;\n\tstruct xfs_da_intnode\t*dead_node;\n\tstruct xfs_dir2_leaf\t*dead_leaf2;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr par_hdr;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp;\n\tstruct xfs_buf\t\t*dead_buf;\n\tstruct xfs_buf\t\t*last_buf;\n\tstruct xfs_buf\t\t*sib_buf;\n\tstruct xfs_buf\t\t*par_buf;\n\txfs_dahash_t\t\tdead_hash;\n\txfs_fileoff_t\t\tlastoff;\n\txfs_dablk_t\t\tdead_blkno;\n\txfs_dablk_t\t\tlast_blkno;\n\txfs_dablk_t\t\tsib_blkno;\n\txfs_dablk_t\t\tpar_blkno;\n\tint\t\t\terror;\n\tint\t\t\tw;\n\tint\t\t\tentno;\n\tint\t\t\tlevel;\n\tint\t\t\tdead_level;\n\n\ttrace_xfs_da_swap_lastblock(args);\n\n\tdead_buf = *dead_bufp;\n\tdead_blkno = *dead_blknop;\n\ttp = args->trans;\n\tdp = args->dp;\n\tw = args->whichfork;\n\tASSERT(w == XFS_DATA_FORK);\n\tmp = dp->i_mount;\n\tlastoff = args->geo->freeblk;\n\terror = xfs_bmap_last_before(tp, dp, &lastoff, w);\n\tif (error)\n\t\treturn error;\n\tif (unlikely(lastoff == 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t/*\n\t * Read the last block in the btree space.\n\t */\n\tlast_blkno = (xfs_dablk_t)lastoff - args->geo->fsbcount;\n\terror = xfs_da3_node_read(tp, dp, last_blkno, -1, &last_buf, w);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Copy the last block into the dead buffer and log it.\n\t */\n\tmemcpy(dead_buf->b_addr, last_buf->b_addr, args->geo->blksize);\n\txfs_trans_log_buf(tp, dead_buf, 0, args->geo->blksize - 1);\n\tdead_info = dead_buf->b_addr;\n\t/*\n\t * Get values from the moved block.\n\t */\n\tif (dead_info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    dead_info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tdead_leaf2 = (xfs_dir2_leaf_t *)dead_info;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, dead_leaf2);\n\t\tents = dp->d_ops->leaf_ents_p(dead_leaf2);\n\t\tdead_level = 0;\n\t\tdead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);\n\t} else {\n\t\tstruct xfs_da3_icnode_hdr deadhdr;\n\n\t\tdead_node = (xfs_da_intnode_t *)dead_info;\n\t\tdp->d_ops->node_hdr_from_disk(&deadhdr, dead_node);\n\t\tbtree = dp->d_ops->node_tree_p(dead_node);\n\t\tdead_level = deadhdr.level;\n\t\tdead_hash = be32_to_cpu(btree[deadhdr.count - 1].hashval);\n\t}\n\tsib_buf = par_buf = NULL;\n\t/*\n\t * If the moved block has a left sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->back))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t    be32_to_cpu(sib_info->forw) != last_blkno ||\n\t\t    sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->forw = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->forw,\n\t\t\t\t\tsizeof(sib_info->forw)));\n\t\tsib_buf = NULL;\n\t}\n\t/*\n\t * If the moved block has a right sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->forw))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t       be32_to_cpu(sib_info->back) != last_blkno ||\n\t\t       sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->back = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->back,\n\t\t\t\t\tsizeof(sib_info->back)));\n\t\tsib_buf = NULL;\n\t}\n\tpar_blkno = args->geo->leafblk;\n\tlevel = -1;\n\t/*\n\t * Walk down the tree looking for the parent of the moved block.\n\t */\n\tfor (;;) {\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (level >= 0 && level != par_hdr.level + 1) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(4)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tlevel = par_hdr.level;\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tfor (entno = 0;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].hashval) < dead_hash;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno == par_hdr.count) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(5)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tpar_blkno = be32_to_cpu(btree[entno].before);\n\t\tif (level == dead_level + 1)\n\t\t\tbreak;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t}\n\t/*\n\t * We're in the right parent block.\n\t * Look for the right entry.\n\t */\n\tfor (;;) {\n\t\tfor (;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].before) != last_blkno;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno < par_hdr.count)\n\t\t\tbreak;\n\t\tpar_blkno = par_hdr.forw;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t\tif (unlikely(par_blkno == 0)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(6)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (par_hdr.level != level) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(7)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tentno = 0;\n\t}\n\t/*\n\t * Update the parent entry pointing to the moved block.\n\t */\n\tbtree[entno].before = cpu_to_be32(dead_blkno);\n\txfs_trans_log_buf(tp, par_buf,\n\t\tXFS_DA_LOGRANGE(par_node, &btree[entno].before,\n\t\t\t\tsizeof(btree[entno].before)));\n\t*dead_blknop = last_blkno;\n\t*dead_bufp = last_buf;\n\treturn 0;\ndone:\n\tif (par_buf)\n\t\txfs_trans_brelse(tp, par_buf);\n\tif (sib_buf)\n\t\txfs_trans_brelse(tp, sib_buf);\n\txfs_trans_brelse(tp, last_buf);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "last_buf"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "par_buf",
            "XFS_DA_LOGRANGE(par_node, &btree[entno].before,\n\t\t\t\tsizeof(btree[entno].before))"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "par_node",
            "&btree[entno].before",
            "sizeof(btree[entno].before)"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dead_blkno"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "par_node"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(7)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&par_hdr",
            "par_node"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "tp",
            "dp",
            "par_blkno",
            "-1",
            "&par_buf",
            "w"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(6)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "par_blkno == 0"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[entno].before"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[entno].before"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(5)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[entno].hashval"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "par_node"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(4)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&par_hdr",
            "par_node"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "sib_buf",
            "XFS_DA_LOGRANGE(sib_info, &sib_info->back,\n\t\t\t\t\tsizeof(sib_info->back))"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "sib_info",
            "&sib_info->back",
            "sizeof(sib_info->back)"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dead_blkno"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(3)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "be32_to_cpu(sib_info->back) != last_blkno ||\n\t\t       sib_info->magic != dead_info->magic"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sib_info->back"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dead_info->forw"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "sib_buf",
            "XFS_DA_LOGRANGE(sib_info, &sib_info->forw,\n\t\t\t\t\tsizeof(sib_info->forw))"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "sib_info",
            "&sib_info->forw",
            "sizeof(sib_info->forw)"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dead_blkno"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(2)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "be32_to_cpu(sib_info->forw) != last_blkno ||\n\t\t    sib_info->magic != dead_info->magic"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sib_info->forw"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dead_info->back"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[deadhdr.count - 1].hashval"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "dead_node"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&deadhdr",
            "dead_node"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents[leafhdr.count - 1].hashval"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "dead_leaf2"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "dead_leaf2"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "dead_buf",
            "0",
            "args->geo->blksize - 1"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dead_buf->b_addr",
            "last_buf->b_addr",
            "args->geo->blksize"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_da_swap_lastblock(1)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lastoff == 0"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_before",
          "args": [
            "tp",
            "dp",
            "&lastoff",
            "w"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1555-1596",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "w == XFS_DATA_FORK"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_swap_lastblock",
          "args": [
            "args"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_da3_swap_lastblock(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*dead_blknop,\n\tstruct xfs_buf\t\t**dead_bufp)\n{\n\tstruct xfs_da_blkinfo\t*dead_info;\n\tstruct xfs_da_blkinfo\t*sib_info;\n\tstruct xfs_da_intnode\t*par_node;\n\tstruct xfs_da_intnode\t*dead_node;\n\tstruct xfs_dir2_leaf\t*dead_leaf2;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr par_hdr;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_mount\t*mp;\n\tstruct xfs_buf\t\t*dead_buf;\n\tstruct xfs_buf\t\t*last_buf;\n\tstruct xfs_buf\t\t*sib_buf;\n\tstruct xfs_buf\t\t*par_buf;\n\txfs_dahash_t\t\tdead_hash;\n\txfs_fileoff_t\t\tlastoff;\n\txfs_dablk_t\t\tdead_blkno;\n\txfs_dablk_t\t\tlast_blkno;\n\txfs_dablk_t\t\tsib_blkno;\n\txfs_dablk_t\t\tpar_blkno;\n\tint\t\t\terror;\n\tint\t\t\tw;\n\tint\t\t\tentno;\n\tint\t\t\tlevel;\n\tint\t\t\tdead_level;\n\n\ttrace_xfs_da_swap_lastblock(args);\n\n\tdead_buf = *dead_bufp;\n\tdead_blkno = *dead_blknop;\n\ttp = args->trans;\n\tdp = args->dp;\n\tw = args->whichfork;\n\tASSERT(w == XFS_DATA_FORK);\n\tmp = dp->i_mount;\n\tlastoff = args->geo->freeblk;\n\terror = xfs_bmap_last_before(tp, dp, &lastoff, w);\n\tif (error)\n\t\treturn error;\n\tif (unlikely(lastoff == 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t/*\n\t * Read the last block in the btree space.\n\t */\n\tlast_blkno = (xfs_dablk_t)lastoff - args->geo->fsbcount;\n\terror = xfs_da3_node_read(tp, dp, last_blkno, -1, &last_buf, w);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Copy the last block into the dead buffer and log it.\n\t */\n\tmemcpy(dead_buf->b_addr, last_buf->b_addr, args->geo->blksize);\n\txfs_trans_log_buf(tp, dead_buf, 0, args->geo->blksize - 1);\n\tdead_info = dead_buf->b_addr;\n\t/*\n\t * Get values from the moved block.\n\t */\n\tif (dead_info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    dead_info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tdead_leaf2 = (xfs_dir2_leaf_t *)dead_info;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, dead_leaf2);\n\t\tents = dp->d_ops->leaf_ents_p(dead_leaf2);\n\t\tdead_level = 0;\n\t\tdead_hash = be32_to_cpu(ents[leafhdr.count - 1].hashval);\n\t} else {\n\t\tstruct xfs_da3_icnode_hdr deadhdr;\n\n\t\tdead_node = (xfs_da_intnode_t *)dead_info;\n\t\tdp->d_ops->node_hdr_from_disk(&deadhdr, dead_node);\n\t\tbtree = dp->d_ops->node_tree_p(dead_node);\n\t\tdead_level = deadhdr.level;\n\t\tdead_hash = be32_to_cpu(btree[deadhdr.count - 1].hashval);\n\t}\n\tsib_buf = par_buf = NULL;\n\t/*\n\t * If the moved block has a left sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->back))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t    be32_to_cpu(sib_info->forw) != last_blkno ||\n\t\t    sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(2)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->forw = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->forw,\n\t\t\t\t\tsizeof(sib_info->forw)));\n\t\tsib_buf = NULL;\n\t}\n\t/*\n\t * If the moved block has a right sibling, fix up the pointers.\n\t */\n\tif ((sib_blkno = be32_to_cpu(dead_info->forw))) {\n\t\terror = xfs_da3_node_read(tp, dp, sib_blkno, -1, &sib_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tsib_info = sib_buf->b_addr;\n\t\tif (unlikely(\n\t\t       be32_to_cpu(sib_info->back) != last_blkno ||\n\t\t       sib_info->magic != dead_info->magic)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(3)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tsib_info->back = cpu_to_be32(dead_blkno);\n\t\txfs_trans_log_buf(tp, sib_buf,\n\t\t\tXFS_DA_LOGRANGE(sib_info, &sib_info->back,\n\t\t\t\t\tsizeof(sib_info->back)));\n\t\tsib_buf = NULL;\n\t}\n\tpar_blkno = args->geo->leafblk;\n\tlevel = -1;\n\t/*\n\t * Walk down the tree looking for the parent of the moved block.\n\t */\n\tfor (;;) {\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (level >= 0 && level != par_hdr.level + 1) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(4)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tlevel = par_hdr.level;\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tfor (entno = 0;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].hashval) < dead_hash;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno == par_hdr.count) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(5)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tpar_blkno = be32_to_cpu(btree[entno].before);\n\t\tif (level == dead_level + 1)\n\t\t\tbreak;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t}\n\t/*\n\t * We're in the right parent block.\n\t * Look for the right entry.\n\t */\n\tfor (;;) {\n\t\tfor (;\n\t\t     entno < par_hdr.count &&\n\t\t     be32_to_cpu(btree[entno].before) != last_blkno;\n\t\t     entno++)\n\t\t\tcontinue;\n\t\tif (entno < par_hdr.count)\n\t\t\tbreak;\n\t\tpar_blkno = par_hdr.forw;\n\t\txfs_trans_brelse(tp, par_buf);\n\t\tpar_buf = NULL;\n\t\tif (unlikely(par_blkno == 0)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(6)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\terror = xfs_da3_node_read(tp, dp, par_blkno, -1, &par_buf, w);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tpar_node = par_buf->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&par_hdr, par_node);\n\t\tif (par_hdr.level != level) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_da_swap_lastblock(7)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto done;\n\t\t}\n\t\tbtree = dp->d_ops->node_tree_p(par_node);\n\t\tentno = 0;\n\t}\n\t/*\n\t * Update the parent entry pointing to the moved block.\n\t */\n\tbtree[entno].before = cpu_to_be32(dead_blkno);\n\txfs_trans_log_buf(tp, par_buf,\n\t\tXFS_DA_LOGRANGE(par_node, &btree[entno].before,\n\t\t\t\tsizeof(btree[entno].before)));\n\t*dead_blknop = last_blkno;\n\t*dead_bufp = last_buf;\n\treturn 0;\ndone:\n\tif (par_buf)\n\t\txfs_trans_brelse(tp, par_buf);\n\tif (sib_buf)\n\t\txfs_trans_brelse(tp, sib_buf);\n\txfs_trans_brelse(tp, last_buf);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_da_grow_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "2084-2099",
    "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_grow_inode_int",
          "args": [
            "args",
            "&bno",
            "args->geo->fsbcount"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1994-2078",
          "snippet": "int\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_grow_inode",
          "args": [
            "args"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_da_grow_inode_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1994-2078",
    "snippet": "int\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "mapp"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_write",
          "args": [
            "tp",
            "dp",
            "b",
            "c",
            "xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA",
            "args->firstblock",
            "args->total",
            "&mapp[mapi]",
            "&nmap",
            "args->flist"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4483-4700",
          "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_aflag",
          "args": [
            "w"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_aflag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "122-125",
          "snippet": "static inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */\n\nstatic inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "XFS_BMAP_MAX_NMAP",
            "count"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(*mapp) * count",
            "KM_SLEEP"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap <= 1"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->firstblock != NULL"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_first_unused",
          "args": [
            "tp",
            "dp",
            "count",
            "bno",
            "w"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_first_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1502-1547",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_first_unused(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_extlen_t\tlen,\t\t\t/* size of hole to find */\n\txfs_fileoff_t\t*first_unused,\t\t/* unused block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_fileoff_t\tlastaddr;\t\t/* last block number seen */\n\txfs_fileoff_t\tlowest;\t\t\t/* lowest useful block */\n\txfs_fileoff_t\tmax;\t\t\t/* starting useful block */\n\txfs_fileoff_t\toff;\t\t\t/* offset for this block */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tlowest = *first_unused;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0, lastaddr = 0, max = lowest; idx < nextents; idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\toff = xfs_bmbt_get_startoff(ep);\n\t\t/*\n\t\t * See if the hole before this extent will work.\n\t\t */\n\t\tif (off >= lowest + len && off - max >= len) {\n\t\t\t*first_unused = max;\n\t\t\treturn 0;\n\t\t}\n\t\tlastaddr = off + xfs_bmbt_get_blockcount(ep);\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_first_unused(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_extlen_t\tlen,\t\t\t/* size of hole to find */\n\txfs_fileoff_t\t*first_unused,\t\t/* unused block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_fileoff_t\tlastaddr;\t\t/* last block number seen */\n\txfs_fileoff_t\tlowest;\t\t\t/* lowest useful block */\n\txfs_fileoff_t\tmax;\t\t\t/* starting useful block */\n\txfs_fileoff_t\toff;\t\t\t/* offset for this block */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tlowest = *first_unused;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0, lastaddr = 0, max = lowest; idx < nextents; idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\toff = xfs_bmbt_get_startoff(ep);\n\t\t/*\n\t\t * See if the hole before this extent will work.\n\t\t */\n\t\tif (off >= lowest + len && off - max >= len) {\n\t\t\t*first_unused = max;\n\t\t\treturn 0;\n\t\t}\n\t\tlastaddr = off + xfs_bmbt_get_blockcount(ep);\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_default_hashname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1982-1987",
    "snippet": "static xfs_dahash_t\nxfs_default_hashname(\n\tstruct xfs_name\t*name)\n{\n\treturn xfs_da_hashname(name->name, name->len);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_hashname",
          "args": [
            "name->name",
            "name->len"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_hashname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1944-1970",
          "snippet": "xfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_dahash_t\nxfs_default_hashname(\n\tstruct xfs_name\t*name)\n{\n\treturn xfs_da_hashname(name->name, name->len);\n}"
  },
  {
    "function_name": "xfs_da_compname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1972-1980",
    "snippet": "enum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "args->name",
            "name",
            "len"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nenum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}"
  },
  {
    "function_name": "xfs_da_hashname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1944-1970",
    "snippet": "xfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "hash",
            "7 * 1"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "hash",
            "7 * 2"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "hash",
            "7 * 3"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rol32",
          "args": [
            "hash",
            "7 * 4"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}"
  },
  {
    "function_name": "xfs_da3_path_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1811-1932",
    "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lasthash",
          "args": [
            "args->dp",
            "blk->bp",
            "NULL"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lasthash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "479-501",
          "snippet": "xfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level == path->active-1"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_lasthash",
          "args": [
            "blk->bp",
            "NULL"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level == path->active-1"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[blk->index].before"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[nodehdr.count - 1].hashval"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "info->magic"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA3_NODE_MAGIC"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA_NODE_MAGIC"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "args->trans",
            "dp",
            "blkno",
            "-1",
            "&blk->bp",
            "args->whichfork"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "blk->bp"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[blk->index].before"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[blk->index].before"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH)"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "path != NULL"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args != NULL"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_path_shift",
          "args": [
            "state->args"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_blk_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1731-1801",
    "snippet": "STATIC int\t\t\t\t\t\t/* error */\nxfs_da3_blk_unlink(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_blkinfo\t*drop_info;\n\tstruct xfs_da_blkinfo\t*save_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tsave_info = save_blk->bp->b_addr;\n\tdrop_info = drop_blk->bp->b_addr;\n\tASSERT(save_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       save_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       save_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(save_blk->magic == drop_blk->magic);\n\tASSERT((be32_to_cpu(save_info->forw) == drop_blk->blkno) ||\n\t       (be32_to_cpu(save_info->back) == drop_blk->blkno));\n\tASSERT((be32_to_cpu(drop_info->forw) == save_blk->blkno) ||\n\t       (be32_to_cpu(drop_info->back) == save_blk->blkno));\n\n\t/*\n\t * Unlink the leaf block from the doubly linked chain of leaves.\n\t */\n\tif (be32_to_cpu(save_info->back) == drop_blk->blkno) {\n\t\ttrace_xfs_da_unlink_back(args);\n\t\tsave_info->back = drop_info->back;\n\t\tif (drop_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == drop_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t} else {\n\t\ttrace_xfs_da_unlink_forward(args);\n\t\tsave_info->forw = drop_info->forw;\n\t\tif (drop_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == drop_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t}\n\n\txfs_trans_log_buf(args->trans, save_blk->bp, 0, sizeof(*save_info) - 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
      "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "save_blk->bp",
            "0",
            "sizeof(*save_info) - 1"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "save_blk->blkno"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(tmp_info->back) == drop_blk->blkno"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp_info->back"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tmp_info->magic == save_info->magic"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp != NULL"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "args->trans",
            "args->dp",
            "be32_to_cpu(drop_info->forw)",
            "-1",
            "&bp",
            "args->whichfork"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "drop_info->forw"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_unlink_forward",
          "args": [
            "args"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "save_blk->blkno"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(tmp_info->forw) == drop_blk->blkno"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp_info->forw"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tmp_info->magic == save_info->magic"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp != NULL"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "drop_info->back"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_unlink_back",
          "args": [
            "args"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "save_info->back"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(be32_to_cpu(drop_info->forw) == save_blk->blkno) ||\n\t       (be32_to_cpu(drop_info->back) == save_blk->blkno)"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "drop_info->back"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "drop_info->forw"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(be32_to_cpu(save_info->forw) == drop_blk->blkno) ||\n\t       (be32_to_cpu(save_info->back) == drop_blk->blkno)"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "save_info->back"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "save_info->forw"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "save_blk->magic == drop_blk->magic"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "save_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       save_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       save_blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args != NULL"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nSTATIC int\t\t\t\t\t\t/* error */\nxfs_da3_blk_unlink(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_blkinfo\t*drop_info;\n\tstruct xfs_da_blkinfo\t*save_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tsave_info = save_blk->bp->b_addr;\n\tdrop_info = drop_blk->bp->b_addr;\n\tASSERT(save_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       save_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       save_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(save_blk->magic == drop_blk->magic);\n\tASSERT((be32_to_cpu(save_info->forw) == drop_blk->blkno) ||\n\t       (be32_to_cpu(save_info->back) == drop_blk->blkno));\n\tASSERT((be32_to_cpu(drop_info->forw) == save_blk->blkno) ||\n\t       (be32_to_cpu(drop_info->back) == save_blk->blkno));\n\n\t/*\n\t * Unlink the leaf block from the doubly linked chain of leaves.\n\t */\n\tif (be32_to_cpu(save_info->back) == drop_blk->blkno) {\n\t\ttrace_xfs_da_unlink_back(args);\n\t\tsave_info->back = drop_info->back;\n\t\tif (drop_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == drop_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t} else {\n\t\ttrace_xfs_da_unlink_forward(args);\n\t\tsave_info->forw = drop_info->forw;\n\t\tif (drop_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == drop_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t}\n\n\txfs_trans_log_buf(args->trans, save_blk->bp, 0, sizeof(*save_info) - 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_blk_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1638-1726",
    "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "new_blk->bp",
            "0",
            "sizeof(*tmp_info) - 1"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_blk->blkno"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_blk->blkno"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(tmp_info->back) == old_blk->blkno"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp_info->back"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tmp_info->magic == old_info->magic"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp != NULL"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "args->trans",
            "dp",
            "be32_to_cpu(old_info->forw)",
            "-1",
            "&bp",
            "args->whichfork"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "old_info->forw"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "old_blk->blkno"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_link_after",
          "args": [
            "args"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_blk->blkno"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_blk->blkno"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(tmp_info->forw) == old_blk->blkno"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp_info->forw"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tmp_info->magic == old_info->magic"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp != NULL"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "old_info->back"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "old_blk->blkno"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_link_before",
          "args": [
            "args"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_order",
          "args": [
            "dp",
            "old_blk->bp",
            "new_blk->bp"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1606-1633",
          "snippet": "STATIC int\nxfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_order",
          "args": [
            "dp",
            "old_blk->bp",
            "new_blk->bp"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "910-934",
          "snippet": "int\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_order",
          "args": [
            "old_blk->bp",
            "new_blk->bp"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1340-1351",
          "snippet": "int\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args != NULL"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_node_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1606-1633",
    "snippet": "STATIC int\nxfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree1[node1hdr.count - 1].hashval"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree2[node2hdr.count - 1].hashval"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree1[0].hashval"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree2[0].hashval"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node2"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node1"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&node2hdr",
            "node2"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&node1hdr",
            "node1"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_node_lookup_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1445-1597",
    "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
      "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_path_shift",
          "args": [
            "state",
            "&state->path",
            "1",
            "1",
            "&retval"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_path_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1811-1932",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_lookup_int",
          "args": [
            "blk->bp",
            "args"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2070-2174",
          "snippet": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lookup_int",
          "args": [
            "blk->bp",
            "args",
            "&blk->index",
            "state"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "815-826",
          "snippet": "int\nxfs_dir2_leafn_lookup_int(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tif (args->op_flags & XFS_DA_OP_ADDNAME)\n\t\treturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\n\t\t\t\t\t\t\tstate);\n\treturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nint\nxfs_dir2_leafn_lookup_int(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tif (args->op_flags & XFS_DA_OP_ADDNAME)\n\t\treturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\n\t\t\t\t\t\t\tstate);\n\treturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[probe].before"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[max - 1].before"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[probe].hashval"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[probe].hashval"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval)"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[probe].hashval"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(probe >= 0) && (probe < max)"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[probe].hashval"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[max - 1].hashval"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lasthash",
          "args": [
            "args->dp",
            "blk->bp",
            "NULL"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lasthash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "479-501",
          "snippet": "xfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_lasthash",
          "args": [
            "blk->bp",
            "NULL"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "curr->magic"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "args->trans",
            "args->dp",
            "blkno",
            "-1",
            "&blk->bp",
            "args->whichfork"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_node_unbalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1361-1428",
    "snippet": "STATIC void\nxfs_da3_node_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_intnode\t*drop_node;\n\tstruct xfs_da_intnode\t*save_node;\n\tstruct xfs_da_node_entry *drop_btree;\n\tstruct xfs_da_node_entry *save_btree;\n\tstruct xfs_da3_icnode_hdr drop_hdr;\n\tstruct xfs_da3_icnode_hdr save_hdr;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tsindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_unbalance(state->args);\n\n\tdrop_node = drop_blk->bp->b_addr;\n\tsave_node = save_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&drop_hdr, drop_node);\n\tdp->d_ops->node_hdr_from_disk(&save_hdr, save_node);\n\tdrop_btree = dp->d_ops->node_tree_p(drop_node);\n\tsave_btree = dp->d_ops->node_tree_p(save_node);\n\ttp = state->args->trans;\n\n\t/*\n\t * If the dying block has lower hashvals, then move all the\n\t * elements in the remaining block up to make a hole.\n\t */\n\tif ((be32_to_cpu(drop_btree[0].hashval) <\n\t\t\tbe32_to_cpu(save_btree[0].hashval)) ||\n\t    (be32_to_cpu(drop_btree[drop_hdr.count - 1].hashval) <\n\t\t\tbe32_to_cpu(save_btree[save_hdr.count - 1].hashval))) {\n\t\t/* XXX: check this - is memmove dst correct? */\n\t\ttmp = save_hdr.count * sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&save_btree[drop_hdr.count], &save_btree[0], tmp);\n\n\t\tsindex = 0;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[0],\n\t\t\t\t(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t)));\n\t} else {\n\t\tsindex = save_hdr.count;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[sindex],\n\t\t\t\tdrop_hdr.count * sizeof(xfs_da_node_entry_t)));\n\t}\n\n\t/*\n\t * Move all the B-tree elements from drop_blk to save_blk.\n\t */\n\ttmp = drop_hdr.count * (uint)sizeof(xfs_da_node_entry_t);\n\tmemcpy(&save_btree[sindex], &drop_btree[0], tmp);\n\tsave_hdr.count += drop_hdr.count;\n\n\tdp->d_ops->node_hdr_to_disk(save_node, &save_hdr);\n\txfs_trans_log_buf(tp, save_blk->bp,\n\t\tXFS_DA_LOGRANGE(save_node, &save_node->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size));\n\n\t/*\n\t * Save the last hashval in the remaining block for upward propagation.\n\t */\n\tsave_blk->hashval = be32_to_cpu(save_btree[save_hdr.count - 1].hashval);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
      "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "save_btree[save_hdr.count - 1].hashval"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "save_blk->bp",
            "XFS_DA_LOGRANGE(save_node, &save_node->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "save_node",
            "&save_node->hdr",
            "dp->d_ops->node_hdr_size"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "save_node",
            "&save_hdr"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&save_btree[sindex]",
            "&drop_btree[0]",
            "tmp"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "save_blk->bp",
            "XFS_DA_LOGRANGE(save_node, &save_btree[sindex],\n\t\t\t\tdrop_hdr.count * sizeof(xfs_da_node_entry_t))"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "save_node",
            "&save_btree[sindex]",
            "drop_hdr.count * sizeof(xfs_da_node_entry_t)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "save_blk->bp",
            "XFS_DA_LOGRANGE(save_node, &save_btree[0],\n\t\t\t\t(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t))"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "save_node",
            "&save_btree[0]",
            "(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&save_btree[drop_hdr.count]",
            "&save_btree[0]",
            "tmp"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "save_btree[save_hdr.count - 1].hashval"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "drop_btree[drop_hdr.count - 1].hashval"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "save_btree[0].hashval"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "drop_btree[0].hashval"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "save_node"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "drop_node"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&save_hdr",
            "save_node"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&drop_hdr",
            "drop_node"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_unbalance",
          "args": [
            "state->args"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nSTATIC void\nxfs_da3_node_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_intnode\t*drop_node;\n\tstruct xfs_da_intnode\t*save_node;\n\tstruct xfs_da_node_entry *drop_btree;\n\tstruct xfs_da_node_entry *save_btree;\n\tstruct xfs_da3_icnode_hdr drop_hdr;\n\tstruct xfs_da3_icnode_hdr save_hdr;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tsindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_unbalance(state->args);\n\n\tdrop_node = drop_blk->bp->b_addr;\n\tsave_node = save_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&drop_hdr, drop_node);\n\tdp->d_ops->node_hdr_from_disk(&save_hdr, save_node);\n\tdrop_btree = dp->d_ops->node_tree_p(drop_node);\n\tsave_btree = dp->d_ops->node_tree_p(save_node);\n\ttp = state->args->trans;\n\n\t/*\n\t * If the dying block has lower hashvals, then move all the\n\t * elements in the remaining block up to make a hole.\n\t */\n\tif ((be32_to_cpu(drop_btree[0].hashval) <\n\t\t\tbe32_to_cpu(save_btree[0].hashval)) ||\n\t    (be32_to_cpu(drop_btree[drop_hdr.count - 1].hashval) <\n\t\t\tbe32_to_cpu(save_btree[save_hdr.count - 1].hashval))) {\n\t\t/* XXX: check this - is memmove dst correct? */\n\t\ttmp = save_hdr.count * sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&save_btree[drop_hdr.count], &save_btree[0], tmp);\n\n\t\tsindex = 0;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[0],\n\t\t\t\t(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t)));\n\t} else {\n\t\tsindex = save_hdr.count;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[sindex],\n\t\t\t\tdrop_hdr.count * sizeof(xfs_da_node_entry_t)));\n\t}\n\n\t/*\n\t * Move all the B-tree elements from drop_blk to save_blk.\n\t */\n\ttmp = drop_hdr.count * (uint)sizeof(xfs_da_node_entry_t);\n\tmemcpy(&save_btree[sindex], &drop_btree[0], tmp);\n\tsave_hdr.count += drop_hdr.count;\n\n\tdp->d_ops->node_hdr_to_disk(save_node, &save_hdr);\n\txfs_trans_log_buf(tp, save_blk->bp,\n\t\tXFS_DA_LOGRANGE(save_node, &save_node->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size));\n\n\t/*\n\t * Save the last hashval in the remaining block for upward propagation.\n\t */\n\tsave_blk->hashval = be32_to_cpu(save_btree[save_hdr.count - 1].hashval);\n}"
  },
  {
    "function_name": "xfs_da3_node_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1311-1355",
    "snippet": "STATIC void\nxfs_da3_node_remove(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\tindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_remove(state->args);\n\n\tnode = drop_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tASSERT(drop_blk->index < nodehdr.count);\n\tASSERT(drop_blk->index >= 0);\n\n\t/*\n\t * Copy over the offending entry, or just zero it out.\n\t */\n\tindex = drop_blk->index;\n\tbtree = dp->d_ops->node_tree_p(node);\n\tif (index < nodehdr.count - 1) {\n\t\ttmp  = nodehdr.count - index - 1;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&btree[index], &btree[index + 1], tmp);\n\t\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t\t    XFS_DA_LOGRANGE(node, &btree[index], tmp));\n\t\tindex = nodehdr.count - 1;\n\t}\n\tmemset(&btree[index], 0, sizeof(xfs_da_node_entry_t));\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index])));\n\tnodehdr.count -= 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the block to propagate upwards.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(btree[index - 1].hashval);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[index - 1].hashval"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "drop_blk->bp",
            "XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&node->hdr",
            "dp->d_ops->node_hdr_size"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node",
            "&nodehdr"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "drop_blk->bp",
            "XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index]))"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&btree[index]",
            "sizeof(btree[index])"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&btree[index]",
            "0",
            "sizeof(xfs_da_node_entry_t)"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "drop_blk->bp",
            "XFS_DA_LOGRANGE(node, &btree[index], tmp)"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&btree[index]",
            "tmp"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&btree[index]",
            "&btree[index + 1]",
            "tmp"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "drop_blk->index >= 0"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "drop_blk->index < nodehdr.count"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_remove",
          "args": [
            "state->args"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\n\nSTATIC void\nxfs_da3_node_remove(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\tindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_remove(state->args);\n\n\tnode = drop_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tASSERT(drop_blk->index < nodehdr.count);\n\tASSERT(drop_blk->index >= 0);\n\n\t/*\n\t * Copy over the offending entry, or just zero it out.\n\t */\n\tindex = drop_blk->index;\n\tbtree = dp->d_ops->node_tree_p(node);\n\tif (index < nodehdr.count - 1) {\n\t\ttmp  = nodehdr.count - index - 1;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&btree[index], &btree[index + 1], tmp);\n\t\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t\t    XFS_DA_LOGRANGE(node, &btree[index], tmp));\n\t\tindex = nodehdr.count - 1;\n\t}\n\tmemset(&btree[index], 0, sizeof(xfs_da_node_entry_t));\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index])));\n\tnodehdr.count -= 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the block to propagate upwards.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(btree[index - 1].hashval);\n}"
  },
  {
    "function_name": "xfs_da3_fixhashpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1256-1306",
    "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[nodehdr.count - 1].hashval"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "blk->bp",
            "XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree))"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&btree[blk->index]",
            "sizeof(*btree)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lasthash"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[blk->index].hashval"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lasthash",
          "args": [
            "dp",
            "blk->bp",
            "&count"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lasthash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1232-1250",
          "snippet": "STATIC uint\nxfs_da3_node_lasthash(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\t*count)\n{\n\tstruct xfs_da_intnode\t *node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (count)\n\t\t*count = nodehdr.count;\n\tif (!nodehdr.count)\n\t\treturn 0;\n\tbtree = dp->d_ops->node_tree_p(node);\n\treturn be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC uint\nxfs_da3_node_lasthash(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\t*count)\n{\n\tstruct xfs_da_intnode\t *node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (count)\n\t\t*count = nodehdr.count;\n\tif (!nodehdr.count)\n\t\treturn 0;\n\tbtree = dp->d_ops->node_tree_p(node);\n\treturn be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lasthash",
          "args": [
            "dp",
            "blk->bp",
            "&count"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lasthash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "479-501",
          "snippet": "xfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_lasthash",
          "args": [
            "blk->bp",
            "&count"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_fixhashpath",
          "args": [
            "state->args"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
  },
  {
    "function_name": "xfs_da3_node_lasthash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1232-1250",
    "snippet": "STATIC uint\nxfs_da3_node_lasthash(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\t*count)\n{\n\tstruct xfs_da_intnode\t *node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (count)\n\t\t*count = nodehdr.count;\n\tif (!nodehdr.count)\n\t\treturn 0;\n\tbtree = dp->d_ops->node_tree_p(node);\n\treturn be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[nodehdr.count - 1].hashval"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC uint\nxfs_da3_node_lasthash(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\t*count)\n{\n\tstruct xfs_da_intnode\t *node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (count)\n\t\t*count = nodehdr.count;\n\tif (!nodehdr.count)\n\t\treturn 0;\n\tbtree = dp->d_ops->node_tree_p(node);\n\treturn be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}"
  },
  {
    "function_name": "xfs_da3_node_toosmall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1110-1227",
    "snippet": "STATIC int\nxfs_da3_node_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\txfs_dablk_t\t\tblkno;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tint\t\t\tcount;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tinfo = blk->bp->b_addr;\n\tnode = (xfs_da_intnode_t *)info;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (nodehdr.count > (state->args->geo->node_ents >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\t/* blk over 50%, don't try to join */\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (nodehdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (info->forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tcount  = state->args->geo->node_ents;\n\tcount -= state->args->geo->node_ents >> 2;\n\tcount -= nodehdr.count;\n\n\t/* start with smaller blk num */\n\tforward = nodehdr.forw < nodehdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_da3_icnode_hdr thdr;\n\t\tif (forward)\n\t\t\tblkno = nodehdr.forw;\n\t\telse\n\t\t\tblkno = nodehdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_da3_node_read(state->args->trans, dp,\n\t\t\t\t\tblkno, -1, &bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnode = bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&thdr, node);\n\t\txfs_trans_brelse(state->args->trans, bp);\n\n\t\tif (count - thdr.count >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t*action = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_path_shift",
          "args": [
            "state",
            "&state->path",
            "forward",
            "0",
            "&retval"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_path_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1811-1932",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&state->altpath",
            "&state->path",
            "sizeof(state->path)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "state->args->trans",
            "bp"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&thdr",
            "node"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "state->args->trans",
            "dp",
            "blkno",
            "-1",
            "&bp",
            "state->args->whichfork"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&state->altpath",
            "&state->path",
            "sizeof(state->path)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_toosmall",
          "args": [
            "state->args"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nSTATIC int\nxfs_da3_node_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\txfs_dablk_t\t\tblkno;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tint\t\t\tcount;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tinfo = blk->bp->b_addr;\n\tnode = (xfs_da_intnode_t *)info;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (nodehdr.count > (state->args->geo->node_ents >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\t/* blk over 50%, don't try to join */\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (nodehdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (info->forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tcount  = state->args->geo->node_ents;\n\tcount -= state->args->geo->node_ents >> 2;\n\tcount -= nodehdr.count;\n\n\t/* start with smaller blk num */\n\tforward = nodehdr.forw < nodehdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_da3_icnode_hdr thdr;\n\t\tif (forward)\n\t\t\tblkno = nodehdr.forw;\n\t\telse\n\t\t\tblkno = nodehdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_da3_node_read(state->args->trans, dp,\n\t\t\t\t\tblkno, -1, &bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnode = bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&thdr, node);\n\t\txfs_trans_brelse(state->args->trans, bp);\n\n\t\tif (count - thdr.count >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t*action = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_root_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1038-1099",
    "snippet": "STATIC int\nxfs_da3_root_join(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*root_blk)\n{\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tchild;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr oldroothdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_root_join(state->args);\n\n\tASSERT(root_blk->magic == XFS_DA_NODE_MAGIC);\n\n\targs = state->args;\n\toldroot = root_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&oldroothdr, oldroot);\n\tASSERT(oldroothdr.forw == 0);\n\tASSERT(oldroothdr.back == 0);\n\n\t/*\n\t * If the root has more than one child, then don't do anything.\n\t */\n\tif (oldroothdr.count > 1)\n\t\treturn 0;\n\n\t/*\n\t * Read in the (only) child block, then copy those bytes into\n\t * the root block's buffer and free the original child block.\n\t */\n\tbtree = dp->d_ops->node_tree_p(oldroot);\n\tchild = be32_to_cpu(btree[0].before);\n\tASSERT(child != 0);\n\terror = xfs_da3_node_read(args->trans, dp, child, -1, &bp,\n\t\t\t\t\t     args->whichfork);\n\tif (error)\n\t\treturn error;\n\txfs_da_blkinfo_onlychild_validate(bp->b_addr, oldroothdr.level);\n\n\t/*\n\t * This could be copying a leaf back into the root block in the case of\n\t * there only being a single leaf block left in the tree. Hence we have\n\t * to update the b_ops pointer as well to match the buffer type change\n\t * that could occur. For dir3 blocks we also need to update the block\n\t * number in the buffer header.\n\t */\n\tmemcpy(root_blk->bp->b_addr, bp->b_addr, args->geo->blksize);\n\troot_blk->bp->b_ops = bp->b_ops;\n\txfs_trans_buf_copy_type(root_blk->bp, bp);\n\tif (oldroothdr.magic == XFS_DA3_NODE_MAGIC) {\n\t\tstruct xfs_da3_blkinfo *da3 = root_blk->bp->b_addr;\n\t\tda3->blkno = cpu_to_be64(root_blk->bp->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, root_blk->bp, 0,\n\t\t\t  args->geo->blksize - 1);\n\terror = xfs_da_shrink_inode(args, child, bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_da3_root_join(xfs_da_state_t *state,\n\t\t\t\t\t   xfs_da_state_blk_t *root_blk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_shrink_inode",
          "args": [
            "args",
            "child",
            "bp"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2332-2369",
          "snippet": "int\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "root_blk->bp",
            "0",
            "args->geo->blksize - 1"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "root_blk->bp->b_bn"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_copy_type",
          "args": [
            "root_blk->bp",
            "bp"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_copy_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "748-759",
          "snippet": "void\nxfs_trans_buf_copy_type(\n\tstruct xfs_buf\t\t*dst_bp,\n\tstruct xfs_buf\t\t*src_bp)\n{\n\tstruct xfs_buf_log_item\t*sbip = src_bp->b_fspriv;\n\tstruct xfs_buf_log_item\t*dbip = dst_bp->b_fspriv;\n\tenum xfs_blft\t\ttype;\n\n\ttype = xfs_blft_from_flags(&sbip->__bli_format);\n\txfs_blft_to_flags(&dbip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_copy_type(\n\tstruct xfs_buf\t\t*dst_bp,\n\tstruct xfs_buf\t\t*src_bp)\n{\n\tstruct xfs_buf_log_item\t*sbip = src_bp->b_fspriv;\n\tstruct xfs_buf_log_item\t*dbip = dst_bp->b_fspriv;\n\tenum xfs_blft\t\ttype;\n\n\ttype = xfs_blft_from_flags(&sbip->__bli_format);\n\txfs_blft_to_flags(&dbip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root_blk->bp->b_addr",
            "bp->b_addr",
            "args->geo->blksize"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_blkinfo_onlychild_validate",
          "args": [
            "bp->b_addr",
            "oldroothdr.level"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_blkinfo_onlychild_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1013-1029",
          "snippet": "static void\nxfs_da_blkinfo_onlychild_validate(struct xfs_da_blkinfo *blkinfo, __u16 level)\n{\n\t__be16\tmagic = blkinfo->magic;\n\n\tif (level == 1) {\n\t\tASSERT(magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\t} else {\n\t\tASSERT(magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DA3_NODE_MAGIC));\n\t}\n\tASSERT(!blkinfo->forw);\n\tASSERT(!blkinfo->back);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_da_blkinfo_onlychild_validate(struct xfs_da_blkinfo *blkinfo, __u16 level)\n{\n\t__be16\tmagic = blkinfo->magic;\n\n\tif (level == 1) {\n\t\tASSERT(magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\t} else {\n\t\tASSERT(magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DA3_NODE_MAGIC));\n\t}\n\tASSERT(!blkinfo->forw);\n\tASSERT(!blkinfo->back);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "args->trans",
            "dp",
            "child",
            "-1",
            "&bp",
            "args->whichfork"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "child != 0"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[0].before"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "oldroot"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldroothdr.back == 0"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldroothdr.forw == 0"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&oldroothdr",
            "oldroot"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "root_blk->magic == XFS_DA_NODE_MAGIC"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_root_join",
          "args": [
            "state->args"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_root_join(xfs_da_state_t *state,\n\t\t\t\t\t   xfs_da_state_blk_t *root_blk);\n\nSTATIC int\nxfs_da3_root_join(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*root_blk)\n{\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tchild;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr oldroothdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_root_join(state->args);\n\n\tASSERT(root_blk->magic == XFS_DA_NODE_MAGIC);\n\n\targs = state->args;\n\toldroot = root_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&oldroothdr, oldroot);\n\tASSERT(oldroothdr.forw == 0);\n\tASSERT(oldroothdr.back == 0);\n\n\t/*\n\t * If the root has more than one child, then don't do anything.\n\t */\n\tif (oldroothdr.count > 1)\n\t\treturn 0;\n\n\t/*\n\t * Read in the (only) child block, then copy those bytes into\n\t * the root block's buffer and free the original child block.\n\t */\n\tbtree = dp->d_ops->node_tree_p(oldroot);\n\tchild = be32_to_cpu(btree[0].before);\n\tASSERT(child != 0);\n\terror = xfs_da3_node_read(args->trans, dp, child, -1, &bp,\n\t\t\t\t\t     args->whichfork);\n\tif (error)\n\t\treturn error;\n\txfs_da_blkinfo_onlychild_validate(bp->b_addr, oldroothdr.level);\n\n\t/*\n\t * This could be copying a leaf back into the root block in the case of\n\t * there only being a single leaf block left in the tree. Hence we have\n\t * to update the b_ops pointer as well to match the buffer type change\n\t * that could occur. For dir3 blocks we also need to update the block\n\t * number in the buffer header.\n\t */\n\tmemcpy(root_blk->bp->b_addr, bp->b_addr, args->geo->blksize);\n\troot_blk->bp->b_ops = bp->b_ops;\n\txfs_trans_buf_copy_type(root_blk->bp, bp);\n\tif (oldroothdr.magic == XFS_DA3_NODE_MAGIC) {\n\t\tstruct xfs_da3_blkinfo *da3 = root_blk->bp->b_addr;\n\t\tda3->blkno = cpu_to_be64(root_blk->bp->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, root_blk->bp, 0,\n\t\t\t  args->geo->blksize - 1);\n\terror = xfs_da_shrink_inode(args, child, bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_da_blkinfo_onlychild_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "1013-1029",
    "snippet": "static void\nxfs_da_blkinfo_onlychild_validate(struct xfs_da_blkinfo *blkinfo, __u16 level)\n{\n\t__be16\tmagic = blkinfo->magic;\n\n\tif (level == 1) {\n\t\tASSERT(magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\t} else {\n\t\tASSERT(magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DA3_NODE_MAGIC));\n\t}\n\tASSERT(!blkinfo->forw);\n\tASSERT(!blkinfo->back);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!blkinfo->back"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!blkinfo->forw"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA3_NODE_MAGIC"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA_NODE_MAGIC"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_da_blkinfo_onlychild_validate(struct xfs_da_blkinfo *blkinfo, __u16 level)\n{\n\t__be16\tmagic = blkinfo->magic;\n\n\tif (level == 1) {\n\t\tASSERT(magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\t} else {\n\t\tASSERT(magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       magic == cpu_to_be16(XFS_DA3_NODE_MAGIC));\n\t}\n\tASSERT(!blkinfo->forw);\n\tASSERT(!blkinfo->back);\n}"
  },
  {
    "function_name": "xfs_da3_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "929-1010",
    "snippet": "int\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
      "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_root_join",
          "args": [
            "state",
            "&state->path.blk[0]"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_root_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1038-1099",
          "snippet": "STATIC int\nxfs_da3_root_join(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*root_blk)\n{\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tchild;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr oldroothdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_root_join(state->args);\n\n\tASSERT(root_blk->magic == XFS_DA_NODE_MAGIC);\n\n\targs = state->args;\n\toldroot = root_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&oldroothdr, oldroot);\n\tASSERT(oldroothdr.forw == 0);\n\tASSERT(oldroothdr.back == 0);\n\n\t/*\n\t * If the root has more than one child, then don't do anything.\n\t */\n\tif (oldroothdr.count > 1)\n\t\treturn 0;\n\n\t/*\n\t * Read in the (only) child block, then copy those bytes into\n\t * the root block's buffer and free the original child block.\n\t */\n\tbtree = dp->d_ops->node_tree_p(oldroot);\n\tchild = be32_to_cpu(btree[0].before);\n\tASSERT(child != 0);\n\terror = xfs_da3_node_read(args->trans, dp, child, -1, &bp,\n\t\t\t\t\t     args->whichfork);\n\tif (error)\n\t\treturn error;\n\txfs_da_blkinfo_onlychild_validate(bp->b_addr, oldroothdr.level);\n\n\t/*\n\t * This could be copying a leaf back into the root block in the case of\n\t * there only being a single leaf block left in the tree. Hence we have\n\t * to update the b_ops pointer as well to match the buffer type change\n\t * that could occur. For dir3 blocks we also need to update the block\n\t * number in the buffer header.\n\t */\n\tmemcpy(root_blk->bp->b_addr, bp->b_addr, args->geo->blksize);\n\troot_blk->bp->b_ops = bp->b_ops;\n\txfs_trans_buf_copy_type(root_blk->bp, bp);\n\tif (oldroothdr.magic == XFS_DA3_NODE_MAGIC) {\n\t\tstruct xfs_da3_blkinfo *da3 = root_blk->bp->b_addr;\n\t\tda3->blkno = cpu_to_be64(root_blk->bp->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, root_blk->bp, 0,\n\t\t\t  args->geo->blksize - 1);\n\terror = xfs_da_shrink_inode(args, child, bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_root_join(xfs_da_state_t *state,\n\t\t\t\t\t   xfs_da_state_blk_t *root_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_root_join(xfs_da_state_t *state,\n\t\t\t\t\t   xfs_da_state_blk_t *root_blk);\n\nSTATIC int\nxfs_da3_root_join(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*root_blk)\n{\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tchild;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr oldroothdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_root_join(state->args);\n\n\tASSERT(root_blk->magic == XFS_DA_NODE_MAGIC);\n\n\targs = state->args;\n\toldroot = root_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&oldroothdr, oldroot);\n\tASSERT(oldroothdr.forw == 0);\n\tASSERT(oldroothdr.back == 0);\n\n\t/*\n\t * If the root has more than one child, then don't do anything.\n\t */\n\tif (oldroothdr.count > 1)\n\t\treturn 0;\n\n\t/*\n\t * Read in the (only) child block, then copy those bytes into\n\t * the root block's buffer and free the original child block.\n\t */\n\tbtree = dp->d_ops->node_tree_p(oldroot);\n\tchild = be32_to_cpu(btree[0].before);\n\tASSERT(child != 0);\n\terror = xfs_da3_node_read(args->trans, dp, child, -1, &bp,\n\t\t\t\t\t     args->whichfork);\n\tif (error)\n\t\treturn error;\n\txfs_da_blkinfo_onlychild_validate(bp->b_addr, oldroothdr.level);\n\n\t/*\n\t * This could be copying a leaf back into the root block in the case of\n\t * there only being a single leaf block left in the tree. Hence we have\n\t * to update the b_ops pointer as well to match the buffer type change\n\t * that could occur. For dir3 blocks we also need to update the block\n\t * number in the buffer header.\n\t */\n\tmemcpy(root_blk->bp->b_addr, bp->b_addr, args->geo->blksize);\n\troot_blk->bp->b_ops = bp->b_ops;\n\txfs_trans_buf_copy_type(root_blk->bp, bp);\n\tif (oldroothdr.magic == XFS_DA3_NODE_MAGIC) {\n\t\tstruct xfs_da3_blkinfo *da3 = root_blk->bp->b_addr;\n\t\tda3->blkno = cpu_to_be64(root_blk->bp->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, root_blk->bp, 0,\n\t\t\t  args->geo->blksize - 1);\n\terror = xfs_da_shrink_inode(args, child, bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_fixhashpath",
          "args": [
            "state",
            "&state->path"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_fixhashpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1256-1306",
          "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_remove",
          "args": [
            "state",
            "drop_blk"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1311-1355",
          "snippet": "STATIC void\nxfs_da3_node_remove(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\tindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_remove(state->args);\n\n\tnode = drop_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tASSERT(drop_blk->index < nodehdr.count);\n\tASSERT(drop_blk->index >= 0);\n\n\t/*\n\t * Copy over the offending entry, or just zero it out.\n\t */\n\tindex = drop_blk->index;\n\tbtree = dp->d_ops->node_tree_p(node);\n\tif (index < nodehdr.count - 1) {\n\t\ttmp  = nodehdr.count - index - 1;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&btree[index], &btree[index + 1], tmp);\n\t\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t\t    XFS_DA_LOGRANGE(node, &btree[index], tmp));\n\t\tindex = nodehdr.count - 1;\n\t}\n\tmemset(&btree[index], 0, sizeof(xfs_da_node_entry_t));\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index])));\n\tnodehdr.count -= 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the block to propagate upwards.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(btree[index - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\n\nSTATIC void\nxfs_da3_node_remove(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\tindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_remove(state->args);\n\n\tnode = drop_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tASSERT(drop_blk->index < nodehdr.count);\n\tASSERT(drop_blk->index >= 0);\n\n\t/*\n\t * Copy over the offending entry, or just zero it out.\n\t */\n\tindex = drop_blk->index;\n\tbtree = dp->d_ops->node_tree_p(node);\n\tif (index < nodehdr.count - 1) {\n\t\ttmp  = nodehdr.count - index - 1;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&btree[index], &btree[index + 1], tmp);\n\t\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t\t    XFS_DA_LOGRANGE(node, &btree[index], tmp));\n\t\tindex = nodehdr.count - 1;\n\t}\n\tmemset(&btree[index], 0, sizeof(xfs_da_node_entry_t));\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &btree[index], sizeof(btree[index])));\n\tnodehdr.count -= 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, drop_blk->bp,\n\t    XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the block to propagate upwards.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(btree[index - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_shrink_inode",
          "args": [
            "state->args",
            "drop_blk->blkno",
            "drop_blk->bp"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2332-2369",
          "snippet": "int\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_kill_altpath",
          "args": [
            "state"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_kill_altpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "107-115",
          "snippet": "STATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_blk_unlink",
          "args": [
            "state",
            "drop_blk",
            "save_blk"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_blk_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1731-1801",
          "snippet": "STATIC int\t\t\t\t\t\t/* error */\nxfs_da3_blk_unlink(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_blkinfo\t*drop_info;\n\tstruct xfs_da_blkinfo\t*save_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tsave_info = save_blk->bp->b_addr;\n\tdrop_info = drop_blk->bp->b_addr;\n\tASSERT(save_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       save_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       save_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(save_blk->magic == drop_blk->magic);\n\tASSERT((be32_to_cpu(save_info->forw) == drop_blk->blkno) ||\n\t       (be32_to_cpu(save_info->back) == drop_blk->blkno));\n\tASSERT((be32_to_cpu(drop_info->forw) == save_blk->blkno) ||\n\t       (be32_to_cpu(drop_info->back) == save_blk->blkno));\n\n\t/*\n\t * Unlink the leaf block from the doubly linked chain of leaves.\n\t */\n\tif (be32_to_cpu(save_info->back) == drop_blk->blkno) {\n\t\ttrace_xfs_da_unlink_back(args);\n\t\tsave_info->back = drop_info->back;\n\t\tif (drop_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == drop_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t} else {\n\t\ttrace_xfs_da_unlink_forward(args);\n\t\tsave_info->forw = drop_info->forw;\n\t\tif (drop_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == drop_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t}\n\n\txfs_trans_log_buf(args->trans, save_blk->bp, 0, sizeof(*save_info) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
            "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nSTATIC int\t\t\t\t\t\t/* error */\nxfs_da3_blk_unlink(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_blkinfo\t*drop_info;\n\tstruct xfs_da_blkinfo\t*save_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tsave_info = save_blk->bp->b_addr;\n\tdrop_info = drop_blk->bp->b_addr;\n\tASSERT(save_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       save_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       save_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(save_blk->magic == drop_blk->magic);\n\tASSERT((be32_to_cpu(save_info->forw) == drop_blk->blkno) ||\n\t       (be32_to_cpu(save_info->back) == drop_blk->blkno));\n\tASSERT((be32_to_cpu(drop_info->forw) == save_blk->blkno) ||\n\t       (be32_to_cpu(drop_info->back) == save_blk->blkno));\n\n\t/*\n\t * Unlink the leaf block from the doubly linked chain of leaves.\n\t */\n\tif (be32_to_cpu(save_info->back) == drop_blk->blkno) {\n\t\ttrace_xfs_da_unlink_back(args);\n\t\tsave_info->back = drop_info->back;\n\t\tif (drop_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == drop_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t} else {\n\t\ttrace_xfs_da_unlink_forward(args);\n\t\tsave_info->forw = drop_info->forw;\n\t\tif (drop_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, args->dp,\n\t\t\t\t\t\tbe32_to_cpu(drop_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == save_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == drop_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(save_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t\t\t\t    sizeof(*tmp_info) - 1);\n\t\t}\n\t}\n\n\txfs_trans_log_buf(args->trans, save_blk->bp, 0, sizeof(*save_info) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_unbalance",
          "args": [
            "state",
            "drop_blk",
            "save_blk"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_unbalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1361-1428",
          "snippet": "STATIC void\nxfs_da3_node_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_intnode\t*drop_node;\n\tstruct xfs_da_intnode\t*save_node;\n\tstruct xfs_da_node_entry *drop_btree;\n\tstruct xfs_da_node_entry *save_btree;\n\tstruct xfs_da3_icnode_hdr drop_hdr;\n\tstruct xfs_da3_icnode_hdr save_hdr;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tsindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_unbalance(state->args);\n\n\tdrop_node = drop_blk->bp->b_addr;\n\tsave_node = save_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&drop_hdr, drop_node);\n\tdp->d_ops->node_hdr_from_disk(&save_hdr, save_node);\n\tdrop_btree = dp->d_ops->node_tree_p(drop_node);\n\tsave_btree = dp->d_ops->node_tree_p(save_node);\n\ttp = state->args->trans;\n\n\t/*\n\t * If the dying block has lower hashvals, then move all the\n\t * elements in the remaining block up to make a hole.\n\t */\n\tif ((be32_to_cpu(drop_btree[0].hashval) <\n\t\t\tbe32_to_cpu(save_btree[0].hashval)) ||\n\t    (be32_to_cpu(drop_btree[drop_hdr.count - 1].hashval) <\n\t\t\tbe32_to_cpu(save_btree[save_hdr.count - 1].hashval))) {\n\t\t/* XXX: check this - is memmove dst correct? */\n\t\ttmp = save_hdr.count * sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&save_btree[drop_hdr.count], &save_btree[0], tmp);\n\n\t\tsindex = 0;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[0],\n\t\t\t\t(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t)));\n\t} else {\n\t\tsindex = save_hdr.count;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[sindex],\n\t\t\t\tdrop_hdr.count * sizeof(xfs_da_node_entry_t)));\n\t}\n\n\t/*\n\t * Move all the B-tree elements from drop_blk to save_blk.\n\t */\n\ttmp = drop_hdr.count * (uint)sizeof(xfs_da_node_entry_t);\n\tmemcpy(&save_btree[sindex], &drop_btree[0], tmp);\n\tsave_hdr.count += drop_hdr.count;\n\n\tdp->d_ops->node_hdr_to_disk(save_node, &save_hdr);\n\txfs_trans_log_buf(tp, save_blk->bp,\n\t\tXFS_DA_LOGRANGE(save_node, &save_node->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size));\n\n\t/*\n\t * Save the last hashval in the remaining block for upward propagation.\n\t */\n\tsave_blk->hashval = be32_to_cpu(save_btree[save_hdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
            "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nSTATIC void\nxfs_da3_node_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_da_intnode\t*drop_node;\n\tstruct xfs_da_intnode\t*save_node;\n\tstruct xfs_da_node_entry *drop_btree;\n\tstruct xfs_da_node_entry *save_btree;\n\tstruct xfs_da3_icnode_hdr drop_hdr;\n\tstruct xfs_da3_icnode_hdr save_hdr;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tsindex;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_unbalance(state->args);\n\n\tdrop_node = drop_blk->bp->b_addr;\n\tsave_node = save_blk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&drop_hdr, drop_node);\n\tdp->d_ops->node_hdr_from_disk(&save_hdr, save_node);\n\tdrop_btree = dp->d_ops->node_tree_p(drop_node);\n\tsave_btree = dp->d_ops->node_tree_p(save_node);\n\ttp = state->args->trans;\n\n\t/*\n\t * If the dying block has lower hashvals, then move all the\n\t * elements in the remaining block up to make a hole.\n\t */\n\tif ((be32_to_cpu(drop_btree[0].hashval) <\n\t\t\tbe32_to_cpu(save_btree[0].hashval)) ||\n\t    (be32_to_cpu(drop_btree[drop_hdr.count - 1].hashval) <\n\t\t\tbe32_to_cpu(save_btree[save_hdr.count - 1].hashval))) {\n\t\t/* XXX: check this - is memmove dst correct? */\n\t\ttmp = save_hdr.count * sizeof(xfs_da_node_entry_t);\n\t\tmemmove(&save_btree[drop_hdr.count], &save_btree[0], tmp);\n\n\t\tsindex = 0;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[0],\n\t\t\t\t(save_hdr.count + drop_hdr.count) *\n\t\t\t\t\t\tsizeof(xfs_da_node_entry_t)));\n\t} else {\n\t\tsindex = save_hdr.count;\n\t\txfs_trans_log_buf(tp, save_blk->bp,\n\t\t\tXFS_DA_LOGRANGE(save_node, &save_btree[sindex],\n\t\t\t\tdrop_hdr.count * sizeof(xfs_da_node_entry_t)));\n\t}\n\n\t/*\n\t * Move all the B-tree elements from drop_blk to save_blk.\n\t */\n\ttmp = drop_hdr.count * (uint)sizeof(xfs_da_node_entry_t);\n\tmemcpy(&save_btree[sindex], &drop_btree[0], tmp);\n\tsave_hdr.count += drop_hdr.count;\n\n\tdp->d_ops->node_hdr_to_disk(save_node, &save_hdr);\n\txfs_trans_log_buf(tp, save_blk->bp,\n\t\tXFS_DA_LOGRANGE(save_node, &save_node->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size));\n\n\t/*\n\t * Save the last hashval in the remaining block for upward propagation.\n\t */\n\tsave_blk->hashval = be32_to_cpu(save_btree[save_hdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_toosmall",
          "args": [
            "state",
            "&action"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_toosmall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1110-1227",
          "snippet": "STATIC int\nxfs_da3_node_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\txfs_dablk_t\t\tblkno;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tint\t\t\tcount;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tinfo = blk->bp->b_addr;\n\tnode = (xfs_da_intnode_t *)info;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (nodehdr.count > (state->args->geo->node_ents >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\t/* blk over 50%, don't try to join */\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (nodehdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (info->forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tcount  = state->args->geo->node_ents;\n\tcount -= state->args->geo->node_ents >> 2;\n\tcount -= nodehdr.count;\n\n\t/* start with smaller blk num */\n\tforward = nodehdr.forw < nodehdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_da3_icnode_hdr thdr;\n\t\tif (forward)\n\t\t\tblkno = nodehdr.forw;\n\t\telse\n\t\t\tblkno = nodehdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_da3_node_read(state->args->trans, dp,\n\t\t\t\t\tblkno, -1, &bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnode = bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&thdr, node);\n\t\txfs_trans_brelse(state->args->trans, bp);\n\n\t\tif (count - thdr.count >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t*action = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nSTATIC int\nxfs_da3_node_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\txfs_dablk_t\t\tblkno;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tint\t\t\tcount;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tinfo = blk->bp->b_addr;\n\tnode = (xfs_da_intnode_t *)info;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (nodehdr.count > (state->args->geo->node_ents >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\t/* blk over 50%, don't try to join */\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (nodehdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (info->forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tcount  = state->args->geo->node_ents;\n\tcount -= state->args->geo->node_ents >> 2;\n\tcount -= nodehdr.count;\n\n\t/* start with smaller blk num */\n\tforward = nodehdr.forw < nodehdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_da3_icnode_hdr thdr;\n\t\tif (forward)\n\t\t\tblkno = nodehdr.forw;\n\t\telse\n\t\t\tblkno = nodehdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_da3_node_read(state->args->trans, dp,\n\t\t\t\t\tblkno, -1, &bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tnode = bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&thdr, node);\n\t\txfs_trans_brelse(state->args->trans, bp);\n\n\t\tif (count - thdr.count >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t*action = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_unbalance",
          "args": [
            "state",
            "drop_blk",
            "save_blk"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_unbalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1504-1561",
          "snippet": "void\nxfs_dir2_leafn_unbalance(\n\txfs_da_state_t\t\t*state,\t\t/* cursor */\n\txfs_da_state_blk_t\t*drop_blk,\t/* dead block */\n\txfs_da_state_blk_t\t*save_blk)\t/* surviving block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dir2_leaf_t\t\t*drop_leaf;\t/* dead leaf structure */\n\txfs_dir2_leaf_t\t\t*save_leaf;\t/* surviving leaf structure */\n\tstruct xfs_dir3_icleaf_hdr savehdr;\n\tstruct xfs_dir3_icleaf_hdr drophdr;\n\tstruct xfs_dir2_leaf_entry *sents;\n\tstruct xfs_dir2_leaf_entry *dents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\tASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&savehdr, save_leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&drophdr, drop_leaf);\n\tsents = dp->d_ops->leaf_ents_p(save_leaf);\n\tdents = dp->d_ops->leaf_ents_p(drop_leaf);\n\n\t/*\n\t * If there are any stale leaf entries, take this opportunity\n\t * to purge them.\n\t */\n\tif (drophdr.stale)\n\t\txfs_dir3_leaf_compact(args, &drophdr, drop_blk->bp);\n\tif (savehdr.stale)\n\t\txfs_dir3_leaf_compact(args, &savehdr, save_blk->bp);\n\n\t/*\n\t * Move the entries from drop to the appropriate end of save.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(dents[drophdr.count - 1].hashval);\n\tif (xfs_dir2_leafn_order(dp, save_blk->bp, drop_blk->bp))\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents, 0,\n\t\t\t\t\tdrophdr.count);\n\telse\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents,\n\t\t\t\t\tsavehdr.count, drophdr.count);\n\tsave_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(save_leaf, &savehdr);\n\tdp->d_ops->leaf_hdr_to_disk(drop_leaf, &drophdr);\n\txfs_dir3_leaf_log_header(args, save_blk->bp);\n\txfs_dir3_leaf_log_header(args, drop_blk->bp);\n\n\txfs_dir3_leaf_check(dp, save_blk->bp);\n\txfs_dir3_leaf_check(dp, drop_blk->bp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_leafn_unbalance(\n\txfs_da_state_t\t\t*state,\t\t/* cursor */\n\txfs_da_state_blk_t\t*drop_blk,\t/* dead block */\n\txfs_da_state_blk_t\t*save_blk)\t/* surviving block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dir2_leaf_t\t\t*drop_leaf;\t/* dead leaf structure */\n\txfs_dir2_leaf_t\t\t*save_leaf;\t/* surviving leaf structure */\n\tstruct xfs_dir3_icleaf_hdr savehdr;\n\tstruct xfs_dir3_icleaf_hdr drophdr;\n\tstruct xfs_dir2_leaf_entry *sents;\n\tstruct xfs_dir2_leaf_entry *dents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\tASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&savehdr, save_leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&drophdr, drop_leaf);\n\tsents = dp->d_ops->leaf_ents_p(save_leaf);\n\tdents = dp->d_ops->leaf_ents_p(drop_leaf);\n\n\t/*\n\t * If there are any stale leaf entries, take this opportunity\n\t * to purge them.\n\t */\n\tif (drophdr.stale)\n\t\txfs_dir3_leaf_compact(args, &drophdr, drop_blk->bp);\n\tif (savehdr.stale)\n\t\txfs_dir3_leaf_compact(args, &savehdr, save_blk->bp);\n\n\t/*\n\t * Move the entries from drop to the appropriate end of save.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(dents[drophdr.count - 1].hashval);\n\tif (xfs_dir2_leafn_order(dp, save_blk->bp, drop_blk->bp))\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents, 0,\n\t\t\t\t\tdrophdr.count);\n\telse\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents,\n\t\t\t\t\tsavehdr.count, drophdr.count);\n\tsave_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(save_leaf, &savehdr);\n\tdp->d_ops->leaf_hdr_to_disk(drop_leaf, &drophdr);\n\txfs_dir3_leaf_log_header(args, save_blk->bp);\n\txfs_dir3_leaf_log_header(args, drop_blk->bp);\n\n\txfs_dir3_leaf_check(dp, save_blk->bp);\n\txfs_dir3_leaf_check(dp, drop_blk->bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_toosmall",
          "args": [
            "state",
            "&action"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_toosmall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1373-1498",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_toosmall(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\tint\t\t\t*action)\t/* resulting action to take */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block number */\n\tstruct xfs_buf\t\t*bp;\t\t/* leaf buffer */\n\tint\t\t\tbytes;\t\t/* bytes in use */\n\tint\t\t\tcount;\t\t/* leaf live entry count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tforward;\t/* sibling block direction */\n\tint\t\t\ti;\t\t/* sibling counter */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\trval;\t\t/* result from path_shift */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[state->path.active - 1];\n\tleaf = blk->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\txfs_dir3_leaf_check(dp, blk->bp);\n\n\tcount = leafhdr.count - leafhdr.stale;\n\tbytes = dp->d_ops->leaf_hdr_size + count * sizeof(ents[0]);\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t/*\n\t\t * Blk over 50%, don't try to join.\n\t\t */\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (leafhdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = rval ? 2 : 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tforward = leafhdr.forw < leafhdr.back;\n\tfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\t\tblkno = forward ? leafhdr.forw : leafhdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Read the sibling leaf block.\n\t\t */\n\t\terror = xfs_dir3_leafn_read(state->args->trans, dp,\n\t\t\t\t\t    blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Count bytes in the two blocks combined.\n\t\t */\n\t\tcount = leafhdr.count - leafhdr.stale;\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2);\n\n\t\tleaf = bp->b_addr;\n\t\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\t\tcount += hdr2.count - hdr2.stale;\n\t\tbytes -= count * sizeof(ents[0]);\n\n\t\t/*\n\t\t * Fits with at least 25% to spare.\n\t\t */\n\t\tif (bytes >= 0)\n\t\t\tbreak;\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t}\n\t/*\n\t * Didn't like either block, give up.\n\t */\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno)\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\telse\n\t\terror = xfs_da3_path_shift(state, &state->path, forward, 0,\n\t\t\t&rval);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*action = rval ? 0 : 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_toosmall(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\tint\t\t\t*action)\t/* resulting action to take */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block number */\n\tstruct xfs_buf\t\t*bp;\t\t/* leaf buffer */\n\tint\t\t\tbytes;\t\t/* bytes in use */\n\tint\t\t\tcount;\t\t/* leaf live entry count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tforward;\t/* sibling block direction */\n\tint\t\t\ti;\t\t/* sibling counter */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\trval;\t\t/* result from path_shift */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[state->path.active - 1];\n\tleaf = blk->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\txfs_dir3_leaf_check(dp, blk->bp);\n\n\tcount = leafhdr.count - leafhdr.stale;\n\tbytes = dp->d_ops->leaf_hdr_size + count * sizeof(ents[0]);\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t/*\n\t\t * Blk over 50%, don't try to join.\n\t\t */\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (leafhdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = rval ? 2 : 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tforward = leafhdr.forw < leafhdr.back;\n\tfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\t\tblkno = forward ? leafhdr.forw : leafhdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Read the sibling leaf block.\n\t\t */\n\t\terror = xfs_dir3_leafn_read(state->args->trans, dp,\n\t\t\t\t\t    blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Count bytes in the two blocks combined.\n\t\t */\n\t\tcount = leafhdr.count - leafhdr.stale;\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2);\n\n\t\tleaf = bp->b_addr;\n\t\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\t\tcount += hdr2.count - hdr2.stale;\n\t\tbytes -= count * sizeof(ents[0]);\n\n\t\t/*\n\t\t * Fits with at least 25% to spare.\n\t\t */\n\t\tif (bytes >= 0)\n\t\t\tbreak;\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t}\n\t/*\n\t * Didn't like either block, give up.\n\t */\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno)\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\telse\n\t\terror = xfs_da3_path_shift(state, &state->path, forward, 0,\n\t\t\t&rval);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*action = rval ? 0 : 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_unbalance",
          "args": [
            "state",
            "drop_blk",
            "save_blk"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_unbalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1944-2051",
          "snippet": "void\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(&savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t/*\n\t * Save last hashval from dying block for later Btree fixup.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t/*\n\t * Check if we need a temp buffer, or can we do it in place.\n\t * Note that we don't check \"leaf\" for holes because we will\n\t * always be dropping it, toosmall() decided that for us already.\n\t */\n\tif (savehdr.holes == 0) {\n\t\t/*\n\t\t * dest leaf has no holes, so we add there.  May need\n\t\t * to make some room in the entry array.\n\t\t */\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Destination has holes, so we make a temporary copy\n\t\t * of the leaf and add them both to that.\n\t\t */\n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);\n\n\t\t/*\n\t\t * Copy the header into the temp leaf so that all the stuff\n\t\t * not in the incore header is present and gets copied back in\n\t\t * once we've moved all the entries.\n\t\t */\n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t/* write the header to the temp buffer to initialise it */\n\t\txfs_attr3_leaf_hdr_to_disk(tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr; /* struct copy */\n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(&savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t/*\n\t * Save last hashval from dying block for later Btree fixup.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t/*\n\t * Check if we need a temp buffer, or can we do it in place.\n\t * Note that we don't check \"leaf\" for holes because we will\n\t * always be dropping it, toosmall() decided that for us already.\n\t */\n\tif (savehdr.holes == 0) {\n\t\t/*\n\t\t * dest leaf has no holes, so we add there.  May need\n\t\t * to make some room in the entry array.\n\t\t */\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Destination has holes, so we make a temporary copy\n\t\t * of the leaf and add them both to that.\n\t\t */\n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);\n\n\t\t/*\n\t\t * Copy the header into the temp leaf so that all the stuff\n\t\t * not in the incore header is present and gets copied back in\n\t\t * once we've moved all the entries.\n\t\t */\n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t/* write the header to the temp buffer to initialise it */\n\t\txfs_attr3_leaf_hdr_to_disk(tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr; /* struct copy */\n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_toosmall",
          "args": [
            "state",
            "&action"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_toosmall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1662-1781",
          "snippet": "int\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (ichdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink an attribute list over time.\n\t */\n\t/* start with smaller blk num */\n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(&ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (ichdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink an attribute list over time.\n\t */\n\t/* start with smaller blk num */\n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(&ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->path.blk[0].magic == XFS_DA_NODE_MAGIC"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_join",
          "args": [
            "state->args"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nint\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_da3_node_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "872-919",
    "snippet": "STATIC void\nxfs_da3_node_add(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_add(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tASSERT(oldblk->index >= 0 && oldblk->index <= nodehdr.count);\n\tASSERT(newblk->blkno != 0);\n\tif (state->args->whichfork == XFS_DATA_FORK)\n\t\tASSERT(newblk->blkno >= state->args->geo->leafblk &&\n\t\t       newblk->blkno < state->args->geo->freeblk);\n\n\t/*\n\t * We may need to make some room before we insert the new node.\n\t */\n\ttmp = 0;\n\tif (oldblk->index < nodehdr.count) {\n\t\ttmp = (nodehdr.count - oldblk->index) * (uint)sizeof(*btree);\n\t\tmemmove(&btree[oldblk->index + 1], &btree[oldblk->index], tmp);\n\t}\n\tbtree[oldblk->index].hashval = cpu_to_be32(newblk->hashval);\n\tbtree[oldblk->index].before = cpu_to_be32(newblk->blkno);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &btree[oldblk->index],\n\t\t\t\ttmp + sizeof(*btree)));\n\n\tnodehdr.count += 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the oldblk to propagate upwards.\n\t */\n\toldblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[nodehdr.count - 1].hashval"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "oldblk->bp",
            "XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&node->hdr",
            "dp->d_ops->node_hdr_size"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node",
            "&nodehdr"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "oldblk->bp",
            "XFS_DA_LOGRANGE(node, &btree[oldblk->index],\n\t\t\t\ttmp + sizeof(*btree))"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&btree[oldblk->index]",
            "tmp + sizeof(*btree)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "newblk->blkno"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "newblk->hashval"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&btree[oldblk->index + 1]",
            "&btree[oldblk->index]",
            "tmp"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "newblk->blkno >= state->args->geo->leafblk &&\n\t\t       newblk->blkno < state->args->geo->freeblk"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "newblk->blkno != 0"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldblk->index >= 0 && oldblk->index <= nodehdr.count"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_add",
          "args": [
            "state->args"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da3_node_add(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_add(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tASSERT(oldblk->index >= 0 && oldblk->index <= nodehdr.count);\n\tASSERT(newblk->blkno != 0);\n\tif (state->args->whichfork == XFS_DATA_FORK)\n\t\tASSERT(newblk->blkno >= state->args->geo->leafblk &&\n\t\t       newblk->blkno < state->args->geo->freeblk);\n\n\t/*\n\t * We may need to make some room before we insert the new node.\n\t */\n\ttmp = 0;\n\tif (oldblk->index < nodehdr.count) {\n\t\ttmp = (nodehdr.count - oldblk->index) * (uint)sizeof(*btree);\n\t\tmemmove(&btree[oldblk->index + 1], &btree[oldblk->index], tmp);\n\t}\n\tbtree[oldblk->index].hashval = cpu_to_be32(newblk->hashval);\n\tbtree[oldblk->index].before = cpu_to_be32(newblk->blkno);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &btree[oldblk->index],\n\t\t\t\ttmp + sizeof(*btree)));\n\n\tnodehdr.count += 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the oldblk to propagate upwards.\n\t */\n\toldblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}"
  },
  {
    "function_name": "xfs_da3_node_rebalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "729-867",
    "snippet": "STATIC void\nxfs_da3_node_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_intnode\t*tmpnode;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da_node_entry *btree_s;\n\tstruct xfs_da_node_entry *btree_d;\n\tstruct xfs_da3_icnode_hdr nodehdr1;\n\tstruct xfs_da3_icnode_hdr nodehdr2;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tcount;\n\tint\t\t\ttmp;\n\tint\t\t\tswap = 0;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_rebalance(state->args);\n\n\tnode1 = blk1->bp->b_addr;\n\tnode2 = blk2->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\t/*\n\t * Figure out how many entries need to move, and in which direction.\n\t * Swap the nodes around if that makes it simpler.\n\t */\n\tif (nodehdr1.count > 0 && nodehdr2.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[nodehdr2.count - 1].hashval) <\n\t\t\tbe32_to_cpu(btree1[nodehdr1.count - 1].hashval)))) {\n\t\ttmpnode = node1;\n\t\tnode1 = node2;\n\t\tnode2 = tmpnode;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t\tswap = 1;\n\t}\n\n\tcount = (nodehdr1.count - nodehdr2.count) / 2;\n\tif (count == 0)\n\t\treturn;\n\ttp = state->args->trans;\n\t/*\n\t * Two cases: high-to-low and low-to-high.\n\t */\n\tif (count > 0) {\n\t\t/*\n\t\t * Move elements in node2 up to make a hole.\n\t\t */\n\t\ttmp = nodehdr2.count;\n\t\tif (tmp > 0) {\n\t\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\t\tbtree_s = &btree2[0];\n\t\t\tbtree_d = &btree2[count];\n\t\t\tmemmove(btree_d, btree_s, tmp);\n\t\t}\n\n\t\t/*\n\t\t * Move the req'd B-tree elements from high in node1 to\n\t\t * low in node2.\n\t\t */\n\t\tnodehdr2.count += count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree1[nodehdr1.count - count];\n\t\tbtree_d = &btree2[0];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count -= count;\n\t} else {\n\t\t/*\n\t\t * Move the req'd B-tree elements from low in node2 to\n\t\t * high in node1.\n\t\t */\n\t\tcount = -count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[0];\n\t\tbtree_d = &btree1[nodehdr1.count];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count += count;\n\n\t\txfs_trans_log_buf(tp, blk1->bp,\n\t\t\tXFS_DA_LOGRANGE(node1, btree_d, tmp));\n\n\t\t/*\n\t\t * Move elements in node2 down to fill the hole.\n\t\t */\n\t\ttmp  = nodehdr2.count - count;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[count];\n\t\tbtree_d = &btree2[0];\n\t\tmemmove(btree_d, btree_s, tmp);\n\t\tnodehdr2.count -= count;\n\t}\n\n\t/*\n\t * Log header of node 1 and all current bits of node 2.\n\t */\n\tdp->d_ops->node_hdr_to_disk(node1, &nodehdr1);\n\txfs_trans_log_buf(tp, blk1->bp,\n\t\tXFS_DA_LOGRANGE(node1, &node1->hdr, dp->d_ops->node_hdr_size));\n\n\tdp->d_ops->node_hdr_to_disk(node2, &nodehdr2);\n\txfs_trans_log_buf(tp, blk2->bp,\n\t\tXFS_DA_LOGRANGE(node2, &node2->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count)));\n\n\t/*\n\t * Record the last hashval from each block for upward propagation.\n\t * (note: don't use the swapped node pointers)\n\t */\n\tif (swap) {\n\t\tnode1 = blk1->bp->b_addr;\n\t\tnode2 = blk2->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t}\n\tblk1->hashval = be32_to_cpu(btree1[nodehdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(btree2[nodehdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (blk1->index >= nodehdr1.count) {\n\t\tblk2->index = blk1->index - nodehdr1.count;\n\t\tblk1->index = nodehdr1.count + 1;\t/* make it invalid */\n\t}\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree2[nodehdr2.count - 1].hashval"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree1[nodehdr1.count - 1].hashval"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node2"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node1"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr2",
            "node2"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr1",
            "node1"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "blk2->bp",
            "XFS_DA_LOGRANGE(node2, &node2->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count))"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node2",
            "&node2->hdr",
            "dp->d_ops->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node2",
            "&nodehdr2"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "blk1->bp",
            "XFS_DA_LOGRANGE(node1, &node1->hdr, dp->d_ops->node_hdr_size)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node1",
            "&node1->hdr",
            "dp->d_ops->node_hdr_size"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node1",
            "&nodehdr1"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "btree_d",
            "btree_s",
            "tmp"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "blk1->bp",
            "XFS_DA_LOGRANGE(node1, btree_d, tmp)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node1",
            "btree_d",
            "tmp"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "btree_d",
            "btree_s",
            "tmp"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "btree_d",
            "btree_s",
            "tmp"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "btree_d",
            "btree_s",
            "tmp"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node2"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node1"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr2",
            "node2"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr1",
            "node1"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree1[nodehdr1.count - 1].hashval"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree2[nodehdr2.count - 1].hashval"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree1[0].hashval"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree2[0].hashval"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node2"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node1"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr2",
            "node2"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr1",
            "node1"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_rebalance",
          "args": [
            "state->args"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da3_node_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_intnode\t*tmpnode;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da_node_entry *btree_s;\n\tstruct xfs_da_node_entry *btree_d;\n\tstruct xfs_da3_icnode_hdr nodehdr1;\n\tstruct xfs_da3_icnode_hdr nodehdr2;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tcount;\n\tint\t\t\ttmp;\n\tint\t\t\tswap = 0;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_rebalance(state->args);\n\n\tnode1 = blk1->bp->b_addr;\n\tnode2 = blk2->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\t/*\n\t * Figure out how many entries need to move, and in which direction.\n\t * Swap the nodes around if that makes it simpler.\n\t */\n\tif (nodehdr1.count > 0 && nodehdr2.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[nodehdr2.count - 1].hashval) <\n\t\t\tbe32_to_cpu(btree1[nodehdr1.count - 1].hashval)))) {\n\t\ttmpnode = node1;\n\t\tnode1 = node2;\n\t\tnode2 = tmpnode;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t\tswap = 1;\n\t}\n\n\tcount = (nodehdr1.count - nodehdr2.count) / 2;\n\tif (count == 0)\n\t\treturn;\n\ttp = state->args->trans;\n\t/*\n\t * Two cases: high-to-low and low-to-high.\n\t */\n\tif (count > 0) {\n\t\t/*\n\t\t * Move elements in node2 up to make a hole.\n\t\t */\n\t\ttmp = nodehdr2.count;\n\t\tif (tmp > 0) {\n\t\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\t\tbtree_s = &btree2[0];\n\t\t\tbtree_d = &btree2[count];\n\t\t\tmemmove(btree_d, btree_s, tmp);\n\t\t}\n\n\t\t/*\n\t\t * Move the req'd B-tree elements from high in node1 to\n\t\t * low in node2.\n\t\t */\n\t\tnodehdr2.count += count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree1[nodehdr1.count - count];\n\t\tbtree_d = &btree2[0];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count -= count;\n\t} else {\n\t\t/*\n\t\t * Move the req'd B-tree elements from low in node2 to\n\t\t * high in node1.\n\t\t */\n\t\tcount = -count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[0];\n\t\tbtree_d = &btree1[nodehdr1.count];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count += count;\n\n\t\txfs_trans_log_buf(tp, blk1->bp,\n\t\t\tXFS_DA_LOGRANGE(node1, btree_d, tmp));\n\n\t\t/*\n\t\t * Move elements in node2 down to fill the hole.\n\t\t */\n\t\ttmp  = nodehdr2.count - count;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[count];\n\t\tbtree_d = &btree2[0];\n\t\tmemmove(btree_d, btree_s, tmp);\n\t\tnodehdr2.count -= count;\n\t}\n\n\t/*\n\t * Log header of node 1 and all current bits of node 2.\n\t */\n\tdp->d_ops->node_hdr_to_disk(node1, &nodehdr1);\n\txfs_trans_log_buf(tp, blk1->bp,\n\t\tXFS_DA_LOGRANGE(node1, &node1->hdr, dp->d_ops->node_hdr_size));\n\n\tdp->d_ops->node_hdr_to_disk(node2, &nodehdr2);\n\txfs_trans_log_buf(tp, blk2->bp,\n\t\tXFS_DA_LOGRANGE(node2, &node2->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count)));\n\n\t/*\n\t * Record the last hashval from each block for upward propagation.\n\t * (note: don't use the swapped node pointers)\n\t */\n\tif (swap) {\n\t\tnode1 = blk1->bp->b_addr;\n\t\tnode2 = blk2->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t}\n\tblk1->hashval = be32_to_cpu(btree1[nodehdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(btree2[nodehdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (blk1->index >= nodehdr1.count) {\n\t\tblk2->index = blk1->index - nodehdr1.count;\n\t\tblk1->index = nodehdr1.count + 1;\t/* make it invalid */\n\t}\n}"
  },
  {
    "function_name": "xfs_da3_node_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "632-721",
    "snippet": "STATIC int\t\t\t\t\t\t/* error */\nxfs_da3_node_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk,\n\tstruct xfs_da_state_blk\t*addblk,\n\tint\t\t\ttreelevel,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tnewcount;\n\tint\t\t\terror;\n\tint\t\t\tuseextra;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_split(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\n\t/*\n\t * With V2 dirs the extra block is data or freespace.\n\t */\n\tuseextra = state->extravalid && state->args->whichfork == XFS_ATTR_FORK;\n\tnewcount = 1 + useextra;\n\t/*\n\t * Do we have to split the node?\n\t */\n\tif (nodehdr.count + newcount > state->args->geo->node_ents) {\n\t\t/*\n\t\t * Allocate a new node, add to the doubly linked chain of\n\t\t * nodes, then move some of our excess entries into it.\n\t\t */\n\t\terror = xfs_da_grow_inode(state->args, &blkno);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\n\t\terror = xfs_da3_node_create(state->args, blkno, treelevel,\n\t\t\t\t\t   &newblk->bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\tnewblk->blkno = blkno;\n\t\tnewblk->magic = XFS_DA_NODE_MAGIC;\n\t\txfs_da3_node_rebalance(state, oldblk, newblk);\n\t\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*result = 1;\n\t} else {\n\t\t*result = 0;\n\t}\n\n\t/*\n\t * Insert the new entry(s) into the correct block\n\t * (updating last hashval in the process).\n\t *\n\t * xfs_da3_node_add() inserts BEFORE the given index,\n\t * and as a result of using node_lookup_int() we always\n\t * point to a valid entry (not after one), but a split\n\t * operation always results in a new block whose hashvals\n\t * FOLLOW the current block.\n\t *\n\t * If we had double-split op below us, then add the extra block too.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (oldblk->index <= nodehdr.count) {\n\t\toldblk->index++;\n\t\txfs_da3_node_add(state, oldblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\toldblk->index++;\n\t\t\txfs_da3_node_add(state, oldblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t} else {\n\t\tnewblk->index++;\n\t\txfs_da3_node_add(state, newblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\tnewblk->index++;\n\t\t\txfs_da3_node_add(state, newblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_node_add",
          "args": [
            "state",
            "newblk",
            "&state->extrablk"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "872-919",
          "snippet": "STATIC void\nxfs_da3_node_add(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_add(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tASSERT(oldblk->index >= 0 && oldblk->index <= nodehdr.count);\n\tASSERT(newblk->blkno != 0);\n\tif (state->args->whichfork == XFS_DATA_FORK)\n\t\tASSERT(newblk->blkno >= state->args->geo->leafblk &&\n\t\t       newblk->blkno < state->args->geo->freeblk);\n\n\t/*\n\t * We may need to make some room before we insert the new node.\n\t */\n\ttmp = 0;\n\tif (oldblk->index < nodehdr.count) {\n\t\ttmp = (nodehdr.count - oldblk->index) * (uint)sizeof(*btree);\n\t\tmemmove(&btree[oldblk->index + 1], &btree[oldblk->index], tmp);\n\t}\n\tbtree[oldblk->index].hashval = cpu_to_be32(newblk->hashval);\n\tbtree[oldblk->index].before = cpu_to_be32(newblk->blkno);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &btree[oldblk->index],\n\t\t\t\ttmp + sizeof(*btree)));\n\n\tnodehdr.count += 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the oldblk to propagate upwards.\n\t */\n\toldblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da3_node_add(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint\t\t\ttmp;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_add(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tASSERT(oldblk->index >= 0 && oldblk->index <= nodehdr.count);\n\tASSERT(newblk->blkno != 0);\n\tif (state->args->whichfork == XFS_DATA_FORK)\n\t\tASSERT(newblk->blkno >= state->args->geo->leafblk &&\n\t\t       newblk->blkno < state->args->geo->freeblk);\n\n\t/*\n\t * We may need to make some room before we insert the new node.\n\t */\n\ttmp = 0;\n\tif (oldblk->index < nodehdr.count) {\n\t\ttmp = (nodehdr.count - oldblk->index) * (uint)sizeof(*btree);\n\t\tmemmove(&btree[oldblk->index + 1], &btree[oldblk->index], tmp);\n\t}\n\tbtree[oldblk->index].hashval = cpu_to_be32(newblk->hashval);\n\tbtree[oldblk->index].before = cpu_to_be32(newblk->blkno);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &btree[oldblk->index],\n\t\t\t\ttmp + sizeof(*btree)));\n\n\tnodehdr.count += 1;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\txfs_trans_log_buf(state->args->trans, oldblk->bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t/*\n\t * Copy the last hash value from the oldblk to propagate upwards.\n\t */\n\toldblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_blk_link",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_blk_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1638-1726",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_rebalance",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_rebalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "729-867",
          "snippet": "STATIC void\nxfs_da3_node_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_intnode\t*tmpnode;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da_node_entry *btree_s;\n\tstruct xfs_da_node_entry *btree_d;\n\tstruct xfs_da3_icnode_hdr nodehdr1;\n\tstruct xfs_da3_icnode_hdr nodehdr2;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tcount;\n\tint\t\t\ttmp;\n\tint\t\t\tswap = 0;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_rebalance(state->args);\n\n\tnode1 = blk1->bp->b_addr;\n\tnode2 = blk2->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\t/*\n\t * Figure out how many entries need to move, and in which direction.\n\t * Swap the nodes around if that makes it simpler.\n\t */\n\tif (nodehdr1.count > 0 && nodehdr2.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[nodehdr2.count - 1].hashval) <\n\t\t\tbe32_to_cpu(btree1[nodehdr1.count - 1].hashval)))) {\n\t\ttmpnode = node1;\n\t\tnode1 = node2;\n\t\tnode2 = tmpnode;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t\tswap = 1;\n\t}\n\n\tcount = (nodehdr1.count - nodehdr2.count) / 2;\n\tif (count == 0)\n\t\treturn;\n\ttp = state->args->trans;\n\t/*\n\t * Two cases: high-to-low and low-to-high.\n\t */\n\tif (count > 0) {\n\t\t/*\n\t\t * Move elements in node2 up to make a hole.\n\t\t */\n\t\ttmp = nodehdr2.count;\n\t\tif (tmp > 0) {\n\t\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\t\tbtree_s = &btree2[0];\n\t\t\tbtree_d = &btree2[count];\n\t\t\tmemmove(btree_d, btree_s, tmp);\n\t\t}\n\n\t\t/*\n\t\t * Move the req'd B-tree elements from high in node1 to\n\t\t * low in node2.\n\t\t */\n\t\tnodehdr2.count += count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree1[nodehdr1.count - count];\n\t\tbtree_d = &btree2[0];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count -= count;\n\t} else {\n\t\t/*\n\t\t * Move the req'd B-tree elements from low in node2 to\n\t\t * high in node1.\n\t\t */\n\t\tcount = -count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[0];\n\t\tbtree_d = &btree1[nodehdr1.count];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count += count;\n\n\t\txfs_trans_log_buf(tp, blk1->bp,\n\t\t\tXFS_DA_LOGRANGE(node1, btree_d, tmp));\n\n\t\t/*\n\t\t * Move elements in node2 down to fill the hole.\n\t\t */\n\t\ttmp  = nodehdr2.count - count;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[count];\n\t\tbtree_d = &btree2[0];\n\t\tmemmove(btree_d, btree_s, tmp);\n\t\tnodehdr2.count -= count;\n\t}\n\n\t/*\n\t * Log header of node 1 and all current bits of node 2.\n\t */\n\tdp->d_ops->node_hdr_to_disk(node1, &nodehdr1);\n\txfs_trans_log_buf(tp, blk1->bp,\n\t\tXFS_DA_LOGRANGE(node1, &node1->hdr, dp->d_ops->node_hdr_size));\n\n\tdp->d_ops->node_hdr_to_disk(node2, &nodehdr2);\n\txfs_trans_log_buf(tp, blk2->bp,\n\t\tXFS_DA_LOGRANGE(node2, &node2->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count)));\n\n\t/*\n\t * Record the last hashval from each block for upward propagation.\n\t * (note: don't use the swapped node pointers)\n\t */\n\tif (swap) {\n\t\tnode1 = blk1->bp->b_addr;\n\t\tnode2 = blk2->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t}\n\tblk1->hashval = be32_to_cpu(btree1[nodehdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(btree2[nodehdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (blk1->index >= nodehdr1.count) {\n\t\tblk2->index = blk1->index - nodehdr1.count;\n\t\tblk1->index = nodehdr1.count + 1;\t/* make it invalid */\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da3_node_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_intnode\t*tmpnode;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da_node_entry *btree_s;\n\tstruct xfs_da_node_entry *btree_d;\n\tstruct xfs_da3_icnode_hdr nodehdr1;\n\tstruct xfs_da3_icnode_hdr nodehdr2;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\tcount;\n\tint\t\t\ttmp;\n\tint\t\t\tswap = 0;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_rebalance(state->args);\n\n\tnode1 = blk1->bp->b_addr;\n\tnode2 = blk2->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\t/*\n\t * Figure out how many entries need to move, and in which direction.\n\t * Swap the nodes around if that makes it simpler.\n\t */\n\tif (nodehdr1.count > 0 && nodehdr2.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[nodehdr2.count - 1].hashval) <\n\t\t\tbe32_to_cpu(btree1[nodehdr1.count - 1].hashval)))) {\n\t\ttmpnode = node1;\n\t\tnode1 = node2;\n\t\tnode2 = tmpnode;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t\tswap = 1;\n\t}\n\n\tcount = (nodehdr1.count - nodehdr2.count) / 2;\n\tif (count == 0)\n\t\treturn;\n\ttp = state->args->trans;\n\t/*\n\t * Two cases: high-to-low and low-to-high.\n\t */\n\tif (count > 0) {\n\t\t/*\n\t\t * Move elements in node2 up to make a hole.\n\t\t */\n\t\ttmp = nodehdr2.count;\n\t\tif (tmp > 0) {\n\t\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\t\tbtree_s = &btree2[0];\n\t\t\tbtree_d = &btree2[count];\n\t\t\tmemmove(btree_d, btree_s, tmp);\n\t\t}\n\n\t\t/*\n\t\t * Move the req'd B-tree elements from high in node1 to\n\t\t * low in node2.\n\t\t */\n\t\tnodehdr2.count += count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree1[nodehdr1.count - count];\n\t\tbtree_d = &btree2[0];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count -= count;\n\t} else {\n\t\t/*\n\t\t * Move the req'd B-tree elements from low in node2 to\n\t\t * high in node1.\n\t\t */\n\t\tcount = -count;\n\t\ttmp = count * (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[0];\n\t\tbtree_d = &btree1[nodehdr1.count];\n\t\tmemcpy(btree_d, btree_s, tmp);\n\t\tnodehdr1.count += count;\n\n\t\txfs_trans_log_buf(tp, blk1->bp,\n\t\t\tXFS_DA_LOGRANGE(node1, btree_d, tmp));\n\n\t\t/*\n\t\t * Move elements in node2 down to fill the hole.\n\t\t */\n\t\ttmp  = nodehdr2.count - count;\n\t\ttmp *= (uint)sizeof(xfs_da_node_entry_t);\n\t\tbtree_s = &btree2[count];\n\t\tbtree_d = &btree2[0];\n\t\tmemmove(btree_d, btree_s, tmp);\n\t\tnodehdr2.count -= count;\n\t}\n\n\t/*\n\t * Log header of node 1 and all current bits of node 2.\n\t */\n\tdp->d_ops->node_hdr_to_disk(node1, &nodehdr1);\n\txfs_trans_log_buf(tp, blk1->bp,\n\t\tXFS_DA_LOGRANGE(node1, &node1->hdr, dp->d_ops->node_hdr_size));\n\n\tdp->d_ops->node_hdr_to_disk(node2, &nodehdr2);\n\txfs_trans_log_buf(tp, blk2->bp,\n\t\tXFS_DA_LOGRANGE(node2, &node2->hdr,\n\t\t\t\tdp->d_ops->node_hdr_size +\n\t\t\t\t(sizeof(btree2[0]) * nodehdr2.count)));\n\n\t/*\n\t * Record the last hashval from each block for upward propagation.\n\t * (note: don't use the swapped node pointers)\n\t */\n\tif (swap) {\n\t\tnode1 = blk1->bp->b_addr;\n\t\tnode2 = blk2->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr1, node1);\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr2, node2);\n\t\tbtree1 = dp->d_ops->node_tree_p(node1);\n\t\tbtree2 = dp->d_ops->node_tree_p(node2);\n\t}\n\tblk1->hashval = be32_to_cpu(btree1[nodehdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(btree2[nodehdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (blk1->index >= nodehdr1.count) {\n\t\tblk2->index = blk1->index - nodehdr1.count;\n\t\tblk1->index = nodehdr1.count + 1;\t/* make it invalid */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_create",
          "args": [
            "state->args",
            "blkno",
            "treelevel",
            "&newblk->bp",
            "state->args->whichfork"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "295-339",
          "snippet": "int\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "state->args",
            "&blkno"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_split",
          "args": [
            "state->args"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nSTATIC int\t\t\t\t\t\t/* error */\nxfs_da3_node_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk,\n\tstruct xfs_da_state_blk\t*addblk,\n\tint\t\t\ttreelevel,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tnewcount;\n\tint\t\t\terror;\n\tint\t\t\tuseextra;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_split(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\n\t/*\n\t * With V2 dirs the extra block is data or freespace.\n\t */\n\tuseextra = state->extravalid && state->args->whichfork == XFS_ATTR_FORK;\n\tnewcount = 1 + useextra;\n\t/*\n\t * Do we have to split the node?\n\t */\n\tif (nodehdr.count + newcount > state->args->geo->node_ents) {\n\t\t/*\n\t\t * Allocate a new node, add to the doubly linked chain of\n\t\t * nodes, then move some of our excess entries into it.\n\t\t */\n\t\terror = xfs_da_grow_inode(state->args, &blkno);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\n\t\terror = xfs_da3_node_create(state->args, blkno, treelevel,\n\t\t\t\t\t   &newblk->bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\tnewblk->blkno = blkno;\n\t\tnewblk->magic = XFS_DA_NODE_MAGIC;\n\t\txfs_da3_node_rebalance(state, oldblk, newblk);\n\t\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*result = 1;\n\t} else {\n\t\t*result = 0;\n\t}\n\n\t/*\n\t * Insert the new entry(s) into the correct block\n\t * (updating last hashval in the process).\n\t *\n\t * xfs_da3_node_add() inserts BEFORE the given index,\n\t * and as a result of using node_lookup_int() we always\n\t * point to a valid entry (not after one), but a split\n\t * operation always results in a new block whose hashvals\n\t * FOLLOW the current block.\n\t *\n\t * If we had double-split op below us, then add the extra block too.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (oldblk->index <= nodehdr.count) {\n\t\toldblk->index++;\n\t\txfs_da3_node_add(state, oldblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\toldblk->index++;\n\t\t\txfs_da3_node_add(state, oldblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t} else {\n\t\tnewblk->index++;\n\t\txfs_da3_node_add(state, newblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\tnewblk->index++;\n\t\t\txfs_da3_node_add(state, newblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_root_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "501-627",
    "snippet": "STATIC int\t\t\t\t\t\t/* error */\nxfs_da3_root_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dir2_leaf\t*leaf;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tint\t\t\tsize;\n\n\ttrace_xfs_da_root_split(state->args);\n\n\t/*\n\t * Copy the existing (incorrect) block from the root node position\n\t * to a free space somewhere.\n\t */\n\targs = state->args;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\treturn error;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\tnode = bp->b_addr;\n\toldroot = blk1->bp->b_addr;\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, oldroot);\n\t\tbtree = dp->d_ops->node_tree_p(oldroot);\n\t\tsize = (int)((char *)&btree[nodehdr.count] - (char *)oldroot);\n\t\tlevel = nodehdr.level;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\t} else {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tleaf = (xfs_dir2_leaf_t *)oldroot;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\t\tsize = (int)((char *)&ents[leafhdr.count] - (char *)leaf);\n\t\tlevel = 0;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n\n\t/*\n\t * we can copy most of the information in the node from one block to\n\t * another, but for CRC enabled headers we have to make sure that the\n\t * block specific identifiers are kept intact. We update the buffer\n\t * directly for this.\n\t */\n\tmemcpy(node, oldroot, size);\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_da3_intnode *node3 = (struct xfs_da3_intnode *)node;\n\n\t\tnode3->hdr.info.blkno = cpu_to_be64(bp->b_bn);\n\t}\n\txfs_trans_log_buf(tp, bp, 0, size - 1);\n\n\tbp->b_ops = blk1->bp->b_ops;\n\txfs_trans_buf_copy_type(bp, blk1->bp);\n\tblk1->bp = bp;\n\tblk1->blkno = blkno;\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args,\n\t\t(args->whichfork == XFS_DATA_FORK) ? args->geo->leafblk : 0,\n\t\tlevel + 1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\tbtree[0].hashval = cpu_to_be32(blk1->hashval);\n\tbtree[0].before = cpu_to_be32(blk1->blkno);\n\tbtree[1].hashval = cpu_to_be32(blk2->hashval);\n\tbtree[1].before = cpu_to_be32(blk2->blkno);\n\tnodehdr.count = 2;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\n#ifdef DEBUG\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tASSERT(blk1->blkno >= args->geo->leafblk &&\n\t\t       blk1->blkno < args->geo->freeblk);\n\t\tASSERT(blk2->blkno >= args->geo->leafblk &&\n\t\t       blk2->blkno < args->geo->freeblk);\n\t}\n#endif\n\n\t/* Header is already logged by xfs_da_node_create */\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, btree, sizeof(xfs_da_node_entry_t) * 2));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "XFS_DA_LOGRANGE(node, btree, sizeof(xfs_da_node_entry_t) * 2)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "btree",
            "sizeof(xfs_da_node_entry_t) * 2"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk2->blkno >= args->geo->leafblk &&\n\t\t       blk2->blkno < args->geo->freeblk"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk1->blkno >= args->geo->leafblk &&\n\t\t       blk1->blkno < args->geo->freeblk"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node",
            "&nodehdr"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blk2->blkno"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blk2->hashval"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blk1->blkno"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "blk1->hashval"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "node"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_create",
          "args": [
            "args",
            "(args->whichfork == XFS_DATA_FORK) ? args->geo->leafblk : 0",
            "level + 1",
            "&bp",
            "args->whichfork"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "295-339",
          "snippet": "int\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_copy_type",
          "args": [
            "bp",
            "blk1->bp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_copy_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "748-759",
          "snippet": "void\nxfs_trans_buf_copy_type(\n\tstruct xfs_buf\t\t*dst_bp,\n\tstruct xfs_buf\t\t*src_bp)\n{\n\tstruct xfs_buf_log_item\t*sbip = src_bp->b_fspriv;\n\tstruct xfs_buf_log_item\t*dbip = dst_bp->b_fspriv;\n\tenum xfs_blft\t\ttype;\n\n\ttype = xfs_blft_from_flags(&sbip->__bli_format);\n\txfs_blft_to_flags(&dbip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_copy_type(\n\tstruct xfs_buf\t\t*dst_bp,\n\tstruct xfs_buf\t\t*src_bp)\n{\n\tstruct xfs_buf_log_item\t*sbip = src_bp->b_fspriv;\n\tstruct xfs_buf_log_item\t*dbip = dst_bp->b_fspriv;\n\tenum xfs_blft\t\ttype;\n\n\ttype = xfs_blft_from_flags(&sbip->__bli_format);\n\txfs_blft_to_flags(&dbip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "0",
            "size - 1"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA3_NODE_MAGIC"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node",
            "oldroot",
            "size"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DIR_LEAFN_BUF"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "oldroot"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&nodehdr",
            "oldroot"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA3_NODE_MAGIC"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA_NODE_MAGIC"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "tp",
            "dp",
            "blkno",
            "-1",
            "&bp",
            "args->whichfork"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "args",
            "&blkno"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_root_split",
          "args": [
            "state->args"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t\t/* error */\nxfs_da3_root_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dir2_leaf\t*leaf;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tint\t\t\tsize;\n\n\ttrace_xfs_da_root_split(state->args);\n\n\t/*\n\t * Copy the existing (incorrect) block from the root node position\n\t * to a free space somewhere.\n\t */\n\targs = state->args;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\treturn error;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\tnode = bp->b_addr;\n\toldroot = blk1->bp->b_addr;\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, oldroot);\n\t\tbtree = dp->d_ops->node_tree_p(oldroot);\n\t\tsize = (int)((char *)&btree[nodehdr.count] - (char *)oldroot);\n\t\tlevel = nodehdr.level;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\t} else {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tleaf = (xfs_dir2_leaf_t *)oldroot;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\t\tsize = (int)((char *)&ents[leafhdr.count] - (char *)leaf);\n\t\tlevel = 0;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n\n\t/*\n\t * we can copy most of the information in the node from one block to\n\t * another, but for CRC enabled headers we have to make sure that the\n\t * block specific identifiers are kept intact. We update the buffer\n\t * directly for this.\n\t */\n\tmemcpy(node, oldroot, size);\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_da3_intnode *node3 = (struct xfs_da3_intnode *)node;\n\n\t\tnode3->hdr.info.blkno = cpu_to_be64(bp->b_bn);\n\t}\n\txfs_trans_log_buf(tp, bp, 0, size - 1);\n\n\tbp->b_ops = blk1->bp->b_ops;\n\txfs_trans_buf_copy_type(bp, blk1->bp);\n\tblk1->bp = bp;\n\tblk1->blkno = blkno;\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args,\n\t\t(args->whichfork == XFS_DATA_FORK) ? args->geo->leafblk : 0,\n\t\tlevel + 1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\tbtree[0].hashval = cpu_to_be32(blk1->hashval);\n\tbtree[0].before = cpu_to_be32(blk1->blkno);\n\tbtree[1].hashval = cpu_to_be32(blk2->hashval);\n\tbtree[1].before = cpu_to_be32(blk2->blkno);\n\tnodehdr.count = 2;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\n#ifdef DEBUG\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tASSERT(blk1->blkno >= args->geo->leafblk &&\n\t\t       blk1->blkno < args->geo->freeblk);\n\t\tASSERT(blk2->blkno >= args->geo->leafblk &&\n\t\t       blk2->blkno < args->geo->freeblk);\n\t}\n#endif\n\n\t/* Header is already logged by xfs_da_node_create */\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, btree, sizeof(xfs_da_node_entry_t) * 2));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "345-494",
    "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\t/*\n\t * Walk back up the tree splitting/inserting/adjusting as necessary.\n\t * If we need to insert and there isn't room, split the node, then\n\t * decide which fragment to insert the new block from below into.\n\t * Note that we may split the root this way, but we need more fixup.\n\t */\n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t/* initial dummy value */\n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t/*\n\t\t * If a leaf node then\n\t\t *     Allocate a new leaf node, then rebalance across them.\n\t\t * else if an intermediate node then\n\t\t *     We split on the last layer, must we split the node?\n\t\t */\n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t/* GROT: attr is inconsistent */\n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Entry wouldn't fit, split the leaf again.\n\t\t\t */\n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t/* before newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t/* after newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: attr inconsistent */\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\t\t/*\n\t\t\t * Record the newly split block for the next time thru?\n\t\t\t */\n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Update the btree to show the new hashval for this child.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t/*\n\t * Split the root node.\n\t */\n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error) {\n\t\taddblk->bp = NULL;\n\t\treturn error;\t/* GROT: dir is inconsistent */\n\t}\n\n\t/*\n\t * Update pointers to the node which used to be block 0 and\n\t * just got bumped because of the addition of a new root node.\n\t * There might be three blocks involved if a double split occurred,\n\t * and the original block 0 could be at any position in the list.\n\t *\n\t * Note: the magic numbers and sibling pointers are in the same\n\t * physical place for both v2 and v3 headers (by design). Hence it\n\t * doesn't matter which version of the xfs_da_intnode structure we use\n\t * here as the result will be the same using either structure.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\taddblk->bp = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "bp",
            "XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info))"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&node->hdr.info",
            "sizeof(node->hdr.info)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oldblk->blkno"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->extravalid"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "node->hdr.info.back"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "state->args->trans",
            "bp",
            "XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info))"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&node->hdr.info",
            "sizeof(node->hdr.info)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "oldblk->blkno"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->extravalid"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "node->hdr.info.forw"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_root_split",
          "args": [
            "state",
            "oldblk",
            "addblk"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_root_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "501-627",
          "snippet": "STATIC int\t\t\t\t\t\t/* error */\nxfs_da3_root_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dir2_leaf\t*leaf;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tint\t\t\tsize;\n\n\ttrace_xfs_da_root_split(state->args);\n\n\t/*\n\t * Copy the existing (incorrect) block from the root node position\n\t * to a free space somewhere.\n\t */\n\targs = state->args;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\treturn error;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\tnode = bp->b_addr;\n\toldroot = blk1->bp->b_addr;\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, oldroot);\n\t\tbtree = dp->d_ops->node_tree_p(oldroot);\n\t\tsize = (int)((char *)&btree[nodehdr.count] - (char *)oldroot);\n\t\tlevel = nodehdr.level;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\t} else {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tleaf = (xfs_dir2_leaf_t *)oldroot;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\t\tsize = (int)((char *)&ents[leafhdr.count] - (char *)leaf);\n\t\tlevel = 0;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n\n\t/*\n\t * we can copy most of the information in the node from one block to\n\t * another, but for CRC enabled headers we have to make sure that the\n\t * block specific identifiers are kept intact. We update the buffer\n\t * directly for this.\n\t */\n\tmemcpy(node, oldroot, size);\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_da3_intnode *node3 = (struct xfs_da3_intnode *)node;\n\n\t\tnode3->hdr.info.blkno = cpu_to_be64(bp->b_bn);\n\t}\n\txfs_trans_log_buf(tp, bp, 0, size - 1);\n\n\tbp->b_ops = blk1->bp->b_ops;\n\txfs_trans_buf_copy_type(bp, blk1->bp);\n\tblk1->bp = bp;\n\tblk1->blkno = blkno;\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args,\n\t\t(args->whichfork == XFS_DATA_FORK) ? args->geo->leafblk : 0,\n\t\tlevel + 1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\tbtree[0].hashval = cpu_to_be32(blk1->hashval);\n\tbtree[0].before = cpu_to_be32(blk1->blkno);\n\tbtree[1].hashval = cpu_to_be32(blk2->hashval);\n\tbtree[1].before = cpu_to_be32(blk2->blkno);\n\tnodehdr.count = 2;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\n#ifdef DEBUG\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tASSERT(blk1->blkno >= args->geo->leafblk &&\n\t\t       blk1->blkno < args->geo->freeblk);\n\t\tASSERT(blk2->blkno >= args->geo->leafblk &&\n\t\t       blk2->blkno < args->geo->freeblk);\n\t}\n#endif\n\n\t/* Header is already logged by xfs_da_node_create */\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, btree, sizeof(xfs_da_node_entry_t) * 2));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t\t/* error */\nxfs_da3_root_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_intnode\t*oldroot;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*dp;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dir2_leaf\t*leaf;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tint\t\t\tsize;\n\n\ttrace_xfs_da_root_split(state->args);\n\n\t/*\n\t * Copy the existing (incorrect) block from the root node position\n\t * to a free space somewhere.\n\t */\n\targs = state->args;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\treturn error;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\tnode = bp->b_addr;\n\toldroot = blk1->bp->b_addr;\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC)) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, oldroot);\n\t\tbtree = dp->d_ops->node_tree_p(oldroot);\n\t\tsize = (int)((char *)&btree[nodehdr.count] - (char *)oldroot);\n\t\tlevel = nodehdr.level;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\t} else {\n\t\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\n\t\tleaf = (xfs_dir2_leaf_t *)oldroot;\n\t\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\t\tsize = (int)((char *)&ents[leafhdr.count] - (char *)leaf);\n\t\tlevel = 0;\n\n\t\t/*\n\t\t * we are about to copy oldroot to bp, so set up the type\n\t\t * of bp while we know exactly what it will be.\n\t\t */\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n\n\t/*\n\t * we can copy most of the information in the node from one block to\n\t * another, but for CRC enabled headers we have to make sure that the\n\t * block specific identifiers are kept intact. We update the buffer\n\t * directly for this.\n\t */\n\tmemcpy(node, oldroot, size);\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tstruct xfs_da3_intnode *node3 = (struct xfs_da3_intnode *)node;\n\n\t\tnode3->hdr.info.blkno = cpu_to_be64(bp->b_bn);\n\t}\n\txfs_trans_log_buf(tp, bp, 0, size - 1);\n\n\tbp->b_ops = blk1->bp->b_ops;\n\txfs_trans_buf_copy_type(bp, blk1->bp);\n\tblk1->bp = bp;\n\tblk1->blkno = blkno;\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args,\n\t\t(args->whichfork == XFS_DATA_FORK) ? args->geo->leafblk : 0,\n\t\tlevel + 1, &bp, args->whichfork);\n\tif (error)\n\t\treturn error;\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\tbtree[0].hashval = cpu_to_be32(blk1->hashval);\n\tbtree[0].before = cpu_to_be32(blk1->blkno);\n\tbtree[1].hashval = cpu_to_be32(blk2->hashval);\n\tbtree[1].before = cpu_to_be32(blk2->blkno);\n\tnodehdr.count = 2;\n\tdp->d_ops->node_hdr_to_disk(node, &nodehdr);\n\n#ifdef DEBUG\n\tif (oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t    oldroot->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)) {\n\t\tASSERT(blk1->blkno >= args->geo->leafblk &&\n\t\t       blk1->blkno < args->geo->freeblk);\n\t\tASSERT(blk2->blkno >= args->geo->leafblk &&\n\t\t       blk2->blkno < args->geo->freeblk);\n\t}\n#endif\n\n\t/* Header is already logged by xfs_da_node_create */\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, btree, sizeof(xfs_da_node_entry_t) * 2));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->path.active == 0"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_fixhashpath",
          "args": [
            "state",
            "&state->path"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_fixhashpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1256-1306",
          "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_split",
          "args": [
            "state",
            "oldblk",
            "newblk",
            "addblk",
            "max - i",
            "&action"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "632-721",
          "snippet": "STATIC int\t\t\t\t\t\t/* error */\nxfs_da3_node_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk,\n\tstruct xfs_da_state_blk\t*addblk,\n\tint\t\t\ttreelevel,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tnewcount;\n\tint\t\t\terror;\n\tint\t\t\tuseextra;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_split(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\n\t/*\n\t * With V2 dirs the extra block is data or freespace.\n\t */\n\tuseextra = state->extravalid && state->args->whichfork == XFS_ATTR_FORK;\n\tnewcount = 1 + useextra;\n\t/*\n\t * Do we have to split the node?\n\t */\n\tif (nodehdr.count + newcount > state->args->geo->node_ents) {\n\t\t/*\n\t\t * Allocate a new node, add to the doubly linked chain of\n\t\t * nodes, then move some of our excess entries into it.\n\t\t */\n\t\terror = xfs_da_grow_inode(state->args, &blkno);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\n\t\terror = xfs_da3_node_create(state->args, blkno, treelevel,\n\t\t\t\t\t   &newblk->bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\tnewblk->blkno = blkno;\n\t\tnewblk->magic = XFS_DA_NODE_MAGIC;\n\t\txfs_da3_node_rebalance(state, oldblk, newblk);\n\t\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*result = 1;\n\t} else {\n\t\t*result = 0;\n\t}\n\n\t/*\n\t * Insert the new entry(s) into the correct block\n\t * (updating last hashval in the process).\n\t *\n\t * xfs_da3_node_add() inserts BEFORE the given index,\n\t * and as a result of using node_lookup_int() we always\n\t * point to a valid entry (not after one), but a split\n\t * operation always results in a new block whose hashvals\n\t * FOLLOW the current block.\n\t *\n\t * If we had double-split op below us, then add the extra block too.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (oldblk->index <= nodehdr.count) {\n\t\toldblk->index++;\n\t\txfs_da3_node_add(state, oldblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\toldblk->index++;\n\t\t\txfs_da3_node_add(state, oldblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t} else {\n\t\tnewblk->index++;\n\t\txfs_da3_node_add(state, newblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\tnewblk->index++;\n\t\t\txfs_da3_node_add(state, newblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nSTATIC int\t\t\t\t\t\t/* error */\nxfs_da3_node_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk,\n\tstruct xfs_da_state_blk\t*addblk,\n\tint\t\t\ttreelevel,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tnewcount;\n\tint\t\t\terror;\n\tint\t\t\tuseextra;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_node_split(state->args);\n\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\n\t/*\n\t * With V2 dirs the extra block is data or freespace.\n\t */\n\tuseextra = state->extravalid && state->args->whichfork == XFS_ATTR_FORK;\n\tnewcount = 1 + useextra;\n\t/*\n\t * Do we have to split the node?\n\t */\n\tif (nodehdr.count + newcount > state->args->geo->node_ents) {\n\t\t/*\n\t\t * Allocate a new node, add to the doubly linked chain of\n\t\t * nodes, then move some of our excess entries into it.\n\t\t */\n\t\terror = xfs_da_grow_inode(state->args, &blkno);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\n\t\terror = xfs_da3_node_create(state->args, blkno, treelevel,\n\t\t\t\t\t   &newblk->bp, state->args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\tnewblk->blkno = blkno;\n\t\tnewblk->magic = XFS_DA_NODE_MAGIC;\n\t\txfs_da3_node_rebalance(state, oldblk, newblk);\n\t\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*result = 1;\n\t} else {\n\t\t*result = 0;\n\t}\n\n\t/*\n\t * Insert the new entry(s) into the correct block\n\t * (updating last hashval in the process).\n\t *\n\t * xfs_da3_node_add() inserts BEFORE the given index,\n\t * and as a result of using node_lookup_int() we always\n\t * point to a valid entry (not after one), but a split\n\t * operation always results in a new block whose hashvals\n\t * FOLLOW the current block.\n\t *\n\t * If we had double-split op below us, then add the extra block too.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\tif (oldblk->index <= nodehdr.count) {\n\t\toldblk->index++;\n\t\txfs_da3_node_add(state, oldblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\toldblk->index++;\n\t\t\txfs_da3_node_add(state, oldblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t} else {\n\t\tnewblk->index++;\n\t\txfs_da3_node_add(state, newblk, addblk);\n\t\tif (useextra) {\n\t\t\tif (state->extraafter)\n\t\t\t\tnewblk->index++;\n\t\t\txfs_da3_node_add(state, newblk, &state->extrablk);\n\t\t\tstate->extravalid = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_split",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1307-1362",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_split(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*oldblk,\t/* original block */\n\txfs_da_state_blk_t\t*newblk)\t/* newly created block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dablk_t\t\tblkno;\t\t/* new leaf block number */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_inode\t*dp;\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\targs = state->args;\n\tdp = args->dp;\n\tASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the new leaf block.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, xfs_dir2_da_to_db(args->geo, blkno),\n\t\t\t\t      &newblk->bp, XFS_DIR2_LEAFN_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t/*\n\t * Rebalance the entries across the two leaves, link the new\n\t * block into the leaves.\n\t */\n\txfs_dir2_leafn_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Insert the new entry in the correct block.\n\t */\n\tif (state->inleaf)\n\t\terror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\n\telse\n\t\terror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_dir2_leafn_lasthash(dp, oldblk->bp, NULL);\n\tnewblk->hashval = xfs_dir2_leafn_lasthash(dp, newblk->bp, NULL);\n\txfs_dir3_leaf_check(dp, oldblk->bp);\n\txfs_dir3_leaf_check(dp, newblk->bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_split(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*oldblk,\t/* original block */\n\txfs_da_state_blk_t\t*newblk)\t/* newly created block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dablk_t\t\tblkno;\t\t/* new leaf block number */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_inode\t*dp;\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\targs = state->args;\n\tdp = args->dp;\n\tASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the new leaf block.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, xfs_dir2_da_to_db(args->geo, blkno),\n\t\t\t\t      &newblk->bp, XFS_DIR2_LEAFN_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t/*\n\t * Rebalance the entries across the two leaves, link the new\n\t * block into the leaves.\n\t */\n\txfs_dir2_leafn_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Insert the new entry in the correct block.\n\t */\n\tif (state->inleaf)\n\t\terror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\n\telse\n\t\terror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_dir2_leafn_lasthash(dp, oldblk->bp, NULL);\n\tnewblk->hashval = xfs_dir2_leafn_lasthash(dp, newblk->bp, NULL);\n\txfs_dir3_leaf_check(dp, oldblk->bp);\n\txfs_dir3_leaf_check(dp, newblk->bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_split",
          "args": [
            "state",
            "newblk",
            "&state->extrablk"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1001-1055",
          "snippet": "int\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t/*\n\t * Rebalance the entries across the two leaves.\n\t * NOTE: rebalance() currently depends on the 2nd block being empty.\n\t */\n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Save info on \"old\" attribute for \"atomic rename\" ops, leaf_add()\n\t * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the\n\t * \"new\" attrs info.  Will need the \"old\" info to remove it later.\n\t *\n\t * Insert the \"new\" entry in the correct block.\n\t */\n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t/*\n\t * Rebalance the entries across the two leaves.\n\t * NOTE: rebalance() currently depends on the 2nd block being empty.\n\t */\n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Save info on \"old\" attribute for \"atomic rename\" ops, leaf_add()\n\t * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the\n\t * \"new\" attrs info.  Will need the \"old\" info to remove it later.\n\t *\n\t * Insert the \"new\" entry in the correct block.\n\t */\n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_split_after",
          "args": [
            "state->args"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_split_before",
          "args": [
            "state->args"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(max >= 0) && (max < XFS_DA_NODE_MAXDEPTH)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_split",
          "args": [
            "state->args"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\t/*\n\t * Walk back up the tree splitting/inserting/adjusting as necessary.\n\t * If we need to insert and there isn't room, split the node, then\n\t * decide which fragment to insert the new block from below into.\n\t * Note that we may split the root this way, but we need more fixup.\n\t */\n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t/* initial dummy value */\n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t/*\n\t\t * If a leaf node then\n\t\t *     Allocate a new leaf node, then rebalance across them.\n\t\t * else if an intermediate node then\n\t\t *     We split on the last layer, must we split the node?\n\t\t */\n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t/* GROT: attr is inconsistent */\n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Entry wouldn't fit, split the leaf again.\n\t\t\t */\n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t/* before newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t/* after newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: attr inconsistent */\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\t\t/*\n\t\t\t * Record the newly split block for the next time thru?\n\t\t\t */\n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Update the btree to show the new hashval for this child.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t/*\n\t * Split the root node.\n\t */\n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error) {\n\t\taddblk->bp = NULL;\n\t\treturn error;\t/* GROT: dir is inconsistent */\n\t}\n\n\t/*\n\t * Update pointers to the node which used to be block 0 and\n\t * just got bumped because of the addition of a new root node.\n\t * There might be three blocks involved if a double split occurred,\n\t * and the original block 0 could be at any position in the list.\n\t *\n\t * Note: the magic numbers and sibling pointers are in the same\n\t * physical place for both v2 and v3 headers (by design). Hence it\n\t * doesn't matter which version of the xfs_da_intnode structure we use\n\t * here as the result will be the same using either structure.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\taddblk->bp = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_node_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "295-339",
    "snippet": "int\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "XFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DA_LOGRANGE",
          "args": [
            "node",
            "&node->hdr",
            "dp->d_ops->node_hdr_size"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_to_disk",
          "args": [
            "node",
            "&ichdr"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&hdr3->info.uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args->dp->i_ino"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DA_NODE_BUF"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "tp",
            "dp",
            "blkno",
            "-1",
            "&bp",
            "whichfork"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level <= XFS_DA_NODE_MAXDEPTH"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_da_node_create",
          "args": [
            "args"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tlevel,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_da3_icnode_hdr ichdr = {0};\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\ttrace_xfs_da_node_create(args);\n\tASSERT(level <= XFS_DA_NODE_MAXDEPTH);\n\n\terror = xfs_da_get_buf(tp, dp, blkno, -1, &bp, whichfork);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_da3_node_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DA_NODE_BUF);\n\tnode = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_DA3_NODE_MAGIC;\n\t\thdr3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->info.owner = cpu_to_be64(args->dp->i_ino);\n\t\tuuid_copy(&hdr3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tichdr.magic = XFS_DA_NODE_MAGIC;\n\t}\n\tichdr.level = level;\n\n\tdp->d_ops->node_hdr_to_disk(node, &ichdr);\n\txfs_trans_log_buf(tp, bp,\n\t\tXFS_DA_LOGRANGE(node, &node->hdr, dp->d_ops->node_hdr_size));\n\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_da3_node_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "248-286",
    "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "type"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "info->magic"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "bno",
            "mappedbno",
            "bpp",
            "which_fork",
            "&xfs_da3_node_buf_ops"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_da3_node_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "206-241",
    "snippet": "static void\nxfs_da3_node_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tif (!xfs_buf_verify_cksum(bp, XFS_DA3_NODE_CRC_OFF)) {\n\t\t\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tif (!xfs_da3_node_verify(bp)) {\n\t\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\treturn;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* corrupt block */\n\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp->b_ops->verify_read",
          "args": [
            "bp"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bp->b_ops->verify_read",
          "args": [
            "bp"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_verify",
          "args": [
            "bp"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "130-175",
          "snippet": "static bool\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tconst struct xfs_dir_ops *ops;\n\n\tops = xfs_dir_get_ops(mp, NULL);\n\n\tops->node_hdr_from_disk(&ichdr, hdr);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_DA3_NODE_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_DA_NODE_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.level == 0)\n\t\treturn false;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn false;\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/*\n\t * we don't know if the node is for and attribute or directory tree,\n\t * so only fail if the count is outside both bounds\n\t */\n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn false;\n\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tconst struct xfs_dir_ops *ops;\n\n\tops = xfs_dir_get_ops(mp, NULL);\n\n\tops->node_hdr_from_disk(&ichdr, hdr);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_DA3_NODE_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_DA_NODE_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.level == 0)\n\t\treturn false;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn false;\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/*\n\t * we don't know if the node is for and attribute or directory tree,\n\t * so only fail if the count is outside both bounds\n\t */\n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn false;\n\n\t/* XXX: hash order check? */\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_DA3_NODE_CRC_OFF"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "info->magic"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_da3_node_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_da_blkinfo\t*info = bp->b_addr;\n\n\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tif (!xfs_buf_verify_cksum(bp, XFS_DA3_NODE_CRC_OFF)) {\n\t\t\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tif (!xfs_da3_node_verify(bp)) {\n\t\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\treturn;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\t\tbp->b_ops->verify_read(bp);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* corrupt block */\n\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_da3_node_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "177-198",
    "snippet": "static void\nxfs_da3_node_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_da3_node_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DA3_NODE_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_DA3_NODE_CRC_OFF"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_verify",
          "args": [
            "bp"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "130-175",
          "snippet": "static bool\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tconst struct xfs_dir_ops *ops;\n\n\tops = xfs_dir_get_ops(mp, NULL);\n\n\tops->node_hdr_from_disk(&ichdr, hdr);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_DA3_NODE_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_DA_NODE_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.level == 0)\n\t\treturn false;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn false;\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/*\n\t * we don't know if the node is for and attribute or directory tree,\n\t * so only fail if the count is outside both bounds\n\t */\n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn false;\n\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tconst struct xfs_dir_ops *ops;\n\n\tops = xfs_dir_get_ops(mp, NULL);\n\n\tops->node_hdr_from_disk(&ichdr, hdr);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_DA3_NODE_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_DA_NODE_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.level == 0)\n\t\treturn false;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn false;\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/*\n\t * we don't know if the node is for and attribute or directory tree,\n\t * so only fail if the count is outside both bounds\n\t */\n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn false;\n\n\t/* XXX: hash order check? */\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_da3_node_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_da3_node_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DA3_NODE_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_da3_node_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "130-175",
    "snippet": "static bool\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tconst struct xfs_dir_ops *ops;\n\n\tops = xfs_dir_get_ops(mp, NULL);\n\n\tops->node_hdr_from_disk(&ichdr, hdr);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_DA3_NODE_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_DA_NODE_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.level == 0)\n\t\treturn false;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn false;\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/*\n\t * we don't know if the node is for and attribute or directory tree,\n\t * so only fail if the count is outside both bounds\n\t */\n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn false;\n\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "hdr3->info.blkno"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&hdr3->info.uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->node_hdr_from_disk",
          "args": [
            "&ichdr",
            "hdr"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_get_ops",
          "args": [
            "mp",
            "NULL"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_get_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.c",
          "lines": "880-894",
          "snippet": "const struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}",
          "includes": [
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};\n\nconst struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_da3_node_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_da_intnode\t*hdr = bp->b_addr;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\tconst struct xfs_dir_ops *ops;\n\n\tops = xfs_dir_get_ops(mp, NULL);\n\n\tops->node_hdr_from_disk(&ichdr, hdr);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_DA3_NODE_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_DA_NODE_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.level == 0)\n\t\treturn false;\n\tif (ichdr.level > XFS_DA_NODE_MAXDEPTH)\n\t\treturn false;\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/*\n\t * we don't know if the node is for and attribute or directory tree,\n\t * so only fail if the count is outside both bounds\n\t */\n\tif (ichdr.count > mp->m_dir_geo->node_ents &&\n\t    ichdr.count > mp->m_attr_geo->node_ents)\n\t\treturn false;\n\n\t/* XXX: hash order check? */\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_da_state_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "120-128",
    "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t *xfs_da_state_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_da_state_zone",
            "state"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)state",
            "0",
            "sizeof(*state)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_state_kill_altpath",
          "args": [
            "state"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_kill_altpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "107-115",
          "snippet": "STATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
  },
  {
    "function_name": "xfs_da_state_kill_altpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "107-115",
    "snippet": "STATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_da_state_kill_altpath(xfs_da_state_t *state)\n{\n\tint\ti;\n\n\tfor (i = 0; i < state->altpath.active; i++)\n\t\tstate->altpath.blk[i].bp = NULL;\n\tstate->altpath.active = 0;\n}"
  },
  {
    "function_name": "xfs_da_state_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
    "lines": "98-102",
    "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
    "includes": [
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t *xfs_da_state_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_da_state_zone",
            "KM_NOFS"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
  }
]