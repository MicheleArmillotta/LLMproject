[
  {
    "function_name": "ff_layout_has_available_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "527-543",
    "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff_layout_test_devid_unavailable",
          "args": [
            "devid"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_test_devid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "116-120",
          "snippet": "static inline bool\nff_layout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn nfs4_test_deviceid_unavailable(node);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline bool\nff_layout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn nfs4_test_deviceid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_MIRROR_COUNT",
          "args": [
            "lseg"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_MIRROR_COUNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "110-114",
          "snippet": "static inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "ff_layout_encode_ds_ioerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "490-525",
    "snippet": "int ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct xdr_stream *xdr, int *count,\n\t\t\t      const struct pnfs_layout_range *range)\n{\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\t__be32 *p;\n\n\tlist_for_each_entry_safe(err, n, &flo->error_list, list) {\n\t\tif (!is_range_intersecting(err->offset, err->length,\n\t\t\t\t\t   range->offset, range->length))\n\t\t\tcontinue;\n\t\t/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)\n\t\t * + deviceid(NFS4_DEVICEID4_SIZE) + status(4) + opnum(4)\n\t\t */\n\t\tp = xdr_reserve_space(xdr,\n\t\t\t\t24 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOBUFS;\n\t\tp = xdr_encode_hyper(p, err->offset);\n\t\tp = xdr_encode_hyper(p, err->length);\n\t\tp = xdr_encode_opaque_fixed(p, &err->stateid,\n\t\t\t\t\t    NFS4_STATEID_SIZE);\n\t\tp = xdr_encode_opaque_fixed(p, &err->deviceid,\n\t\t\t\t\t    NFS4_DEVICEID4_SIZE);\n\t\t*p++ = cpu_to_be32(err->status);\n\t\t*p++ = cpu_to_be32(err->opnum);\n\t\t*count += 1;\n\t\tlist_del(&err->list);\n\t\tdprintk(\"%s: offset %llu length %llu status %d op %d count %d\\n\",\n\t\t\t__func__, err->offset, err->length, err->status,\n\t\t\terr->opnum, *count);\n\t\tkfree(err);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "err"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: offset %llu length %llu status %d op %d count %d\\n\"",
            "__func__",
            "err->offset",
            "err->length",
            "err->status",
            "err->opnum",
            "*count"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&err->list"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "err->opnum"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "err->status"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&err->deviceid",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&err->stateid",
            "NFS4_STATEID_SIZE"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "err->length"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "err->offset"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "24 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_range_intersecting",
          "args": [
            "err->offset",
            "err->length",
            "range->offset",
            "range->length"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "is_range_intersecting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "479-487",
          "snippet": "static bool is_range_intersecting(u64 offset1, u64 length1,\n\t\t\t\t  u64 offset2, u64 length2)\n{\n\tu64 end1 = end_offset(offset1, length1);\n\tu64 end2 = end_offset(offset2, length2);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > offset2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > offset1);\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool is_range_intersecting(u64 offset1, u64 length1,\n\t\t\t\t  u64 offset2, u64 length2)\n{\n\tu64 end1 = end_offset(offset1, length1);\n\tu64 end2 = end_offset(offset2, length2);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > offset2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > offset1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "err",
            "n",
            "&flo->error_list",
            "list"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nint ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct xdr_stream *xdr, int *count,\n\t\t\t      const struct pnfs_layout_range *range)\n{\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\t__be32 *p;\n\n\tlist_for_each_entry_safe(err, n, &flo->error_list, list) {\n\t\tif (!is_range_intersecting(err->offset, err->length,\n\t\t\t\t\t   range->offset, range->length))\n\t\t\tcontinue;\n\t\t/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)\n\t\t * + deviceid(NFS4_DEVICEID4_SIZE) + status(4) + opnum(4)\n\t\t */\n\t\tp = xdr_reserve_space(xdr,\n\t\t\t\t24 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOBUFS;\n\t\tp = xdr_encode_hyper(p, err->offset);\n\t\tp = xdr_encode_hyper(p, err->length);\n\t\tp = xdr_encode_opaque_fixed(p, &err->stateid,\n\t\t\t\t\t    NFS4_STATEID_SIZE);\n\t\tp = xdr_encode_opaque_fixed(p, &err->deviceid,\n\t\t\t\t\t    NFS4_DEVICEID4_SIZE);\n\t\t*p++ = cpu_to_be32(err->status);\n\t\t*p++ = cpu_to_be32(err->opnum);\n\t\t*count += 1;\n\t\tlist_del(&err->list);\n\t\tdprintk(\"%s: offset %llu length %llu status %d op %d count %d\\n\",\n\t\t\t__func__, err->offset, err->length, err->status,\n\t\t\terr->opnum, *count);\n\t\tkfree(err);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_range_intersecting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "479-487",
    "snippet": "static bool is_range_intersecting(u64 offset1, u64 length1,\n\t\t\t\t  u64 offset2, u64 length2)\n{\n\tu64 end1 = end_offset(offset1, length1);\n\tu64 end2 = end_offset(offset2, length2);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > offset2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > offset1);\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "offset2",
            "length2"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "175-182",
          "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool is_range_intersecting(u64 offset1, u64 length1,\n\t\t\t\t  u64 offset2, u64 length2)\n{\n\tu64 end1 = end_offset(offset1, length1);\n\tu64 end2 = end_offset(offset2, length2);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > offset2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > offset1);\n}"
  },
  {
    "function_name": "nfs4_ff_find_or_create_ds_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "462-477",
    "snippet": "struct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_find_or_create_ds_client",
          "args": [
            "ds_clp",
            "inode"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "124-141",
          "snippet": "struct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "lseg",
            "ds_idx"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "ff_layout_get_ds_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "440-456",
    "snippet": "struct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_ff_layout_prepare_ds",
          "args": [
            "lseg",
            "ds_idx",
            "true"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "358-438",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "lseg",
            "ds_idx"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}"
  },
  {
    "function_name": "nfs4_ff_layout_prepare_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "358-438",
    "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
      "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff_layout_update_mirror_cred",
          "args": [
            "mirror",
            "ds"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_update_mirror_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "308-331",
          "snippet": "static int ff_layout_update_mirror_cred(struct nfs4_ff_layout_mirror *mirror,\n\t\t\t\t      struct nfs4_pnfs_ds *ds)\n{\n\tif (ds->ds_clp && !mirror->cred &&\n\t    mirror->mirror_ds->ds_versions[0].version == 3) {\n\t\tstruct rpc_auth *auth = ds->ds_clp->cl_rpcclient->cl_auth;\n\t\tstruct rpc_cred *cred;\n\t\tstruct auth_cred acred = {\n\t\t\t.uid = make_kuid(&init_user_ns, mirror->uid),\n\t\t\t.gid = make_kgid(&init_user_ns, mirror->gid),\n\t\t};\n\n\t\t/* AUTH_NULL ignores acred */\n\t\tcred = auth->au_ops->lookup_cred(auth, &acred, 0);\n\t\tif (IS_ERR(cred)) {\n\t\t\tdprintk(\"%s: lookup_cred failed with %ld\\n\",\n\t\t\t\t__func__, PTR_ERR(cred));\n\t\t\treturn PTR_ERR(cred);\n\t\t} else {\n\t\t\tmirror->cred = cred;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_update_mirror_cred(struct nfs4_ff_layout_mirror *mirror,\n\t\t\t\t      struct nfs4_pnfs_ds *ds)\n{\n\tif (ds->ds_clp && !mirror->cred &&\n\t    mirror->mirror_ds->ds_versions[0].version == 3) {\n\t\tstruct rpc_auth *auth = ds->ds_clp->cl_rpcclient->cl_auth;\n\t\tstruct rpc_cred *cred;\n\t\tstruct auth_cred acred = {\n\t\t\t.uid = make_kuid(&init_user_ns, mirror->uid),\n\t\t\t.gid = make_kgid(&init_user_ns, mirror->gid),\n\t\t};\n\n\t\t/* AUTH_NULL ignores acred */\n\t\tcred = auth->au_ops->lookup_cred(auth, &acred, 0);\n\t\tif (IS_ERR(cred)) {\n\t\t\tdprintk(\"%s: lookup_cred failed with %ld\\n\",\n\t\t\t\t__func__, PTR_ERR(cred));\n\t\t\treturn PTR_ERR(cred);\n\t\t} else {\n\t\t\tmirror->cred = cred;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_retry_layoutget",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "370-377",
          "snippet": "static inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_error_mark_layout_for_return",
          "args": [
            "ino",
            "lseg"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_error_mark_layout_for_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1679-1707",
          "snippet": "void pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LAYOUT_RETURN_BEFORE_CLOSE",
            "&lseg->pls_layout->plh_flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_has_available_ds",
          "args": [
            "lseg"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_available_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "527-543",
          "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_set_retry_layoutget",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "364-368",
          "snippet": "static inline void pnfs_set_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (!test_and_set_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_set_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (!test_and_set_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_track_ds_error",
          "args": [
            "FF_LAYOUT_FROM_HDR(lseg->pls_layout)",
            "mirror",
            "lseg->pls_range.offset",
            "lseg->pls_range.length",
            "NFS4ERR_NXIO",
            "OP_ILLEGAL",
            "GFP_NOIO"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_track_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "254-296",
          "snippet": "int ff_layout_track_ds_error(struct nfs4_flexfile_layout *flo,\n\t\t\t     struct nfs4_ff_layout_mirror *mirror, u64 offset,\n\t\t\t     u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds_err *dserr;\n\tbool needfree;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tif (mirror->mirror_ds == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (ff_layout_update_ds_error(flo, offset, length, status, opnum,\n\t\t\t\t      &mirror->stateid,\n\t\t\t\t      &mirror->mirror_ds->id_node.deviceid)) {\n\t\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tdserr = kmalloc(sizeof(*dserr), gfp_flags);\n\tif (!dserr)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dserr->list);\n\tdserr->offset = offset;\n\tdserr->length = length;\n\tdserr->status = status;\n\tdserr->opnum = opnum;\n\tnfs4_stateid_copy(&dserr->stateid, &mirror->stateid);\n\tmemcpy(&dserr->deviceid, &mirror->mirror_ds->id_node.deviceid,\n\t       NFS4_DEVICEID4_SIZE);\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tneedfree = ff_layout_add_ds_error_locked(flo, dserr);\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (needfree)\n\t\tkfree(dserr);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nint ff_layout_track_ds_error(struct nfs4_flexfile_layout *flo,\n\t\t\t     struct nfs4_ff_layout_mirror *mirror, u64 offset,\n\t\t\t     u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds_err *dserr;\n\tbool needfree;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tif (mirror->mirror_ds == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (ff_layout_update_ds_error(flo, offset, length, status, opnum,\n\t\t\t\t      &mirror->stateid,\n\t\t\t\t      &mirror->mirror_ds->id_node.deviceid)) {\n\t\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tdserr = kmalloc(sizeof(*dserr), gfp_flags);\n\tif (!dserr)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dserr->list);\n\tdserr->offset = offset;\n\tdserr->length = length;\n\tdserr->status = status;\n\tdserr->opnum = opnum;\n\tnfs4_stateid_copy(&dserr->stateid, &mirror->stateid);\n\tmemcpy(&dserr->deviceid, &mirror->mirror_ds->id_node.deviceid,\n\t       NFS4_DEVICEID4_SIZE);\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tneedfree = ff_layout_add_ds_error_locked(flo, dserr);\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (needfree)\n\t\tkfree(dserr);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_FROM_HDR",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_block_size",
          "args": [
            "rpc_max_payload(ds->ds_clp->cl_rpcclient)",
            "NULL"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_block_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "579-588",
          "snippet": "static inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_max_payload",
          "args": [
            "ds->ds_clp->cl_rpcclient"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_ds_connect",
          "args": [
            "s",
            "ds",
            "devid",
            "dataserver_timeo",
            "dataserver_retrans",
            "mirror->mirror_ds->ds_versions[0].version",
            "mirror->mirror_ds->ds_versions[0].minor_version",
            "flavor"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_ds_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "664-691",
          "snippet": "void nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version,\n\t\t\t  u32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\n\t\tint err = 0;\n\n\t\tif (version == 3) {\n\t\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, au_flavor);\n\t\t} else if (version == 4) {\n\t\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, minor_version,\n\t\t\t\t\t\t       au_flavor);\n\t\t} else {\n\t\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__,\n\t\t\t\tversion);\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t}\n\n\t\tif (err)\n\t\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tnfs4_clear_ds_conn_bit(ds);\n\t} else {\n\t\tnfs4_wait_ds_connect(ds);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_client *(*get_v3_ds_connect)(\n\t\t\tstruct nfs_client *mds_clp,\n\t\t\tconst struct sockaddr *ds_addr,\n\t\t\tint ds_addrlen,\n\t\t\tint ds_proto,\n\t\t\tunsigned int ds_timeo,\n\t\t\tunsigned int ds_retrans,\n\t\t\trpc_authflavor_t au_flavor);\n\nvoid nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\n\t\t\t  struct nfs4_deviceid_node *devid, unsigned int timeo,\n\t\t\t  unsigned int retrans, u32 version,\n\t\t\t  u32 minor_version, rpc_authflavor_t au_flavor)\n{\n\tif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\n\t\tint err = 0;\n\n\t\tif (version == 3) {\n\t\t\terr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, au_flavor);\n\t\t} else if (version == 4) {\n\t\t\terr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\n\t\t\t\t\t\t       retrans, minor_version,\n\t\t\t\t\t\t       au_flavor);\n\t\t} else {\n\t\t\tdprintk(\"%s: unsupported DS version %d\\n\", __func__,\n\t\t\t\tversion);\n\t\t\terr = -EPROTONOSUPPORT;\n\t\t}\n\n\t\tif (err)\n\t\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tnfs4_clear_ds_conn_bit(ds);\n\t} else {\n\t\tnfs4_wait_ds_connect(ds);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_choose_authflavor",
          "args": [
            "mirror"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_choose_authflavor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "299-305",
          "snippet": "static rpc_authflavor_t\nnfs4_ff_layout_choose_authflavor(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror->uid == (u32)-1)\n\t\treturn RPC_AUTH_NULL;\n\treturn RPC_AUTH_UNIX;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic rpc_authflavor_t\nnfs4_ff_layout_choose_authflavor(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror->uid == (u32)-1)\n\t\treturn RPC_AUTH_NULL;\n\treturn RPC_AUTH_UNIX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_test_devid_unavailable",
          "args": [
            "devid"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_test_devid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "116-120",
          "snippet": "static inline bool\nff_layout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn nfs4_test_deviceid_unavailable(node);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline bool\nff_layout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn nfs4_test_deviceid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_generic_mark_devid_invalid",
          "args": [
            "devid"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_mark_devid_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "419-423",
          "snippet": "static inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s: No data server for offset index %d\\n\"",
            "__func__",
            "ds_idx"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "lseg",
            "ds_idx"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
  },
  {
    "function_name": "nfs4_ff_layout_select_ds_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "333-355",
    "snippet": "struct nfs_fh *\nnfs4_ff_layout_select_ds_fh(struct pnfs_layout_segment *lseg, u32 mirror_idx)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, mirror_idx);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\",\n\t\t\t__func__, mirror_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* FIXME: For now assume there is only 1 version available for the DS */\n\tfh = &mirror->fh_versions[0];\nout:\n\treturn fh;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_mark_devid_invalid",
          "args": [
            "devid"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_mark_devid_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "419-423",
          "snippet": "static inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void\npnfs_generic_mark_devid_invalid(struct nfs4_deviceid_node *node)\n{\n\tset_bit(NFS_DEVICEID_INVALID, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\"",
            "__func__",
            "mirror_idx"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "lseg",
            "mirror_idx"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs_fh *\nnfs4_ff_layout_select_ds_fh(struct pnfs_layout_segment *lseg, u32 mirror_idx)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, mirror_idx);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\",\n\t\t\t__func__, mirror_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* FIXME: For now assume there is only 1 version available for the DS */\n\tfh = &mirror->fh_versions[0];\nout:\n\treturn fh;\n}"
  },
  {
    "function_name": "ff_layout_update_mirror_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "308-331",
    "snippet": "static int ff_layout_update_mirror_cred(struct nfs4_ff_layout_mirror *mirror,\n\t\t\t\t      struct nfs4_pnfs_ds *ds)\n{\n\tif (ds->ds_clp && !mirror->cred &&\n\t    mirror->mirror_ds->ds_versions[0].version == 3) {\n\t\tstruct rpc_auth *auth = ds->ds_clp->cl_rpcclient->cl_auth;\n\t\tstruct rpc_cred *cred;\n\t\tstruct auth_cred acred = {\n\t\t\t.uid = make_kuid(&init_user_ns, mirror->uid),\n\t\t\t.gid = make_kgid(&init_user_ns, mirror->gid),\n\t\t};\n\n\t\t/* AUTH_NULL ignores acred */\n\t\tcred = auth->au_ops->lookup_cred(auth, &acred, 0);\n\t\tif (IS_ERR(cred)) {\n\t\t\tdprintk(\"%s: lookup_cred failed with %ld\\n\",\n\t\t\t\t__func__, PTR_ERR(cred));\n\t\t\treturn PTR_ERR(cred);\n\t\t} else {\n\t\t\tmirror->cred = cred;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cred"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lookup_cred failed with %ld\\n\"",
            "__func__",
            "PTR_ERR(cred)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cred"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cred"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth->au_ops->lookup_cred",
          "args": [
            "auth",
            "&acred",
            "0"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "mirror->gid"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "mirror->uid"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_update_mirror_cred(struct nfs4_ff_layout_mirror *mirror,\n\t\t\t\t      struct nfs4_pnfs_ds *ds)\n{\n\tif (ds->ds_clp && !mirror->cred &&\n\t    mirror->mirror_ds->ds_versions[0].version == 3) {\n\t\tstruct rpc_auth *auth = ds->ds_clp->cl_rpcclient->cl_auth;\n\t\tstruct rpc_cred *cred;\n\t\tstruct auth_cred acred = {\n\t\t\t.uid = make_kuid(&init_user_ns, mirror->uid),\n\t\t\t.gid = make_kgid(&init_user_ns, mirror->gid),\n\t\t};\n\n\t\t/* AUTH_NULL ignores acred */\n\t\tcred = auth->au_ops->lookup_cred(auth, &acred, 0);\n\t\tif (IS_ERR(cred)) {\n\t\t\tdprintk(\"%s: lookup_cred failed with %ld\\n\",\n\t\t\t\t__func__, PTR_ERR(cred));\n\t\t\treturn PTR_ERR(cred);\n\t\t} else {\n\t\t\tmirror->cred = cred;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_ff_layout_choose_authflavor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "299-305",
    "snippet": "static rpc_authflavor_t\nnfs4_ff_layout_choose_authflavor(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror->uid == (u32)-1)\n\t\treturn RPC_AUTH_NULL;\n\treturn RPC_AUTH_UNIX;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic rpc_authflavor_t\nnfs4_ff_layout_choose_authflavor(struct nfs4_ff_layout_mirror *mirror)\n{\n\tif (mirror->uid == (u32)-1)\n\t\treturn RPC_AUTH_NULL;\n\treturn RPC_AUTH_UNIX;\n}"
  },
  {
    "function_name": "ff_layout_track_ds_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "254-296",
    "snippet": "int ff_layout_track_ds_error(struct nfs4_flexfile_layout *flo,\n\t\t\t     struct nfs4_ff_layout_mirror *mirror, u64 offset,\n\t\t\t     u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds_err *dserr;\n\tbool needfree;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tif (mirror->mirror_ds == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (ff_layout_update_ds_error(flo, offset, length, status, opnum,\n\t\t\t\t      &mirror->stateid,\n\t\t\t\t      &mirror->mirror_ds->id_node.deviceid)) {\n\t\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tdserr = kmalloc(sizeof(*dserr), gfp_flags);\n\tif (!dserr)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dserr->list);\n\tdserr->offset = offset;\n\tdserr->length = length;\n\tdserr->status = status;\n\tdserr->opnum = opnum;\n\tnfs4_stateid_copy(&dserr->stateid, &mirror->stateid);\n\tmemcpy(&dserr->deviceid, &mirror->mirror_ds->id_node.deviceid,\n\t       NFS4_DEVICEID4_SIZE);\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tneedfree = ff_layout_add_ds_error_locked(flo, dserr);\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (needfree)\n\t\tkfree(dserr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dserr"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&flo->generic_hdr.plh_inode->i_lock"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_add_ds_error_locked",
          "args": [
            "flo",
            "dserr"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_add_ds_error_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "218-232",
          "snippet": "static bool\nff_layout_add_ds_error_locked(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct nfs4_ff_layout_ds_err *dserr)\n{\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (merge_ds_error(err, dserr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tlist_add(&dserr->list, &flo->error_list);\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_add_ds_error_locked(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct nfs4_ff_layout_ds_err *dserr)\n{\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (merge_ds_error(err, dserr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tlist_add(&dserr->list, &flo->error_list);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&flo->generic_hdr.plh_inode->i_lock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dserr->deviceid",
            "&mirror->mirror_ds->id_node.deviceid",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "&dserr->stateid",
            "&mirror->stateid"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dserr->list"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dserr)",
            "gfp_flags"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_update_ds_error",
          "args": [
            "flo",
            "offset",
            "length",
            "status",
            "opnum",
            "&mirror->stateid",
            "&mirror->mirror_ds->id_node.deviceid"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_update_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "234-252",
          "snippet": "static bool\nff_layout_update_ds_error(struct nfs4_flexfile_layout *flo, u64 offset,\n\t\t\t  u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t  nfs4_stateid *stateid, struct nfs4_deviceid *deviceid)\n{\n\tbool found = false;\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (ds_error_can_merge(err, offset, length, status, opnum,\n\t\t\t\t       stateid, deviceid)) {\n\t\t\tfound = true;\n\t\t\textend_ds_error(err, offset, length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_update_ds_error(struct nfs4_flexfile_layout *flo, u64 offset,\n\t\t\t  u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t  nfs4_stateid *stateid, struct nfs4_deviceid *deviceid)\n{\n\tbool found = false;\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (ds_error_can_merge(err, offset, length, status, opnum,\n\t\t\t\t       stateid, deviceid)) {\n\t\t\tfound = true;\n\t\t\textend_ds_error(err, offset, length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nint ff_layout_track_ds_error(struct nfs4_flexfile_layout *flo,\n\t\t\t     struct nfs4_ff_layout_mirror *mirror, u64 offset,\n\t\t\t     u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds_err *dserr;\n\tbool needfree;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tif (mirror->mirror_ds == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (ff_layout_update_ds_error(flo, offset, length, status, opnum,\n\t\t\t\t      &mirror->stateid,\n\t\t\t\t      &mirror->mirror_ds->id_node.deviceid)) {\n\t\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tdserr = kmalloc(sizeof(*dserr), gfp_flags);\n\tif (!dserr)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dserr->list);\n\tdserr->offset = offset;\n\tdserr->length = length;\n\tdserr->status = status;\n\tdserr->opnum = opnum;\n\tnfs4_stateid_copy(&dserr->stateid, &mirror->stateid);\n\tmemcpy(&dserr->deviceid, &mirror->mirror_ds->id_node.deviceid,\n\t       NFS4_DEVICEID4_SIZE);\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tneedfree = ff_layout_add_ds_error_locked(flo, dserr);\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (needfree)\n\t\tkfree(dserr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_update_ds_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "234-252",
    "snippet": "static bool\nff_layout_update_ds_error(struct nfs4_flexfile_layout *flo, u64 offset,\n\t\t\t  u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t  nfs4_stateid *stateid, struct nfs4_deviceid *deviceid)\n{\n\tbool found = false;\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (ds_error_can_merge(err, offset, length, status, opnum,\n\t\t\t\t       stateid, deviceid)) {\n\t\t\tfound = true;\n\t\t\textend_ds_error(err, offset, length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extend_ds_error",
          "args": [
            "err",
            "offset",
            "length"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "extend_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "184-193",
          "snippet": "static void extend_ds_error(struct nfs4_ff_layout_ds_err *err,\n\t\t\t    u64 offset, u64 length)\n{\n\tu64 end;\n\n\tend = max_t(u64, end_offset(err->offset, err->length),\n\t\t    end_offset(offset, length));\n\terr->offset = min_t(u64, err->offset, offset);\n\terr->length = end - err->offset;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic void extend_ds_error(struct nfs4_ff_layout_ds_err *err,\n\t\t\t    u64 offset, u64 length)\n{\n\tu64 end;\n\n\tend = max_t(u64, end_offset(err->offset, err->length),\n\t\t    end_offset(offset, length));\n\terr->offset = min_t(u64, err->offset, offset);\n\terr->length = end - err->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ds_error_can_merge",
          "args": [
            "err",
            "offset",
            "length",
            "status",
            "opnum",
            "stateid",
            "deviceid"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ds_error_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "195-205",
          "snippet": "static bool ds_error_can_merge(struct nfs4_ff_layout_ds_err *err,  u64 offset,\n\t\t\t       u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t       nfs4_stateid *stateid,\n\t\t\t       struct nfs4_deviceid *deviceid)\n{\n\treturn err->status == status && err->opnum == opnum &&\n\t       nfs4_stateid_match(&err->stateid, stateid) &&\n\t       !memcmp(&err->deviceid, deviceid, sizeof(*deviceid)) &&\n\t       end_offset(err->offset, err->length) >= offset &&\n\t       err->offset <= end_offset(offset, length);\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool ds_error_can_merge(struct nfs4_ff_layout_ds_err *err,  u64 offset,\n\t\t\t       u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t       nfs4_stateid *stateid,\n\t\t\t       struct nfs4_deviceid *deviceid)\n{\n\treturn err->status == status && err->opnum == opnum &&\n\t       nfs4_stateid_match(&err->stateid, stateid) &&\n\t       !memcmp(&err->deviceid, deviceid, sizeof(*deviceid)) &&\n\t       end_offset(err->offset, err->length) >= offset &&\n\t       err->offset <= end_offset(offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "err",
            "&flo->error_list",
            "list"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_update_ds_error(struct nfs4_flexfile_layout *flo, u64 offset,\n\t\t\t  u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t  nfs4_stateid *stateid, struct nfs4_deviceid *deviceid)\n{\n\tbool found = false;\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (ds_error_can_merge(err, offset, length, status, opnum,\n\t\t\t\t       stateid, deviceid)) {\n\t\t\tfound = true;\n\t\t\textend_ds_error(err, offset, length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "ff_layout_add_ds_error_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "218-232",
    "snippet": "static bool\nff_layout_add_ds_error_locked(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct nfs4_ff_layout_ds_err *dserr)\n{\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (merge_ds_error(err, dserr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tlist_add(&dserr->list, &flo->error_list);\n\treturn false;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dserr->list",
            "&flo->error_list"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_ds_error",
          "args": [
            "err",
            "dserr"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "merge_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "207-216",
          "snippet": "static bool merge_ds_error(struct nfs4_ff_layout_ds_err *old,\n\t\t\t   struct nfs4_ff_layout_ds_err *new)\n{\n\tif (!ds_error_can_merge(old, new->offset, new->length, new->status,\n\t\t\t\tnew->opnum, &new->stateid, &new->deviceid))\n\t\treturn false;\n\n\textend_ds_error(old, new->offset, new->length);\n\treturn true;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool merge_ds_error(struct nfs4_ff_layout_ds_err *old,\n\t\t\t   struct nfs4_ff_layout_ds_err *new)\n{\n\tif (!ds_error_can_merge(old, new->offset, new->length, new->status,\n\t\t\t\tnew->opnum, &new->stateid, &new->deviceid))\n\t\treturn false;\n\n\textend_ds_error(old, new->offset, new->length);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "err",
            "&flo->error_list",
            "list"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_add_ds_error_locked(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct nfs4_ff_layout_ds_err *dserr)\n{\n\tstruct nfs4_ff_layout_ds_err *err;\n\n\tlist_for_each_entry(err, &flo->error_list, list) {\n\t\tif (merge_ds_error(err, dserr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tlist_add(&dserr->list, &flo->error_list);\n\treturn false;\n}"
  },
  {
    "function_name": "merge_ds_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "207-216",
    "snippet": "static bool merge_ds_error(struct nfs4_ff_layout_ds_err *old,\n\t\t\t   struct nfs4_ff_layout_ds_err *new)\n{\n\tif (!ds_error_can_merge(old, new->offset, new->length, new->status,\n\t\t\t\tnew->opnum, &new->stateid, &new->deviceid))\n\t\treturn false;\n\n\textend_ds_error(old, new->offset, new->length);\n\treturn true;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extend_ds_error",
          "args": [
            "old",
            "new->offset",
            "new->length"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "extend_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "184-193",
          "snippet": "static void extend_ds_error(struct nfs4_ff_layout_ds_err *err,\n\t\t\t    u64 offset, u64 length)\n{\n\tu64 end;\n\n\tend = max_t(u64, end_offset(err->offset, err->length),\n\t\t    end_offset(offset, length));\n\terr->offset = min_t(u64, err->offset, offset);\n\terr->length = end - err->offset;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic void extend_ds_error(struct nfs4_ff_layout_ds_err *err,\n\t\t\t    u64 offset, u64 length)\n{\n\tu64 end;\n\n\tend = max_t(u64, end_offset(err->offset, err->length),\n\t\t    end_offset(offset, length));\n\terr->offset = min_t(u64, err->offset, offset);\n\terr->length = end - err->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ds_error_can_merge",
          "args": [
            "old",
            "new->offset",
            "new->length",
            "new->status",
            "new->opnum",
            "&new->stateid",
            "&new->deviceid"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ds_error_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "195-205",
          "snippet": "static bool ds_error_can_merge(struct nfs4_ff_layout_ds_err *err,  u64 offset,\n\t\t\t       u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t       nfs4_stateid *stateid,\n\t\t\t       struct nfs4_deviceid *deviceid)\n{\n\treturn err->status == status && err->opnum == opnum &&\n\t       nfs4_stateid_match(&err->stateid, stateid) &&\n\t       !memcmp(&err->deviceid, deviceid, sizeof(*deviceid)) &&\n\t       end_offset(err->offset, err->length) >= offset &&\n\t       err->offset <= end_offset(offset, length);\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool ds_error_can_merge(struct nfs4_ff_layout_ds_err *err,  u64 offset,\n\t\t\t       u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t       nfs4_stateid *stateid,\n\t\t\t       struct nfs4_deviceid *deviceid)\n{\n\treturn err->status == status && err->opnum == opnum &&\n\t       nfs4_stateid_match(&err->stateid, stateid) &&\n\t       !memcmp(&err->deviceid, deviceid, sizeof(*deviceid)) &&\n\t       end_offset(err->offset, err->length) >= offset &&\n\t       err->offset <= end_offset(offset, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool merge_ds_error(struct nfs4_ff_layout_ds_err *old,\n\t\t\t   struct nfs4_ff_layout_ds_err *new)\n{\n\tif (!ds_error_can_merge(old, new->offset, new->length, new->status,\n\t\t\t\tnew->opnum, &new->stateid, &new->deviceid))\n\t\treturn false;\n\n\textend_ds_error(old, new->offset, new->length);\n\treturn true;\n}"
  },
  {
    "function_name": "ds_error_can_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "195-205",
    "snippet": "static bool ds_error_can_merge(struct nfs4_ff_layout_ds_err *err,  u64 offset,\n\t\t\t       u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t       nfs4_stateid *stateid,\n\t\t\t       struct nfs4_deviceid *deviceid)\n{\n\treturn err->status == status && err->opnum == opnum &&\n\t       nfs4_stateid_match(&err->stateid, stateid) &&\n\t       !memcmp(&err->deviceid, deviceid, sizeof(*deviceid)) &&\n\t       end_offset(err->offset, err->length) >= offset &&\n\t       err->offset <= end_offset(offset, length);\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "offset",
            "length"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "175-182",
          "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&err->deviceid",
            "deviceid",
            "sizeof(*deviceid)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_match",
          "args": [
            "&err->stateid",
            "stateid"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_match_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "506-509",
          "snippet": "static inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic bool ds_error_can_merge(struct nfs4_ff_layout_ds_err *err,  u64 offset,\n\t\t\t       u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t       nfs4_stateid *stateid,\n\t\t\t       struct nfs4_deviceid *deviceid)\n{\n\treturn err->status == status && err->opnum == opnum &&\n\t       nfs4_stateid_match(&err->stateid, stateid) &&\n\t       !memcmp(&err->deviceid, deviceid, sizeof(*deviceid)) &&\n\t       end_offset(err->offset, err->length) >= offset &&\n\t       err->offset <= end_offset(offset, length);\n}"
  },
  {
    "function_name": "extend_ds_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "184-193",
    "snippet": "static void extend_ds_error(struct nfs4_ff_layout_ds_err *err,\n\t\t\t    u64 offset, u64 length)\n{\n\tu64 end;\n\n\tend = max_t(u64, end_offset(err->offset, err->length),\n\t\t    end_offset(offset, length));\n\terr->offset = min_t(u64, err->offset, offset);\n\terr->length = end - err->offset;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "err->offset",
            "offset"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "end_offset(err->offset, err->length)",
            "end_offset(offset, length)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "offset",
            "length"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "175-182",
          "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic void extend_ds_error(struct nfs4_ff_layout_ds_err *err,\n\t\t\t    u64 offset, u64 length)\n{\n\tu64 end;\n\n\tend = max_t(u64, end_offset(err->offset, err->length),\n\t\t    end_offset(offset, length));\n\terr->offset = min_t(u64, err->offset, offset);\n\terr->length = end - err->offset;\n}"
  },
  {
    "function_name": "end_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "175-182",
    "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "nfs4_ff_alloc_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "37-173",
    "snippet": "struct nfs4_ff_layout_ds *\nnfs4_ff_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\tstruct nfs4_ff_layout_ds *new_ds = NULL;\n\tstruct nfs4_ff_ds_version *ds_versions = NULL;\n\tu32 mp_count;\n\tu32 version_count;\n\t__be32 *p;\n\tint i, ret = -ENOMEM;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\tnew_ds = kzalloc(sizeof(struct nfs4_ff_layout_ds), gfp_flags);\n\tif (!new_ds)\n\t\tgoto out_scratch;\n\n\tnfs4_init_deviceid_node(&new_ds->id_node,\n\t\t\t\tserver,\n\t\t\t\t&pdev->dev_id);\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* multipath count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tmp_count = be32_to_cpup(p);\n\tdprintk(\"%s: multipath ds count %d\\n\", __func__, mp_count);\n\n\tfor (i = 0; i < mp_count; i++) {\n\t\t/* multipath ds */\n\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t    &stream, gfp_flags);\n\t\tif (da)\n\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t}\n\tif (list_empty(&dsaddrs)) {\n\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEDIUM;\n\t\tgoto out_err_drain_dsaddrs;\n\t}\n\n\t/* version count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tversion_count = be32_to_cpup(p);\n\tdprintk(\"%s: version count %d\\n\", __func__, version_count);\n\n\tds_versions = kzalloc(version_count * sizeof(struct nfs4_ff_ds_version),\n\t\t\t      gfp_flags);\n\tif (!ds_versions)\n\t\tgoto out_scratch;\n\n\tfor (i = 0; i < version_count; i++) {\n\t\t/* 20 = version(4) + minor_version(4) + rsize(4) + wsize(4) +\n\t\t * tightly_coupled(4) */\n\t\tp = xdr_inline_decode(&stream, 20);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\tds_versions[i].version = be32_to_cpup(p++);\n\t\tds_versions[i].minor_version = be32_to_cpup(p++);\n\t\tds_versions[i].rsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].wsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].tightly_coupled = be32_to_cpup(p);\n\n\t\tif (ds_versions[i].rsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].rsize = NFS_MAX_FILE_IO_SIZE;\n\t\tif (ds_versions[i].wsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].wsize = NFS_MAX_FILE_IO_SIZE;\n\n\t\tif (ds_versions[i].version != 3 || ds_versions[i].minor_version != 0) {\n\t\t\tdprintk(\"%s: [%d] unsupported ds version %d-%d\\n\", __func__,\n\t\t\t\ti, ds_versions[i].version,\n\t\t\t\tds_versions[i].minor_version);\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\t}\n\n\t\tdprintk(\"%s: [%d] vers %u minor_ver %u rsize %u wsize %u coupled %d\\n\",\n\t\t\t__func__, i, ds_versions[i].version,\n\t\t\tds_versions[i].minor_version,\n\t\t\tds_versions[i].rsize,\n\t\t\tds_versions[i].wsize,\n\t\t\tds_versions[i].tightly_coupled);\n\t}\n\n\tnew_ds->ds_versions = ds_versions;\n\tnew_ds->ds_versions_cnt = version_count;\n\n\tnew_ds->ds = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\tif (!new_ds->ds)\n\t\tgoto out_err_drain_dsaddrs;\n\n\t/* If DS was already in cache, free ds addrs */\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\t__free_page(scratch);\n\treturn new_ds;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds_versions);\nout_scratch:\n\t__free_page(scratch);\nout_err:\n\tkfree(new_ds);\n\n\tdprintk(\"%s ERROR: returning %d\\n\", __func__, ret);\n\treturn NULL;\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ERROR: returning %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_ds"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ds_versions"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da->da_remotestr"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&da->da_node"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dsaddrs",
            "structnfs4_pnfs_ds_addr",
            "da_node"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dsaddrs"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "da->da_remotestr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&da->da_node"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dsaddrs",
            "structnfs4_pnfs_ds_addr",
            "da_node"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_ds_add",
          "args": [
            "&dsaddrs",
            "gfp_flags"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_ds_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "485-527",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t/* this is only used for debugging, so it's ok if its NULL */\n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\tatomic_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\tatomic_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\tatomic_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs4_ds_cache_lock);",
            "static LIST_HEAD(nfs4_data_server_cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\nstatic LIST_HEAD(nfs4_data_server_cache);\n\nstruct nfs4_pnfs_ds *\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\n\tchar *remotestr;\n\n\tif (list_empty(dsaddrs)) {\n\t\tdprintk(\"%s: no addresses defined\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tds = kzalloc(sizeof(*ds), gfp_flags);\n\tif (!ds)\n\t\tgoto out;\n\n\t/* this is only used for debugging, so it's ok if its NULL */\n\tremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\n\n\tspin_lock(&nfs4_ds_cache_lock);\n\ttmp_ds = _data_server_lookup_locked(dsaddrs);\n\tif (tmp_ds == NULL) {\n\t\tINIT_LIST_HEAD(&ds->ds_addrs);\n\t\tlist_splice_init(dsaddrs, &ds->ds_addrs);\n\t\tds->ds_remotestr = remotestr;\n\t\tatomic_set(&ds->ds_count, 1);\n\t\tINIT_LIST_HEAD(&ds->ds_node);\n\t\tds->ds_clp = NULL;\n\t\tlist_add(&ds->ds_node, &nfs4_data_server_cache);\n\t\tdprintk(\"%s add new data server %s\\n\", __func__,\n\t\t\tds->ds_remotestr);\n\t} else {\n\t\tkfree(remotestr);\n\t\tkfree(ds);\n\t\tatomic_inc(&tmp_ds->ds_count);\n\t\tdprintk(\"%s data server %s found, inc'ed ds_count to %d\\n\",\n\t\t\t__func__, tmp_ds->ds_remotestr,\n\t\t\tatomic_read(&tmp_ds->ds_count));\n\t\tds = tmp_ds;\n\t}\n\tspin_unlock(&nfs4_ds_cache_lock);\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: [%d] vers %u minor_ver %u rsize %u wsize %u coupled %d\\n\"",
            "__func__",
            "i",
            "ds_versions[i].version",
            "ds_versions[i].minor_version",
            "ds_versions[i].rsize",
            "ds_versions[i].wsize",
            "ds_versions[i].tightly_coupled"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: [%d] unsupported ds version %d-%d\\n\"",
            "__func__",
            "i",
            "ds_versions[i].version",
            "ds_versions[i].minor_version"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_block_size",
          "args": [
            "be32_to_cpup(p++)",
            "NULL"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_block_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "579-588",
          "snippet": "static inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "20"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "version_count * sizeof(struct nfs4_ff_ds_version)",
            "gfp_flags"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: version count %d\\n\"",
            "__func__",
            "version_count"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: no suitable DS addresses found\\n\"",
            "__func__"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&da->da_node",
            "&dsaddrs"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_decode_mp_ds_addr",
          "args": [
            "server->nfs_client->cl_net",
            "&stream",
            "gfp_flags"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_decode_mp_ds_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "697-839",
          "snippet": "struct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tint nlen, rlen;\n\tint tmp[2];\n\t__be32 *p;\n\tchar *netid, *match_netid;\n\tsize_t len, match_netid_len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t/* r_netid */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\tnlen = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, nlen);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tnetid = kmalloc(nlen+1, gfp_flags);\n\tif (unlikely(!netid))\n\t\tgoto out_err;\n\n\tnetid[nlen] = '\\0';\n\tmemcpy(netid, p, nlen);\n\n\t/* r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\trlen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, rlen);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\n\t/* port is \".ABC.DEF\", 8 chars max */\n\tif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\n\t\tdprintk(\"%s: Invalid address, length %d\\n\", __func__,\n\t\t\trlen);\n\t\tgoto out_free_netid;\n\t}\n\tbuf = kmalloc(rlen + 1, gfp_flags);\n\tif (!buf) {\n\t\tdprintk(\"%s: Not enough memory\\n\", __func__);\n\t\tgoto out_free_netid;\n\t}\n\tbuf[rlen] = '\\0';\n\tmemcpy(buf, p, rlen);\n\n\t/* replace port '.' with '-' */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t/* find '.' between address and port */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = kzalloc(sizeof(*da), gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tINIT_LIST_HEAD(&da->da_node);\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tmatch_netid = \"tcp\";\n\t\tmatch_netid_len = 3;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\n\t\tdprintk(\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\t__func__, netid, match_netid);\n\t\tgoto out_free_da;\n\t}\n\n\t/* save human readable address */\n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t/* NULL is ok, only used for dprintk */\n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\tkfree(netid);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_pnfs_ds_addr *\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\n{\n\tstruct nfs4_pnfs_ds_addr *da = NULL;\n\tchar *buf, *portstr;\n\t__be16 port;\n\tint nlen, rlen;\n\tint tmp[2];\n\t__be32 *p;\n\tchar *netid, *match_netid;\n\tsize_t len, match_netid_len;\n\tchar *startsep = \"\";\n\tchar *endsep = \"\";\n\n\n\t/* r_netid */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\tnlen = be32_to_cpup(p++);\n\n\tp = xdr_inline_decode(xdr, nlen);\n\tif (unlikely(!p))\n\t\tgoto out_err;\n\n\tnetid = kmalloc(nlen+1, gfp_flags);\n\tif (unlikely(!netid))\n\t\tgoto out_err;\n\n\tnetid[nlen] = '\\0';\n\tmemcpy(netid, p, nlen);\n\n\t/* r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\trlen = be32_to_cpup(p);\n\n\tp = xdr_inline_decode(xdr, rlen);\n\tif (unlikely(!p))\n\t\tgoto out_free_netid;\n\n\t/* port is \".ABC.DEF\", 8 chars max */\n\tif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\n\t\tdprintk(\"%s: Invalid address, length %d\\n\", __func__,\n\t\t\trlen);\n\t\tgoto out_free_netid;\n\t}\n\tbuf = kmalloc(rlen + 1, gfp_flags);\n\tif (!buf) {\n\t\tdprintk(\"%s: Not enough memory\\n\", __func__);\n\t\tgoto out_free_netid;\n\t}\n\tbuf[rlen] = '\\0';\n\tmemcpy(buf, p, rlen);\n\n\t/* replace port '.' with '-' */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot in port\\n\",\n\t\t\t__func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '-';\n\n\t/* find '.' between address and port */\n\tportstr = strrchr(buf, '.');\n\tif (!portstr) {\n\t\tdprintk(\"%s: Failed finding expected dot between address and \"\n\t\t\t\"port\\n\", __func__);\n\t\tgoto out_free_buf;\n\t}\n\t*portstr = '\\0';\n\n\tda = kzalloc(sizeof(*da), gfp_flags);\n\tif (unlikely(!da))\n\t\tgoto out_free_buf;\n\n\tINIT_LIST_HEAD(&da->da_node);\n\n\tif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\n\t\t      sizeof(da->da_addr))) {\n\t\tdprintk(\"%s: error parsing address %s\\n\", __func__, buf);\n\t\tgoto out_free_da;\n\t}\n\n\tportstr++;\n\tsscanf(portstr, \"%d-%d\", &tmp[0], &tmp[1]);\n\tport = htons((tmp[0] << 8) | (tmp[1]));\n\n\tswitch (da->da_addr.ss_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)&da->da_addr)->sin_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in);\n\t\tmatch_netid = \"tcp\";\n\t\tmatch_netid_len = 3;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\n\t\tda->da_addrlen = sizeof(struct sockaddr_in6);\n\t\tmatch_netid = \"tcp6\";\n\t\tmatch_netid_len = 4;\n\t\tstartsep = \"[\";\n\t\tendsep = \"]\";\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported address family: %u\\n\",\n\t\t\t__func__, da->da_addr.ss_family);\n\t\tgoto out_free_da;\n\t}\n\n\tif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\n\t\tdprintk(\"%s: ERROR: r_netid \\\"%s\\\" != \\\"%s\\\"\\n\",\n\t\t\t__func__, netid, match_netid);\n\t\tgoto out_free_da;\n\t}\n\n\t/* save human readable address */\n\tlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\n\tda->da_remotestr = kzalloc(len, gfp_flags);\n\n\t/* NULL is ok, only used for dprintk */\n\tif (da->da_remotestr)\n\t\tsnprintf(da->da_remotestr, len, \"%s%s%s:%u\", startsep,\n\t\t\t buf, endsep, ntohs(port));\n\n\tdprintk(\"%s: Parsed DS addr %s\\n\", __func__, da->da_remotestr);\n\tkfree(buf);\n\tkfree(netid);\n\treturn da;\n\nout_free_da:\n\tkfree(da);\nout_free_buf:\n\tdprintk(\"%s: Error parsing DS addr: %s\\n\", __func__, buf);\n\tkfree(buf);\nout_free_netid:\n\tkfree(netid);\nout_err:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: multipath ds count %d\\n\"",
            "__func__",
            "mp_count"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&stream",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&stream",
            "&buf",
            "pdev->pages",
            "pdev->pglen"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dsaddrs"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_deviceid_node",
          "args": [
            "&new_ds->id_node",
            "server",
            "&pdev->dev_id"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "247-258",
          "snippet": "void\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct nfs4_ff_layout_ds)",
            "gfp_flags"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_flags"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_ff_layout_ds *\nnfs4_ff_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\tstruct nfs4_ff_layout_ds *new_ds = NULL;\n\tstruct nfs4_ff_ds_version *ds_versions = NULL;\n\tu32 mp_count;\n\tu32 version_count;\n\t__be32 *p;\n\tint i, ret = -ENOMEM;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\tnew_ds = kzalloc(sizeof(struct nfs4_ff_layout_ds), gfp_flags);\n\tif (!new_ds)\n\t\tgoto out_scratch;\n\n\tnfs4_init_deviceid_node(&new_ds->id_node,\n\t\t\t\tserver,\n\t\t\t\t&pdev->dev_id);\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* multipath count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tmp_count = be32_to_cpup(p);\n\tdprintk(\"%s: multipath ds count %d\\n\", __func__, mp_count);\n\n\tfor (i = 0; i < mp_count; i++) {\n\t\t/* multipath ds */\n\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t    &stream, gfp_flags);\n\t\tif (da)\n\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t}\n\tif (list_empty(&dsaddrs)) {\n\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEDIUM;\n\t\tgoto out_err_drain_dsaddrs;\n\t}\n\n\t/* version count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tversion_count = be32_to_cpup(p);\n\tdprintk(\"%s: version count %d\\n\", __func__, version_count);\n\n\tds_versions = kzalloc(version_count * sizeof(struct nfs4_ff_ds_version),\n\t\t\t      gfp_flags);\n\tif (!ds_versions)\n\t\tgoto out_scratch;\n\n\tfor (i = 0; i < version_count; i++) {\n\t\t/* 20 = version(4) + minor_version(4) + rsize(4) + wsize(4) +\n\t\t * tightly_coupled(4) */\n\t\tp = xdr_inline_decode(&stream, 20);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\tds_versions[i].version = be32_to_cpup(p++);\n\t\tds_versions[i].minor_version = be32_to_cpup(p++);\n\t\tds_versions[i].rsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].wsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].tightly_coupled = be32_to_cpup(p);\n\n\t\tif (ds_versions[i].rsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].rsize = NFS_MAX_FILE_IO_SIZE;\n\t\tif (ds_versions[i].wsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].wsize = NFS_MAX_FILE_IO_SIZE;\n\n\t\tif (ds_versions[i].version != 3 || ds_versions[i].minor_version != 0) {\n\t\t\tdprintk(\"%s: [%d] unsupported ds version %d-%d\\n\", __func__,\n\t\t\t\ti, ds_versions[i].version,\n\t\t\t\tds_versions[i].minor_version);\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\t}\n\n\t\tdprintk(\"%s: [%d] vers %u minor_ver %u rsize %u wsize %u coupled %d\\n\",\n\t\t\t__func__, i, ds_versions[i].version,\n\t\t\tds_versions[i].minor_version,\n\t\t\tds_versions[i].rsize,\n\t\t\tds_versions[i].wsize,\n\t\t\tds_versions[i].tightly_coupled);\n\t}\n\n\tnew_ds->ds_versions = ds_versions;\n\tnew_ds->ds_versions_cnt = version_count;\n\n\tnew_ds->ds = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\tif (!new_ds->ds)\n\t\tgoto out_err_drain_dsaddrs;\n\n\t/* If DS was already in cache, free ds addrs */\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\t__free_page(scratch);\n\treturn new_ds;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds_versions);\nout_scratch:\n\t__free_page(scratch);\nout_err:\n\tkfree(new_ds);\n\n\tdprintk(\"%s ERROR: returning %d\\n\", __func__, ret);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_ff_layout_free_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "29-34",
    "snippet": "void nfs4_ff_layout_free_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tnfs4_print_deviceid(&mirror_ds->id_node.deviceid);\n\tnfs4_pnfs_ds_put(mirror_ds->ds);\n\tkfree(mirror_ds);\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mirror_ds"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pnfs_ds_put",
          "args": [
            "mirror_ds->ds"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pnfs_ds_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "421-429",
          "snippet": "void nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (atomic_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs4_ds_cache_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(nfs4_ds_cache_lock);\n\nvoid nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\n{\n\tif (atomic_dec_and_lock(&ds->ds_count,\n\t\t\t\t&nfs4_ds_cache_lock)) {\n\t\tlist_del_init(&ds->ds_node);\n\t\tspin_unlock(&nfs4_ds_cache_lock);\n\t\tdestroy_ds(ds);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_print_deviceid",
          "args": [
            "&mirror_ds->id_node.deviceid"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_print_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "520-522",
          "snippet": "static inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid nfs4_ff_layout_free_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tnfs4_print_deviceid(&mirror_ds->id_node.deviceid);\n\tnfs4_pnfs_ds_put(mirror_ds->ds);\n\tkfree(mirror_ds);\n}"
  },
  {
    "function_name": "nfs4_ff_layout_put_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
    "lines": "23-27",
    "snippet": "void nfs4_ff_layout_put_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tif (mirror_ds)\n\t\tnfs4_put_deviceid_node(&mirror_ds->id_node);\n}",
    "includes": [
      "#include \"flexfilelayout.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../internal.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "&mirror_ds->id_node"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid nfs4_ff_layout_put_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tif (mirror_ds)\n\t\tnfs4_put_deviceid_node(&mirror_ds->id_node);\n}"
  }
]