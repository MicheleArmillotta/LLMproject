[
  {
    "function_name": "fs2_do_mount_fs(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "330-394",
    "snippet": "t jffs2_do_mount_fs(struct jffs2_sb_info *c)\n{\n\tint ret;\n\tint i;\n\tint size;\n\n\tc->free_size = c->flash_size;\n\tc->nr_blocks = c->flash_size / c->sector_size;\n\tsize = sizeof(struct jffs2_eraseblock) * c->nr_blocks;\n#ifndef __ECOS\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tc->blocks = vzalloc(size);\n\telse\n#endif\n\t\tc->blocks = kzalloc(size, GFP_KERNEL);\n\tif (!c->blocks)\n\t\treturn -ENOMEM;\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tINIT_LIST_HEAD(&c->blocks[i].list);\n\t\tc->blocks[i].offset = i * c->sector_size;\n\t\tc->blocks[i].free_size = c->sector_size;\n\t}\n\n\tINIT_LIST_HEAD(&c->clean_list);\n\tINIT_LIST_HEAD(&c->very_dirty_list);\n\tINIT_LIST_HEAD(&c->dirty_list);\n\tINIT_LIST_HEAD(&c->erasable_list);\n\tINIT_LIST_HEAD(&c->erasing_list);\n\tINIT_LIST_HEAD(&c->erase_checking_list);\n\tINIT_LIST_HEAD(&c->erase_pending_list);\n\tINIT_LIST_HEAD(&c->erasable_pending_wbuf_list);\n\tINIT_LIST_HEAD(&c->erase_complete_list);\n\tINIT_LIST_HEAD(&c->free_list);\n\tINIT_LIST_HEAD(&c->bad_list);\n\tINIT_LIST_HEAD(&c->bad_used_list);\n\tc->highest_ino = 1;\n\tc->summary = NULL;\n\n\tret = jffs2_sum_init(c);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (jffs2_build_filesystem(c)) {\n\t\tdbg_fsbuild(\"build_fs failed\\n\");\n\t\tjffs2_free_ino_caches(c);\n\t\tjffs2_free_raw_node_refs(c);\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tjffs2_calc_trigger_levels(c);\n\n\treturn 0;\n\n out_free:\n#ifndef __ECOS\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tvfree(c->blocks);\n\telse\n#endif\n\t\tkfree(c->blocks);\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">blocks);"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">blocks);"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_blocks_use_vmalloc(c",
          "args": [
            ")"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_calc_trigger_levels(c",
          "args": [
            ";"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_raw_node_refs(c",
          "args": [
            ";"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_ino_caches(c",
          "args": [
            ";"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "uild_fs failed\\n\");"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_build_filesystem(c",
          "args": [
            ")"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_sum_init(c",
          "args": [
            ";"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->bad_used_list);"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->bad_list);"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->free_list);"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->erase_complete_list);"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->erasable_pending_wbuf_list);"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->erase_pending_list);"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->erase_checking_list);"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->erasing_list);"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->erasable_list);"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->dirty_list);"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->very_dirty_list);"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->clean_list);"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LIST_HEAD(&",
          "args": [
            "->blocks[i].list);"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(s",
          "args": [
            "ze,",
            "P_KERNEL);"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(s",
          "args": [
            "ze);"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_blocks_use_vmalloc(c",
          "args": [
            ")"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_do_mount_fs(struct jffs2_sb_info *c)\n{\n\tint ret;\n\tint i;\n\tint size;\n\n\tc->free_size = c->flash_size;\n\tc->nr_blocks = c->flash_size / c->sector_size;\n\tsize = sizeof(struct jffs2_eraseblock) * c->nr_blocks;\n#ifndef __ECOS\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tc->blocks = vzalloc(size);\n\telse\n#endif\n\t\tc->blocks = kzalloc(size, GFP_KERNEL);\n\tif (!c->blocks)\n\t\treturn -ENOMEM;\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tINIT_LIST_HEAD(&c->blocks[i].list);\n\t\tc->blocks[i].offset = i * c->sector_size;\n\t\tc->blocks[i].free_size = c->sector_size;\n\t}\n\n\tINIT_LIST_HEAD(&c->clean_list);\n\tINIT_LIST_HEAD(&c->very_dirty_list);\n\tINIT_LIST_HEAD(&c->dirty_list);\n\tINIT_LIST_HEAD(&c->erasable_list);\n\tINIT_LIST_HEAD(&c->erasing_list);\n\tINIT_LIST_HEAD(&c->erase_checking_list);\n\tINIT_LIST_HEAD(&c->erase_pending_list);\n\tINIT_LIST_HEAD(&c->erasable_pending_wbuf_list);\n\tINIT_LIST_HEAD(&c->erase_complete_list);\n\tINIT_LIST_HEAD(&c->free_list);\n\tINIT_LIST_HEAD(&c->bad_list);\n\tINIT_LIST_HEAD(&c->bad_used_list);\n\tc->highest_ino = 1;\n\tc->summary = NULL;\n\n\tret = jffs2_sum_init(c);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (jffs2_build_filesystem(c)) {\n\t\tdbg_fsbuild(\"build_fs failed\\n\");\n\t\tjffs2_free_ino_caches(c);\n\t\tjffs2_free_raw_node_refs(c);\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tjffs2_calc_trigger_levels(c);\n\n\treturn 0;\n\n out_free:\n#ifndef __ECOS\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tvfree(c->blocks);\n\telse\n#endif\n\t\tkfree(c->blocks);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_calc_trigger_levels(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "268-328",
    "snippet": "atic void jffs2_calc_trigger_levels(struct jffs2_sb_info *c)\n{\n\tuint32_t size;\n\n\t/* Deletion should almost _always_ be allowed. We're fairly\n\t   buggered once we stop allowing people to delete stuff\n\t   because there's not enough free space... */\n\tc->resv_blocks_deletion = 2;\n\n\t/* Be conservative about how much space we need before we allow writes.\n\t   On top of that which is required for deletia, require an extra 2%\n\t   of the medium to be available, for overhead caused by nodes being\n\t   split across blocks, etc. */\n\n\tsize = c->flash_size / 50; /* 2% of flash size */\n\tsize += c->nr_blocks * 100; /* And 100 bytes per eraseblock */\n\tsize += c->sector_size - 1; /* ... and round up */\n\n\tc->resv_blocks_write = c->resv_blocks_deletion + (size / c->sector_size);\n\n\t/* When do we let the GC thread run in the background */\n\n\tc->resv_blocks_gctrigger = c->resv_blocks_write + 1;\n\n\t/* When do we allow garbage collection to merge nodes to make\n\t   long-term progress at the expense of short-term space exhaustion? */\n\tc->resv_blocks_gcmerge = c->resv_blocks_deletion + 1;\n\n\t/* When do we allow garbage collection to eat from bad blocks rather\n\t   than actually making progress? */\n\tc->resv_blocks_gcbad = 0;//c->resv_blocks_deletion + 2;\n\n\t/* What number of 'very dirty' eraseblocks do we allow before we\n\t   trigger the GC thread even if we don't _need_ the space. When we\n\t   can't mark nodes obsolete on the medium, the old dirty nodes cause\n\t   performance problems because we have to inspect and discard them. */\n\tc->vdirty_blocks_gctrigger = c->resv_blocks_gctrigger;\n\tif (jffs2_can_mark_obsolete(c))\n\t\tc->vdirty_blocks_gctrigger *= 10;\n\n\t/* If there's less than this amount of dirty space, don't bother\n\t   trying to GC to make more space. It'll be a fruitless task */\n\tc->nospc_dirty_size = c->sector_size + (c->flash_size / 100);\n\n\tdbg_fsbuild(\"trigger levels (size %d KiB, block size %d KiB, %d blocks)\\n\",\n\t\t    c->flash_size / 1024, c->sector_size / 1024, c->nr_blocks);\n\tdbg_fsbuild(\"Blocks required to allow deletion:    %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_deletion, c->resv_blocks_deletion*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to allow writes:      %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_write, c->resv_blocks_write*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to quiesce GC thread: %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gctrigger, c->resv_blocks_gctrigger*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to allow GC merges:   %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gcmerge, c->resv_blocks_gcmerge*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to GC bad blocks:     %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gcbad, c->resv_blocks_gcbad*c->sector_size/1024);\n\tdbg_fsbuild(\"Amount of dirty space required to GC: %d bytes\\n\",\n\t\t  c->nospc_dirty_size);\n\tdbg_fsbuild(\"Very dirty blocks before GC triggered: %d\\n\",\n\t\t  c->vdirty_blocks_gctrigger);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ery dirty blocks before GC triggered: %d\\n\",",
            ">vdirty_blocks_gctrigger);"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "mount of dirty space required to GC: %d bytes\\n\",",
            ">nospc_dirty_size);"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "locks required to GC bad blocks:     %d (%d KiB)\\n\",",
            ">resv_blocks_gcbad,",
            ">resv_blocks_gcbad*c->sector_size/1024);"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "locks required to allow GC merges:   %d (%d KiB)\\n\",",
            ">resv_blocks_gcmerge,",
            ">resv_blocks_gcmerge*c->sector_size/1024);"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "locks required to quiesce GC thread: %d (%d KiB)\\n\",",
            ">resv_blocks_gctrigger,",
            ">resv_blocks_gctrigger*c->sector_size/1024);"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "locks required to allow writes:      %d (%d KiB)\\n\",",
            ">resv_blocks_write,",
            ">resv_blocks_write*c->sector_size/1024);"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "locks required to allow deletion:    %d (%d KiB)\\n\",",
            ">resv_blocks_deletion,",
            ">resv_blocks_deletion*c->sector_size/1024);"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "rigger levels (size %d KiB, block size %d KiB, %d blocks)\\n\",",
            ">flash_size / 1024,",
            ">sector_size / 1024,",
            ">nr_blocks);"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_can_mark_obsolete(c",
          "args": [
            ")"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_calc_trigger_levels(struct jffs2_sb_info *c)\n{\n\tuint32_t size;\n\n\t/* Deletion should almost _always_ be allowed. We're fairly\n\t   buggered once we stop allowing people to delete stuff\n\t   because there's not enough free space... */\n\tc->resv_blocks_deletion = 2;\n\n\t/* Be conservative about how much space we need before we allow writes.\n\t   On top of that which is required for deletia, require an extra 2%\n\t   of the medium to be available, for overhead caused by nodes being\n\t   split across blocks, etc. */\n\n\tsize = c->flash_size / 50; /* 2% of flash size */\n\tsize += c->nr_blocks * 100; /* And 100 bytes per eraseblock */\n\tsize += c->sector_size - 1; /* ... and round up */\n\n\tc->resv_blocks_write = c->resv_blocks_deletion + (size / c->sector_size);\n\n\t/* When do we let the GC thread run in the background */\n\n\tc->resv_blocks_gctrigger = c->resv_blocks_write + 1;\n\n\t/* When do we allow garbage collection to merge nodes to make\n\t   long-term progress at the expense of short-term space exhaustion? */\n\tc->resv_blocks_gcmerge = c->resv_blocks_deletion + 1;\n\n\t/* When do we allow garbage collection to eat from bad blocks rather\n\t   than actually making progress? */\n\tc->resv_blocks_gcbad = 0;//c->resv_blocks_deletion + 2;\n\n\t/* What number of 'very dirty' eraseblocks do we allow before we\n\t   trigger the GC thread even if we don't _need_ the space. When we\n\t   can't mark nodes obsolete on the medium, the old dirty nodes cause\n\t   performance problems because we have to inspect and discard them. */\n\tc->vdirty_blocks_gctrigger = c->resv_blocks_gctrigger;\n\tif (jffs2_can_mark_obsolete(c))\n\t\tc->vdirty_blocks_gctrigger *= 10;\n\n\t/* If there's less than this amount of dirty space, don't bother\n\t   trying to GC to make more space. It'll be a fruitless task */\n\tc->nospc_dirty_size = c->sector_size + (c->flash_size / 100);\n\n\tdbg_fsbuild(\"trigger levels (size %d KiB, block size %d KiB, %d blocks)\\n\",\n\t\t    c->flash_size / 1024, c->sector_size / 1024, c->nr_blocks);\n\tdbg_fsbuild(\"Blocks required to allow deletion:    %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_deletion, c->resv_blocks_deletion*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to allow writes:      %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_write, c->resv_blocks_write*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to quiesce GC thread: %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gctrigger, c->resv_blocks_gctrigger*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to allow GC merges:   %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gcmerge, c->resv_blocks_gcmerge*c->sector_size/1024);\n\tdbg_fsbuild(\"Blocks required to GC bad blocks:     %d (%d KiB)\\n\",\n\t\t  c->resv_blocks_gcbad, c->resv_blocks_gcbad*c->sector_size/1024);\n\tdbg_fsbuild(\"Amount of dirty space required to GC: %d bytes\\n\",\n\t\t  c->nospc_dirty_size);\n\tdbg_fsbuild(\"Very dirty blocks before GC triggered: %d\\n\",\n\t\t  c->vdirty_blocks_gctrigger);\n}"
  },
  {
    "function_name": "fs2_build_remove_unlinked_inode(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "195-266",
    "snippet": "atic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *c,\n\t\t\t\t\tstruct jffs2_inode_cache *ic,\n\t\t\t\t\tstruct jffs2_full_dirent **dead_fds)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_fsbuild(\"removing ino #%u with nlink == zero.\\n\", ic->ino);\n\n\traw = ic->nodes;\n\twhile (raw != (void *)ic) {\n\t\tstruct jffs2_raw_node_ref *next = raw->next_in_ino;\n\t\tdbg_fsbuild(\"obsoleting node at 0x%08x\\n\", ref_offset(raw));\n\t\tjffs2_mark_node_obsolete(c, raw);\n\t\traw = next;\n\t}\n\n\tif (ic->scan_dents) {\n\t\tint whinged = 0;\n\t\tdbg_fsbuild(\"inode #%u was a directory which may have children...\\n\", ic->ino);\n\n\t\twhile(ic->scan_dents) {\n\t\t\tstruct jffs2_inode_cache *child_ic;\n\n\t\t\tfd = ic->scan_dents;\n\t\t\tic->scan_dents = fd->next;\n\n\t\t\tif (!fd->ino) {\n\t\t\t\t/* It's a deletion dirent. Ignore it */\n\t\t\t\tdbg_fsbuild(\"child \\\"%s\\\" is a deletion dirent, skipping...\\n\", fd->name);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!whinged)\n\t\t\t\twhinged = 1;\n\n\t\t\tdbg_fsbuild(\"removing child \\\"%s\\\", ino #%u\\n\", fd->name, fd->ino);\n\n\t\t\tchild_ic = jffs2_get_ino_cache(c, fd->ino);\n\t\t\tif (!child_ic) {\n\t\t\t\tdbg_fsbuild(\"cannot remove child \\\"%s\\\", ino #%u, because it doesn't exist\\n\",\n\t\t\t\t\t\tfd->name, fd->ino);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Reduce nlink of the child. If it's now zero, stick it on the\n\t\t\t   dead_fds list to be cleaned up later. Else just free the fd */\n\n\t\t\tif (fd->type == DT_DIR)\n\t\t\t\tchild_ic->pino_nlink = 0;\n\t\t\telse\n\t\t\t\tchild_ic->pino_nlink--;\n\n\t\t\tif (!child_ic->pino_nlink) {\n\t\t\t\tdbg_fsbuild(\"inode #%u (\\\"%s\\\") now has no links; adding to dead_fds list.\\n\",\n\t\t\t\t\t  fd->ino, fd->name);\n\t\t\t\tfd->next = *dead_fds;\n\t\t\t\t*dead_fds = fd;\n\t\t\t} else {\n\t\t\t\tdbg_fsbuild(\"inode #%u (\\\"%s\\\") has now got nlink %d. Ignoring.\\n\",\n\t\t\t\t\t  fd->ino, fd->name, child_ic->pino_nlink);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t   We don't delete the inocache from the hash list and free it yet.\n\t   The erase code will do that, when all the nodes are completely gone.\n\t*/\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "node #%u (\\\"%s\\\") has now got nlink %d. Ignoring.\\n\",",
            "->ino,",
            "->name,",
            "ild_ic->pino_nlink);"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "node #%u (\\\"%s\\\") now has no links; adding to dead_fds list.\\n\",",
            "->ino,",
            "->name);"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "annot remove child \\\"%s\\\", ino #%u, because it doesn't exist\\n\",",
            "->name,",
            "->ino);"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_get_ino_cache(c",
          "args": [
            "->ino);"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "emoving child \\\"%s\\\", ino #%u\\n\",",
            "->name,",
            "->ino);"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "hild \\\"%s\\\" is a deletion dirent, skipping...\\n\",",
            "->name);"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "node #%u was a directory which may have children...\\n\",",
            "->ino);"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "w);"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "bsoleting node at 0x%08x\\n\",",
            "f_offset(raw));"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "emoving ino #%u with nlink == zero.\\n\",",
            "->ino);"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);\n\natic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *c,\n\t\t\t\t\tstruct jffs2_inode_cache *ic,\n\t\t\t\t\tstruct jffs2_full_dirent **dead_fds)\n{\n\tstruct jffs2_raw_node_ref *raw;\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_fsbuild(\"removing ino #%u with nlink == zero.\\n\", ic->ino);\n\n\traw = ic->nodes;\n\twhile (raw != (void *)ic) {\n\t\tstruct jffs2_raw_node_ref *next = raw->next_in_ino;\n\t\tdbg_fsbuild(\"obsoleting node at 0x%08x\\n\", ref_offset(raw));\n\t\tjffs2_mark_node_obsolete(c, raw);\n\t\traw = next;\n\t}\n\n\tif (ic->scan_dents) {\n\t\tint whinged = 0;\n\t\tdbg_fsbuild(\"inode #%u was a directory which may have children...\\n\", ic->ino);\n\n\t\twhile(ic->scan_dents) {\n\t\t\tstruct jffs2_inode_cache *child_ic;\n\n\t\t\tfd = ic->scan_dents;\n\t\t\tic->scan_dents = fd->next;\n\n\t\t\tif (!fd->ino) {\n\t\t\t\t/* It's a deletion dirent. Ignore it */\n\t\t\t\tdbg_fsbuild(\"child \\\"%s\\\" is a deletion dirent, skipping...\\n\", fd->name);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!whinged)\n\t\t\t\twhinged = 1;\n\n\t\t\tdbg_fsbuild(\"removing child \\\"%s\\\", ino #%u\\n\", fd->name, fd->ino);\n\n\t\t\tchild_ic = jffs2_get_ino_cache(c, fd->ino);\n\t\t\tif (!child_ic) {\n\t\t\t\tdbg_fsbuild(\"cannot remove child \\\"%s\\\", ino #%u, because it doesn't exist\\n\",\n\t\t\t\t\t\tfd->name, fd->ino);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Reduce nlink of the child. If it's now zero, stick it on the\n\t\t\t   dead_fds list to be cleaned up later. Else just free the fd */\n\n\t\t\tif (fd->type == DT_DIR)\n\t\t\t\tchild_ic->pino_nlink = 0;\n\t\t\telse\n\t\t\t\tchild_ic->pino_nlink--;\n\n\t\t\tif (!child_ic->pino_nlink) {\n\t\t\t\tdbg_fsbuild(\"inode #%u (\\\"%s\\\") now has no links; adding to dead_fds list.\\n\",\n\t\t\t\t\t  fd->ino, fd->name);\n\t\t\t\tfd->next = *dead_fds;\n\t\t\t\t*dead_fds = fd;\n\t\t\t} else {\n\t\t\t\tdbg_fsbuild(\"inode #%u (\\\"%s\\\") has now got nlink %d. Ignoring.\\n\",\n\t\t\t\t\t  fd->ino, fd->name, child_ic->pino_nlink);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t   We don't delete the inocache from the hash list and free it yet.\n\t   The erase code will do that, when all the nodes are completely gone.\n\t*/\n}"
  },
  {
    "function_name": "fs2_build_filesystem(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "95-193",
    "snippet": "atic int jffs2_build_filesystem(struct jffs2_sb_info *c)\n{\n\tint ret;\n\tint i;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_full_dirent *dead_fds = NULL;\n\n\tdbg_fsbuild(\"build FS data structures\\n\");\n\n\t/* First, scan the medium and build all the inode caches with\n\t   lists of physical nodes */\n\n\tc->flags |= JFFS2_SB_FLAG_SCANNING;\n\tret = jffs2_scan_medium(c);\n\tc->flags &= ~JFFS2_SB_FLAG_SCANNING;\n\tif (ret)\n\t\tgoto exit;\n\n\tdbg_fsbuild(\"scanned flash completely\\n\");\n\tjffs2_dbg_dump_block_lists_nolock(c);\n\n\tdbg_fsbuild(\"pass 1 starting\\n\");\n\tc->flags |= JFFS2_SB_FLAG_BUILDING;\n\t/* Now scan the directory tree, increasing nlink according to every dirent found. */\n\tfor_each_inode(i, c, ic) {\n\t\tif (ic->scan_dents) {\n\t\t\tjffs2_build_inode_pass1(c, ic);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tdbg_fsbuild(\"pass 1 complete\\n\");\n\n\t/* Next, scan for inodes with nlink == 0 and remove them. If\n\t   they were directories, then decrement the nlink of their\n\t   children too, and repeat the scan. As that's going to be\n\t   a fairly uncommon occurrence, it's not so evil to do it this\n\t   way. Recursion bad. */\n\tdbg_fsbuild(\"pass 2 starting\\n\");\n\n\tfor_each_inode(i, c, ic) {\n\t\tif (ic->pino_nlink)\n\t\t\tcontinue;\n\n\t\tjffs2_build_remove_unlinked_inode(c, ic, &dead_fds);\n\t\tcond_resched();\n\t}\n\n\tdbg_fsbuild(\"pass 2a starting\\n\");\n\n\twhile (dead_fds) {\n\t\tfd = dead_fds;\n\t\tdead_fds = fd->next;\n\n\t\tic = jffs2_get_ino_cache(c, fd->ino);\n\n\t\tif (ic)\n\t\t\tjffs2_build_remove_unlinked_inode(c, ic, &dead_fds);\n\t\tjffs2_free_full_dirent(fd);\n\t}\n\n\tdbg_fsbuild(\"pass 2a complete\\n\");\n\tdbg_fsbuild(\"freeing temporary data structures\\n\");\n\n\t/* Finally, we can scan again and free the dirent structs */\n\tfor_each_inode(i, c, ic) {\n\t\twhile(ic->scan_dents) {\n\t\t\tfd = ic->scan_dents;\n\t\t\tic->scan_dents = fd->next;\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t}\n\t\tic->scan_dents = NULL;\n\t\tcond_resched();\n\t}\n\tjffs2_build_xattr_subsystem(c);\n\tc->flags &= ~JFFS2_SB_FLAG_BUILDING;\n\n\tdbg_fsbuild(\"FS build complete\\n\");\n\n\t/* Rotate the lists by some number to ensure wear levelling */\n\tjffs2_rotate_lists(c);\n\n\tret = 0;\n\nexit:\n\tif (ret) {\n\t\tfor_each_inode(i, c, ic) {\n\t\t\twhile(ic->scan_dents) {\n\t\t\t\tfd = ic->scan_dents;\n\t\t\t\tic->scan_dents = fd->next;\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t}\n\t\tjffs2_clear_xattr_subsystem(c);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_clear_xattr_subsystem(c",
          "args": [
            ";"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_each_inode(i",
          "args": [
            ")"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_rotate_lists(c",
          "args": [
            ";"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "S build complete\\n\");"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_build_xattr_subsystem(c",
          "args": [
            ";"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_resched()",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_each_inode(i",
          "args": [
            ")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "reeing temporary data structures\\n\");"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ass 2a complete\\n\");"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_build_remove_unlinked_inode(c",
          "args": [
            ",",
            "ead_fds);"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_get_ino_cache(c",
          "args": [
            "->ino);"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ass 2a starting\\n\");"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_resched()",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_build_remove_unlinked_inode(c",
          "args": [
            ",",
            "ead_fds);"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_each_inode(i",
          "args": [
            ")"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ass 2 starting\\n\");"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ass 1 complete\\n\");"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_resched()",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_build_inode_pass1(c",
          "args": [
            ");"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_each_inode(i",
          "args": [
            ")"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ass 1 starting\\n\");"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_dump_block_lists_nolock(c",
          "args": [
            ";"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "canned flash completely\\n\");"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_scan_medium(c",
          "args": [
            ";"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "uild FS data structures\\n\");"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);\n\natic int jffs2_build_filesystem(struct jffs2_sb_info *c)\n{\n\tint ret;\n\tint i;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_full_dirent *dead_fds = NULL;\n\n\tdbg_fsbuild(\"build FS data structures\\n\");\n\n\t/* First, scan the medium and build all the inode caches with\n\t   lists of physical nodes */\n\n\tc->flags |= JFFS2_SB_FLAG_SCANNING;\n\tret = jffs2_scan_medium(c);\n\tc->flags &= ~JFFS2_SB_FLAG_SCANNING;\n\tif (ret)\n\t\tgoto exit;\n\n\tdbg_fsbuild(\"scanned flash completely\\n\");\n\tjffs2_dbg_dump_block_lists_nolock(c);\n\n\tdbg_fsbuild(\"pass 1 starting\\n\");\n\tc->flags |= JFFS2_SB_FLAG_BUILDING;\n\t/* Now scan the directory tree, increasing nlink according to every dirent found. */\n\tfor_each_inode(i, c, ic) {\n\t\tif (ic->scan_dents) {\n\t\t\tjffs2_build_inode_pass1(c, ic);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tdbg_fsbuild(\"pass 1 complete\\n\");\n\n\t/* Next, scan for inodes with nlink == 0 and remove them. If\n\t   they were directories, then decrement the nlink of their\n\t   children too, and repeat the scan. As that's going to be\n\t   a fairly uncommon occurrence, it's not so evil to do it this\n\t   way. Recursion bad. */\n\tdbg_fsbuild(\"pass 2 starting\\n\");\n\n\tfor_each_inode(i, c, ic) {\n\t\tif (ic->pino_nlink)\n\t\t\tcontinue;\n\n\t\tjffs2_build_remove_unlinked_inode(c, ic, &dead_fds);\n\t\tcond_resched();\n\t}\n\n\tdbg_fsbuild(\"pass 2a starting\\n\");\n\n\twhile (dead_fds) {\n\t\tfd = dead_fds;\n\t\tdead_fds = fd->next;\n\n\t\tic = jffs2_get_ino_cache(c, fd->ino);\n\n\t\tif (ic)\n\t\t\tjffs2_build_remove_unlinked_inode(c, ic, &dead_fds);\n\t\tjffs2_free_full_dirent(fd);\n\t}\n\n\tdbg_fsbuild(\"pass 2a complete\\n\");\n\tdbg_fsbuild(\"freeing temporary data structures\\n\");\n\n\t/* Finally, we can scan again and free the dirent structs */\n\tfor_each_inode(i, c, ic) {\n\t\twhile(ic->scan_dents) {\n\t\t\tfd = ic->scan_dents;\n\t\t\tic->scan_dents = fd->next;\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t}\n\t\tic->scan_dents = NULL;\n\t\tcond_resched();\n\t}\n\tjffs2_build_xattr_subsystem(c);\n\tc->flags &= ~JFFS2_SB_FLAG_BUILDING;\n\n\tdbg_fsbuild(\"FS build complete\\n\");\n\n\t/* Rotate the lists by some number to ensure wear levelling */\n\tjffs2_rotate_lists(c);\n\n\tret = 0;\n\nexit:\n\tif (ret) {\n\t\tfor_each_inode(i, c, ic) {\n\t\t\twhile(ic->scan_dents) {\n\t\t\t\tfd = ic->scan_dents;\n\t\t\t\tic->scan_dents = fd->next;\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t}\n\t\tjffs2_clear_xattr_subsystem(c);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_build_inode_pass1(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "51-88",
    "snippet": "atic void jffs2_build_inode_pass1(struct jffs2_sb_info *c,\n\t\t\t\t    struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_fsbuild(\"building directory inode #%u\\n\", ic->ino);\n\n\t/* For each child, increase nlink */\n\tfor(fd = ic->scan_dents; fd; fd = fd->next) {\n\t\tstruct jffs2_inode_cache *child_ic;\n\t\tif (!fd->ino)\n\t\t\tcontinue;\n\n\t\t/* we can get high latency here with huge directories */\n\n\t\tchild_ic = jffs2_get_ino_cache(c, fd->ino);\n\t\tif (!child_ic) {\n\t\t\tdbg_fsbuild(\"child \\\"%s\\\" (ino #%u) of dir ino #%u doesn't exist!\\n\",\n\t\t\t\t  fd->name, fd->ino, ic->ino);\n\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd->type == DT_DIR) {\n\t\t\tif (child_ic->pino_nlink) {\n\t\t\t\tJFFS2_ERROR(\"child dir \\\"%s\\\" (ino #%u) of dir ino #%u appears to be a hard link\\n\",\n\t\t\t\t\t    fd->name, fd->ino, ic->ino);\n\t\t\t\t/* TODO: What do we do about it? */\n\t\t\t} else {\n\t\t\t\tchild_ic->pino_nlink = ic->ino;\n\t\t\t}\n\t\t} else\n\t\t\tchild_ic->pino_nlink++;\n\n\t\tdbg_fsbuild(\"increased nlink for child \\\"%s\\\" (ino #%u)\\n\", fd->name, fd->ino);\n\t\t/* Can't free scan_dents so far. We might need them in pass 2 */\n\t}\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "ncreased nlink for child \\\"%s\\\" (ino #%u)\\n\",",
            "->name,",
            "->ino);"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_ERROR(\"",
          "args": [
            "hild dir \\\"%s\\\" (ino #%u) of dir ino #%u appears to be a hard link\\n\",",
            "->name,",
            "->ino,",
            "->ino);"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "->raw);"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "hild \\\"%s\\\" (ino #%u) of dir ino #%u doesn't exist!\\n\",",
            "->name,",
            "->ino,",
            "->ino);"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_get_ino_cache(c",
          "args": [
            "->ino);"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_fsbuild(\"",
          "args": [
            "uilding directory inode #%u\\n\",",
            "->ino);"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,\n\t\tstruct jffs2_inode_cache *, struct jffs2_full_dirent **);\n\natic void jffs2_build_inode_pass1(struct jffs2_sb_info *c,\n\t\t\t\t    struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_fsbuild(\"building directory inode #%u\\n\", ic->ino);\n\n\t/* For each child, increase nlink */\n\tfor(fd = ic->scan_dents; fd; fd = fd->next) {\n\t\tstruct jffs2_inode_cache *child_ic;\n\t\tif (!fd->ino)\n\t\t\tcontinue;\n\n\t\t/* we can get high latency here with huge directories */\n\n\t\tchild_ic = jffs2_get_ino_cache(c, fd->ino);\n\t\tif (!child_ic) {\n\t\t\tdbg_fsbuild(\"child \\\"%s\\\" (ino #%u) of dir ino #%u doesn't exist!\\n\",\n\t\t\t\t  fd->name, fd->ino, ic->ino);\n\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd->type == DT_DIR) {\n\t\t\tif (child_ic->pino_nlink) {\n\t\t\t\tJFFS2_ERROR(\"child dir \\\"%s\\\" (ino #%u) of dir ino #%u appears to be a hard link\\n\",\n\t\t\t\t\t    fd->name, fd->ino, ic->ino);\n\t\t\t\t/* TODO: What do we do about it? */\n\t\t\t} else {\n\t\t\t\tchild_ic->pino_nlink = ic->ino;\n\t\t\t}\n\t\t} else\n\t\t\tchild_ic->pino_nlink++;\n\n\t\tdbg_fsbuild(\"increased nlink for child \\\"%s\\\" (ino #%u)\\n\", fd->name, fd->ino);\n\t\t/* Can't free scan_dents so far. We might need them in pass 2 */\n\t}\n}"
  },
  {
    "function_name": "xt_inode(i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "35-43",
    "snippet": "atic inline struct jffs2_inode_cache *\nnext_inode(int *i, struct jffs2_inode_cache *ic, struct jffs2_sb_info *c)\n{\n\t/* More in this chain? */\n\tif (ic->next)\n\t\treturn ic->next;\n\t(*i)++;\n\treturn first_inode_chain(i, c);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rst_inode_chain(i",
          "args": [
            ";"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic inline struct jffs2_inode_cache *\nnext_inode(int *i, struct jffs2_inode_cache *ic, struct jffs2_sb_info *c)\n{\n\t/* More in this chain? */\n\tif (ic->next)\n\t\treturn ic->next;\n\t(*i)++;\n\treturn first_inode_chain(i, c);\n}"
  },
  {
    "function_name": "rst_inode_chain(i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/build.c",
    "lines": "25-33",
    "snippet": "atic inline struct jffs2_inode_cache *\nfirst_inode_chain(int *i, struct jffs2_sb_info *c)\n{\n\tfor (; *i < c->inocache_hashsize; (*i)++) {\n\t\tif (c->inocache_list[*i])\n\t\t\treturn c->inocache_list[*i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic inline struct jffs2_inode_cache *\nfirst_inode_chain(int *i, struct jffs2_sb_info *c)\n{\n\tfor (; *i < c->inocache_hashsize; (*i)++) {\n\t\tif (c->inocache_list[*i])\n\t\t\treturn c->inocache_list[*i];\n\t}\n\treturn NULL;\n}"
  }
]