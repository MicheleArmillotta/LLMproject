[
  {
    "function_name": "sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/mount.c",
    "lines": "64-82",
    "snippet": "int __init sysfs_init(void)\n{\n\tint err;\n\n\tsysfs_root = kernfs_create_root(NULL, KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(sysfs_root))\n\t\treturn PTR_ERR(sysfs_root);\n\n\tsysfs_root_kn = sysfs_root->kn;\n\n\terr = register_filesystem(&sysfs_fs_type);\n\tif (err) {\n\t\tkernfs_destroy_root(sysfs_root);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kernfs_root *sysfs_root;",
      "struct kernfs_node *sysfs_root_kn;",
      "static struct file_system_type sysfs_fs_type = {\n\t.name\t\t= \"sysfs\",\n\t.mount\t\t= sysfs_mount,\n\t.kill_sb\t= sysfs_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_destroy_root",
          "args": [
            "sysfs_root"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_destroy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "739-742",
          "snippet": "void kernfs_destroy_root(struct kernfs_root *root)\n{\n\tkernfs_remove(root->kn);\t/* will also free @root */\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_destroy_root(struct kernfs_root *root)\n{\n\tkernfs_remove(root->kn);\t/* will also free @root */\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&sysfs_fs_type"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sysfs_root"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sysfs_root"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_root",
          "args": [
            "NULL",
            "KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK",
            "NULL"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_create_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "697-730",
          "snippet": "struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,\n\t\t\t\t       unsigned int flags, void *priv)\n{\n\tstruct kernfs_root *root;\n\tstruct kernfs_node *kn;\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tida_init(&root->ino_ida);\n\tINIT_LIST_HEAD(&root->supers);\n\n\tkn = __kernfs_new_node(root, \"\", S_IFDIR | S_IRUGO | S_IXUGO,\n\t\t\t       KERNFS_DIR);\n\tif (!kn) {\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkn->priv = priv;\n\tkn->dir.root = root;\n\n\troot->syscall_ops = scops;\n\troot->flags = flags;\n\troot->kn = kn;\n\tinit_waitqueue_head(&root->deactivate_waitq);\n\n\tif (!(root->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\n\treturn root;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,\n\t\t\t\t       unsigned int flags, void *priv)\n{\n\tstruct kernfs_root *root;\n\tstruct kernfs_node *kn;\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tida_init(&root->ino_ida);\n\tINIT_LIST_HEAD(&root->supers);\n\n\tkn = __kernfs_new_node(root, \"\", S_IFDIR | S_IRUGO | S_IXUGO,\n\t\t\t       KERNFS_DIR);\n\tif (!kn) {\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkn->priv = priv;\n\tkn->dir.root = root;\n\n\troot->syscall_ops = scops;\n\troot->flags = flags;\n\troot->kn = kn;\n\tinit_waitqueue_head(&root->deactivate_waitq);\n\n\tif (!(root->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_root *sysfs_root;\nstruct kernfs_node *sysfs_root_kn;\nstatic struct file_system_type sysfs_fs_type = {\n\t.name\t\t= \"sysfs\",\n\t.mount\t\t= sysfs_mount,\n\t.kill_sb\t= sysfs_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};\n\nint __init sysfs_init(void)\n{\n\tint err;\n\n\tsysfs_root = kernfs_create_root(NULL, KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK,\n\t\t\t\t\tNULL);\n\tif (IS_ERR(sysfs_root))\n\t\treturn PTR_ERR(sysfs_root);\n\n\tsysfs_root_kn = sysfs_root->kn;\n\n\terr = register_filesystem(&sysfs_fs_type);\n\tif (err) {\n\t\tkernfs_destroy_root(sysfs_root);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sysfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/mount.c",
    "lines": "49-55",
    "snippet": "static void sysfs_kill_sb(struct super_block *sb)\n{\n\tvoid *ns = (void *)kernfs_super_ns(sb);\n\n\tkernfs_kill_sb(sb);\n\tkobj_ns_drop(KOBJ_NS_TYPE_NET, ns);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobj_ns_drop",
          "args": [
            "KOBJ_NS_TYPE_NET",
            "ns"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_kill_sb",
          "args": [
            "sb"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_kill_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
          "lines": "196-212",
          "snippet": "void kernfs_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_node *root_kn = sb->s_root->d_fsdata;\n\n\tmutex_lock(&kernfs_mutex);\n\tlist_del(&info->node);\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Remove the superblock from fs_supers/s_instances\n\t * so we can't find it, before freeing kernfs_super_info.\n\t */\n\tkill_anon_super(sb);\n\tkfree(info);\n\tkernfs_put(root_kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid kernfs_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\tstruct kernfs_node *root_kn = sb->s_root->d_fsdata;\n\n\tmutex_lock(&kernfs_mutex);\n\tlist_del(&info->node);\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Remove the superblock from fs_supers/s_instances\n\t * so we can't find it, before freeing kernfs_super_info.\n\t */\n\tkill_anon_super(sb);\n\tkfree(info);\n\tkernfs_put(root_kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_super_ns",
          "args": [
            "sb"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_super_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
          "lines": "123-128",
          "snippet": "const void *kernfs_super_ns(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\treturn info->ns;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst void *kernfs_super_ns(struct super_block *sb)\n{\n\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\treturn info->ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic void sysfs_kill_sb(struct super_block *sb)\n{\n\tvoid *ns = (void *)kernfs_super_ns(sb);\n\n\tkernfs_kill_sb(sb);\n\tkobj_ns_drop(KOBJ_NS_TYPE_NET, ns);\n}"
  },
  {
    "function_name": "sysfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/mount.c",
    "lines": "26-47",
    "snippet": "static struct dentry *sysfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *root;\n\tvoid *ns;\n\tbool new_sb;\n\n\tif (!(flags & MS_KERNMOUNT)) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tns = kobj_ns_grab_current(KOBJ_NS_TYPE_NET);\n\troot = kernfs_mount_ns(fs_type, flags, sysfs_root,\n\t\t\t\tSYSFS_MAGIC, &new_sb, ns);\n\tif (IS_ERR(root) || !new_sb)\n\t\tkobj_ns_drop(KOBJ_NS_TYPE_NET, ns);\n\treturn root;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/init.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kernfs_root *sysfs_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobj_ns_drop",
          "args": [
            "KOBJ_NS_TYPE_NET",
            "ns"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_mount_ns",
          "args": [
            "fs_type",
            "flags",
            "sysfs_root",
            "SYSFS_MAGIC",
            "&new_sb",
            "ns"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_mount_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
          "lines": "146-186",
          "snippet": "struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,\n\t\t\t\tstruct kernfs_root *root, unsigned long magic,\n\t\t\t\tbool *new_sb_created, const void *ns)\n{\n\tstruct super_block *sb;\n\tstruct kernfs_super_info *info;\n\tint error;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->root = root;\n\tinfo->ns = ns;\n\n\tsb = sget(fs_type, kernfs_test_super, kernfs_set_super, flags, info);\n\tif (IS_ERR(sb) || sb->s_fs_info != info)\n\t\tkfree(info);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (new_sb_created)\n\t\t*new_sb_created = !sb->s_root;\n\n\tif (!sb->s_root) {\n\t\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\t\terror = kernfs_fill_super(sb, magic);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\tsb->s_flags |= MS_ACTIVE;\n\n\t\tmutex_lock(&kernfs_mutex);\n\t\tlist_add(&info->node, &root->supers);\n\t\tmutex_unlock(&kernfs_mutex);\n\t}\n\n\treturn dget(sb->s_root);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,\n\t\t\t\tstruct kernfs_root *root, unsigned long magic,\n\t\t\t\tbool *new_sb_created, const void *ns)\n{\n\tstruct super_block *sb;\n\tstruct kernfs_super_info *info;\n\tint error;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->root = root;\n\tinfo->ns = ns;\n\n\tsb = sget(fs_type, kernfs_test_super, kernfs_set_super, flags, info);\n\tif (IS_ERR(sb) || sb->s_fs_info != info)\n\t\tkfree(info);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (new_sb_created)\n\t\t*new_sb_created = !sb->s_root;\n\n\tif (!sb->s_root) {\n\t\tstruct kernfs_super_info *info = kernfs_info(sb);\n\n\t\terror = kernfs_fill_super(sb, magic);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\tsb->s_flags |= MS_ACTIVE;\n\n\t\tmutex_lock(&kernfs_mutex);\n\t\tlist_add(&info->node, &root->supers);\n\t\tmutex_unlock(&kernfs_mutex);\n\t}\n\n\treturn dget(sb->s_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobj_ns_grab_current",
          "args": [
            "KOBJ_NS_TYPE_NET"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj_ns_current_may_mount",
          "args": [
            "KOBJ_NS_TYPE_NET"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_fully_visible",
          "args": [
            "fs_type"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "fs_fully_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3140-3172",
          "snippet": "bool fs_fully_visible(struct file_system_type *type)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool visible = false;\n\n\tif (unlikely(!ns))\n\t\treturn false;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tstruct mount *child;\n\t\tif (mnt->mnt.mnt_sb->s_type != type)\n\t\t\tcontinue;\n\n\t\t/* This mount is not fully visible if there are any child mounts\n\t\t * that cover anything except for empty directories.\n\t\t */\n\t\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\t\tstruct inode *inode = child->mnt_mountpoint->d_inode;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tgoto next;\n\t\t\tif (inode->i_nlink > 2)\n\t\t\t\tgoto next;\n\t\t}\n\t\tvisible = true;\n\t\tgoto found;\n\tnext:\t;\n\t}\nfound:\n\tup_read(&namespace_sem);\n\treturn visible;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nbool fs_fully_visible(struct file_system_type *type)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool visible = false;\n\n\tif (unlikely(!ns))\n\t\treturn false;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tstruct mount *child;\n\t\tif (mnt->mnt.mnt_sb->s_type != type)\n\t\t\tcontinue;\n\n\t\t/* This mount is not fully visible if there are any child mounts\n\t\t * that cover anything except for empty directories.\n\t\t */\n\t\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\t\tstruct inode *inode = child->mnt_mountpoint->d_inode;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tgoto next;\n\t\t\tif (inode->i_nlink > 2)\n\t\t\t\tgoto next;\n\t\t}\n\t\tvisible = true;\n\t\tgoto found;\n\tnext:\t;\n\t}\nfound:\n\tup_read(&namespace_sem);\n\treturn visible;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_root *sysfs_root;\n\nstatic struct dentry *sysfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *root;\n\tvoid *ns;\n\tbool new_sb;\n\n\tif (!(flags & MS_KERNMOUNT)) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tns = kobj_ns_grab_current(KOBJ_NS_TYPE_NET);\n\troot = kernfs_mount_ns(fs_type, flags, sysfs_root,\n\t\t\t\tSYSFS_MAGIC, &new_sb, ns);\n\tif (IS_ERR(root) || !new_sb)\n\t\tkobj_ns_drop(KOBJ_NS_TYPE_NET, ns);\n\treturn root;\n}"
  }
]