[
  {
    "function_name": "journal_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2131-2140",
    "snippet": "static void __exit journal_exit(void)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tint n = atomic_read(&nr_journal_heads);\n\tif (n)\n\t\tprintk(KERN_ERR \"JBD: leaked %d journal_heads!\\n\", n);\n#endif\n\tjbd_remove_debugfs_entry();\n\tjournal_destroy_caches();\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_destroy_caches",
          "args": [],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2111-2116",
          "snippet": "static void journal_destroy_caches(void)\n{\n\tjournal_destroy_revoke_caches();\n\tjournal_destroy_journal_head_cache();\n\tjournal_destroy_handle_cache();\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_destroy_caches(void)\n{\n\tjournal_destroy_revoke_caches();\n\tjournal_destroy_journal_head_cache();\n\tjournal_destroy_handle_cache();\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_remove_debugfs_entry",
          "args": [],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "jbd_remove_debugfs_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2067-2069",
          "snippet": "static inline void jbd_remove_debugfs_entry(void)\n{\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic inline void jbd_remove_debugfs_entry(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: leaked %d journal_heads!\\n\"",
            "n"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_journal_heads"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __exit journal_exit(void)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tint n = atomic_read(&nr_journal_heads);\n\tif (n)\n\t\tprintk(KERN_ERR \"JBD: leaked %d journal_heads!\\n\", n);\n#endif\n\tjbd_remove_debugfs_entry();\n\tjournal_destroy_caches();\n}"
  },
  {
    "function_name": "journal_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2118-2129",
    "snippet": "static int __init journal_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct journal_superblock_s) != 1024);\n\n\tret = journal_init_caches();\n\tif (ret != 0)\n\t\tjournal_destroy_caches();\n\tjbd_create_debugfs_entry();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_create_debugfs_entry",
          "args": [],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "jbd_create_debugfs_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2063-2065",
          "snippet": "static inline void jbd_create_debugfs_entry(void)\n{\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic inline void jbd_create_debugfs_entry(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy_caches",
          "args": [],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2111-2116",
          "snippet": "static void journal_destroy_caches(void)\n{\n\tjournal_destroy_revoke_caches();\n\tjournal_destroy_journal_head_cache();\n\tjournal_destroy_handle_cache();\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_destroy_caches(void)\n{\n\tjournal_destroy_revoke_caches();\n\tjournal_destroy_journal_head_cache();\n\tjournal_destroy_handle_cache();\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_caches",
          "args": [],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2099-2109",
          "snippet": "static int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = journal_init_handle_cache();\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = journal_init_handle_cache();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct journal_superblock_s) != 1024"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __init journal_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct journal_superblock_s) != 1024);\n\n\tret = journal_init_caches();\n\tif (ret != 0)\n\t\tjournal_destroy_caches();\n\tjbd_create_debugfs_entry();\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_destroy_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2111-2116",
    "snippet": "static void journal_destroy_caches(void)\n{\n\tjournal_destroy_revoke_caches();\n\tjournal_destroy_journal_head_cache();\n\tjournal_destroy_handle_cache();\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_destroy_handle_cache",
          "args": [],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_handle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2089-2093",
          "snippet": "static void journal_destroy_handle_cache(void)\n{\n\tif (jbd_handle_cache)\n\t\tkmem_cache_destroy(jbd_handle_cache);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *jbd_handle_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd_handle_cache;\n\nstatic void journal_destroy_handle_cache(void)\n{\n\tif (jbd_handle_cache)\n\t\tkmem_cache_destroy(jbd_handle_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy_journal_head_cache",
          "args": [],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_journal_head_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1854-1860",
          "snippet": "static void journal_destroy_journal_head_cache(void)\n{\n\tif (journal_head_cache) {\n\t\tkmem_cache_destroy(journal_head_cache);\n\t\tjournal_head_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic void journal_destroy_journal_head_cache(void)\n{\n\tif (journal_head_cache) {\n\t\tkmem_cache_destroy(journal_head_cache);\n\t\tjournal_head_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_destroy_revoke_caches",
          "args": [],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "190-200",
          "snippet": "void journal_destroy_revoke_caches(void)\n{\n\tif (revoke_record_cache) {\n\t\tkmem_cache_destroy(revoke_record_cache);\n\t\trevoke_record_cache = NULL;\n\t}\n\tif (revoke_table_cache) {\n\t\tkmem_cache_destroy(revoke_table_cache);\n\t\trevoke_table_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;",
            "static struct kmem_cache *revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\nstatic struct kmem_cache *revoke_table_cache;\n\nvoid journal_destroy_revoke_caches(void)\n{\n\tif (revoke_record_cache) {\n\t\tkmem_cache_destroy(revoke_record_cache);\n\t\trevoke_record_cache = NULL;\n\t}\n\tif (revoke_table_cache) {\n\t\tkmem_cache_destroy(revoke_table_cache);\n\t\trevoke_table_cache = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_destroy_caches(void)\n{\n\tjournal_destroy_revoke_caches();\n\tjournal_destroy_journal_head_cache();\n\tjournal_destroy_handle_cache();\n}"
  },
  {
    "function_name": "journal_init_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2099-2109",
    "snippet": "static int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = journal_init_handle_cache();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_init_handle_cache",
          "args": [],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_handle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2075-2087",
          "snippet": "static int __init journal_init_handle_cache(void)\n{\n\tjbd_handle_cache = kmem_cache_create(\"journal_handle\",\n\t\t\t\tsizeof(handle_t),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tif (jbd_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *jbd_handle_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd_handle_cache;\n\nstatic int __init journal_init_handle_cache(void)\n{\n\tjbd_handle_cache = kmem_cache_create(\"journal_handle\",\n\t\t\t\tsizeof(handle_t),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tif (jbd_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_journal_head_cache",
          "args": [],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_journal_head_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1836-1852",
          "snippet": "static int journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(journal_head_cache == NULL);\n\tjournal_head_cache = kmem_cache_create(\"journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic int journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(journal_head_cache == NULL);\n\tjournal_head_cache = kmem_cache_create(\"journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_revoke_caches",
          "args": [],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_revoke_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "202-227",
          "snippet": "int __init journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!revoke_record_cache);\n\tJ_ASSERT(!revoke_table_cache);\n\n\trevoke_record_cache = kmem_cache_create(\"revoke_record\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_record_s),\n\t\t\t\t\t   0,\n\t\t\t\t\t   SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\t   NULL);\n\tif (!revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\trevoke_table_cache = kmem_cache_create(\"revoke_table\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_table_s),\n\t\t\t\t\t   0, SLAB_TEMPORARY, NULL);\n\tif (!revoke_table_cache)\n\t\tgoto table_cache_failure;\n\n\treturn 0;\n\ntable_cache_failure:\n\tjournal_destroy_revoke_caches();\nrecord_cache_failure:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;",
            "static struct kmem_cache *revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\nstatic struct kmem_cache *revoke_table_cache;\n\nint __init journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!revoke_record_cache);\n\tJ_ASSERT(!revoke_table_cache);\n\n\trevoke_record_cache = kmem_cache_create(\"revoke_record\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_record_s),\n\t\t\t\t\t   0,\n\t\t\t\t\t   SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\t   NULL);\n\tif (!revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\trevoke_table_cache = kmem_cache_create(\"revoke_table\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_table_s),\n\t\t\t\t\t   0, SLAB_TEMPORARY, NULL);\n\tif (!revoke_table_cache)\n\t\tgoto table_cache_failure;\n\n\treturn 0;\n\ntable_cache_failure:\n\tjournal_destroy_revoke_caches();\nrecord_cache_failure:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = journal_init_handle_cache();\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_destroy_handle_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2089-2093",
    "snippet": "static void journal_destroy_handle_cache(void)\n{\n\tif (jbd_handle_cache)\n\t\tkmem_cache_destroy(jbd_handle_cache);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *jbd_handle_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd_handle_cache"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd_handle_cache;\n\nstatic void journal_destroy_handle_cache(void)\n{\n\tif (jbd_handle_cache)\n\t\tkmem_cache_destroy(jbd_handle_cache);\n}"
  },
  {
    "function_name": "journal_init_handle_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2075-2087",
    "snippet": "static int __init journal_init_handle_cache(void)\n{\n\tjbd_handle_cache = kmem_cache_create(\"journal_handle\",\n\t\t\t\tsizeof(handle_t),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tif (jbd_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *jbd_handle_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"JBD: failed to create handle cache\\n\""
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"journal_handle\"",
            "sizeof(handle_t)",
            "0",
            "/* offset */SLAB_TEMPORARY",
            "/* flags */NULL"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd_handle_cache;\n\nstatic int __init journal_init_handle_cache(void)\n{\n\tjbd_handle_cache = kmem_cache_create(\"journal_handle\",\n\t\t\t\tsizeof(handle_t),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tif (jbd_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd_remove_debugfs_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2067-2069",
    "snippet": "static inline void jbd_remove_debugfs_entry(void)\n{\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic inline void jbd_remove_debugfs_entry(void)\n{\n}"
  },
  {
    "function_name": "jbd_create_debugfs_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2063-2065",
    "snippet": "static inline void jbd_create_debugfs_entry(void)\n{\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic inline void jbd_create_debugfs_entry(void)\n{\n}"
  },
  {
    "function_name": "jbd_remove_debugfs_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2055-2059",
    "snippet": "static void __exit jbd_remove_debugfs_entry(void)\n{\n\tdebugfs_remove(jbd_debug);\n\tdebugfs_remove(jbd_debugfs_dir);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "jbd_debugfs_dir"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __exit jbd_remove_debugfs_entry(void)\n{\n\tdebugfs_remove(jbd_debug);\n\tdebugfs_remove(jbd_debugfs_dir);\n}"
  },
  {
    "function_name": "jbd_create_debugfs_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2046-2053",
    "snippet": "static void __init jbd_create_debugfs_entry(void)\n{\n\tjbd_debugfs_dir = debugfs_create_dir(\"jbd\", NULL);\n\tif (jbd_debugfs_dir)\n\t\tjbd_debug = debugfs_create_u8(\"jbd-debug\", S_IRUGO | S_IWUSR,\n\t\t\t\t\t       jbd_debugfs_dir,\n\t\t\t\t\t       &journal_enable_debug);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_u8",
          "args": [
            "\"jbd-debug\"",
            "S_IRUGO | S_IWUSR",
            "jbd_debugfs_dir",
            "&journal_enable_debug"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/file.c",
          "lines": "95-106",
          "snippet": "struct dentry *debugfs_create_u8(const char *name, umode_t mode,\n\t\t\t\t struct dentry *parent, u8 *value)\n{\n\t/* if there are no write bits set, make read only */\n\tif (!(mode & S_IWUGO))\n\t\treturn debugfs_create_file(name, mode, parent, value, &fops_u8_ro);\n\t/* if there are no read bits set, make write only */\n\tif (!(mode & S_IRUGO))\n\t\treturn debugfs_create_file(name, mode, parent, value, &fops_u8_wo);\n\n\treturn debugfs_create_file(name, mode, parent, value, &fops_u8);\n}",
          "includes": [
            "#include <linux/device.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/device.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_u8(const char *name, umode_t mode,\n\t\t\t\t struct dentry *parent, u8 *value)\n{\n\t/* if there are no write bits set, make read only */\n\tif (!(mode & S_IWUGO))\n\t\treturn debugfs_create_file(name, mode, parent, value, &fops_u8_ro);\n\t/* if there are no read bits set, make write only */\n\tif (!(mode & S_IRUGO))\n\t\treturn debugfs_create_file(name, mode, parent, value, &fops_u8_wo);\n\n\treturn debugfs_create_file(name, mode, parent, value, &fops_u8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"jbd\"",
            "NULL"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __init jbd_create_debugfs_entry(void)\n{\n\tjbd_debugfs_dir = debugfs_create_dir(\"jbd\", NULL);\n\tif (jbd_debugfs_dir)\n\t\tjbd_debug = debugfs_create_u8(\"jbd-debug\", S_IRUGO | S_IWUSR,\n\t\t\t\t\t       jbd_debugfs_dir,\n\t\t\t\t\t       &journal_enable_debug);\n}"
  },
  {
    "function_name": "journal_put_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "2020-2033",
    "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_remove_journal_head",
          "args": [
            "bh"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1990-2014",
          "snippet": "static void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jcount > 0"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
  },
  {
    "function_name": "__journal_remove_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1990-2014",
    "snippet": "static void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_free_journal_head",
          "args": [
            "jh"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "journal_free_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1886-1893",
          "snippet": "static void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(journal_head_cache, jh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(journal_head_cache, jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "jh->b_committed_data",
            "bh->b_size"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: freeing b_committed_data\\n\"",
            "__func__"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "jh->b_frozen_data",
            "bh->b_size"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"remove journal_head\""
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "jh2bh(jh) == bh"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "buffer_jbd(bh)"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jlist == BJ_None"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_cp_transaction == NULL"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction == NULL"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction == NULL"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jcount >= 0"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}"
  },
  {
    "function_name": "journal_grab_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1977-1988",
    "snippet": "struct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
  },
  {
    "function_name": "journal_add_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1936-1971",
    "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_free_journal_head",
          "args": [
            "new_jh"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "journal_free_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1886-1893",
          "snippet": "static void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(journal_head_cache, jh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(journal_head_cache, jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"added journal_head\""
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping)"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_alloc_journal_head",
          "args": [],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "journal_alloc_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1865-1884",
          "snippet": "static struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\tif (ret == NULL) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tprintk_ratelimited(KERN_NOTICE \"ENOMEM in %s, retrying.\\n\",\n\t\t\t\t   __func__);\n\n\t\twhile (ret == NULL) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\tif (ret == NULL) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tprintk_ratelimited(KERN_NOTICE \"ENOMEM in %s, retrying.\\n\",\n\t\t\t\t   __func__);\n\n\t\twhile (ret == NULL) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
  },
  {
    "function_name": "journal_free_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1886-1893",
    "snippet": "static void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(journal_head_cache, jh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "journal_head_cache",
            "jh"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "jh",
            "JBD_POISON_FREE",
            "sizeof(*jh)"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&nr_journal_heads"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(journal_head_cache, jh);\n}"
  },
  {
    "function_name": "journal_alloc_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1865-1884",
    "snippet": "static struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\tif (ret == NULL) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tprintk_ratelimited(KERN_NOTICE \"ENOMEM in %s, retrying.\\n\",\n\t\t\t\t   __func__);\n\n\t\twhile (ret == NULL) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "journal_head_cache",
            "GFP_NOFS"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_NOTICE \"ENOMEM in %s, retrying.\\n\"",
            "__func__"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"out of memory for journal_head\\n\""
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "journal_head_cache",
            "GFP_NOFS"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&nr_journal_heads"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\tif (ret == NULL) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tprintk_ratelimited(KERN_NOTICE \"ENOMEM in %s, retrying.\\n\",\n\t\t\t\t   __func__);\n\n\t\twhile (ret == NULL) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_destroy_journal_head_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1854-1860",
    "snippet": "static void journal_destroy_journal_head_cache(void)\n{\n\tif (journal_head_cache) {\n\t\tkmem_cache_destroy(journal_head_cache);\n\t\tjournal_head_cache = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "journal_head_cache"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic void journal_destroy_journal_head_cache(void)\n{\n\tif (journal_head_cache) {\n\t\tkmem_cache_destroy(journal_head_cache);\n\t\tjournal_head_cache = NULL;\n\t}\n}"
  },
  {
    "function_name": "journal_init_journal_head_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1836-1852",
    "snippet": "static int journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(journal_head_cache == NULL);\n\tjournal_head_cache = kmem_cache_create(\"journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"JBD: no memory for journal_head cache\\n\""
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"journal_head\"",
            "sizeof(struct journal_head)",
            "0",
            "/* offset */SLAB_TEMPORARY",
            "/* flags */NULL"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal_head_cache == NULL"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *journal_head_cache;\n\nstatic int journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(journal_head_cache == NULL);\n\tjournal_head_cache = kmem_cache_create(\"journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "journal_blocks_per_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1823-1826",
    "snippet": "int journal_blocks_per_page(struct inode *inode)\n{\n\treturn 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_blocks_per_page(struct inode *inode)\n{\n\treturn 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n}"
  },
  {
    "function_name": "journal_ack_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1815-1821",
    "snippet": "void journal_ack_err(journal_t *journal)\n{\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JFS_ACK_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_ack_err(journal_t *journal)\n{\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JFS_ACK_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "journal_clear_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1795-1806",
    "snippet": "int journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1775-1786",
    "snippet": "int journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JFS_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tspin_unlock(&journal->j_state_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1759-1762",
    "snippet": "void journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__journal_abort_soft",
          "args": [
            "journal",
            "errno"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_abort_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1699-1711",
          "snippet": "static void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjournal_update_sb_errno(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjournal_update_sb_errno(journal);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
  },
  {
    "function_name": "__journal_abort_soft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1699-1711",
    "snippet": "static void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjournal_update_sb_errno(journal);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_update_sb_errno",
          "args": [
            "journal"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "journal_update_sb_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1169-1180",
          "snippet": "static void journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD: updating superblock error (errno %d)\\n\",\n        \t  journal->j_errno);\n\tsb->s_errno = cpu_to_be32(journal->j_errno);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_SYNC);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD: updating superblock error (errno %d)\\n\",\n        \t  journal->j_errno);\n\tsb->s_errno = cpu_to_be32(journal->j_errno);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_abort_hard",
          "args": [
            "journal"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_abort_hard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1678-1695",
          "snippet": "static void __journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\tchar b[BDEVNAME_SIZE];\n\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t\tjournal_dev_name(journal, b));\n\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__log_start_commit(journal, transaction->t_tid);\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\tchar b[BDEVNAME_SIZE];\n\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t\tjournal_dev_name(journal, b));\n\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__log_start_commit(journal, transaction->t_tid);\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjournal_update_sb_errno(journal);\n}"
  },
  {
    "function_name": "__journal_abort_hard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1678-1695",
    "snippet": "static void __journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\tchar b[BDEVNAME_SIZE];\n\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t\tjournal_dev_name(journal, b));\n\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__log_start_commit(journal, transaction->t_tid);\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Aborting journal on device %s.\\n\"",
            "journal_dev_name(journal, b)"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_dev_name",
          "args": [
            "journal",
            "b"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "journal_dev_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1653-1663",
          "snippet": "static const char *journal_dev_name(journal_t *journal, char *buffer)\n{\n\tstruct block_device *bdev;\n\n\tif (journal->j_inode)\n\t\tbdev = journal->j_inode->i_sb->s_bdev;\n\telse\n\t\tbdev = journal->j_dev;\n\n\treturn bdevname(bdev, buffer);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer)\n{\n\tstruct block_device *bdev;\n\n\tif (journal->j_inode)\n\t\tbdev = journal->j_inode->i_sb->s_bdev;\n\telse\n\t\tbdev = journal->j_dev;\n\n\treturn bdevname(bdev, buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\tchar b[BDEVNAME_SIZE];\n\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t\tjournal_dev_name(journal, b));\n\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__log_start_commit(journal, transaction->t_tid);\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "journal_dev_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1653-1663",
    "snippet": "static const char *journal_dev_name(journal_t *journal, char *buffer)\n{\n\tstruct block_device *bdev;\n\n\tif (journal->j_inode)\n\t\tbdev = journal->j_inode->i_sb->s_bdev;\n\telse\n\t\tbdev = journal->j_dev;\n\n\treturn bdevname(bdev, buffer);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *journal_dev_name(journal_t *journal, char *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "buffer"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer)\n{\n\tstruct block_device *bdev;\n\n\tif (journal->j_inode)\n\t\tbdev = journal->j_inode->i_sb->s_bdev;\n\telse\n\t\tbdev = journal->j_dev;\n\n\treturn bdevname(bdev, buffer);\n}"
  },
  {
    "function_name": "journal_wipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1620-1646",
    "snippet": "int journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JFS_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk (KERN_WARNING \"JBD: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tmark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_journal_empty",
          "args": [
            "journal"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "mark_journal_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1136-1160",
          "snippet": "static void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_skip_recovery",
          "args": [
            "journal"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "journal_skip_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "290-315",
          "snippet": "int journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD_DEBUG\n\t\tint dropped = info.end_transaction -\n\t\t\t      be32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD_DEBUG\n\t\tint dropped = info.end_transaction -\n\t\t\t      be32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"JBD: %s recovery information on journal\\n\"",
            "write ? \"Clearing\" : \"Ignoring\""
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_superblock",
          "args": [
            "journal"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "load_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1255-1273",
          "snippet": "static int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!(journal->j_flags & JFS_LOADED)"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JFS_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk (KERN_WARNING \"JBD: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tmark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}"
  },
  {
    "function_name": "journal_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1549-1605",
    "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_tail_sequence == journal->j_transaction_sequence"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_head == journal->j_tail"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!journal->j_checkpoint_transactions"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!journal->j_committing_transaction"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!journal->j_running_transaction"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_journal_empty",
          "args": [
            "journal"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "mark_journal_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1136-1160",
          "snippet": "static void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_journal_tail",
          "args": [
            "journal"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_journal_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "464-542",
          "snippet": "int cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_do_checkpoint",
          "args": [
            "journal"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "log_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "355-446",
          "snippet": "int log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define NR_BATCH\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define NR_BATCH\t64\n\nint log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_convert_superblock_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1514-1537",
    "snippet": "static int journal_convert_superblock_v1(journal_t *journal,\n\t\t\t\t\t journal_superblock_t *sb)\n{\n\tint offset, blocksize;\n\tstruct buffer_head *bh;\n\n\tprintk(KERN_WARNING\n\t\t\"JBD: Converting superblock from version 1 to 2.\\n\");\n\n\t/* Pre-initialise new fields to zero */\n\toffset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);\n\tblocksize = be32_to_cpu(sb->s_blocksize);\n\tmemset(&sb->s_feature_compat, 0, blocksize-offset);\n\n\tsb->s_nr_users = cpu_to_be32(1);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\tjournal->j_format_version = 2;\n\n\tbh = journal->j_sb_buffer;\n\tBUFFER_TRACE(bh, \"marking dirty\");\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"marking dirty\""
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_SUPERBLOCK_V2"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sb->s_feature_compat",
            "0",
            "blocksize-offset"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\"JBD: Converting superblock from version 1 to 2.\\n\""
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int journal_convert_superblock_v1(journal_t *journal,\n\t\t\t\t\t journal_superblock_t *sb)\n{\n\tint offset, blocksize;\n\tstruct buffer_head *bh;\n\n\tprintk(KERN_WARNING\n\t\t\"JBD: Converting superblock from version 1 to 2.\\n\");\n\n\t/* Pre-initialise new fields to zero */\n\toffset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);\n\tblocksize = be32_to_cpu(sb->s_blocksize);\n\tmemset(&sb->s_feature_compat, 0, blocksize-offset);\n\n\tsb->s_nr_users = cpu_to_be32(1);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\tjournal->j_format_version = 2;\n\n\tbh = journal->j_sb_buffer;\n\tBUFFER_TRACE(bh, \"marking dirty\");\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_update_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1492-1512",
    "snippet": "int journal_update_format (journal_t *journal)\n{\n\tjournal_superblock_t *sb;\n\tint err;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tswitch (be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V2:\n\t\treturn 0;\n\tcase JFS_SUPERBLOCK_V1:\n\t\treturn journal_convert_superblock_v1(journal, sb);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_convert_superblock_v1",
          "args": [
            "journal",
            "sb"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "journal_convert_superblock_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1514-1537",
          "snippet": "static int journal_convert_superblock_v1(journal_t *journal,\n\t\t\t\t\t journal_superblock_t *sb)\n{\n\tint offset, blocksize;\n\tstruct buffer_head *bh;\n\n\tprintk(KERN_WARNING\n\t\t\"JBD: Converting superblock from version 1 to 2.\\n\");\n\n\t/* Pre-initialise new fields to zero */\n\toffset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);\n\tblocksize = be32_to_cpu(sb->s_blocksize);\n\tmemset(&sb->s_feature_compat, 0, blocksize-offset);\n\n\tsb->s_nr_users = cpu_to_be32(1);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\tjournal->j_format_version = 2;\n\n\tbh = journal->j_sb_buffer;\n\tBUFFER_TRACE(bh, \"marking dirty\");\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int journal_convert_superblock_v1(journal_t *journal,\n\t\t\t\t\t journal_superblock_t *sb)\n{\n\tint offset, blocksize;\n\tstruct buffer_head *bh;\n\n\tprintk(KERN_WARNING\n\t\t\"JBD: Converting superblock from version 1 to 2.\\n\");\n\n\t/* Pre-initialise new fields to zero */\n\toffset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);\n\tblocksize = be32_to_cpu(sb->s_blocksize);\n\tmemset(&sb->s_feature_compat, 0, blocksize-offset);\n\n\tsb->s_nr_users = cpu_to_be32(1);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\tjournal->j_format_version = 2;\n\n\tbh = journal->j_sb_buffer;\n\tBUFFER_TRACE(bh, \"marking dirty\");\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_header.h_blocktype"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_superblock",
          "args": [
            "journal"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1187-1248",
          "snippet": "static int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"JBD: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JFS_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk (KERN_WARNING \"JBD: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"JBD: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JFS_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk (KERN_WARNING \"JBD: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_update_format (journal_t *journal)\n{\n\tjournal_superblock_t *sb;\n\tint err;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tswitch (be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V2:\n\t\treturn 0;\n\tcase JFS_SUPERBLOCK_V1:\n\t\treturn journal_convert_superblock_v1(journal, sb);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "journal_set_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1461-1482",
    "snippet": "int journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "incompat"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ro"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "compat"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Setting new features 0x%lx/0x%lx/0x%lx\\n\"",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_check_available_features",
          "args": [
            "journal",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "journal_check_available_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1428-1447",
          "snippet": "int journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_check_used_features",
          "args": [
            "journal",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "journal_check_used_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1397-1415",
          "snippet": "int journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "journal_check_available_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1428-1447",
    "snippet": "int journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_check_used_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1397-1415",
    "snippet": "int journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_feature_incompat"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_feature_ro_compat"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_feature_compat"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1336-1383",
    "snippet": "int journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjournal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* We cannot race with anybody but must keep assertions happy */\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tlog_do_checkpoint(journal);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tjournal->j_tail_sequence =\n\t\t\t\t++journal->j_transaction_sequence;\n\t\t\tmark_journal_empty(journal);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjournal_destroy_revoke(journal);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_wbuf"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_destroy_revoke",
          "args": [
            "journal"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "296-303",
          "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "journal->j_inode"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "journal->j_sb_buffer"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_journal_empty",
          "args": [
            "journal"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "mark_journal_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1136-1160",
          "snippet": "static void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_checkpoint_transactions == NULL"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_committing_transaction == NULL"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction == NULL"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_do_checkpoint",
          "args": [
            "journal"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "log_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "355-446",
          "snippet": "int log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define NR_BATCH\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define NR_BATCH\t64\n\nint log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_commit_transaction",
          "args": [
            "journal"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "journal_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "296-1021",
          "snippet": "void journal_commit_transaction(journal_t *journal)\n{\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh, *new_jh, *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned int blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tstruct blk_plug plug;\n\tint write_op = WRITE;\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior journal_flush? */\n\tif (journal->j_flags & JFS_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal, journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail, WRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd_commit_locking(journal, commit_transaction);\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (commit_transaction->t_updates) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (commit_transaction->t_updates) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A journal_get_undo_access()+journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjournal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjournal_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjournal_switch_revoke_table(journal);\n\n\ttrace_jbd_commit_flushing(journal, commit_transaction);\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 2\\n\");\n\n\tif (tid_geq(journal->j_commit_waited, commit_transaction->t_tid))\n\t\twrite_op = WRITE_SYNC;\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\tblk_start_plug(&plug);\n\terr = journal_submit_data_buffers(journal, commit_transaction,\n\t\t\t\t\t  write_op);\n\tblk_finish_plug(&plug);\n\n\t/*\n\t * Wait for all previously submitted IO to complete.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_locked_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_locked_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tif (!trylock_page(bh->b_page)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tlock_page(bh->b_page);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tif (bh->b_page->mapping)\n\t\t\t\tset_bit(AS_EIO, &bh->b_page->mapping->flags);\n\n\t\t\tunlock_page(bh->b_page);\n\t\t\tSetPageError(bh->b_page);\n\t\t\terr = -EIO;\n\t\t}\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tput_bh(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_jbd(bh) && bh2jh(bh) == jh &&\n\t\t    jh->b_transaction == commit_transaction &&\n\t\t    jh->b_jlist == BJ_Locked)\n\t\t\t__journal_unfile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\trelease_data_buffer(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (err) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\", bdevname(journal->j_fs_dev, b));\n\t\tif (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjournal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\tblk_start_plug(&plug);\n\n\tjournal_write_revoke_records(journal, commit_transaction, write_op);\n\n\t/*\n\t * If we found any dirty or locked buffers, then we should have\n\t * looped back up to the write_out_data label.  If there weren't\n\t * any then journal_clean_data_list should have wiped the list\n\t * clean by now, so check that it is in fact empty.\n\t */\n\tJ_ASSERT (commit_transaction->t_sync_datalist == NULL);\n\n\tjbd_debug (3, \"JBD: commit phase 3\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\tspin_unlock(&journal->j_state_lock);\n\n\ttrace_jbd_commit_logging(journal, commit_transaction);\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits);\n\n\tdescriptor = NULL;\n\tbufs = 0;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjournal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD: get descriptor\\n\");\n\n\t\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjournal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbh = jh2bh(descriptor);\n\t\t\tjbd_debug(4, \"JBD: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)bh->b_blocknr, bh->b_data);\n\t\t\theader = (journal_header_t *)&bh->b_data[0];\n\t\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = bh->b_size - sizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(bh);\n\t\t\tset_buffer_dirty(bh);\n\t\t\twbuf[bufs++] = bh;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(bh, \"ph3: file as descriptor\");\n\t\t\tjournal_file_buffer(descriptor, commit_transaction,\n\t\t\t\t\tBJ_LogCtl);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjournal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by journal_next_log_block() also.\n\t\t */\n\t\tcommit_transaction->t_outstanding_credits--;\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */\n\t\tget_bh(jh2bh(jh));\n\n\t\t/* Make a temporary IO buffer with which to write it out\n                   (this will requeue both the metadata buffer and the\n                   temporary IO buffer). new_bh goes on BJ_IO*/\n\n\t\tset_buffer_jwrite(jh2bh(jh));\n\t\t/*\n\t\t * akpm: journal_write_metadata_buffer() sets\n\t\t * new_bh->b_transaction to commit_transaction.\n\t\t * We need to clean this up before we release new_bh\n\t\t * (which is of type BJ_IO)\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\t      jh, &new_jh, blocknr);\n\t\tset_buffer_jwrite(jh2bh(new_jh));\n\t\twbuf[bufs++] = jh2bh(new_jh);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JFS_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JFS_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\ttag->t_blocknr = cpu_to_be32(jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be32(tag_flag);\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tspace_left -= sizeof(journal_block_tag_t);\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < sizeof(journal_block_tag_t) + 16) {\n\n\t\t\tjbd_debug(4, \"JBD: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);\n\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\t/*\n\t\t\t\t * In data=journal mode, here we can end up\n\t\t\t\t * writing pagecache data that might be\n\t\t\t\t * mmapped. Since we can't afford to clean the\n\t\t\t\t * page and set PageWriteback (see the comment\n\t\t\t\t * near the other use of _submit_bh()), the\n\t\t\t\t * data can change while the write is in\n\t\t\t\t * flight.  Tell the block layer to bounce the\n\t\t\t\t * bio pages if stable pages are required.\n\t\t\t\t */\n\t\t\t\t_submit_bh(write_op, bh, 1 << BIO_SNAP_STABLE);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the t_iobuf_list queue.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD: commit phase 4\\n\");\n\n\t/*\n\t * akpm: these are BJ_IO, and j_list_lock is not needed.\n\t * See __journal_try_to_free_buffer.\n\t */\nwait_for_iobuf:\n\twhile (commit_transaction->t_iobuf_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_iobuf_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_iobuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_iobuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tclear_buffer_jwrite(bh);\n\n\t\tJBUFFER_TRACE(jh, \"ph4: unfile after journal write\");\n\t\tjournal_unfile_buffer(journal, jh);\n\n\t\t/*\n\t\t * ->t_iobuf_list should contain only dummy buffer_heads\n\t\t * which were created by journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to unlock and free the corresponding\n                   shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjournal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\t/*\n\t\t * Wake up any transactions which were waiting for this\n\t\t * IO to complete. The barrier must be here so that changes\n\t\t * by journal_file_buffer() take effect before wake_up_bit()\n\t\t * does the waitqueue check.\n\t\t */\n\t\tsmp_mb();\n\t\twake_up_bit(&bh->b_state, BH_Unshadow);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD: commit phase 5\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n wait_for_ctlbuf:\n\twhile (commit_transaction->t_log_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_log_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_ctlbuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_ctlbuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjournal_unfile_buffer(journal, jh);\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD: commit phase 6\\n\");\n\n\t/* All metadata is written, now write commit record and do cleanup */\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_RECORD;\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (journal_write_commit_record(journal, commit_transaction))\n\t\terr = -EIO;\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\tJ_ASSERT(commit_transaction->t_log_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t * A buffer which has been freed while still being journaled by\n\t\t * a previous transaction.\n\t\t */\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather throughout in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile freed buffer\");\n\t\t__journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD: commit phase 8\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_RECORD);\n\n\tcommit_transaction->t_state = T_FINISHED;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time*3 +\n\t\t\t\tjournal->j_average_commit_time) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__journal_drop_transaction(journal, commit_transaction);\n\t} else {\n\t\tif (journal->j_checkpoint_transactions == NULL) {\n\t\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t\t} else {\n\t\t\tcommit_transaction->t_cpnext =\n\t\t\t\tjournal->j_checkpoint_transactions;\n\t\t\tcommit_transaction->t_cpprev =\n\t\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\t\tcommit_transaction;\n\t\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\ttrace_jbd_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twake_up(&journal->j_wait_done_commit);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_commit_transaction(journal_t *journal)\n{\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh, *new_jh, *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned int blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tstruct blk_plug plug;\n\tint write_op = WRITE;\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior journal_flush? */\n\tif (journal->j_flags & JFS_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal, journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail, WRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd_commit_locking(journal, commit_transaction);\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (commit_transaction->t_updates) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (commit_transaction->t_updates) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A journal_get_undo_access()+journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjournal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjournal_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjournal_switch_revoke_table(journal);\n\n\ttrace_jbd_commit_flushing(journal, commit_transaction);\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 2\\n\");\n\n\tif (tid_geq(journal->j_commit_waited, commit_transaction->t_tid))\n\t\twrite_op = WRITE_SYNC;\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\tblk_start_plug(&plug);\n\terr = journal_submit_data_buffers(journal, commit_transaction,\n\t\t\t\t\t  write_op);\n\tblk_finish_plug(&plug);\n\n\t/*\n\t * Wait for all previously submitted IO to complete.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_locked_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_locked_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tif (!trylock_page(bh->b_page)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tlock_page(bh->b_page);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tif (bh->b_page->mapping)\n\t\t\t\tset_bit(AS_EIO, &bh->b_page->mapping->flags);\n\n\t\t\tunlock_page(bh->b_page);\n\t\t\tSetPageError(bh->b_page);\n\t\t\terr = -EIO;\n\t\t}\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tput_bh(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_jbd(bh) && bh2jh(bh) == jh &&\n\t\t    jh->b_transaction == commit_transaction &&\n\t\t    jh->b_jlist == BJ_Locked)\n\t\t\t__journal_unfile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\trelease_data_buffer(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (err) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\", bdevname(journal->j_fs_dev, b));\n\t\tif (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjournal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\tblk_start_plug(&plug);\n\n\tjournal_write_revoke_records(journal, commit_transaction, write_op);\n\n\t/*\n\t * If we found any dirty or locked buffers, then we should have\n\t * looped back up to the write_out_data label.  If there weren't\n\t * any then journal_clean_data_list should have wiped the list\n\t * clean by now, so check that it is in fact empty.\n\t */\n\tJ_ASSERT (commit_transaction->t_sync_datalist == NULL);\n\n\tjbd_debug (3, \"JBD: commit phase 3\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\tspin_unlock(&journal->j_state_lock);\n\n\ttrace_jbd_commit_logging(journal, commit_transaction);\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits);\n\n\tdescriptor = NULL;\n\tbufs = 0;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjournal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD: get descriptor\\n\");\n\n\t\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjournal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbh = jh2bh(descriptor);\n\t\t\tjbd_debug(4, \"JBD: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)bh->b_blocknr, bh->b_data);\n\t\t\theader = (journal_header_t *)&bh->b_data[0];\n\t\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = bh->b_size - sizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(bh);\n\t\t\tset_buffer_dirty(bh);\n\t\t\twbuf[bufs++] = bh;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(bh, \"ph3: file as descriptor\");\n\t\t\tjournal_file_buffer(descriptor, commit_transaction,\n\t\t\t\t\tBJ_LogCtl);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjournal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by journal_next_log_block() also.\n\t\t */\n\t\tcommit_transaction->t_outstanding_credits--;\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */\n\t\tget_bh(jh2bh(jh));\n\n\t\t/* Make a temporary IO buffer with which to write it out\n                   (this will requeue both the metadata buffer and the\n                   temporary IO buffer). new_bh goes on BJ_IO*/\n\n\t\tset_buffer_jwrite(jh2bh(jh));\n\t\t/*\n\t\t * akpm: journal_write_metadata_buffer() sets\n\t\t * new_bh->b_transaction to commit_transaction.\n\t\t * We need to clean this up before we release new_bh\n\t\t * (which is of type BJ_IO)\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\t      jh, &new_jh, blocknr);\n\t\tset_buffer_jwrite(jh2bh(new_jh));\n\t\twbuf[bufs++] = jh2bh(new_jh);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JFS_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JFS_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\ttag->t_blocknr = cpu_to_be32(jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be32(tag_flag);\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tspace_left -= sizeof(journal_block_tag_t);\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < sizeof(journal_block_tag_t) + 16) {\n\n\t\t\tjbd_debug(4, \"JBD: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);\n\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\t/*\n\t\t\t\t * In data=journal mode, here we can end up\n\t\t\t\t * writing pagecache data that might be\n\t\t\t\t * mmapped. Since we can't afford to clean the\n\t\t\t\t * page and set PageWriteback (see the comment\n\t\t\t\t * near the other use of _submit_bh()), the\n\t\t\t\t * data can change while the write is in\n\t\t\t\t * flight.  Tell the block layer to bounce the\n\t\t\t\t * bio pages if stable pages are required.\n\t\t\t\t */\n\t\t\t\t_submit_bh(write_op, bh, 1 << BIO_SNAP_STABLE);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the t_iobuf_list queue.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD: commit phase 4\\n\");\n\n\t/*\n\t * akpm: these are BJ_IO, and j_list_lock is not needed.\n\t * See __journal_try_to_free_buffer.\n\t */\nwait_for_iobuf:\n\twhile (commit_transaction->t_iobuf_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_iobuf_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_iobuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_iobuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tclear_buffer_jwrite(bh);\n\n\t\tJBUFFER_TRACE(jh, \"ph4: unfile after journal write\");\n\t\tjournal_unfile_buffer(journal, jh);\n\n\t\t/*\n\t\t * ->t_iobuf_list should contain only dummy buffer_heads\n\t\t * which were created by journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to unlock and free the corresponding\n                   shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjournal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\t/*\n\t\t * Wake up any transactions which were waiting for this\n\t\t * IO to complete. The barrier must be here so that changes\n\t\t * by journal_file_buffer() take effect before wake_up_bit()\n\t\t * does the waitqueue check.\n\t\t */\n\t\tsmp_mb();\n\t\twake_up_bit(&bh->b_state, BH_Unshadow);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD: commit phase 5\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n wait_for_ctlbuf:\n\twhile (commit_transaction->t_log_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_log_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_ctlbuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_ctlbuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjournal_unfile_buffer(journal, jh);\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD: commit phase 6\\n\");\n\n\t/* All metadata is written, now write commit record and do cleanup */\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_RECORD;\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (journal_write_commit_record(journal, commit_transaction))\n\t\terr = -EIO;\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\tJ_ASSERT(commit_transaction->t_log_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t * A buffer which has been freed while still being journaled by\n\t\t * a previous transaction.\n\t\t */\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather throughout in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile freed buffer\");\n\t\t__journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD: commit phase 8\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_RECORD);\n\n\tcommit_transaction->t_state = T_FINISHED;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time*3 +\n\t\t\t\tjournal->j_average_commit_time) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__journal_drop_transaction(journal, commit_transaction);\n\t} else {\n\t\tif (journal->j_checkpoint_transactions == NULL) {\n\t\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t\t} else {\n\t\t\tcommit_transaction->t_cpnext =\n\t\t\t\tjournal->j_checkpoint_transactions;\n\t\t\tcommit_transaction->t_cpprev =\n\t\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\t\tcommit_transaction;\n\t\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\ttrace_jbd_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twake_up(&journal->j_wait_done_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_kill_thread",
          "args": [
            "journal"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "journal_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "250-263",
          "snippet": "static void journal_kill_thread(journal_t *journal)\n{\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\tjournal->j_task == NULL);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_kill_thread(journal_t *journal)\n{\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\tjournal->j_task == NULL);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjournal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* We cannot race with anybody but must keep assertions happy */\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tlog_do_checkpoint(journal);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tjournal->j_tail_sequence =\n\t\t\t\t++journal->j_transaction_sequence;\n\t\t\tmark_journal_empty(journal);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjournal_destroy_revoke(journal);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}"
  },
  {
    "function_name": "journal_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1284-1326",
    "snippet": "int journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk (KERN_WARNING\n\t\t\t\t\"JBD: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (journal_recover(journal))\n\t\tgoto recovery_error;\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_flags |= JFS_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk (KERN_WARNING \"JBD: recovery failed\\n\");\n\treturn -EIO;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"JBD: recovery failed\\n\""
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_reset",
          "args": [
            "journal"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "journal_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "925-980",
          "snippet": "static int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned int first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JFS_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1,\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JFS_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal,\n\t\t\t\t\t   journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail,\n\t\t\t\t\t   WRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn journal_start_thread(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned int first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JFS_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1,\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JFS_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal,\n\t\t\t\t\t   journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail,\n\t\t\t\t\t   WRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn journal_start_thread(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_recover",
          "args": [
            "journal"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "journal_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "224-275",
          "snippet": "int journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjournal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Flush disk caches to get replayed data on the permanent storage */\n\tif (journal->j_flags & JFS_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjournal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Flush disk caches to get replayed data on the permanent storage */\n\tif (journal->j_flags & JFS_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_KNOWN_INCOMPAT_FEATURES"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_KNOWN_ROCOMPAT_FEATURES"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_superblock",
          "args": [
            "journal"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "load_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1255-1273",
          "snippet": "static int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JFS_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk (KERN_WARNING\n\t\t\t\t\"JBD: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (journal_recover(journal))\n\t\tgoto recovery_error;\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_flags |= JFS_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk (KERN_WARNING \"JBD: recovery failed\\n\");\n\treturn -EIO;\n}"
  },
  {
    "function_name": "load_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1255-1273",
    "snippet": "static int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_errno"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_start"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_superblock",
          "args": [
            "journal"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1187-1248",
          "snippet": "static int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"JBD: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JFS_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk (KERN_WARNING \"JBD: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"JBD: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JFS_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk (KERN_WARNING \"JBD: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_get_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1187-1248",
    "snippet": "static int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"JBD: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JFS_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk (KERN_WARNING \"JBD: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_fail_superblock",
          "args": [
            "journal"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "journal_fail_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "911-916",
          "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\"",
            "be32_to_cpu(sb->s_first)"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_header.h_blocktype"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_blocksize"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "bh != NULL"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk (KERN_ERR\n\t\t\t\t\"JBD: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JFS_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JFS_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk (KERN_WARNING \"JBD: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_update_sb_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1169-1180",
    "snippet": "static void journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD: updating superblock error (errno %d)\\n\",\n        \t  journal->j_errno);\n\tsb->s_errno = cpu_to_be32(journal->j_errno);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_SYNC);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_write_superblock",
          "args": [
            "journal",
            "WRITE_SYNC"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "journal_write_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1055-1096",
          "snippet": "static void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_errno"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: updating superblock error (errno %d)\\n\"",
            "journal->j_errno"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tspin_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD: updating superblock error (errno %d)\\n\",\n        \t  journal->j_errno);\n\tsb->s_errno = cpu_to_be32(journal->j_errno);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_SYNC);\n}"
  },
  {
    "function_name": "mark_journal_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1136-1160",
    "snippet": "static void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_write_superblock",
          "args": [
            "journal",
            "WRITE_FUA"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "journal_write_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1055-1096",
          "snippet": "static void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_tail_sequence"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: Marking journal as empty (seq %d)\\n\"",
            "journal->j_tail_sequence"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&journal->j_checkpoint_mutex)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nstatic void mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tspin_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD: Marking journal as empty (seq %d)\\n\",\n        \t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjournal_write_superblock(journal, WRITE_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* Log is empty */\n\tjournal->j_flags |= JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "journal_update_sb_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1108-1127",
    "snippet": "void journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sb->s_sequence"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_write_superblock",
          "args": [
            "journal",
            "write_op"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "journal_write_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1055-1096",
          "snippet": "static void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tail_block"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tail_tid"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: updating superblock (start %u, seq %u)\\n\"",
            "tail_block",
            "tail_tid"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&journal->j_checkpoint_mutex)"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nvoid journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "journal_write_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "1055-1096",
    "snippet": "static void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\"",
            "ret",
            "journal_dev_name(journal, b)"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_dev_name",
          "args": [
            "journal",
            "b"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "journal_dev_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1653-1663",
          "snippet": "static const char *journal_dev_name(journal_t *journal, char *buffer)\n{\n\tstruct block_device *bdev;\n\n\tif (journal->j_inode)\n\t\tbdev = journal->j_inode->i_sb->s_bdev;\n\telse\n\t\tbdev = journal->j_dev;\n\n\treturn bdevname(bdev, buffer);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer)\n{\n\tstruct block_device *bdev;\n\n\tif (journal->j_inode)\n\t\tbdev = journal->j_inode->i_sb->s_bdev;\n\telse\n\t\tbdev = journal->j_dev;\n\n\treturn bdevname(bdev, buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "write_op",
            "bh"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_journal_write_superblock",
          "args": [
            "journal",
            "write_op"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tint ret;\n\n\ttrace_journal_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal_dev_name(journal, b));\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(KERN_ERR \"JBD: Error %d detected \"\n\t\t       \"when updating journal superblock for %s.\\n\",\n\t\t       ret, journal_dev_name(journal, b));\n\t}\n}"
  },
  {
    "function_name": "journal_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "990-1053",
    "snippet": "int journal_create(journal_t *journal)\n{\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint i, err;\n\n\tif (journal->j_maxlen < JFS_MIN_JOURNAL_BLOCKS) {\n\t\tprintk (KERN_ERR \"Journal length (%d blocks) too short.\\n\",\n\t\t\tjournal->j_maxlen);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal->j_inode == NULL) {\n\t\t/*\n\t\t * We don't know what block to start at!\n\t\t */\n\t\tprintk(KERN_EMERG\n\t\t       \"%s: creation of journal on external device!\\n\",\n\t\t       __func__);\n\t\tBUG();\n\t}\n\n\t/* Zero out the entire journal on disk.  We cannot afford to\n\t   have any blocks on disk beginning with JFS_MAGIC_NUMBER. */\n\tjbd_debug(1, \"JBD: Zeroing out journal blocks...\\n\");\n\tfor (i = 0; i < journal->j_maxlen; i++) {\n\t\terr = journal_bmap(journal, i, &blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\t\tlock_buffer(bh);\n\t\tmemset (bh->b_data, 0, journal->j_blocksize);\n\t\tBUFFER_TRACE(bh, \"marking dirty\");\n\t\tmark_buffer_dirty(bh);\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\t__brelse(bh);\n\t}\n\n\tsync_blockdev(journal->j_dev);\n\tjbd_debug(1, \"JBD: journal cleared.\\n\");\n\n\t/* OK, fill in the initial static fields in the new superblock */\n\tsb = journal->j_superblock;\n\n\tsb->s_header.h_magic\t = cpu_to_be32(JFS_MAGIC_NUMBER);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\n\tsb->s_blocksize\t= cpu_to_be32(journal->j_blocksize);\n\tsb->s_maxlen\t= cpu_to_be32(journal->j_maxlen);\n\tsb->s_first\t= cpu_to_be32(1);\n\n\tjournal->j_transaction_sequence = 1;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_format_version = 2;\n\n\treturn journal_reset(journal);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_reset",
          "args": [
            "journal"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "journal_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "925-980",
          "snippet": "static int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned int first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JFS_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1,\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JFS_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal,\n\t\t\t\t\t   journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail,\n\t\t\t\t\t   WRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn journal_start_thread(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned int first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JFS_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1,\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JFS_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal,\n\t\t\t\t\t   journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail,\n\t\t\t\t\t   WRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn journal_start_thread(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_maxlen"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_blocksize"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_SUPERBLOCK_V2"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: journal cleared.\\n\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "journal->j_dev"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"marking uptodate\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"marking dirty\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "journal->j_blocksize"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bmap",
          "args": [
            "journal",
            "i",
            "&blocknr"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "671-696",
          "snippet": "int journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: Zeroing out journal blocks...\\n\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG\n\t\t       \"%s: creation of journal on external device!\\n\"",
            "__func__"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_fail_superblock",
          "args": [
            "journal"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "journal_fail_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "911-916",
          "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_create(journal_t *journal)\n{\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint i, err;\n\n\tif (journal->j_maxlen < JFS_MIN_JOURNAL_BLOCKS) {\n\t\tprintk (KERN_ERR \"Journal length (%d blocks) too short.\\n\",\n\t\t\tjournal->j_maxlen);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal->j_inode == NULL) {\n\t\t/*\n\t\t * We don't know what block to start at!\n\t\t */\n\t\tprintk(KERN_EMERG\n\t\t       \"%s: creation of journal on external device!\\n\",\n\t\t       __func__);\n\t\tBUG();\n\t}\n\n\t/* Zero out the entire journal on disk.  We cannot afford to\n\t   have any blocks on disk beginning with JFS_MAGIC_NUMBER. */\n\tjbd_debug(1, \"JBD: Zeroing out journal blocks...\\n\");\n\tfor (i = 0; i < journal->j_maxlen; i++) {\n\t\terr = journal_bmap(journal, i, &blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\t\tlock_buffer(bh);\n\t\tmemset (bh->b_data, 0, journal->j_blocksize);\n\t\tBUFFER_TRACE(bh, \"marking dirty\");\n\t\tmark_buffer_dirty(bh);\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\t__brelse(bh);\n\t}\n\n\tsync_blockdev(journal->j_dev);\n\tjbd_debug(1, \"JBD: journal cleared.\\n\");\n\n\t/* OK, fill in the initial static fields in the new superblock */\n\tsb = journal->j_superblock;\n\n\tsb->s_header.h_magic\t = cpu_to_be32(JFS_MAGIC_NUMBER);\n\tsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);\n\n\tsb->s_blocksize\t= cpu_to_be32(journal->j_blocksize);\n\tsb->s_maxlen\t= cpu_to_be32(journal->j_maxlen);\n\tsb->s_first\t= cpu_to_be32(1);\n\n\tjournal->j_transaction_sequence = 1;\n\n\tjournal->j_flags &= ~JFS_ABORT;\n\tjournal->j_format_version = 2;\n\n\treturn journal_reset(journal);\n}"
  },
  {
    "function_name": "journal_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "925-980",
    "snippet": "static int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned int first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JFS_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1,\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JFS_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal,\n\t\t\t\t\t   journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail,\n\t\t\t\t\t   WRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn journal_start_thread(journal);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_start_thread",
          "args": [
            "journal"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "journal_start_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "238-248",
          "snippet": "static int journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald, journal, \"kjournald\");\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald, journal, \"kjournald\");\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_update_sb_log_tail",
          "args": [
            "journal",
            "journal->j_tail_sequence",
            "journal->j_tail",
            "WRITE_FUA"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "journal_update_sb_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1108-1127",
          "snippet": "void journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nvoid journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\"",
            "journal->j_tail",
            "journal->j_tail_sequence",
            "journal->j_errno"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_fail_superblock",
          "args": [
            "journal"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "journal_fail_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "911-916",
          "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\"",
            "first",
            "last"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned int first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD: Journal too short (blocks %u-%u).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JFS_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1,\"JBD: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %u, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JFS_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal,\n\t\t\t\t\t   journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail,\n\t\t\t\t\t   WRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn journal_start_thread(journal);\n}"
  },
  {
    "function_name": "journal_fail_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "911-916",
    "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
  },
  {
    "function_name": "journal_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "849-904",
    "snippet": "journal_t * journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tint err;\n\tint n;\n\tunsigned int blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
      "static const char *journal_dev_name(journal_t *journal, char *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_wbuf"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\"",
            "__func__"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getblk_unmovable",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bmap",
          "args": [
            "journal",
            "0",
            "&blocknr"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "671-696",
          "snippet": "int journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n * sizeof(struct buffer_head*)",
            "GFP_KERNEL"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\"",
            "journal",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "(long long) inode->i_size",
            "inode->i_sb->s_blocksize_bits",
            "inode->i_sb->s_blocksize"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_common",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "739-773",
          "snippet": "static journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\tgoto fail;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_logspace);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_checkpoint);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD_DEFAULT_MAX_COMMIT_AGE);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JFS_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\tgoto fail;\n\t}\n\treturn journal;\nfail:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\tgoto fail;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_logspace);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_checkpoint);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD_DEFAULT_MAX_COMMIT_AGE);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JFS_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\tgoto fail;\n\t}\n\treturn journal;\nfail:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\njournal_t * journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tint err;\n\tint n;\n\tunsigned int blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}"
  },
  {
    "function_name": "journal_init_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "798-839",
    "snippet": "journal_t * journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tint start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);",
      "static const char *journal_dev_name(journal_t *journal, char *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_wbuf"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\"",
            "__func__"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "start",
            "journal->j_blocksize"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n * sizeof(struct buffer_head*)",
            "GFP_KERNEL"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_common",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "739-773",
          "snippet": "static journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\tgoto fail;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_logspace);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_checkpoint);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD_DEFAULT_MAX_COMMIT_AGE);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JFS_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\tgoto fail;\n\t}\n\treturn journal;\nfail:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\tgoto fail;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_logspace);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_checkpoint);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD_DEFAULT_MAX_COMMIT_AGE);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JFS_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\tgoto fail;\n\t}\n\treturn journal;\nfail:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\njournal_t * journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tint start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\treturn NULL;\n}"
  },
  {
    "function_name": "journal_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "739-773",
    "snippet": "static journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\tgoto fail;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_logspace);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_checkpoint);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD_DEFAULT_MAX_COMMIT_AGE);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JFS_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\tgoto fail;\n\t}\n\treturn journal;\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init_revoke",
          "args": [
            "journal",
            "JOURNAL_REVOKE_DEFAULT_HASH"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "270-293",
          "snippet": "int journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_updates"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_checkpoint"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_done_commit"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_logspace"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_transaction_locked"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*journal)",
            "GFP_KERNEL"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\tgoto fail;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_logspace);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_checkpoint);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\tspin_lock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD_DEFAULT_MAX_COMMIT_AGE);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JFS_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\tgoto fail;\n\t}\n\treturn journal;\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "journal_get_descriptor_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "708-728",
    "snippet": "struct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *journal_dev_name(journal_t *journal, char *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_add_journal_head",
          "args": [
            "bh"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "journal_add_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1936-1971",
          "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"return this buffer\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "journal->j_blocksize"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_next_log_block",
          "args": [
            "journal",
            "&blocknr"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "journal_next_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "648-662",
          "snippet": "int journal_next_log_block(journal_t *journal, unsigned int *retp)\n{\n\tunsigned int blocknr;\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\tspin_unlock(&journal->j_state_lock);\n\treturn journal_bmap(journal, blocknr, retp);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_next_log_block(journal_t *journal, unsigned int *retp)\n{\n\tunsigned int blocknr;\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\tspin_unlock(&journal->j_state_lock);\n\treturn journal_bmap(journal, blocknr, retp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstruct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}"
  },
  {
    "function_name": "journal_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "671-696",
    "snippet": "int journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__journal_abort_soft",
          "args": [
            "journal",
            "err"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_abort_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1699-1711",
          "snippet": "static void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjournal_update_sb_errno(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JFS_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjournal_update_sb_errno(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\"",
            "__func__",
            "blocknr",
            "bdevname(journal->j_dev, b)"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev",
            "b"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap",
          "args": [
            "journal->j_inode",
            "blocknr"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fibmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "50-65",
          "snippet": "static int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "journal_next_log_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "648-662",
    "snippet": "int journal_next_log_block(journal_t *journal, unsigned int *retp)\n{\n\tunsigned int blocknr;\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\tspin_unlock(&journal->j_state_lock);\n\treturn journal_bmap(journal, blocknr, retp);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_bmap",
          "args": [
            "journal",
            "blocknr",
            "retp"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "671-696",
          "snippet": "int journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_free > 1"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_next_log_block(journal_t *journal, unsigned int *retp)\n{\n\tunsigned int blocknr;\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\tspin_unlock(&journal->j_state_lock);\n\treturn journal_bmap(journal, blocknr, retp);\n}"
  },
  {
    "function_name": "journal_trans_will_send_data_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "618-641",
    "snippet": "int journal_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\treturn 0;\n\tspin_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * writing commit record?\n\t */\n\tcommit_trans = journal->j_committing_transaction;\n\tif (commit_trans && commit_trans->t_tid == tid &&\n\t    commit_trans->t_state >= T_COMMIT_RECORD)\n\t\tgoto out;\n\tret = 1;\nout:\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_sequence",
            "tid"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\treturn 0;\n\tspin_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * writing commit record?\n\t */\n\tcommit_trans = journal->j_committing_transaction;\n\tif (commit_trans && commit_trans->t_tid == tid &&\n\t    commit_trans->t_state >= T_COMMIT_RECORD)\n\t\tgoto out;\n\tret = 1;\nout:\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "log_wait_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "569-610",
    "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_journal_aborted(journal)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_done_commit",
            "!tid_gt(tid, journal->j_commit_sequence)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "tid",
            "journal->j_commit_sequence"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: want %d, j_commit_sequence=%d\\n\"",
            "tid",
            "journal->j_commit_sequence"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "tid",
            "journal->j_commit_sequence"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_waited",
            "tid"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\"",
            "__func__",
            "journal->j_commit_request",
            "tid"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_request",
            "tid"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
  },
  {
    "function_name": "journal_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "538-563",
    "snippet": "int journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_force_commit_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "510-531",
    "snippet": "int journal_force_commit_nested(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\t/* Nothing to retry */\n\t}\n\n\ttid = transaction->t_tid;\n\tspin_unlock(&journal->j_state_lock);\n\tlog_wait_commit(journal, tid);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_force_commit_nested(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\t/* Nothing to retry */\n\t}\n\n\ttid = transaction->t_tid;\n\tspin_unlock(&journal->j_state_lock);\n\tlog_wait_commit(journal, tid);\n\treturn 1;\n}"
  },
  {
    "function_name": "log_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "490-498",
    "snippet": "int log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "458-488",
          "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__log_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "458-488",
    "snippet": "int __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"jbd: bad log_start_commit: %u %u %u %u\\n\"",
            "journal->j_commit_request",
            "journal->j_commit_sequence",
            "target",
            "journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_request",
            "target"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: requesting commit %d/%d\\n\"",
            "journal->j_commit_request",
            "journal->j_commit_sequence"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __log_start_commit(journal_t *journal, tid_t target)\n{\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_commit_request != target &&\n\t    journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"jbd: bad log_start_commit: %u %u %u %u\\n\",\n\t\t    journal->j_commit_request, journal->j_commit_sequence,\n\t\t    target, journal->j_running_transaction ?\n\t\t    journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "__log_space_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "434-453",
    "snippet": "int __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\nint __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}"
  },
  {
    "function_name": "journal_write_metadata_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "302-419",
    "snippet": "int journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct journal_head **jh_out,\n\t\t\t\t  unsigned int blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct journal_head *new_jh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\n\tnew_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\tnew_jh = journal_add_journal_head(new_bh);\t/* This sleeps */\n\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd_alloc(bh_in->b_size, GFP_NOFS);\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, jh2bh(jh_in)->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_jh->b_transaction = NULL;\n\tnew_bh->b_size = jh2bh(jh_in)->b_size;\n\tnew_bh->b_bdev = transaction->t_journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*jh_out = new_jh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh_in);\n\n\tJBUFFER_TRACE(new_jh, \"file as BJ_IO\");\n\tjournal_file_buffer(new_jh, transaction, BJ_IO);\n\n\treturn do_escape | (done_copy_out << 1);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *journal_dev_name(journal_t *journal, char *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_file_buffer",
          "args": [
            "new_jh",
            "transaction",
            "BJ_IO"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2156-2164",
          "snippet": "void journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "new_jh",
            "\"file as BJ_IO\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh_in",
            "transaction",
            "BJ_Shadow"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh_in",
            "\"file as BJ_Shadow\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "new_bh"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "new_bh"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bh_page",
          "args": [
            "new_bh",
            "new_page",
            "new_offset"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "set_bh_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1451-1463",
          "snippet": "void set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_data"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "new_page"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "tmp"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "tmp"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_data"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "mapped_data + new_offset",
            "jh2bh(jh_in)->b_size"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "new_page"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "tmp",
            "bh_in->b_size"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_alloc",
          "args": [
            "bh_in->b_size",
            "GFP_NOFS"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_data"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "new_page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "jh2bh(jh_in)->b_data"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "jh_in->b_frozen_data"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "jh_in->b_frozen_data"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_add_journal_head",
          "args": [
            "new_bh"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "journal_add_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1936-1971",
          "snippet": "struct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new_bh->b_count",
            "1"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_buffer_head",
          "args": [
            "GFP_NOFS|__GFP_NOFAIL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh_in",
            "buffer_jbddirty(bh_in)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh_in"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nint journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct journal_head **jh_out,\n\t\t\t\t  unsigned int blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct journal_head *new_jh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\n\tnew_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\tnew_jh = journal_add_journal_head(new_bh);\t/* This sleeps */\n\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd_alloc(bh_in->b_size, GFP_NOFS);\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, jh2bh(jh_in)->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_jh->b_transaction = NULL;\n\tnew_bh->b_size = jh2bh(jh_in)->b_size;\n\tnew_bh->b_bdev = transaction->t_journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*jh_out = new_jh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh_in);\n\n\tJBUFFER_TRACE(new_jh, \"file as BJ_IO\");\n\tjournal_file_buffer(new_jh, transaction, BJ_IO);\n\n\treturn do_escape | (done_copy_out << 1);\n}"
  },
  {
    "function_name": "journal_kill_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "250-263",
    "snippet": "static void journal_kill_thread(journal_t *journal)\n{\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\tjournal->j_task == NULL);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_done_commit",
            "journal->j_task == NULL"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_kill_thread(journal_t *journal)\n{\n\tspin_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JFS_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\tjournal->j_task == NULL);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "journal_start_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "238-248",
    "snippet": "static int journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald, journal, \"kjournald\");\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_done_commit",
            "journal->j_task != NULL"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kjournald",
            "journal",
            "\"kjournald\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald, journal, \"kjournald\");\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "kjournald",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "138-236",
    "snippet": "static int kjournald(void *arg)\n{\n\tjournal_t *journal = arg;\n\ttransaction_t *transaction;\n\n\t/*\n\t * Set up an interval timer which can be used to trigger a commit wakeup\n\t * after the commit interval expires\n\t */\n\tsetup_timer(&journal->j_commit_timer, commit_timeout,\n\t\t\t(unsigned long)current);\n\n\tset_freezable();\n\n\t/* Record that the journal thread is running */\n\tjournal->j_task = current;\n\twake_up(&journal->j_wait_done_commit);\n\n\tprintk(KERN_INFO \"kjournald starting.  Commit interval %ld seconds\\n\",\n\t\t\tjournal->j_commit_interval / HZ);\n\n\t/*\n\t * And now, wait forever for commit wakeup events.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\nloop:\n\tif (journal->j_flags & JFS_UNMOUNT)\n\t\tgoto end_loop;\n\n\tjbd_debug(1, \"commit_sequence=%d, commit_request=%d\\n\",\n\t\tjournal->j_commit_sequence, journal->j_commit_request);\n\n\tif (journal->j_commit_sequence != journal->j_commit_request) {\n\t\tjbd_debug(1, \"OK, requests differ\\n\");\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tdel_timer_sync(&journal->j_commit_timer);\n\t\tjournal_commit_transaction(journal);\n\t\tspin_lock(&journal->j_state_lock);\n\t\tgoto loop;\n\t}\n\n\twake_up(&journal->j_wait_done_commit);\n\tif (freezing(current)) {\n\t\t/*\n\t\t * The simpler the better. Flushing journal isn't a\n\t\t * good idea, because that depends on threads that may\n\t\t * be already stopped.\n\t\t */\n\t\tjbd_debug(1, \"Now suspending kjournald\\n\");\n\t\tspin_unlock(&journal->j_state_lock);\n\t\ttry_to_freeze();\n\t\tspin_lock(&journal->j_state_lock);\n\t} else {\n\t\t/*\n\t\t * We assume on resume that commits are already there,\n\t\t * so we don't sleep\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&journal->j_wait_commit, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (journal->j_commit_sequence != journal->j_commit_request)\n\t\t\tshould_sleep = 0;\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (transaction && time_after_eq(jiffies,\n\t\t\t\t\t\ttransaction->t_expires))\n\t\t\tshould_sleep = 0;\n\t\tif (journal->j_flags & JFS_UNMOUNT)\n\t\t\tshould_sleep = 0;\n\t\tif (should_sleep) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_commit, &wait);\n\t}\n\n\tjbd_debug(1, \"kjournald wakes\\n\");\n\n\t/*\n\t * Were we woken up by a commit wakeup event?\n\t */\n\ttransaction = journal->j_running_transaction;\n\tif (transaction && time_after_eq(jiffies, transaction->t_expires)) {\n\t\tjournal->j_commit_request = transaction->t_tid;\n\t\tjbd_debug(1, \"woke because of timeout\\n\");\n\t}\n\tgoto loop;\n\nend_loop:\n\tspin_unlock(&journal->j_state_lock);\n\tdel_timer_sync(&journal->j_commit_timer);\n\tjournal->j_task = NULL;\n\twake_up(&journal->j_wait_done_commit);\n\tjbd_debug(1, \"Journal thread exiting.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Journal thread exiting.\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_done_commit"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&journal->j_commit_timer"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"woke because of timeout\\n\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "transaction->t_expires"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"kjournald wakes\\n\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_commit",
            "&wait"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "transaction->t_expires"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_commit",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Now suspending kjournald\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_commit_transaction",
          "args": [
            "journal"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "journal_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "296-1021",
          "snippet": "void journal_commit_transaction(journal_t *journal)\n{\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh, *new_jh, *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned int blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tstruct blk_plug plug;\n\tint write_op = WRITE;\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior journal_flush? */\n\tif (journal->j_flags & JFS_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal, journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail, WRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd_commit_locking(journal, commit_transaction);\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (commit_transaction->t_updates) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (commit_transaction->t_updates) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A journal_get_undo_access()+journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjournal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjournal_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjournal_switch_revoke_table(journal);\n\n\ttrace_jbd_commit_flushing(journal, commit_transaction);\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 2\\n\");\n\n\tif (tid_geq(journal->j_commit_waited, commit_transaction->t_tid))\n\t\twrite_op = WRITE_SYNC;\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\tblk_start_plug(&plug);\n\terr = journal_submit_data_buffers(journal, commit_transaction,\n\t\t\t\t\t  write_op);\n\tblk_finish_plug(&plug);\n\n\t/*\n\t * Wait for all previously submitted IO to complete.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_locked_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_locked_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tif (!trylock_page(bh->b_page)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tlock_page(bh->b_page);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tif (bh->b_page->mapping)\n\t\t\t\tset_bit(AS_EIO, &bh->b_page->mapping->flags);\n\n\t\t\tunlock_page(bh->b_page);\n\t\t\tSetPageError(bh->b_page);\n\t\t\terr = -EIO;\n\t\t}\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tput_bh(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_jbd(bh) && bh2jh(bh) == jh &&\n\t\t    jh->b_transaction == commit_transaction &&\n\t\t    jh->b_jlist == BJ_Locked)\n\t\t\t__journal_unfile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\trelease_data_buffer(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (err) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\", bdevname(journal->j_fs_dev, b));\n\t\tif (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjournal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\tblk_start_plug(&plug);\n\n\tjournal_write_revoke_records(journal, commit_transaction, write_op);\n\n\t/*\n\t * If we found any dirty or locked buffers, then we should have\n\t * looped back up to the write_out_data label.  If there weren't\n\t * any then journal_clean_data_list should have wiped the list\n\t * clean by now, so check that it is in fact empty.\n\t */\n\tJ_ASSERT (commit_transaction->t_sync_datalist == NULL);\n\n\tjbd_debug (3, \"JBD: commit phase 3\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\tspin_unlock(&journal->j_state_lock);\n\n\ttrace_jbd_commit_logging(journal, commit_transaction);\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits);\n\n\tdescriptor = NULL;\n\tbufs = 0;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjournal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD: get descriptor\\n\");\n\n\t\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjournal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbh = jh2bh(descriptor);\n\t\t\tjbd_debug(4, \"JBD: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)bh->b_blocknr, bh->b_data);\n\t\t\theader = (journal_header_t *)&bh->b_data[0];\n\t\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = bh->b_size - sizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(bh);\n\t\t\tset_buffer_dirty(bh);\n\t\t\twbuf[bufs++] = bh;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(bh, \"ph3: file as descriptor\");\n\t\t\tjournal_file_buffer(descriptor, commit_transaction,\n\t\t\t\t\tBJ_LogCtl);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjournal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by journal_next_log_block() also.\n\t\t */\n\t\tcommit_transaction->t_outstanding_credits--;\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */\n\t\tget_bh(jh2bh(jh));\n\n\t\t/* Make a temporary IO buffer with which to write it out\n                   (this will requeue both the metadata buffer and the\n                   temporary IO buffer). new_bh goes on BJ_IO*/\n\n\t\tset_buffer_jwrite(jh2bh(jh));\n\t\t/*\n\t\t * akpm: journal_write_metadata_buffer() sets\n\t\t * new_bh->b_transaction to commit_transaction.\n\t\t * We need to clean this up before we release new_bh\n\t\t * (which is of type BJ_IO)\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\t      jh, &new_jh, blocknr);\n\t\tset_buffer_jwrite(jh2bh(new_jh));\n\t\twbuf[bufs++] = jh2bh(new_jh);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JFS_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JFS_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\ttag->t_blocknr = cpu_to_be32(jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be32(tag_flag);\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tspace_left -= sizeof(journal_block_tag_t);\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < sizeof(journal_block_tag_t) + 16) {\n\n\t\t\tjbd_debug(4, \"JBD: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);\n\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\t/*\n\t\t\t\t * In data=journal mode, here we can end up\n\t\t\t\t * writing pagecache data that might be\n\t\t\t\t * mmapped. Since we can't afford to clean the\n\t\t\t\t * page and set PageWriteback (see the comment\n\t\t\t\t * near the other use of _submit_bh()), the\n\t\t\t\t * data can change while the write is in\n\t\t\t\t * flight.  Tell the block layer to bounce the\n\t\t\t\t * bio pages if stable pages are required.\n\t\t\t\t */\n\t\t\t\t_submit_bh(write_op, bh, 1 << BIO_SNAP_STABLE);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the t_iobuf_list queue.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD: commit phase 4\\n\");\n\n\t/*\n\t * akpm: these are BJ_IO, and j_list_lock is not needed.\n\t * See __journal_try_to_free_buffer.\n\t */\nwait_for_iobuf:\n\twhile (commit_transaction->t_iobuf_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_iobuf_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_iobuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_iobuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tclear_buffer_jwrite(bh);\n\n\t\tJBUFFER_TRACE(jh, \"ph4: unfile after journal write\");\n\t\tjournal_unfile_buffer(journal, jh);\n\n\t\t/*\n\t\t * ->t_iobuf_list should contain only dummy buffer_heads\n\t\t * which were created by journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to unlock and free the corresponding\n                   shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjournal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\t/*\n\t\t * Wake up any transactions which were waiting for this\n\t\t * IO to complete. The barrier must be here so that changes\n\t\t * by journal_file_buffer() take effect before wake_up_bit()\n\t\t * does the waitqueue check.\n\t\t */\n\t\tsmp_mb();\n\t\twake_up_bit(&bh->b_state, BH_Unshadow);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD: commit phase 5\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n wait_for_ctlbuf:\n\twhile (commit_transaction->t_log_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_log_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_ctlbuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_ctlbuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjournal_unfile_buffer(journal, jh);\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD: commit phase 6\\n\");\n\n\t/* All metadata is written, now write commit record and do cleanup */\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_RECORD;\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (journal_write_commit_record(journal, commit_transaction))\n\t\terr = -EIO;\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\tJ_ASSERT(commit_transaction->t_log_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t * A buffer which has been freed while still being journaled by\n\t\t * a previous transaction.\n\t\t */\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather throughout in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile freed buffer\");\n\t\t__journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD: commit phase 8\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_RECORD);\n\n\tcommit_transaction->t_state = T_FINISHED;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time*3 +\n\t\t\t\tjournal->j_average_commit_time) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__journal_drop_transaction(journal, commit_transaction);\n\t} else {\n\t\tif (journal->j_checkpoint_transactions == NULL) {\n\t\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t\t} else {\n\t\t\tcommit_transaction->t_cpnext =\n\t\t\t\tjournal->j_checkpoint_transactions;\n\t\t\tcommit_transaction->t_cpprev =\n\t\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\t\tcommit_transaction;\n\t\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\ttrace_jbd_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twake_up(&journal->j_wait_done_commit);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_commit_transaction(journal_t *journal)\n{\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh, *new_jh, *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned int blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tstruct blk_plug plug;\n\tint write_op = WRITE;\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior journal_flush? */\n\tif (journal->j_flags & JFS_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal, journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail, WRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd_commit_locking(journal, commit_transaction);\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (commit_transaction->t_updates) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (commit_transaction->t_updates) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A journal_get_undo_access()+journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjournal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjournal_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjournal_switch_revoke_table(journal);\n\n\ttrace_jbd_commit_flushing(journal, commit_transaction);\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 2\\n\");\n\n\tif (tid_geq(journal->j_commit_waited, commit_transaction->t_tid))\n\t\twrite_op = WRITE_SYNC;\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\tblk_start_plug(&plug);\n\terr = journal_submit_data_buffers(journal, commit_transaction,\n\t\t\t\t\t  write_op);\n\tblk_finish_plug(&plug);\n\n\t/*\n\t * Wait for all previously submitted IO to complete.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_locked_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_locked_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tif (!trylock_page(bh->b_page)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tlock_page(bh->b_page);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tif (bh->b_page->mapping)\n\t\t\t\tset_bit(AS_EIO, &bh->b_page->mapping->flags);\n\n\t\t\tunlock_page(bh->b_page);\n\t\t\tSetPageError(bh->b_page);\n\t\t\terr = -EIO;\n\t\t}\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tput_bh(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_jbd(bh) && bh2jh(bh) == jh &&\n\t\t    jh->b_transaction == commit_transaction &&\n\t\t    jh->b_jlist == BJ_Locked)\n\t\t\t__journal_unfile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\trelease_data_buffer(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (err) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\", bdevname(journal->j_fs_dev, b));\n\t\tif (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjournal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\tblk_start_plug(&plug);\n\n\tjournal_write_revoke_records(journal, commit_transaction, write_op);\n\n\t/*\n\t * If we found any dirty or locked buffers, then we should have\n\t * looped back up to the write_out_data label.  If there weren't\n\t * any then journal_clean_data_list should have wiped the list\n\t * clean by now, so check that it is in fact empty.\n\t */\n\tJ_ASSERT (commit_transaction->t_sync_datalist == NULL);\n\n\tjbd_debug (3, \"JBD: commit phase 3\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\tspin_unlock(&journal->j_state_lock);\n\n\ttrace_jbd_commit_logging(journal, commit_transaction);\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits);\n\n\tdescriptor = NULL;\n\tbufs = 0;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjournal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD: get descriptor\\n\");\n\n\t\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjournal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbh = jh2bh(descriptor);\n\t\t\tjbd_debug(4, \"JBD: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)bh->b_blocknr, bh->b_data);\n\t\t\theader = (journal_header_t *)&bh->b_data[0];\n\t\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = bh->b_size - sizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(bh);\n\t\t\tset_buffer_dirty(bh);\n\t\t\twbuf[bufs++] = bh;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(bh, \"ph3: file as descriptor\");\n\t\t\tjournal_file_buffer(descriptor, commit_transaction,\n\t\t\t\t\tBJ_LogCtl);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjournal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by journal_next_log_block() also.\n\t\t */\n\t\tcommit_transaction->t_outstanding_credits--;\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */\n\t\tget_bh(jh2bh(jh));\n\n\t\t/* Make a temporary IO buffer with which to write it out\n                   (this will requeue both the metadata buffer and the\n                   temporary IO buffer). new_bh goes on BJ_IO*/\n\n\t\tset_buffer_jwrite(jh2bh(jh));\n\t\t/*\n\t\t * akpm: journal_write_metadata_buffer() sets\n\t\t * new_bh->b_transaction to commit_transaction.\n\t\t * We need to clean this up before we release new_bh\n\t\t * (which is of type BJ_IO)\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\t      jh, &new_jh, blocknr);\n\t\tset_buffer_jwrite(jh2bh(new_jh));\n\t\twbuf[bufs++] = jh2bh(new_jh);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JFS_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JFS_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\ttag->t_blocknr = cpu_to_be32(jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be32(tag_flag);\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tspace_left -= sizeof(journal_block_tag_t);\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < sizeof(journal_block_tag_t) + 16) {\n\n\t\t\tjbd_debug(4, \"JBD: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);\n\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\t/*\n\t\t\t\t * In data=journal mode, here we can end up\n\t\t\t\t * writing pagecache data that might be\n\t\t\t\t * mmapped. Since we can't afford to clean the\n\t\t\t\t * page and set PageWriteback (see the comment\n\t\t\t\t * near the other use of _submit_bh()), the\n\t\t\t\t * data can change while the write is in\n\t\t\t\t * flight.  Tell the block layer to bounce the\n\t\t\t\t * bio pages if stable pages are required.\n\t\t\t\t */\n\t\t\t\t_submit_bh(write_op, bh, 1 << BIO_SNAP_STABLE);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the t_iobuf_list queue.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD: commit phase 4\\n\");\n\n\t/*\n\t * akpm: these are BJ_IO, and j_list_lock is not needed.\n\t * See __journal_try_to_free_buffer.\n\t */\nwait_for_iobuf:\n\twhile (commit_transaction->t_iobuf_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_iobuf_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_iobuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_iobuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tclear_buffer_jwrite(bh);\n\n\t\tJBUFFER_TRACE(jh, \"ph4: unfile after journal write\");\n\t\tjournal_unfile_buffer(journal, jh);\n\n\t\t/*\n\t\t * ->t_iobuf_list should contain only dummy buffer_heads\n\t\t * which were created by journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to unlock and free the corresponding\n                   shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjournal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\t/*\n\t\t * Wake up any transactions which were waiting for this\n\t\t * IO to complete. The barrier must be here so that changes\n\t\t * by journal_file_buffer() take effect before wake_up_bit()\n\t\t * does the waitqueue check.\n\t\t */\n\t\tsmp_mb();\n\t\twake_up_bit(&bh->b_state, BH_Unshadow);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD: commit phase 5\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n wait_for_ctlbuf:\n\twhile (commit_transaction->t_log_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_log_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_ctlbuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_ctlbuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjournal_unfile_buffer(journal, jh);\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD: commit phase 6\\n\");\n\n\t/* All metadata is written, now write commit record and do cleanup */\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_RECORD;\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (journal_write_commit_record(journal, commit_transaction))\n\t\terr = -EIO;\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\tJ_ASSERT(commit_transaction->t_log_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t * A buffer which has been freed while still being journaled by\n\t\t * a previous transaction.\n\t\t */\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather throughout in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile freed buffer\");\n\t\t__journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD: commit phase 8\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_RECORD);\n\n\tcommit_transaction->t_state = T_FINISHED;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time*3 +\n\t\t\t\tjournal->j_average_commit_time) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__journal_drop_transaction(journal, commit_transaction);\n\t} else {\n\t\tif (journal->j_checkpoint_transactions == NULL) {\n\t\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t\t} else {\n\t\t\tcommit_transaction->t_cpnext =\n\t\t\t\tjournal->j_checkpoint_transactions;\n\t\t\tcommit_transaction->t_cpprev =\n\t\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\t\tcommit_transaction;\n\t\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\ttrace_jbd_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twake_up(&journal->j_wait_done_commit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&journal->j_commit_timer"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"OK, requests differ\\n\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"commit_sequence=%d, commit_request=%d\\n\"",
            "journal->j_commit_sequence",
            "journal->j_commit_request"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kjournald starting.  Commit interval %ld seconds\\n\"",
            "journal->j_commit_interval / HZ"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_timer",
          "args": [
            "&journal->j_commit_timer",
            "commit_timeout",
            "(unsigned long)current"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int kjournald(void *arg)\n{\n\tjournal_t *journal = arg;\n\ttransaction_t *transaction;\n\n\t/*\n\t * Set up an interval timer which can be used to trigger a commit wakeup\n\t * after the commit interval expires\n\t */\n\tsetup_timer(&journal->j_commit_timer, commit_timeout,\n\t\t\t(unsigned long)current);\n\n\tset_freezable();\n\n\t/* Record that the journal thread is running */\n\tjournal->j_task = current;\n\twake_up(&journal->j_wait_done_commit);\n\n\tprintk(KERN_INFO \"kjournald starting.  Commit interval %ld seconds\\n\",\n\t\t\tjournal->j_commit_interval / HZ);\n\n\t/*\n\t * And now, wait forever for commit wakeup events.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\nloop:\n\tif (journal->j_flags & JFS_UNMOUNT)\n\t\tgoto end_loop;\n\n\tjbd_debug(1, \"commit_sequence=%d, commit_request=%d\\n\",\n\t\tjournal->j_commit_sequence, journal->j_commit_request);\n\n\tif (journal->j_commit_sequence != journal->j_commit_request) {\n\t\tjbd_debug(1, \"OK, requests differ\\n\");\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tdel_timer_sync(&journal->j_commit_timer);\n\t\tjournal_commit_transaction(journal);\n\t\tspin_lock(&journal->j_state_lock);\n\t\tgoto loop;\n\t}\n\n\twake_up(&journal->j_wait_done_commit);\n\tif (freezing(current)) {\n\t\t/*\n\t\t * The simpler the better. Flushing journal isn't a\n\t\t * good idea, because that depends on threads that may\n\t\t * be already stopped.\n\t\t */\n\t\tjbd_debug(1, \"Now suspending kjournald\\n\");\n\t\tspin_unlock(&journal->j_state_lock);\n\t\ttry_to_freeze();\n\t\tspin_lock(&journal->j_state_lock);\n\t} else {\n\t\t/*\n\t\t * We assume on resume that commits are already there,\n\t\t * so we don't sleep\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&journal->j_wait_commit, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (journal->j_commit_sequence != journal->j_commit_request)\n\t\t\tshould_sleep = 0;\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (transaction && time_after_eq(jiffies,\n\t\t\t\t\t\ttransaction->t_expires))\n\t\t\tshould_sleep = 0;\n\t\tif (journal->j_flags & JFS_UNMOUNT)\n\t\t\tshould_sleep = 0;\n\t\tif (should_sleep) {\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_commit, &wait);\n\t}\n\n\tjbd_debug(1, \"kjournald wakes\\n\");\n\n\t/*\n\t * Were we woken up by a commit wakeup event?\n\t */\n\ttransaction = journal->j_running_transaction;\n\tif (transaction && time_after_eq(jiffies, transaction->t_expires)) {\n\t\tjournal->j_commit_request = transaction->t_tid;\n\t\tjbd_debug(1, \"woke because of timeout\\n\");\n\t}\n\tgoto loop;\n\nend_loop:\n\tspin_unlock(&journal->j_state_lock);\n\tdel_timer_sync(&journal->j_commit_timer);\n\tjournal->j_task = NULL;\n\twake_up(&journal->j_wait_done_commit);\n\tjbd_debug(1, \"Journal thread exiting.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "commit_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "115-120",
    "snippet": "static void commit_timeout(unsigned long __data)\n{\n\tstruct task_struct * p = (struct task_struct *) __data;\n\n\twake_up_process(p);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void commit_timeout(unsigned long __data)\n{\n\tstruct task_struct * p = (struct task_struct *) __data;\n\n\twake_up_process(p);\n}"
  },
  {
    "function_name": "__jbd_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
    "lines": "94-107",
    "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s: (%s, %u): %pV\\n\"",
            "file",
            "func",
            "line",
            "&vaf"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
  }
]