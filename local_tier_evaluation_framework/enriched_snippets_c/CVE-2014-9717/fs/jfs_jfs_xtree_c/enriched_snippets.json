[
  {
    "function_name": "jfs_xtstat_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "3891-3894",
    "snippet": "static int jfs_xtstat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_xtstat_proc_show, NULL);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "jfs_xtstat_proc_show",
            "NULL"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_xtstat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_xtstat_proc_show, NULL);\n}"
  },
  {
    "function_name": "jfs_xtstat_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "3877-3889",
    "snippet": "static int jfs_xtstat_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Xtree statistics\\n\"\n\t\t       \"====================\\n\"\n\t\t       \"searches = %d\\n\"\n\t\t       \"fast searches = %d\\n\"\n\t\t       \"splits = %d\\n\",\n\t\t       xtStat.search,\n\t\t       xtStat.fastSearch,\n\t\t       xtStat.split);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"JFS Xtree statistics\\n\"\n\t\t       \"====================\\n\"\n\t\t       \"searches = %d\\n\"\n\t\t       \"fast searches = %d\\n\"\n\t\t       \"splits = %d\\n\"",
            "xtStat.search",
            "xtStat.fastSearch",
            "xtStat.split"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int jfs_xtstat_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Xtree statistics\\n\"\n\t\t       \"====================\\n\"\n\t\t       \"searches = %d\\n\"\n\t\t       \"fast searches = %d\\n\"\n\t\t       \"splits = %d\\n\",\n\t\t       xtStat.search,\n\t\t       xtStat.fastSearch,\n\t\t       xtStat.split);\n\treturn 0;\n}"
  },
  {
    "function_name": "xtTruncate_pmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "3718-3874",
    "snippet": "s64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_TRUNCATE_LEAVES 50"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_PUSH",
          "args": [
            "&btstack",
            "bn",
            "index"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"stack overrun!\\n\""
          ],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_STACK_FULL",
          "args": [
            "&btstack"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "&btstack"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff",
            "NULL",
            "&cmp",
            "&btstack",
            "0"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "&btstack"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xtTruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "3162-3692",
    "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_TRUNCATE_LEAVES 50"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "txFreelock",
          "args": [
            "ip"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "txFreelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2596-2629",
          "snippet": "void txFreelock(struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct tlock *xtlck, *tlck;\n\tlid_t xlid = 0, lid;\n\n\tif (!jfs_ip->atlhead)\n\t\treturn;\n\n\tTXN_LOCK();\n\txtlck = (struct tlock *) &jfs_ip->atlhead;\n\n\twhile ((lid = xtlck->next) != 0) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif (tlck->flag & tlckFREELOCK) {\n\t\t\txtlck->next = tlck->next;\n\t\t\ttxLockFree(lid);\n\t\t} else {\n\t\t\txtlck = tlck;\n\t\t\txlid = lid;\n\t\t}\n\t}\n\n\tif (jfs_ip->atlhead)\n\t\tjfs_ip->atltail = xlid;\n\telse {\n\t\tjfs_ip->atltail = 0;\n\t\t/*\n\t\t * If inode was on anon_list, remove it\n\t\t */\n\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t}\n\tTXN_UNLOCK();\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nvoid txFreelock(struct inode *ip)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tstruct tlock *xtlck, *tlck;\n\tlid_t xlid = 0, lid;\n\n\tif (!jfs_ip->atlhead)\n\t\treturn;\n\n\tTXN_LOCK();\n\txtlck = (struct tlock *) &jfs_ip->atlhead;\n\n\twhile ((lid = xtlck->next) != 0) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tif (tlck->flag & tlckFREELOCK) {\n\t\t\txtlck->next = tlck->next;\n\t\t\ttxLockFree(lid);\n\t\t} else {\n\t\t\txtlck = tlck;\n\t\t\txlid = lid;\n\t\t}\n\t}\n\n\tif (jfs_ip->atlhead)\n\t\tjfs_ip->atltail = xlid;\n\telse {\n\t\tjfs_ip->atltail = 0;\n\t\t/*\n\t\t * If inode was on anon_list, remove it\n\t\t */\n\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t}\n\tTXN_UNLOCK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "nfreed"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_PUSH",
          "args": [
            "&btstack",
            "bn",
            "index"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"stack overrun!\\n\""
          ],
          "line": 3652
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_STACK_FULL",
          "args": [
            "&btstack"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "mp"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "mp->lid"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTROOTINITSLOT"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.maxentry"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txFreeMap",
          "args": [
            "ip",
            "(struct maplock *) & xadlock",
            "NULL",
            "COMMIT_WMAP"
          ],
          "line": 3588
        },
        "resolved": true,
        "details": {
          "function_name": "txFreeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2497-2589",
          "snippet": "void txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "tblk->last"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "prev->next"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "prev->next"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "tblk->next"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "lid"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "mp->lid"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "&p->xad[index]"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "index + 1"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "&btstack"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "mp->lid"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "nextindex"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&pxdlock->pxd",
            "freexlen"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&pxdlock->pxd",
            "xaddr"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "(int)xtlck->lwm.offset"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xad",
            "len"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_xad_metapages",
          "args": [
            "ip",
            "*xad"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3294
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "&btstack"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
  },
  {
    "function_name": "xtInitRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "3073-3098",
    "snippet": "void xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTROOTINITSLOT"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTROOTINITSLOT_DIR"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "(struct metapage *) &JFS_IP(ip)->bxflag",
            "tlckXTREE | tlckNEW"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\n\nvoid xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}"
  },
  {
    "function_name": "xtRelink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "3011-3064",
    "snippet": "static int xtRelink(tid_t tid, struct inode *ip, xtpage_t * p)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tXT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.next = le64_to_cpu(nextbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "nextbn"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE | tlckRELINK"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "prevbn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "prevbn"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "nextbn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtRelink(tid_t tid, struct inode *ip, xtpage_t * p)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tXT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.next = le64_to_cpu(nextbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xtSearchNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "2891-2995",
    "snippet": "static int xtSearchNode(struct inode *ip, xad_t * xad,\t/* required XAD entry */\n\t\t\tint *cmpp, struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\ts64 xoff, xaddr;\n\tint xlen;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* page */\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\ts64 t64;\n\n\tBT_CLR(btstack);\n\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t *\n\t\t\t\t * verify for exact match;\n\t\t\t\t */\n\t\t\t\tif (xaddr == addressXAD(&p->xad[index]) &&\n\t\t\t\t    xoff == offsetXAD(&p->xad[index])) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* descend/search its child page */\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss - non-leaf page:\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "&p->xad[index]"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "&p->xad[index]"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "&p->xad[index]"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_CMP",
          "args": [
            "cmp",
            "xoff",
            "&p->xad[index]",
            "t64"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "btstack"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearchNode(struct inode *ip, xad_t * xad,\t/* required XAD entry */\n\t\t\tint *cmpp, struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\ts64 xoff, xaddr;\n\tint xlen;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* page */\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\ts64 t64;\n\n\tBT_CLR(btstack);\n\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t *\n\t\t\t\t * verify for exact match;\n\t\t\t\t */\n\t\t\t\tif (xaddr == addressXAD(&p->xad[index]) &&\n\t\t\t\t    xoff == offsetXAD(&p->xad[index])) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* descend/search its child page */\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss - non-leaf page:\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
  },
  {
    "function_name": "xtRelocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "2558-2870",
    "snippet": "int\nxtRelocate(tid_t tid, struct inode * ip, xad_t * oxad,\t/* old XAD */\n\t   s64 nxaddr,\t\t/* new xaddr */\n\t   int xtype)\n{\t\t\t\t/* extent type: XTPAGE or DATAEXT */\n\tint rc = 0;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct metapage *mp, *pmp, *lmp, *rmp;\t/* meta-page buffer */\n\txtpage_t *p, *pp, *rp, *lp;\t/* base B+-tree index page */\n\txad_t *xad;\n\tpxd_t *pxd;\n\ts64 xoff, xsize;\n\tint xlen;\n\ts64 oxaddr, sxaddr, dxaddr, nextbn, prevbn;\n\tcbuf_t *cp;\n\ts64 offset, nbytes, nbrd, pno;\n\tint nb, npages, nblks;\n\ts64 bn;\n\tint cmp;\n\tint index;\n\tstruct pxd_lock *pxdlock;\n\tstruct btstack btstack;\t/* traverse stack */\n\n\txtype = xtype & EXTENT_TYPE;\n\n\txoff = offsetXAD(oxad);\n\toxaddr = addressXAD(oxad);\n\txlen = lengthXAD(oxad);\n\n\t/* validate extent offset */\n\toffset = xoff << JFS_SBI(ip->i_sb)->l2bsize;\n\tif (offset >= ip->i_size)\n\t\treturn -ESTALE;\t/* stale extent */\n\n\tjfs_info(\"xtRelocate: xtype:%d xoff:0x%lx xlen:0x%x xaddr:0x%lx:0x%lx\",\n\t\t xtype, (ulong) xoff, xlen, (ulong) oxaddr, (ulong) nxaddr);\n\n\t/*\n\t *\t1. get and validate the parent xtpage/xad entry\n\t *\tcovering the source extent to be relocated;\n\t */\n\tif (xtype == DATAEXT) {\n\t\t/* search in leaf entry */\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\n\t\tif (cmp) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* validate for exact match with a single entry */\n\t\txad = &pp->xad[index];\n\t\tif (addressXAD(xad) != oxaddr || lengthXAD(xad) != xlen) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn -ESTALE;\n\t\t}\n\t} else {\t\t/* (xtype == XTPAGE) */\n\n\t\t/* search in internal entry */\n\t\trc = xtSearchNode(ip, oxad, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\n\t\tif (cmp) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* xtSearchNode() validated for exact match with a single entry\n\t\t */\n\t\txad = &pp->xad[index];\n\t}\n\tjfs_info(\"xtRelocate: parent xad entry validated.\");\n\n\t/*\n\t *\t2. relocate the extent\n\t */\n\tif (xtype == DATAEXT) {\n\t\t/* if the extent is allocated-but-not-recorded\n\t\t * there is no real data to be moved in this extent,\n\t\t */\n\t\tif (xad->flag & XAD_NOTRECORDED)\n\t\t\tgoto out;\n\t\telse\n\t\t\t/* release xtpage for cmRead()/xtLookup() */\n\t\t\tXT_PUTPAGE(pmp);\n\n\t\t/*\n\t\t *\tcmRelocate()\n\t\t *\n\t\t * copy target data pages to be relocated;\n\t\t *\n\t\t * data extent must start at page boundary and\n\t\t * multiple of page size (except the last data extent);\n\t\t * read in each page of the source data extent into cbuf,\n\t\t * update the cbuf extent descriptor of the page to be\n\t\t * homeward bound to new dst data extent\n\t\t * copy the data from the old extent to new extent.\n\t\t * copy is essential for compressed files to avoid problems\n\t\t * that can arise if there was a change in compression\n\t\t * algorithms.\n\t\t * it is a good strategy because it may disrupt cache\n\t\t * policy to keep the pages in memory afterwards.\n\t\t */\n\t\toffset = xoff << JFS_SBI(ip->i_sb)->l2bsize;\n\t\tassert((offset & CM_OFFSET) == 0);\n\t\tnbytes = xlen << JFS_SBI(ip->i_sb)->l2bsize;\n\t\tpno = offset >> CM_L2BSIZE;\n\t\tnpages = (nbytes + (CM_BSIZE - 1)) >> CM_L2BSIZE;\n/*\n\t\tnpages = ((offset + nbytes - 1) >> CM_L2BSIZE) -\n\t\t\t  (offset >> CM_L2BSIZE) + 1;\n*/\n\t\tsxaddr = oxaddr;\n\t\tdxaddr = nxaddr;\n\n\t\t/* process the request one cache buffer at a time */\n\t\tfor (nbrd = 0; nbrd < nbytes; nbrd += nb,\n\t\t     offset += nb, pno++, npages--) {\n\t\t\t/* compute page size */\n\t\t\tnb = min(nbytes - nbrd, CM_BSIZE);\n\n\t\t\t/* get the cache buffer of the page */\n\t\t\tif (rc = cmRead(ip, offset, npages, &cp))\n\t\t\t\tbreak;\n\n\t\t\tassert(addressPXD(&cp->cm_pxd) == sxaddr);\n\t\t\tassert(!cp->cm_modified);\n\n\t\t\t/* bind buffer with the new extent address */\n\t\t\tnblks = nb >> JFS_IP(ip->i_sb)->l2bsize;\n\t\t\tcmSetXD(ip, cp, pno, dxaddr, nblks);\n\n\t\t\t/* release the cbuf, mark it as modified */\n\t\t\tcmPut(cp, true);\n\n\t\t\tdxaddr += nblks;\n\t\t\tsxaddr += nblks;\n\t\t}\n\n\t\t/* get back parent page */\n\t\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0)))\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\t\tjfs_info(\"xtRelocate: target data extent relocated.\");\n\t} else {\t\t/* (xtype == XTPAGE) */\n\n\t\t/*\n\t\t * read in the target xtpage from the source extent;\n\t\t */\n\t\tXT_GETPAGE(ip, oxaddr, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * read in sibling pages if any to update sibling pointers;\n\t\t */\n\t\trmp = NULL;\n\t\tif (p->header.next) {\n\t\t\tnextbn = le64_to_cpu(p->header.next);\n\t\t\tXT_GETPAGE(ip, nextbn, rmp, PSIZE, rp, rc);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(pmp);\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\tlmp = NULL;\n\t\tif (p->header.prev) {\n\t\t\tprevbn = le64_to_cpu(p->header.prev);\n\t\t\tXT_GETPAGE(ip, prevbn, lmp, PSIZE, lp, rc);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(pmp);\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t\tif (rmp)\n\t\t\t\t\tXT_PUTPAGE(rmp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* at this point, all xtpages to be updated are in memory */\n\n\t\t/*\n\t\t * update sibling pointers of sibling xtpages if any;\n\t\t */\n\t\tif (lmp) {\n\t\t\tBT_MARK_DIRTY(lmp, ip);\n\t\t\ttlck = txLock(tid, ip, lmp, tlckXTREE | tlckRELINK);\n\t\t\tlp->header.next = cpu_to_le64(nxaddr);\n\t\t\tXT_PUTPAGE(lmp);\n\t\t}\n\n\t\tif (rmp) {\n\t\t\tBT_MARK_DIRTY(rmp, ip);\n\t\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckRELINK);\n\t\t\trp->header.prev = cpu_to_le64(nxaddr);\n\t\t\tXT_PUTPAGE(rmp);\n\t\t}\n\n\t\t/*\n\t\t * update the target xtpage to be relocated\n\t\t *\n\t\t * update the self address of the target page\n\t\t * and write to destination extent;\n\t\t * redo image covers the whole xtpage since it is new page\n\t\t * to the destination extent;\n\t\t * update of bmap for the free of source extent\n\t\t * of the target xtpage itself:\n\t\t * update of bmap for the allocation of destination extent\n\t\t * of the target xtpage itself:\n\t\t * update of bmap for the extents covered by xad entries in\n\t\t * the target xtpage is not necessary since they are not\n\t\t * updated;\n\t\t * if not committed before this relocation,\n\t\t * target page may contain XAD_NEW entries which must\n\t\t * be scanned for bmap update (logredo() always\n\t\t * scan xtpage REDOPAGE image for bmap update);\n\t\t * if committed before this relocation (tlckRELOCATE),\n\t\t * scan may be skipped by commit() and logredo();\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/* tlckNEW init xtlck->lwm.offset = XTENTRYSTART; */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\n\t\t/* update the self address in the xtpage header */\n\t\tpxd = &p->header.self;\n\t\tPXDaddress(pxd, nxaddr);\n\n\t\t/* linelock for the after image of the whole page */\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\n\t\t/* update the buffer extent descriptor of target xtpage */\n\t\txsize = xlen << JFS_SBI(ip->i_sb)->l2bsize;\n\t\tbmSetXD(mp, nxaddr, xsize);\n\n\t\t/* unpin the target page to new homeward bound */\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_info(\"xtRelocate: target xtpage relocated.\");\n\t}\n\n\t/*\n\t *\t3. acquire maplock for the source extent to be freed;\n\t *\n\t * acquire a maplock saving the src relocated extent address;\n\t * to free of the extent at commit time;\n\t */\n      out:\n\t/* if DATAEXT relocation, write a LOG_UPDATEMAP record for\n\t * free PXD of the source data extent (logredo() will update\n\t * bmap for free of source data extent), and update bmap for\n\t * free of the source data extent;\n\t */\n\tif (xtype == DATAEXT)\n\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t/* if XTPAGE relocation, write a LOG_NOREDOPAGE record\n\t * for the source xtpage (logredo() will init NoRedoPage\n\t * filter and will also update bmap for free of the source\n\t * xtpage), and update bmap for free of the source xtpage;\n\t * N.B. We use tlckMAP instead of tlkcXTREE because there\n\t *      is no buffer associated with this lock since the buffer\n\t *      has been redirected to the target location.\n\t */\n\telse\t\t\t/* (xtype == XTPAGE) */\n\t\ttlck = txMaplock(tid, ip, tlckMAP | tlckRELOCATE);\n\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tPXDaddress(&pxdlock->pxd, oxaddr);\n\tPXDlength(&pxdlock->pxd, xlen);\n\tpxdlock->index = 1;\n\n\t/*\n\t *\t4. update the parent xad entry for relocation;\n\t *\n\t * acquire tlck for the parent entry with XAD_NEW as entry\n\t * update which will write LOG_REDOPAGE and update bmap for\n\t * allocation of XAD_NEW destination extent;\n\t */\n\tjfs_info(\"xtRelocate: update parent xad entry.\");\n\tBT_MARK_DIRTY(pmp, ip);\n\ttlck = txLock(tid, ip, pmp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t/* update the XAD with the new destination extent; */\n\txad = &pp->xad[index];\n\txad->flag |= XAD_NEW;\n\tXADaddress(xad, nxaddr);\n\n\txtlck->lwm.offset = min(index, xtlck->lwm.offset);\n\txtlck->lwm.length = le16_to_cpu(pp->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t/* unpin the parent xtpage */\n\tXT_PUTPAGE(pmp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pp->header.nextindex"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "xtlck->lwm.offset"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xad",
            "nxaddr"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "pmp",
            "tlckXTREE | tlckGROW"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "pmp",
            "ip"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtRelocate: update parent xad entry.\""
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&pxdlock->pxd",
            "xlen"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&pxdlock->pxd",
            "oxaddr"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txMaplock",
          "args": [
            "tid",
            "ip",
            "tlckMAP | tlckRELOCATE"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "txMaplock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "995-1061",
          "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtRelocate: target xtpage relocated.\""
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmSetXD",
          "args": [
            "mp",
            "nxaddr",
            "xsize"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nxaddr"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "rmp",
            "ip"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "lmp"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nxaddr"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "lmp",
            "ip"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "prevbn",
            "lmp",
            "PSIZE",
            "lp",
            "rc"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.prev"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "nextbn",
            "rmp",
            "PSIZE",
            "rp",
            "rc"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "oxaddr",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtRelocate: target data extent relocated.\""
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "pmp",
            "pp",
            "index"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff",
            "NULL",
            "&cmp",
            "&btstack",
            "0"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmPut",
          "args": [
            "cp",
            "true"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmSetXD",
          "args": [
            "ip",
            "cp",
            "pno",
            "dxaddr",
            "nblks"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip->i_sb"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!cp->cm_modified"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&cp->cm_pxd"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmRead",
          "args": [
            "ip",
            "offset",
            "npages",
            "&cp"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtRelocate: parent xad entry validated.\""
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "pmp",
            "pp",
            "index"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearchNode",
          "args": [
            "ip",
            "oxad",
            "&cmp",
            "&btstack",
            "0"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearchNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "2891-2995",
          "snippet": "static int xtSearchNode(struct inode *ip, xad_t * xad,\t/* required XAD entry */\n\t\t\tint *cmpp, struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\ts64 xoff, xaddr;\n\tint xlen;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* page */\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\ts64 t64;\n\n\tBT_CLR(btstack);\n\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t *\n\t\t\t\t * verify for exact match;\n\t\t\t\t */\n\t\t\t\tif (xaddr == addressXAD(&p->xad[index]) &&\n\t\t\t\t    xoff == offsetXAD(&p->xad[index])) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* descend/search its child page */\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss - non-leaf page:\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearchNode(struct inode *ip, xad_t * xad,\t/* required XAD entry */\n\t\t\tint *cmpp, struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\ts64 xoff, xaddr;\n\tint xlen;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* page */\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\ts64 t64;\n\n\tBT_CLR(btstack);\n\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t *\n\t\t\t\t * verify for exact match;\n\t\t\t\t */\n\t\t\t\tif (xaddr == addressXAD(&p->xad[index]) &&\n\t\t\t\t    xoff == offsetXAD(&p->xad[index])) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* descend/search its child page */\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss - non-leaf page:\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "pmp",
            "pp",
            "index"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtRelocate: xtype:%d xoff:0x%lx xlen:0x%x xaddr:0x%lx:0x%lx\"",
            "xtype",
            "(ulong) xoff",
            "xlen",
            "(ulong) oxaddr",
            "(ulong) nxaddr"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "oxad"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "oxad"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "oxad"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint\nxtRelocate(tid_t tid, struct inode * ip, xad_t * oxad,\t/* old XAD */\n\t   s64 nxaddr,\t\t/* new xaddr */\n\t   int xtype)\n{\t\t\t\t/* extent type: XTPAGE or DATAEXT */\n\tint rc = 0;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct metapage *mp, *pmp, *lmp, *rmp;\t/* meta-page buffer */\n\txtpage_t *p, *pp, *rp, *lp;\t/* base B+-tree index page */\n\txad_t *xad;\n\tpxd_t *pxd;\n\ts64 xoff, xsize;\n\tint xlen;\n\ts64 oxaddr, sxaddr, dxaddr, nextbn, prevbn;\n\tcbuf_t *cp;\n\ts64 offset, nbytes, nbrd, pno;\n\tint nb, npages, nblks;\n\ts64 bn;\n\tint cmp;\n\tint index;\n\tstruct pxd_lock *pxdlock;\n\tstruct btstack btstack;\t/* traverse stack */\n\n\txtype = xtype & EXTENT_TYPE;\n\n\txoff = offsetXAD(oxad);\n\toxaddr = addressXAD(oxad);\n\txlen = lengthXAD(oxad);\n\n\t/* validate extent offset */\n\toffset = xoff << JFS_SBI(ip->i_sb)->l2bsize;\n\tif (offset >= ip->i_size)\n\t\treturn -ESTALE;\t/* stale extent */\n\n\tjfs_info(\"xtRelocate: xtype:%d xoff:0x%lx xlen:0x%x xaddr:0x%lx:0x%lx\",\n\t\t xtype, (ulong) xoff, xlen, (ulong) oxaddr, (ulong) nxaddr);\n\n\t/*\n\t *\t1. get and validate the parent xtpage/xad entry\n\t *\tcovering the source extent to be relocated;\n\t */\n\tif (xtype == DATAEXT) {\n\t\t/* search in leaf entry */\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\n\t\tif (cmp) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* validate for exact match with a single entry */\n\t\txad = &pp->xad[index];\n\t\tif (addressXAD(xad) != oxaddr || lengthXAD(xad) != xlen) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn -ESTALE;\n\t\t}\n\t} else {\t\t/* (xtype == XTPAGE) */\n\n\t\t/* search in internal entry */\n\t\trc = xtSearchNode(ip, oxad, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\n\t\tif (cmp) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* xtSearchNode() validated for exact match with a single entry\n\t\t */\n\t\txad = &pp->xad[index];\n\t}\n\tjfs_info(\"xtRelocate: parent xad entry validated.\");\n\n\t/*\n\t *\t2. relocate the extent\n\t */\n\tif (xtype == DATAEXT) {\n\t\t/* if the extent is allocated-but-not-recorded\n\t\t * there is no real data to be moved in this extent,\n\t\t */\n\t\tif (xad->flag & XAD_NOTRECORDED)\n\t\t\tgoto out;\n\t\telse\n\t\t\t/* release xtpage for cmRead()/xtLookup() */\n\t\t\tXT_PUTPAGE(pmp);\n\n\t\t/*\n\t\t *\tcmRelocate()\n\t\t *\n\t\t * copy target data pages to be relocated;\n\t\t *\n\t\t * data extent must start at page boundary and\n\t\t * multiple of page size (except the last data extent);\n\t\t * read in each page of the source data extent into cbuf,\n\t\t * update the cbuf extent descriptor of the page to be\n\t\t * homeward bound to new dst data extent\n\t\t * copy the data from the old extent to new extent.\n\t\t * copy is essential for compressed files to avoid problems\n\t\t * that can arise if there was a change in compression\n\t\t * algorithms.\n\t\t * it is a good strategy because it may disrupt cache\n\t\t * policy to keep the pages in memory afterwards.\n\t\t */\n\t\toffset = xoff << JFS_SBI(ip->i_sb)->l2bsize;\n\t\tassert((offset & CM_OFFSET) == 0);\n\t\tnbytes = xlen << JFS_SBI(ip->i_sb)->l2bsize;\n\t\tpno = offset >> CM_L2BSIZE;\n\t\tnpages = (nbytes + (CM_BSIZE - 1)) >> CM_L2BSIZE;\n/*\n\t\tnpages = ((offset + nbytes - 1) >> CM_L2BSIZE) -\n\t\t\t  (offset >> CM_L2BSIZE) + 1;\n*/\n\t\tsxaddr = oxaddr;\n\t\tdxaddr = nxaddr;\n\n\t\t/* process the request one cache buffer at a time */\n\t\tfor (nbrd = 0; nbrd < nbytes; nbrd += nb,\n\t\t     offset += nb, pno++, npages--) {\n\t\t\t/* compute page size */\n\t\t\tnb = min(nbytes - nbrd, CM_BSIZE);\n\n\t\t\t/* get the cache buffer of the page */\n\t\t\tif (rc = cmRead(ip, offset, npages, &cp))\n\t\t\t\tbreak;\n\n\t\t\tassert(addressPXD(&cp->cm_pxd) == sxaddr);\n\t\t\tassert(!cp->cm_modified);\n\n\t\t\t/* bind buffer with the new extent address */\n\t\t\tnblks = nb >> JFS_IP(ip->i_sb)->l2bsize;\n\t\t\tcmSetXD(ip, cp, pno, dxaddr, nblks);\n\n\t\t\t/* release the cbuf, mark it as modified */\n\t\t\tcmPut(cp, true);\n\n\t\t\tdxaddr += nblks;\n\t\t\tsxaddr += nblks;\n\t\t}\n\n\t\t/* get back parent page */\n\t\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0)))\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\t\tjfs_info(\"xtRelocate: target data extent relocated.\");\n\t} else {\t\t/* (xtype == XTPAGE) */\n\n\t\t/*\n\t\t * read in the target xtpage from the source extent;\n\t\t */\n\t\tXT_GETPAGE(ip, oxaddr, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(pmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * read in sibling pages if any to update sibling pointers;\n\t\t */\n\t\trmp = NULL;\n\t\tif (p->header.next) {\n\t\t\tnextbn = le64_to_cpu(p->header.next);\n\t\t\tXT_GETPAGE(ip, nextbn, rmp, PSIZE, rp, rc);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(pmp);\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\tlmp = NULL;\n\t\tif (p->header.prev) {\n\t\t\tprevbn = le64_to_cpu(p->header.prev);\n\t\t\tXT_GETPAGE(ip, prevbn, lmp, PSIZE, lp, rc);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(pmp);\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t\tif (rmp)\n\t\t\t\t\tXT_PUTPAGE(rmp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* at this point, all xtpages to be updated are in memory */\n\n\t\t/*\n\t\t * update sibling pointers of sibling xtpages if any;\n\t\t */\n\t\tif (lmp) {\n\t\t\tBT_MARK_DIRTY(lmp, ip);\n\t\t\ttlck = txLock(tid, ip, lmp, tlckXTREE | tlckRELINK);\n\t\t\tlp->header.next = cpu_to_le64(nxaddr);\n\t\t\tXT_PUTPAGE(lmp);\n\t\t}\n\n\t\tif (rmp) {\n\t\t\tBT_MARK_DIRTY(rmp, ip);\n\t\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckRELINK);\n\t\t\trp->header.prev = cpu_to_le64(nxaddr);\n\t\t\tXT_PUTPAGE(rmp);\n\t\t}\n\n\t\t/*\n\t\t * update the target xtpage to be relocated\n\t\t *\n\t\t * update the self address of the target page\n\t\t * and write to destination extent;\n\t\t * redo image covers the whole xtpage since it is new page\n\t\t * to the destination extent;\n\t\t * update of bmap for the free of source extent\n\t\t * of the target xtpage itself:\n\t\t * update of bmap for the allocation of destination extent\n\t\t * of the target xtpage itself:\n\t\t * update of bmap for the extents covered by xad entries in\n\t\t * the target xtpage is not necessary since they are not\n\t\t * updated;\n\t\t * if not committed before this relocation,\n\t\t * target page may contain XAD_NEW entries which must\n\t\t * be scanned for bmap update (logredo() always\n\t\t * scan xtpage REDOPAGE image for bmap update);\n\t\t * if committed before this relocation (tlckRELOCATE),\n\t\t * scan may be skipped by commit() and logredo();\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/* tlckNEW init xtlck->lwm.offset = XTENTRYSTART; */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\n\t\t/* update the self address in the xtpage header */\n\t\tpxd = &p->header.self;\n\t\tPXDaddress(pxd, nxaddr);\n\n\t\t/* linelock for the after image of the whole page */\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\n\t\t/* update the buffer extent descriptor of target xtpage */\n\t\txsize = xlen << JFS_SBI(ip->i_sb)->l2bsize;\n\t\tbmSetXD(mp, nxaddr, xsize);\n\n\t\t/* unpin the target page to new homeward bound */\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_info(\"xtRelocate: target xtpage relocated.\");\n\t}\n\n\t/*\n\t *\t3. acquire maplock for the source extent to be freed;\n\t *\n\t * acquire a maplock saving the src relocated extent address;\n\t * to free of the extent at commit time;\n\t */\n      out:\n\t/* if DATAEXT relocation, write a LOG_UPDATEMAP record for\n\t * free PXD of the source data extent (logredo() will update\n\t * bmap for free of source data extent), and update bmap for\n\t * free of the source data extent;\n\t */\n\tif (xtype == DATAEXT)\n\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t/* if XTPAGE relocation, write a LOG_NOREDOPAGE record\n\t * for the source xtpage (logredo() will init NoRedoPage\n\t * filter and will also update bmap for free of the source\n\t * xtpage), and update bmap for free of the source xtpage;\n\t * N.B. We use tlckMAP instead of tlkcXTREE because there\n\t *      is no buffer associated with this lock since the buffer\n\t *      has been redirected to the target location.\n\t */\n\telse\t\t\t/* (xtype == XTPAGE) */\n\t\ttlck = txMaplock(tid, ip, tlckMAP | tlckRELOCATE);\n\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tPXDaddress(&pxdlock->pxd, oxaddr);\n\tPXDlength(&pxdlock->pxd, xlen);\n\tpxdlock->index = 1;\n\n\t/*\n\t *\t4. update the parent xad entry for relocation;\n\t *\n\t * acquire tlck for the parent entry with XAD_NEW as entry\n\t * update which will write LOG_REDOPAGE and update bmap for\n\t * allocation of XAD_NEW destination extent;\n\t */\n\tjfs_info(\"xtRelocate: update parent xad entry.\");\n\tBT_MARK_DIRTY(pmp, ip);\n\ttlck = txLock(tid, ip, pmp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t/* update the XAD with the new destination extent; */\n\txad = &pp->xad[index];\n\txad->flag |= XAD_NEW;\n\tXADaddress(xad, nxaddr);\n\n\txtlck->lwm.offset = min(index, xtlck->lwm.offset);\n\txtlck->lwm.length = le16_to_cpu(pp->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t/* unpin the parent xtpage */\n\tXT_PUTPAGE(pmp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xtDeleteUp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "2409-2544",
    "snippet": "static int\nxtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, xtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index, nextindex;\n\ts64 xaddr;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\t/*\n\t * keep root leaf page which has become empty\n\t */\n\tif (fp->header.flag & BT_ROOT) {\n\t\t/* keep the root page */\n\t\tfp->header.flag &= ~BT_INTERNAL;\n\t\tfp->header.flag |= BT_LEAF;\n\t\tfp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\t/* XT_PUTPAGE(fmp); */\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * free non-root leaf page\n\t */\n\tif ((rc = xtRelink(tid, ip, fp))) {\n\t\tXT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txaddr = addressPXD(&fp->header.self);\n\txlen = lengthPXD(&fp->header.self);\n\t/* free the page extent */\n\tdbFree(ip, xaddr, (s64) xlen);\n\n\t/* free the buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t * propagate page deletion up the index tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tindex = parent->index;\n\n\t\t/* delete the entry for the freed child page from parent.\n\t\t */\n\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/* keep the root page */\n\t\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\t\tp->header.flag |= BT_LEAF;\n\t\t\t\tp->header.nextindex =\n\t\t\t\t    cpu_to_le16(XTENTRYSTART);\n\n\t\t\t\t/* XT_PUTPAGE(mp); */\n\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* free the parent page */\n\t\t\t\tif ((rc = xtRelink(tid, ip, p)))\n\t\t\t\t\treturn rc;\n\n\t\t\t\txaddr = addressPXD(&p->header.self);\n\t\t\t\t/* free the page extent */\n\t\t\t\tdbFree(ip, xaddr,\n\t\t\t\t       (s64) JFS_SBI(ip->i_sb)->nbperpage);\n\n\t\t\t\t/* unpin/free the buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the leaf page;\n\t\t\t *\n\t\t\t * action:xad deletion;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset =\n\t\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t\t      xtlck->lwm.\n\t\t\t\t\t\t      offset) : index;\n\n\t\t\t/* if delete from middle,\n\t\t\t * shift left/compact the remaining entries in the page\n\t\t\t */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tle16_add_cpu(&p->header.nextindex, -1);\n\t\t\tjfs_info(\"xtDeleteUp(entry): 0x%lx[%d]\",\n\t\t\t\t (ulong) parent->bn, index);\n\t\t}\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtDeleteUp(entry): 0x%lx[%d]\"",
            "(ulong) parent->bn",
            "index"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&p->header.nextindex",
            "-1"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[index]",
            "&p->xad[index + 1]",
            "(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "xtlck->lwm.\n\t\t\t\t\t\t      offset"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "mp"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "xaddr",
            "(s64) JFS_SBI(ip->i_sb)->nbperpage"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&p->header.self"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtRelink",
          "args": [
            "tid",
            "ip",
            "p"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "xtRelink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3011-3064",
          "snippet": "static int xtRelink(tid_t tid, struct inode *ip, xtpage_t * p)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tXT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.next = le64_to_cpu(nextbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtRelink(tid_t tid, struct inode *ip, xtpage_t * p)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tXT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * acquire a transaction lock on the page;\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\t/* the page may already have been tlock'd */\n\n\t\tp->header.next = le64_to_cpu(nextbn);\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "parent->bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "btstack"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&fp->header.self"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "fmp"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, xtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index, nextindex;\n\ts64 xaddr;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\t/*\n\t * keep root leaf page which has become empty\n\t */\n\tif (fp->header.flag & BT_ROOT) {\n\t\t/* keep the root page */\n\t\tfp->header.flag &= ~BT_INTERNAL;\n\t\tfp->header.flag |= BT_LEAF;\n\t\tfp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\t/* XT_PUTPAGE(fmp); */\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * free non-root leaf page\n\t */\n\tif ((rc = xtRelink(tid, ip, fp))) {\n\t\tXT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txaddr = addressPXD(&fp->header.self);\n\txlen = lengthPXD(&fp->header.self);\n\t/* free the page extent */\n\tdbFree(ip, xaddr, (s64) xlen);\n\n\t/* free the buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t * propagate page deletion up the index tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tindex = parent->index;\n\n\t\t/* delete the entry for the freed child page from parent.\n\t\t */\n\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/* keep the root page */\n\t\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\t\tp->header.flag |= BT_LEAF;\n\t\t\t\tp->header.nextindex =\n\t\t\t\t    cpu_to_le16(XTENTRYSTART);\n\n\t\t\t\t/* XT_PUTPAGE(mp); */\n\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* free the parent page */\n\t\t\t\tif ((rc = xtRelink(tid, ip, p)))\n\t\t\t\t\treturn rc;\n\n\t\t\t\txaddr = addressPXD(&p->header.self);\n\t\t\t\t/* free the page extent */\n\t\t\t\tdbFree(ip, xaddr,\n\t\t\t\t       (s64) JFS_SBI(ip->i_sb)->nbperpage);\n\n\t\t\t\t/* unpin/free the buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the leaf page;\n\t\t\t *\n\t\t\t * action:xad deletion;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset =\n\t\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t\t      xtlck->lwm.\n\t\t\t\t\t\t      offset) : index;\n\n\t\t\t/* if delete from middle,\n\t\t\t * shift left/compact the remaining entries in the page\n\t\t\t */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tle16_add_cpu(&p->header.nextindex, -1);\n\t\t\tjfs_info(\"xtDeleteUp(entry): 0x%lx[%d]\",\n\t\t\t\t (ulong) parent->bn, index);\n\t\t}\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xtDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "2339-2395",
    "snippet": "int xtDelete(tid_t tid, struct inode *ip, s64 xoff, s32 xlen, int flag)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index, nextindex;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\t/*\n\t * find the matching entry; xtSearch() pins the page\n\t */\n\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0)))\n\t\treturn rc;\n\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\tif (cmp) {\n\t\t/* unpin the leaf page */\n\t\tXT_PUTPAGE(mp);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * delete the entry from the leaf page\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tle16_add_cpu(&p->header.nextindex, -1);\n\n\t/*\n\t * if the leaf page bocome empty, free the page\n\t */\n\tif (p->header.nextindex == cpu_to_le16(XTENTRYSTART))\n\t\treturn (xtDeleteUp(tid, ip, mp, p, &btstack));\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action:xad deletion;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index, xtlck->lwm.offset) : index;\n\n\t/* if delete from middle, shift left/compact the remaining entries */\n\tif (index < nextindex - 1)\n\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t(nextindex - index - 1) * sizeof(xad_t));\n\n\tXT_PUTPAGE(mp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[index]",
            "&p->xad[index + 1]",
            "(nextindex - index - 1) * sizeof(xad_t)"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "xtlck->lwm.offset"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtDeleteUp",
          "args": [
            "tid",
            "ip",
            "mp",
            "p",
            "&btstack"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "xtDeleteUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "2409-2544",
          "snippet": "static int\nxtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, xtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index, nextindex;\n\ts64 xaddr;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\t/*\n\t * keep root leaf page which has become empty\n\t */\n\tif (fp->header.flag & BT_ROOT) {\n\t\t/* keep the root page */\n\t\tfp->header.flag &= ~BT_INTERNAL;\n\t\tfp->header.flag |= BT_LEAF;\n\t\tfp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\t/* XT_PUTPAGE(fmp); */\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * free non-root leaf page\n\t */\n\tif ((rc = xtRelink(tid, ip, fp))) {\n\t\tXT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txaddr = addressPXD(&fp->header.self);\n\txlen = lengthPXD(&fp->header.self);\n\t/* free the page extent */\n\tdbFree(ip, xaddr, (s64) xlen);\n\n\t/* free the buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t * propagate page deletion up the index tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tindex = parent->index;\n\n\t\t/* delete the entry for the freed child page from parent.\n\t\t */\n\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/* keep the root page */\n\t\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\t\tp->header.flag |= BT_LEAF;\n\t\t\t\tp->header.nextindex =\n\t\t\t\t    cpu_to_le16(XTENTRYSTART);\n\n\t\t\t\t/* XT_PUTPAGE(mp); */\n\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* free the parent page */\n\t\t\t\tif ((rc = xtRelink(tid, ip, p)))\n\t\t\t\t\treturn rc;\n\n\t\t\t\txaddr = addressPXD(&p->header.self);\n\t\t\t\t/* free the page extent */\n\t\t\t\tdbFree(ip, xaddr,\n\t\t\t\t       (s64) JFS_SBI(ip->i_sb)->nbperpage);\n\n\t\t\t\t/* unpin/free the buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the leaf page;\n\t\t\t *\n\t\t\t * action:xad deletion;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset =\n\t\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t\t      xtlck->lwm.\n\t\t\t\t\t\t      offset) : index;\n\n\t\t\t/* if delete from middle,\n\t\t\t * shift left/compact the remaining entries in the page\n\t\t\t */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tle16_add_cpu(&p->header.nextindex, -1);\n\t\t\tjfs_info(\"xtDeleteUp(entry): 0x%lx[%d]\",\n\t\t\t\t (ulong) parent->bn, index);\n\t\t}\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, xtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index, nextindex;\n\ts64 xaddr;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\t/*\n\t * keep root leaf page which has become empty\n\t */\n\tif (fp->header.flag & BT_ROOT) {\n\t\t/* keep the root page */\n\t\tfp->header.flag &= ~BT_INTERNAL;\n\t\tfp->header.flag |= BT_LEAF;\n\t\tfp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\t/* XT_PUTPAGE(fmp); */\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * free non-root leaf page\n\t */\n\tif ((rc = xtRelink(tid, ip, fp))) {\n\t\tXT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txaddr = addressPXD(&fp->header.self);\n\txlen = lengthPXD(&fp->header.self);\n\t/* free the page extent */\n\tdbFree(ip, xaddr, (s64) xlen);\n\n\t/* free the buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t * propagate page deletion up the index tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tindex = parent->index;\n\n\t\t/* delete the entry for the freed child page from parent.\n\t\t */\n\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/* keep the root page */\n\t\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\t\tp->header.flag |= BT_LEAF;\n\t\t\t\tp->header.nextindex =\n\t\t\t\t    cpu_to_le16(XTENTRYSTART);\n\n\t\t\t\t/* XT_PUTPAGE(mp); */\n\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* free the parent page */\n\t\t\t\tif ((rc = xtRelink(tid, ip, p)))\n\t\t\t\t\treturn rc;\n\n\t\t\t\txaddr = addressPXD(&p->header.self);\n\t\t\t\t/* free the page extent */\n\t\t\t\tdbFree(ip, xaddr,\n\t\t\t\t       (s64) JFS_SBI(ip->i_sb)->nbperpage);\n\n\t\t\t\t/* unpin/free the buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the leaf page;\n\t\t\t *\n\t\t\t * action:xad deletion;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset =\n\t\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t\t      xtlck->lwm.\n\t\t\t\t\t\t      offset) : index;\n\n\t\t\t/* if delete from middle,\n\t\t\t * shift left/compact the remaining entries in the page\n\t\t\t */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tle16_add_cpu(&p->header.nextindex, -1);\n\t\t\tjfs_info(\"xtDeleteUp(entry): 0x%lx[%d]\",\n\t\t\t\t (ulong) parent->bn, index);\n\t\t}\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&p->header.nextindex",
            "-1"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff",
            "NULL",
            "&cmp",
            "&btstack",
            "0"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtDelete(tid_t tid, struct inode *ip, s64 xoff, s32 xlen, int flag)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index, nextindex;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\t/*\n\t * find the matching entry; xtSearch() pins the page\n\t */\n\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0)))\n\t\treturn rc;\n\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\tif (cmp) {\n\t\t/* unpin the leaf page */\n\t\tXT_PUTPAGE(mp);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * delete the entry from the leaf page\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tle16_add_cpu(&p->header.nextindex, -1);\n\n\t/*\n\t * if the leaf page bocome empty, free the page\n\t */\n\tif (p->header.nextindex == cpu_to_le16(XTENTRYSTART))\n\t\treturn (xtDeleteUp(tid, ip, mp, p, &btstack));\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action:xad deletion;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index, xtlck->lwm.offset) : index;\n\n\t/* if delete from middle, shift left/compact the remaining entries */\n\tif (index < nextindex - 1)\n\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t(nextindex - index - 1) * sizeof(xad_t));\n\n\tXT_PUTPAGE(mp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xtAppend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "2169-2320",
    "snippet": "int xtAppend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 maxblocks,\n\t     s32 * xlenp,\t/* (in/out) */\n\t     s64 * xaddrp,\t/* (in/out) */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn, xaddr;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint nsplit, nblocks, xlen;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\ts64 next;\n\n\txaddr = *xaddrp;\n\txlen = *xlenp;\n\tjfs_info(\"xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx\",\n\t\t (ulong) xoff, maxblocks, xlen, (ulong) xaddr);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp == 0) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (next)\n\t\txlen = min(xlen, (int)(next - xoff));\n//insert:\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex < le16_to_cpu(p->header.maxentry))\n\t\tgoto insertLeaf;\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t */\n\tnsplit = btstack.nsplit;\n\tsplit.pxdlist = &pxdlist;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\tpxd = &pxdlist.pxd[0];\n\tnblocks = JFS_SBI(ip->i_sb)->nbperpage;\n\tfor (; nsplit > 0; nsplit--, pxd++, xaddr += nblocks, maxblocks -= nblocks) {\n\t\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) nblocks)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, nblocks);\n\n\t\t\tpxdlist.maxnpxd++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* undo allocation */\n\n\t\tgoto out;\n\t}\n\n\txlen = min(xlen, maxblocks);\n\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tsplit.mp = mp;\n\tsplit.index = index;\n\tsplit.flag = xflag;\n\tsplit.off = xoff;\n\tsplit.len = xlen;\n\tsplit.addr = xaddr;\n\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t/* undo data extent allocation */\n\t\tdbFree(ip, *xaddrp, (s64) * xlenp);\n\n\t\treturn rc;\n\t}\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\treturn 0;\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n      insertLeaf:\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index,(int) xtlck->lwm.offset) : index;\n\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define XT_INSERT\t0x00000001"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "(int) xtlck->lwm.offset"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&p->header.nextindex",
            "1"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "xflag",
            "xoff",
            "xlen",
            "xaddr"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE | tlckGROW"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAllocBottomUp",
          "args": [
            "ip",
            "xaddr",
            "(s64) xlen"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocBottomUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3208-3260",
          "snippet": "int dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be allocated better be within the mapsize. */\n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t/*\n\t * allocate the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be allocated from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* allocate the blocks. */\n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be allocated better be within the mapsize. */\n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t/*\n\t * allocate the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be allocated from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* allocate the blocks. */\n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "*xaddrp",
            "(s64) * xlenp"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtSplitUp",
          "args": [
            "tid",
            "ip",
            "&split",
            "&btstack"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "687-936",
          "snippet": "static int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "pxd",
            "nblocks"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "xaddr"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff",
            "&next",
            "&cmp",
            "&btstack",
            "XT_INSERT"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx\"",
            "(ulong) xoff",
            "maxblocks",
            "xlen",
            "(ulong) xaddr"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtAppend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 maxblocks,\n\t     s32 * xlenp,\t/* (in/out) */\n\t     s64 * xaddrp,\t/* (in/out) */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn, xaddr;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint nsplit, nblocks, xlen;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\ts64 next;\n\n\txaddr = *xaddrp;\n\txlen = *xlenp;\n\tjfs_info(\"xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx\",\n\t\t (ulong) xoff, maxblocks, xlen, (ulong) xaddr);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp == 0) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (next)\n\t\txlen = min(xlen, (int)(next - xoff));\n//insert:\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex < le16_to_cpu(p->header.maxentry))\n\t\tgoto insertLeaf;\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t */\n\tnsplit = btstack.nsplit;\n\tsplit.pxdlist = &pxdlist;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\tpxd = &pxdlist.pxd[0];\n\tnblocks = JFS_SBI(ip->i_sb)->nbperpage;\n\tfor (; nsplit > 0; nsplit--, pxd++, xaddr += nblocks, maxblocks -= nblocks) {\n\t\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) nblocks)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, nblocks);\n\n\t\t\tpxdlist.maxnpxd++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* undo allocation */\n\n\t\tgoto out;\n\t}\n\n\txlen = min(xlen, maxblocks);\n\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tsplit.mp = mp;\n\tsplit.index = index;\n\tsplit.flag = xflag;\n\tsplit.off = xoff;\n\tsplit.len = xlen;\n\tsplit.addr = xaddr;\n\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t/* undo data extent allocation */\n\t\tdbFree(ip, *xaddrp, (s64) * xlenp);\n\n\t\treturn rc;\n\t}\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\treturn 0;\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n      insertLeaf:\n\t/*\n\t * allocate data extent requested\n\t */\n\tif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\n\t\tgoto out;\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\txtlck = (struct xtlock *) & tlck->lock;\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\txtlck->lwm.offset =\n\t    (xtlck->lwm.offset) ? min(index,(int) xtlck->lwm.offset) : index;\n\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t    xtlck->lwm.offset;\n\n\t*xaddrp = xaddr;\n\t*xlenp = xlen;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xtUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "1705-2149",
    "snippet": "int xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t/* new XAD */\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t/* there must exist extent to be tailgated */\n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/* nXAD must be completely contained within XAD */\n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n#ifdef  _JFS_WIP_NOCOALESCE\n\tif (xoff < nxoff)\n\t\tgoto updateRight;\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto out;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n#endif\t\t\t\t/* _JFS_WIP_NOCOALESCE */\n\n/* #ifdef _JFS_WIP_COALESCE */\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t/*\n\t * coalesce with left XAD\n\t */\n//coalesceLeft: /* (xoff == nxoff) */\n\t/* is XAD first entry of page ? */\n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t/* is nXAD logically and physically contiguous with lXAD ? */\n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t/* extend right lXAD */\n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t/* If we just merged two extents together, need to make sure the\n\t\t * right extent gets logged.  If the left one is marked XAD_NEW,\n\t\t * then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t/* truncate XAD */\n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n\n\t/*\n\t * coalesce with right XAD\n\t */\n      coalesceRight:\t\t/* (xoff <= nxoff) */\n\t/* is XAD last entry of page ? */\n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t/* is nXAD logically and physically contiguous with rXAD ? */\n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t/* extend left rXAD */\n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t/* If we just merged two extents together, need to make sure\n\t\t * the left extent gets logged.  If the right one is marked\n\t\t * XAD_NEW, then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t/* truncate XAD */\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n/* #endif _JFS_WIP_COALESCE */\n\n\t/*\n\t * split XAD into (lXAD, nXAD):\n\t *\n\t *          |---nXAD--->\n\t * --|----------XAD----------|--\n\t *   |-lXAD-|\n\t */\n      updateRight:\t\t/* (xoff < nxoff) */\n\t/* truncate old XAD as lXAD:not_recorded */\n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t/* insert nXAD:recorded */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* is nXAD on new page ? */\n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t/*\n\t * does nXAD force 3-way split ?\n\t *\n\t *          |---nXAD--->|\n\t * --|----------XAD-------------|--\n\t *   |-lXAD-|           |-rXAD -|\n\t */\n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */\n\tif (newpage) {\n\t\t/* close out old page */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* get new right page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t/* recompute split pages */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * split XAD into (nXAD, rXAD)\n\t *\n\t *          ---nXAD---|\n\t * --|----------XAD----------|--\n\t *                    |-rXAD-|\n\t */\n      updateLeft:\t\t/* (nxoff == xoff) && (nxlen < xlen) */\n\t/* update old XAD with nXAD:recorded */\n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t/* insert rXAD:not_recorded */\n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n/*\nprintf(\"xtUpdate.updateLeft.split p:0x%p\\n\", p);\n*/\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define XT_INSERT\t0x00000001"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index0",
            "(int)xtlck->lwm.offset"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(p->header.nextindex) + 1"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "xflag",
            "xoff",
            "xlen",
            "xaddr"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[newindex + 1]",
            "&p->xad[newindex]",
            "(nextindex - newindex) << L2XTSLOTSIZE"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE|tlckGROW"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1)"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + 1"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSplitUp",
          "args": [
            "tid",
            "ip",
            "&split",
            "&btstack"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "687-936",
          "snippet": "static int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"unexpected value of index\\n\""
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index0"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "nxoff",
            "NULL",
            "&cmp",
            "&btstack",
            "XT_INSERT"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.next"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(p->header.nextindex) + 1"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[newindex + 1]",
            "&p->xad[newindex]",
            "(nextindex - newindex) << L2XTSLOTSIZE"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1)"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + 1"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xad",
            "nxoff - xoff"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[index]",
            "&p->xad[index + 1]",
            "(nextindex - index - 1) << L2XTSLOTSIZE"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xad",
            "xlen - nxlen"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "rxad",
            "nxaddr"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "rxad",
            "rxlen + nxlen"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADoffset",
          "args": [
            "rxad",
            "nxoff"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "rxad"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "rxad"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "rxad"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "lxad"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "lxad"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[index]",
            "&p->xad[index + 1]",
            "(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xad",
            "xaddr + nxlen"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xad",
            "xlen - nxlen"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADoffset",
          "args": [
            "xad",
            "xoff + nxlen"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "lxad",
            "lxlen + nxlen"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "lxad"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "lxad"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "lxad"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index0"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "nxad"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "nxad"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "nxad"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t/* new XAD */\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t/* there must exist extent to be tailgated */\n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/* nXAD must be completely contained within XAD */\n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n#ifdef  _JFS_WIP_NOCOALESCE\n\tif (xoff < nxoff)\n\t\tgoto updateRight;\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto out;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n#endif\t\t\t\t/* _JFS_WIP_NOCOALESCE */\n\n/* #ifdef _JFS_WIP_COALESCE */\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t/*\n\t * coalesce with left XAD\n\t */\n//coalesceLeft: /* (xoff == nxoff) */\n\t/* is XAD first entry of page ? */\n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t/* is nXAD logically and physically contiguous with lXAD ? */\n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t/* extend right lXAD */\n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t/* If we just merged two extents together, need to make sure the\n\t\t * right extent gets logged.  If the left one is marked XAD_NEW,\n\t\t * then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t/* truncate XAD */\n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n\n\t/*\n\t * coalesce with right XAD\n\t */\n      coalesceRight:\t\t/* (xoff <= nxoff) */\n\t/* is XAD last entry of page ? */\n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t/* is nXAD logically and physically contiguous with rXAD ? */\n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t/* extend left rXAD */\n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t/* If we just merged two extents together, need to make sure\n\t\t * the left extent gets logged.  If the right one is marked\n\t\t * XAD_NEW, then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t/* truncate XAD */\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n/* #endif _JFS_WIP_COALESCE */\n\n\t/*\n\t * split XAD into (lXAD, nXAD):\n\t *\n\t *          |---nXAD--->\n\t * --|----------XAD----------|--\n\t *   |-lXAD-|\n\t */\n      updateRight:\t\t/* (xoff < nxoff) */\n\t/* truncate old XAD as lXAD:not_recorded */\n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t/* insert nXAD:recorded */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* is nXAD on new page ? */\n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t/*\n\t * does nXAD force 3-way split ?\n\t *\n\t *          |---nXAD--->|\n\t * --|----------XAD-------------|--\n\t *   |-lXAD-|           |-rXAD -|\n\t */\n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */\n\tif (newpage) {\n\t\t/* close out old page */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* get new right page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t/* recompute split pages */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * split XAD into (nXAD, rXAD)\n\t *\n\t *          ---nXAD---|\n\t * --|----------XAD----------|--\n\t *                    |-rXAD-|\n\t */\n      updateLeft:\t\t/* (nxoff == xoff) && (nxlen < xlen) */\n\t/* update old XAD with nXAD:recorded */\n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t/* insert rXAD:not_recorded */\n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n/*\nprintf(\"xtUpdate.updateLeft.split p:0x%p\\n\", p);\n*/\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xtTailgate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "1522-1689",
    "snippet": "int xtTailgate(tid_t tid,\t\t/* transaction id */\n\t       struct inode *ip, s64 xoff,\t/* split/new extent offset */\n\t       s32 xlen,\t/* new extent length */\n\t       s64 xaddr,\t/* new extent address */\n\t       int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, llen, rlen;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = 0;\n\tstruct tlock *mtlck;\n\tstruct maplock *pxdlock;\n\n/*\nprintf(\"xtTailgate: nxoff:0x%lx nxlen:0x%x nxaddr:0x%lx\\n\",\n\t(ulong)xoff, xlen, (ulong)xaddr);\n*/\n\n\t/* there must exist extent to be tailgated */\n\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"couldn't find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* entry found must be last entry */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (index != nextindex - 1) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"the entry found is not the last entry\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* completely replace extent ? */\n\txad = &p->xad[index];\n/*\nprintf(\"xtTailgate: xoff:0x%lx xlen:0x%x xaddr:0x%lx\\n\",\n\t(ulong)offsetXAD(xad), lengthXAD(xad), (ulong)addressXAD(xad));\n*/\n\tif ((llen = xoff - offsetXAD(xad)) == 0)\n\t\tgoto updateOld;\n\n\t/*\n\t *\tpartially replace extent: insert entry for new extent\n\t */\n//insertNew:\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old XAD */\n\txad = &p->xad[index];\n\n\t/*\n\t * truncate/relocate old extent at split offset\n\t */\n      updateOld:\n\t/* update dmap for old/committed/truncated extent */\n\trlen = lengthXAD(xad) - llen;\n\tif (!(xad->flag & XAD_NEW)) {\n\t\t/* free from PWMAP at commit */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tmtlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tpxdlock = (struct maplock *) & mtlck->lock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressXAD(xad) + llen);\n\t\t\tPXDlength(&pxdlock->pxd, rlen);\n\t\t\tpxdlock->index = 1;\n\t\t}\n\t} else\n\t\t/* free from WMAP */\n\t\tdbFree(ip, addressXAD(xad) + llen, (s64) rlen);\n\n\tif (llen)\n\t\t/* truncate */\n\t\tXADlength(xad, llen);\n\telse\n\t\t/* replace */\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define XT_INSERT\t0x00000001"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "(int)xtlck->lwm.offset"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "XAD_NEW",
            "xoff",
            "xlen",
            "xaddr"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xad",
            "llen"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "addressXAD(xad) + llen",
            "(s64) rlen"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&pxdlock->pxd",
            "rlen"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&pxdlock->pxd",
            "addressXAD(xad) + llen"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txMaplock",
          "args": [
            "tid",
            "ip",
            "tlckMAP"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "txMaplock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "995-1061",
          "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&p->header.nextindex",
            "1"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "XAD_NEW",
            "xoff",
            "xlen",
            "xaddr"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE|tlckGROW"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1)"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + 1"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSplitUp",
          "args": [
            "tid",
            "ip",
            "&split",
            "&btstack"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "687-936",
          "snippet": "static int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"the entry found is not the last entry\\n\""
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff",
            "NULL",
            "&cmp",
            "&btstack",
            "XT_INSERT"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtTailgate(tid_t tid,\t\t/* transaction id */\n\t       struct inode *ip, s64 xoff,\t/* split/new extent offset */\n\t       s32 xlen,\t/* new extent length */\n\t       s64 xaddr,\t/* new extent address */\n\t       int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, llen, rlen;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = 0;\n\tstruct tlock *mtlck;\n\tstruct maplock *pxdlock;\n\n/*\nprintf(\"xtTailgate: nxoff:0x%lx nxlen:0x%x nxaddr:0x%lx\\n\",\n\t(ulong)xoff, xlen, (ulong)xaddr);\n*/\n\n\t/* there must exist extent to be tailgated */\n\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"couldn't find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* entry found must be last entry */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (index != nextindex - 1) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"the entry found is not the last entry\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* completely replace extent ? */\n\txad = &p->xad[index];\n/*\nprintf(\"xtTailgate: xoff:0x%lx xlen:0x%x xaddr:0x%lx\\n\",\n\t(ulong)offsetXAD(xad), lengthXAD(xad), (ulong)addressXAD(xad));\n*/\n\tif ((llen = xoff - offsetXAD(xad)) == 0)\n\t\tgoto updateOld;\n\n\t/*\n\t *\tpartially replace extent: insert entry for new extent\n\t */\n//insertNew:\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old XAD */\n\txad = &p->xad[index];\n\n\t/*\n\t * truncate/relocate old extent at split offset\n\t */\n      updateOld:\n\t/* update dmap for old/committed/truncated extent */\n\trlen = lengthXAD(xad) - llen;\n\tif (!(xad->flag & XAD_NEW)) {\n\t\t/* free from PWMAP at commit */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tmtlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tpxdlock = (struct maplock *) & mtlck->lock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressXAD(xad) + llen);\n\t\t\tPXDlength(&pxdlock->pxd, rlen);\n\t\t\tpxdlock->index = 1;\n\t\t}\n\t} else\n\t\t/* free from WMAP */\n\t\tdbFree(ip, addressXAD(xad) + llen, (s64) rlen);\n\n\tif (llen)\n\t\t/* truncate */\n\t\tXADlength(xad, llen);\n\telse\n\t\t/* replace */\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xtExtend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "1360-1507",
    "snippet": "int xtExtend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, s64 xoff,\t/* delta extent offset */\n\t     s32 xlen,\t\t/* delta extent length */\n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/* there must exist extent to be extended */\n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extension must be contiguous */\n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* extend will overflow extent ? */\n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t/*\n\t *\textent overflow: insert entry for new extent\n\t */\n//insertNew:\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old entry */\n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t/*\n\t * extend old extent\n\t */\n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define XT_INSERT\t0x00000001"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "(int)xtlck->lwm.offset"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xad",
            "xlen"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&p->header.nextindex",
            "1"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "XAD_NEW",
            "xoff",
            "len",
            "xaddr"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE|tlckGROW"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1)"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + 1"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSplitUp",
          "args": [
            "tid",
            "ip",
            "&split",
            "&btstack"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "687-936",
          "snippet": "static int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"extension is not contiguous\\n\""
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff - 1",
            "NULL",
            "&cmp",
            "&btstack",
            "XT_INSERT"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtExtend: nxoff:0x%lx nxlen:0x%x\"",
            "(ulong) xoff",
            "xlen"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtExtend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, s64 xoff,\t/* delta extent offset */\n\t     s32 xlen,\t\t/* delta extent length */\n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/* there must exist extent to be extended */\n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extension must be contiguous */\n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* extend will overflow extent ? */\n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t/*\n\t *\textent overflow: insert entry for new extent\n\t */\n//insertNew:\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old entry */\n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t/*\n\t * extend old extent\n\t */\n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xtSplitRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "1224-1347",
    "snippet": "static int\nxtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct xtsplit * split, struct metapage ** rmpp)\n{\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\n\ts64 rbn;\n\tint skip, nextindex;\n\txad_t *xad;\n\tpxd_t *pxd;\n\tstruct pxdlist *pxdlist;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint rc;\n\n\tsp = &JFS_IP(ip)->i_xtroot;\n\n\tINCREMENT(xtStat.split);\n\n\t/*\n\t *\tallocate a single (right) child page\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"xtSplitRoot: ip:0x%p rmp:0x%p\", ip, rmp);\n\n\t/*\n\t * acquire a transaction lock on the new right page;\n\t *\n\t * action: new page;\n\t */\n\tBT_MARK_DIRTY(rmp, ip);\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\trp->header.maxentry = cpu_to_le16(PSIZE >> L2XTSLOTSIZE);\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t * copy the in-line root page into new right page extent\n\t */\n\tnextindex = le16_to_cpu(sp->header.maxentry);\n\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[XTENTRYSTART],\n\t\t(nextindex - XTENTRYSTART) << L2XTSLOTSIZE);\n\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tskip = split->index;\n\t/* if insert into middle, shift right remaining entries */\n\tif (skip != nextindex)\n\t\tmemmove(&rp->xad[skip + 1], &rp->xad[skip],\n\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\txad = &rp->xad[skip];\n\tXT_PUTENTRY(xad, split->flag, split->off, split->len, split->addr);\n\n\t/* update page header */\n\trp->header.nextindex = cpu_to_le16(nextindex + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t/*\n\t *\treset the root\n\t *\n\t * init root with the single entry for the new right page\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t */\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode);\n\t *\n\t * action: root split;\n\t */\n\tBT_MARK_DIRTY(split->mp, ip);\n\n\txad = &sp->xad[XTENTRYSTART];\n\tXT_PUTENTRY(xad, XAD_NEW, 0, JFS_SBI(ip->i_sb)->nbperpage, rbn);\n\n\t/* update page header of root */\n\tsp->header.flag &= ~BT_LEAF;\n\tsp->header.flag |= BT_INTERNAL;\n\n\tsp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, split->mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = 1;\n\t}\n\n\t*rmpp = rmp;\n\n\tjfs_info(\"xtSplitRoot: sp:0x%p rp:0x%p\", sp, rp);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtSplitRoot: sp:0x%p rp:0x%p\"",
            "sp",
            "rp"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "split->mp",
            "tlckXTREE | tlckGROW"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + 1"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "XAD_NEW",
            "0",
            "JFS_SBI(ip->i_sb)->nbperpage",
            "rbn"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "split->mp",
            "ip"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rp->header.nextindex"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "nextindex + 1"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "split->flag",
            "split->off",
            "split->len",
            "split->addr"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rp->xad[skip + 1]",
            "&rp->xad[skip]",
            "(nextindex - skip) * sizeof(xad_t)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rp->xad[XTENTRYSTART]",
            "&sp->xad[XTENTRYSTART]",
            "(nextindex - XTENTRYSTART) << L2XTSLOTSIZE"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "PSIZE >> L2XTSLOTSIZE"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "rmp",
            "ip"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtSplitRoot: ip:0x%p rmp:0x%p\"",
            "ip",
            "rmp"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "rmp"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "lengthPXD(pxd)"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ip",
            "rbn",
            "PSIZE",
            "1"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "pxd"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "xtStat.split"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);\n\nstatic int\nxtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct xtsplit * split, struct metapage ** rmpp)\n{\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\n\ts64 rbn;\n\tint skip, nextindex;\n\txad_t *xad;\n\tpxd_t *pxd;\n\tstruct pxdlist *pxdlist;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint rc;\n\n\tsp = &JFS_IP(ip)->i_xtroot;\n\n\tINCREMENT(xtStat.split);\n\n\t/*\n\t *\tallocate a single (right) child page\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"xtSplitRoot: ip:0x%p rmp:0x%p\", ip, rmp);\n\n\t/*\n\t * acquire a transaction lock on the new right page;\n\t *\n\t * action: new page;\n\t */\n\tBT_MARK_DIRTY(rmp, ip);\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\trp->header.maxentry = cpu_to_le16(PSIZE >> L2XTSLOTSIZE);\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t * copy the in-line root page into new right page extent\n\t */\n\tnextindex = le16_to_cpu(sp->header.maxentry);\n\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[XTENTRYSTART],\n\t\t(nextindex - XTENTRYSTART) << L2XTSLOTSIZE);\n\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tskip = split->index;\n\t/* if insert into middle, shift right remaining entries */\n\tif (skip != nextindex)\n\t\tmemmove(&rp->xad[skip + 1], &rp->xad[skip],\n\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\txad = &rp->xad[skip];\n\tXT_PUTENTRY(xad, split->flag, split->off, split->len, split->addr);\n\n\t/* update page header */\n\trp->header.nextindex = cpu_to_le16(nextindex + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t/*\n\t *\treset the root\n\t *\n\t * init root with the single entry for the new right page\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t */\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode);\n\t *\n\t * action: root split;\n\t */\n\tBT_MARK_DIRTY(split->mp, ip);\n\n\txad = &sp->xad[XTENTRYSTART];\n\tXT_PUTENTRY(xad, XAD_NEW, 0, JFS_SBI(ip->i_sb)->nbperpage, rbn);\n\n\t/* update page header of root */\n\tsp->header.flag &= ~BT_LEAF;\n\tsp->header.flag |= BT_INTERNAL;\n\n\tsp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, split->mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = 1;\n\t}\n\n\t*rmpp = rmp;\n\n\tjfs_info(\"xtSplitRoot: sp:0x%p rp:0x%p\", sp, rp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xtSplitPage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "957-1201",
    "snippet": "static int\nxtSplitPage(tid_t tid, struct inode *ip,\n\t    struct xtsplit * split, struct metapage ** rmpp, s64 * rbnp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 nextbn;\n\tint skip, maxentry, middle, righthalf, n;\n\txad_t *xad;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *sxtlck = NULL, *rxtlck = NULL;\n\tint quota_allocation = 0;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\tINCREMENT(xtStat.split);\n\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc)\n\t\tgoto clean_up;\n\n\tquota_allocation += lengthPXD(pxd);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\tjfs_info(\"xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * action: new page;\n\t */\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.self = *pxd;\n\trp->header.flag = sp->header.flag & BT_TYPE;\n\trp->header.maxentry = sp->header.maxentry;\t/* little-endian */\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new right page;\n\t\t */\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\trxtlck = (struct xtlock *) & tlck->lock;\n\t\trxtlck->lwm.offset = XTENTRYSTART;\n\t\t/*\n\t\t * acquire a transaction lock on the split page\n\t\t */\n\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\tsxtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/*\n\t * initialize/update sibling pointers of <sp> and <rp>\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\tskip = split->index;\n\n\t/*\n\t *\tsequential append at tail (after last entry of last page)\n\t *\n\t * if splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * if we're wrong it's no big deal -  we will do the split the right\n\t * way next time.\n\t * (it may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left, but it's not.\n\t * Be my guest.)\n\t */\n\tif (nextbn == 0 && skip == le16_to_cpu(sp->header.maxentry)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new/right page;\n\t\t *\n\t\t * action: xad insertion;\n\t\t */\n\t\t/* insert entry at the first entry of the new right page */\n\t\txad = &rp->xad[XTENTRYSTART];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\t\trxtlck->lwm.length = 1;\n\t\t}\n\n\t\t*rmpp = rmp;\n\t\t*rbnp = rbn;\n\n\t\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update previous pointer of old next/right page of <sp>\n\t */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rmp);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page;\n\t\t *\n\t\t * action:sibling pointer update;\n\t\t */\n\t\tif (!test_cflag(COMMIT_Nolink, ip))\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\t/* sibling page may have been updated previously, or\n\t\t * it may be updated later;\n\t\t */\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and new/right pages\n\t */\n\tmaxentry = le16_to_cpu(sp->header.maxentry);\n\tmiddle = maxentry >> 1;\n\trighthalf = maxentry - middle;\n\n\t/*\n\t * skip index in old split/left page - insert into left page:\n\t */\n\tif (skip <= middle) {\n\t\t/* move right half of split page to the new right page */\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\trighthalf << L2XTSLOTSIZE);\n\n\t\t/* shift right tail of left half to make room for new entry */\n\t\tif (skip < middle)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(middle - skip) << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle + 1);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)sxtlck->lwm.offset) : skip;\n\t\t}\n\n\t\trp->header.nextindex =\n\t\t    cpu_to_le16(XTENTRYSTART + righthalf);\n\t}\n\t/*\n\t * skip index in new right page - insert into right page:\n\t */\n\telse {\n\t\t/* move left head of right half to right page */\n\t\tn = skip - middle;\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\tn << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\tn += XTENTRYSTART;\n\t\txad = &rp->xad[n];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* move right tail of right half to right page */\n\t\tif (skip < maxentry)\n\t\t\tmemmove(&rp->xad[n + 1], &sp->xad[skip],\n\t\t\t\t(maxentry - skip) << L2XTSLOTSIZE);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(middle, (int)sxtlck->lwm.offset) : middle;\n\t\t}\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART +\n\t\t\t\t\t\t   righthalf + 1);\n\t}\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\tsxtlck->lwm.length = le16_to_cpu(sp->header.nextindex) -\n\t\t    sxtlck->lwm.offset;\n\n\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\trxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t*rmpp = rmp;\n\t*rbnp = rbn;\n\n\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\treturn rc;\n\n      clean_up:\n\n\t/* Rollback quota allocation. */\n\tif (quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitPage(tid_t tid, struct inode *ip, struct xtsplit * split,\n\t\t       struct metapage ** rmpp, s64 * rbnp);",
      "static int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "quota_allocation"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtSplitPage: sp:0x%p rp:0x%p\"",
            "sp",
            "rp"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rp->header.nextindex"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART +\n\t\t\t\t\t\t   righthalf + 1"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "middle",
            "(int)sxtlck->lwm.offset"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "middle"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rp->xad[n + 1]",
            "&sp->xad[skip]",
            "(maxentry - skip) << L2XTSLOTSIZE"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "split->flag",
            "split->off",
            "split->len",
            "split->addr"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rp->xad[XTENTRYSTART]",
            "&sp->xad[middle]",
            "n << L2XTSLOTSIZE"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + righthalf"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "middle + 1"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "split->flag",
            "split->off",
            "split->len",
            "split->addr"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&sp->xad[skip + 1]",
            "&sp->xad[skip]",
            "(middle - skip) << L2XTSLOTSIZE"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rp->xad[XTENTRYSTART]",
            "&sp->xad[middle]",
            "righthalf << L2XTSLOTSIZE"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "rbn"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE | tlckRELINK"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "nextbn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtSplitPage: sp:0x%p rp:0x%p\"",
            "sp",
            "rp"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART + 1"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "split->flag",
            "split->off",
            "split->len",
            "split->addr"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "rbn"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "addressPXD(&sp->header.self)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&sp->header.self"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nextbn"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sp->header.next"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTENTRYSTART"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "rmp",
            "ip"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\"",
            "ip",
            "smp",
            "rmp"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ip",
            "rbn",
            "PSIZE",
            "1"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "lengthPXD(pxd)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "xtStat.split"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PAGE",
          "args": [
            "ip",
            "smp"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitPage(tid_t tid, struct inode *ip, struct xtsplit * split,\n\t\t       struct metapage ** rmpp, s64 * rbnp);\nstatic int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);\n\nstatic int\nxtSplitPage(tid_t tid, struct inode *ip,\n\t    struct xtsplit * split, struct metapage ** rmpp, s64 * rbnp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 nextbn;\n\tint skip, maxentry, middle, righthalf, n;\n\txad_t *xad;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *sxtlck = NULL, *rxtlck = NULL;\n\tint quota_allocation = 0;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\tINCREMENT(xtStat.split);\n\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc)\n\t\tgoto clean_up;\n\n\tquota_allocation += lengthPXD(pxd);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\tjfs_info(\"xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * action: new page;\n\t */\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.self = *pxd;\n\trp->header.flag = sp->header.flag & BT_TYPE;\n\trp->header.maxentry = sp->header.maxentry;\t/* little-endian */\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new right page;\n\t\t */\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\trxtlck = (struct xtlock *) & tlck->lock;\n\t\trxtlck->lwm.offset = XTENTRYSTART;\n\t\t/*\n\t\t * acquire a transaction lock on the split page\n\t\t */\n\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\tsxtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/*\n\t * initialize/update sibling pointers of <sp> and <rp>\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\tskip = split->index;\n\n\t/*\n\t *\tsequential append at tail (after last entry of last page)\n\t *\n\t * if splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * if we're wrong it's no big deal -  we will do the split the right\n\t * way next time.\n\t * (it may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left, but it's not.\n\t * Be my guest.)\n\t */\n\tif (nextbn == 0 && skip == le16_to_cpu(sp->header.maxentry)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new/right page;\n\t\t *\n\t\t * action: xad insertion;\n\t\t */\n\t\t/* insert entry at the first entry of the new right page */\n\t\txad = &rp->xad[XTENTRYSTART];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\t\trxtlck->lwm.length = 1;\n\t\t}\n\n\t\t*rmpp = rmp;\n\t\t*rbnp = rbn;\n\n\t\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update previous pointer of old next/right page of <sp>\n\t */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rmp);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page;\n\t\t *\n\t\t * action:sibling pointer update;\n\t\t */\n\t\tif (!test_cflag(COMMIT_Nolink, ip))\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\t/* sibling page may have been updated previously, or\n\t\t * it may be updated later;\n\t\t */\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and new/right pages\n\t */\n\tmaxentry = le16_to_cpu(sp->header.maxentry);\n\tmiddle = maxentry >> 1;\n\trighthalf = maxentry - middle;\n\n\t/*\n\t * skip index in old split/left page - insert into left page:\n\t */\n\tif (skip <= middle) {\n\t\t/* move right half of split page to the new right page */\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\trighthalf << L2XTSLOTSIZE);\n\n\t\t/* shift right tail of left half to make room for new entry */\n\t\tif (skip < middle)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(middle - skip) << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle + 1);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)sxtlck->lwm.offset) : skip;\n\t\t}\n\n\t\trp->header.nextindex =\n\t\t    cpu_to_le16(XTENTRYSTART + righthalf);\n\t}\n\t/*\n\t * skip index in new right page - insert into right page:\n\t */\n\telse {\n\t\t/* move left head of right half to right page */\n\t\tn = skip - middle;\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\tn << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\tn += XTENTRYSTART;\n\t\txad = &rp->xad[n];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* move right tail of right half to right page */\n\t\tif (skip < maxentry)\n\t\t\tmemmove(&rp->xad[n + 1], &sp->xad[skip],\n\t\t\t\t(maxentry - skip) << L2XTSLOTSIZE);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(middle, (int)sxtlck->lwm.offset) : middle;\n\t\t}\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART +\n\t\t\t\t\t\t   righthalf + 1);\n\t}\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\tsxtlck->lwm.length = le16_to_cpu(sp->header.nextindex) -\n\t\t    sxtlck->lwm.offset;\n\n\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\trxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t*rmpp = rmp;\n\t*rbnp = rbn;\n\n\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\treturn rc;\n\n      clean_up:\n\n\t/* Rollback quota allocation. */\n\tif (quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "xtSplitUp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "687-936",
    "snippet": "static int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sp->header.nextindex"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "skip",
            "(int)xtlck->lwm.offset"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "smp",
            "tlckXTREE | tlckGROW"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&sp->header.nextindex",
            "1"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "XAD_NEW",
            "offsetXAD(&rcp->xad[XTENTRYSTART])",
            "JFS_SBI(ip->i_sb)->nbperpage",
            "rcbn"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "&rcp->xad[XTENTRYSTART]"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&sp->xad[skip + 1]",
            "&sp->xad[skip]",
            "(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSplitPage",
          "args": [
            "tid",
            "ip",
            "split",
            "&rmp",
            "&rbn"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitPage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "957-1201",
          "snippet": "static int\nxtSplitPage(tid_t tid, struct inode *ip,\n\t    struct xtsplit * split, struct metapage ** rmpp, s64 * rbnp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 nextbn;\n\tint skip, maxentry, middle, righthalf, n;\n\txad_t *xad;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *sxtlck = NULL, *rxtlck = NULL;\n\tint quota_allocation = 0;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\tINCREMENT(xtStat.split);\n\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc)\n\t\tgoto clean_up;\n\n\tquota_allocation += lengthPXD(pxd);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\tjfs_info(\"xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * action: new page;\n\t */\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.self = *pxd;\n\trp->header.flag = sp->header.flag & BT_TYPE;\n\trp->header.maxentry = sp->header.maxentry;\t/* little-endian */\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new right page;\n\t\t */\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\trxtlck = (struct xtlock *) & tlck->lock;\n\t\trxtlck->lwm.offset = XTENTRYSTART;\n\t\t/*\n\t\t * acquire a transaction lock on the split page\n\t\t */\n\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\tsxtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/*\n\t * initialize/update sibling pointers of <sp> and <rp>\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\tskip = split->index;\n\n\t/*\n\t *\tsequential append at tail (after last entry of last page)\n\t *\n\t * if splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * if we're wrong it's no big deal -  we will do the split the right\n\t * way next time.\n\t * (it may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left, but it's not.\n\t * Be my guest.)\n\t */\n\tif (nextbn == 0 && skip == le16_to_cpu(sp->header.maxentry)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new/right page;\n\t\t *\n\t\t * action: xad insertion;\n\t\t */\n\t\t/* insert entry at the first entry of the new right page */\n\t\txad = &rp->xad[XTENTRYSTART];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\t\trxtlck->lwm.length = 1;\n\t\t}\n\n\t\t*rmpp = rmp;\n\t\t*rbnp = rbn;\n\n\t\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update previous pointer of old next/right page of <sp>\n\t */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rmp);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page;\n\t\t *\n\t\t * action:sibling pointer update;\n\t\t */\n\t\tif (!test_cflag(COMMIT_Nolink, ip))\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\t/* sibling page may have been updated previously, or\n\t\t * it may be updated later;\n\t\t */\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and new/right pages\n\t */\n\tmaxentry = le16_to_cpu(sp->header.maxentry);\n\tmiddle = maxentry >> 1;\n\trighthalf = maxentry - middle;\n\n\t/*\n\t * skip index in old split/left page - insert into left page:\n\t */\n\tif (skip <= middle) {\n\t\t/* move right half of split page to the new right page */\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\trighthalf << L2XTSLOTSIZE);\n\n\t\t/* shift right tail of left half to make room for new entry */\n\t\tif (skip < middle)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(middle - skip) << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle + 1);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)sxtlck->lwm.offset) : skip;\n\t\t}\n\n\t\trp->header.nextindex =\n\t\t    cpu_to_le16(XTENTRYSTART + righthalf);\n\t}\n\t/*\n\t * skip index in new right page - insert into right page:\n\t */\n\telse {\n\t\t/* move left head of right half to right page */\n\t\tn = skip - middle;\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\tn << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\tn += XTENTRYSTART;\n\t\txad = &rp->xad[n];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* move right tail of right half to right page */\n\t\tif (skip < maxentry)\n\t\t\tmemmove(&rp->xad[n + 1], &sp->xad[skip],\n\t\t\t\t(maxentry - skip) << L2XTSLOTSIZE);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(middle, (int)sxtlck->lwm.offset) : middle;\n\t\t}\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART +\n\t\t\t\t\t\t   righthalf + 1);\n\t}\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\tsxtlck->lwm.length = le16_to_cpu(sp->header.nextindex) -\n\t\t    sxtlck->lwm.offset;\n\n\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\trxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t*rmpp = rmp;\n\t*rbnp = rbn;\n\n\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\treturn rc;\n\n      clean_up:\n\n\t/* Rollback quota allocation. */\n\tif (quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitPage(tid_t tid, struct inode *ip, struct xtsplit * split,\n\t\t       struct metapage ** rmpp, s64 * rbnp);",
            "static int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitPage(tid_t tid, struct inode *ip, struct xtsplit * split,\n\t\t       struct metapage ** rmpp, s64 * rbnp);\nstatic int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);\n\nstatic int\nxtSplitPage(tid_t tid, struct inode *ip,\n\t    struct xtsplit * split, struct metapage ** rmpp, s64 * rbnp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 nextbn;\n\tint skip, maxentry, middle, righthalf, n;\n\txad_t *xad;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *sxtlck = NULL, *rxtlck = NULL;\n\tint quota_allocation = 0;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\tINCREMENT(xtStat.split);\n\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc)\n\t\tgoto clean_up;\n\n\tquota_allocation += lengthPXD(pxd);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL) {\n\t\trc = -EIO;\n\t\tgoto clean_up;\n\t}\n\n\tjfs_info(\"xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * action: new page;\n\t */\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.self = *pxd;\n\trp->header.flag = sp->header.flag & BT_TYPE;\n\trp->header.maxentry = sp->header.maxentry;\t/* little-endian */\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new right page;\n\t\t */\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\trxtlck = (struct xtlock *) & tlck->lock;\n\t\trxtlck->lwm.offset = XTENTRYSTART;\n\t\t/*\n\t\t * acquire a transaction lock on the split page\n\t\t */\n\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\tsxtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/*\n\t * initialize/update sibling pointers of <sp> and <rp>\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\tskip = split->index;\n\n\t/*\n\t *\tsequential append at tail (after last entry of last page)\n\t *\n\t * if splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * if we're wrong it's no big deal -  we will do the split the right\n\t * way next time.\n\t * (it may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left, but it's not.\n\t * Be my guest.)\n\t */\n\tif (nextbn == 0 && skip == le16_to_cpu(sp->header.maxentry)) {\n\t\t/*\n\t\t * acquire a transaction lock on the new/right page;\n\t\t *\n\t\t * action: xad insertion;\n\t\t */\n\t\t/* insert entry at the first entry of the new right page */\n\t\txad = &rp->xad[XTENTRYSTART];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\t\trxtlck->lwm.length = 1;\n\t\t}\n\n\t\t*rmpp = rmp;\n\t\t*rbnp = rbn;\n\n\t\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update previous pointer of old next/right page of <sp>\n\t */\n\tif (nextbn != 0) {\n\t\tXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rmp);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page;\n\t\t *\n\t\t * action:sibling pointer update;\n\t\t */\n\t\tif (!test_cflag(COMMIT_Nolink, ip))\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\t/* sibling page may have been updated previously, or\n\t\t * it may be updated later;\n\t\t */\n\n\t\tXT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and new/right pages\n\t */\n\tmaxentry = le16_to_cpu(sp->header.maxentry);\n\tmiddle = maxentry >> 1;\n\trighthalf = maxentry - middle;\n\n\t/*\n\t * skip index in old split/left page - insert into left page:\n\t */\n\tif (skip <= middle) {\n\t\t/* move right half of split page to the new right page */\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\trighthalf << L2XTSLOTSIZE);\n\n\t\t/* shift right tail of left half to make room for new entry */\n\t\tif (skip < middle)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(middle - skip) << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle + 1);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)sxtlck->lwm.offset) : skip;\n\t\t}\n\n\t\trp->header.nextindex =\n\t\t    cpu_to_le16(XTENTRYSTART + righthalf);\n\t}\n\t/*\n\t * skip index in new right page - insert into right page:\n\t */\n\telse {\n\t\t/* move left head of right half to right page */\n\t\tn = skip - middle;\n\t\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\n\t\t\tn << L2XTSLOTSIZE);\n\n\t\t/* insert new entry */\n\t\tn += XTENTRYSTART;\n\t\txad = &rp->xad[n];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* move right tail of right half to right page */\n\t\tif (skip < maxentry)\n\t\t\tmemmove(&rp->xad[n + 1], &sp->xad[skip],\n\t\t\t\t(maxentry - skip) << L2XTSLOTSIZE);\n\n\t\t/* update page header */\n\t\tsp->header.nextindex = cpu_to_le16(middle);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\n\t\t\t    min(middle, (int)sxtlck->lwm.offset) : middle;\n\t\t}\n\n\t\trp->header.nextindex = cpu_to_le16(XTENTRYSTART +\n\t\t\t\t\t\t   righthalf + 1);\n\t}\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\tsxtlck->lwm.length = le16_to_cpu(sp->header.nextindex) -\n\t\t    sxtlck->lwm.offset;\n\n\t\t/* rxtlck->lwm.offset = XTENTRYSTART; */\n\t\trxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t*rmpp = rmp;\n\t*rbnp = rbn;\n\n\tjfs_info(\"xtSplitPage: sp:0x%p rp:0x%p\", sp, rp);\n\treturn rc;\n\n      clean_up:\n\n\t/* Rollback quota allocation. */\n\tif (quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtSplitRoot",
          "args": [
            "tid",
            "ip",
            "split",
            "&rmp"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "1224-1347",
          "snippet": "static int\nxtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct xtsplit * split, struct metapage ** rmpp)\n{\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\n\ts64 rbn;\n\tint skip, nextindex;\n\txad_t *xad;\n\tpxd_t *pxd;\n\tstruct pxdlist *pxdlist;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint rc;\n\n\tsp = &JFS_IP(ip)->i_xtroot;\n\n\tINCREMENT(xtStat.split);\n\n\t/*\n\t *\tallocate a single (right) child page\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"xtSplitRoot: ip:0x%p rmp:0x%p\", ip, rmp);\n\n\t/*\n\t * acquire a transaction lock on the new right page;\n\t *\n\t * action: new page;\n\t */\n\tBT_MARK_DIRTY(rmp, ip);\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\trp->header.maxentry = cpu_to_le16(PSIZE >> L2XTSLOTSIZE);\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t * copy the in-line root page into new right page extent\n\t */\n\tnextindex = le16_to_cpu(sp->header.maxentry);\n\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[XTENTRYSTART],\n\t\t(nextindex - XTENTRYSTART) << L2XTSLOTSIZE);\n\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tskip = split->index;\n\t/* if insert into middle, shift right remaining entries */\n\tif (skip != nextindex)\n\t\tmemmove(&rp->xad[skip + 1], &rp->xad[skip],\n\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\txad = &rp->xad[skip];\n\tXT_PUTENTRY(xad, split->flag, split->off, split->len, split->addr);\n\n\t/* update page header */\n\trp->header.nextindex = cpu_to_le16(nextindex + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t/*\n\t *\treset the root\n\t *\n\t * init root with the single entry for the new right page\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t */\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode);\n\t *\n\t * action: root split;\n\t */\n\tBT_MARK_DIRTY(split->mp, ip);\n\n\txad = &sp->xad[XTENTRYSTART];\n\tXT_PUTENTRY(xad, XAD_NEW, 0, JFS_SBI(ip->i_sb)->nbperpage, rbn);\n\n\t/* update page header of root */\n\tsp->header.flag &= ~BT_LEAF;\n\tsp->header.flag |= BT_INTERNAL;\n\n\tsp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, split->mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = 1;\n\t}\n\n\t*rmpp = rmp;\n\n\tjfs_info(\"xtSplitRoot: sp:0x%p rp:0x%p\", sp, rp);\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct xtsplit * split, struct metapage ** rmpp);\n\nstatic int\nxtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct xtsplit * split, struct metapage ** rmpp)\n{\n\txtpage_t *sp;\n\tstruct metapage *rmp;\n\txtpage_t *rp;\n\ts64 rbn;\n\tint skip, nextindex;\n\txad_t *xad;\n\tpxd_t *pxd;\n\tstruct pxdlist *pxdlist;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tint rc;\n\n\tsp = &JFS_IP(ip)->i_xtroot;\n\n\tINCREMENT(xtStat.split);\n\n\t/*\n\t *\tallocate a single (right) child page\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"xtSplitRoot: ip:0x%p rmp:0x%p\", ip, rmp);\n\n\t/*\n\t * acquire a transaction lock on the new right page;\n\t *\n\t * action: new page;\n\t */\n\tBT_MARK_DIRTY(rmp, ip);\n\n\trp = (xtpage_t *) rmp->data;\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\trp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\trp->header.maxentry = cpu_to_le16(PSIZE >> L2XTSLOTSIZE);\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t * copy the in-line root page into new right page extent\n\t */\n\tnextindex = le16_to_cpu(sp->header.maxentry);\n\tmemmove(&rp->xad[XTENTRYSTART], &sp->xad[XTENTRYSTART],\n\t\t(nextindex - XTENTRYSTART) << L2XTSLOTSIZE);\n\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tskip = split->index;\n\t/* if insert into middle, shift right remaining entries */\n\tif (skip != nextindex)\n\t\tmemmove(&rp->xad[skip + 1], &rp->xad[skip],\n\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\txad = &rp->xad[skip];\n\tXT_PUTENTRY(xad, split->flag, split->off, split->len, split->addr);\n\n\t/* update page header */\n\trp->header.nextindex = cpu_to_le16(nextindex + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\n\t\t    XTENTRYSTART;\n\t}\n\n\t/*\n\t *\treset the root\n\t *\n\t * init root with the single entry for the new right page\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t */\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode);\n\t *\n\t * action: root split;\n\t */\n\tBT_MARK_DIRTY(split->mp, ip);\n\n\txad = &sp->xad[XTENTRYSTART];\n\tXT_PUTENTRY(xad, XAD_NEW, 0, JFS_SBI(ip->i_sb)->nbperpage, rbn);\n\n\t/* update page header of root */\n\tsp->header.flag &= ~BT_LEAF;\n\tsp->header.flag |= BT_INTERNAL;\n\n\tsp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, split->mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\txtlck->lwm.length = 1;\n\t}\n\n\t*rmpp = rmp;\n\n\tjfs_info(\"xtSplitRoot: sp:0x%p rp:0x%p\", sp, rp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "rcmp"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "&rcp->xad[XTENTRYSTART]"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "rcmp"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "parent->bn",
            "smp",
            "PSIZE",
            "sp",
            "rc"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PAGE",
          "args": [
            "ip",
            "rcmp"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "btstack"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "pxd",
            "xlen"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "xaddr"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "(s64) 0",
            "(s64) xlen",
            "&xaddr"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&sp->header.nextindex",
            "1"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "split->flag",
            "split->off",
            "split->len",
            "split->addr"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&sp->xad[skip + 1]",
            "&sp->xad[skip]",
            "(nextindex - skip) * sizeof(xad_t)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "XTROOTMAXSLOT"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_mode"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PAGE",
          "args": [
            "ip",
            "smp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xtInsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "537-670",
    "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define XT_INSERT\t0x00000001"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "index",
            "(int)xtlck->lwm.offset"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckXTREE | tlckGROW"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&p->header.nextindex",
            "1"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTENTRY",
          "args": [
            "xad",
            "xflag",
            "xoff",
            "xlen",
            "xaddr"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&p->xad[index + 1]",
            "&p->xad[index]",
            "(nextindex - index) * sizeof(xad_t)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "xlen"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "xaddr",
            "(s64) xlen"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtSplitUp",
          "args": [
            "tid",
            "ip",
            "&split",
            "&btstack"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "xtSplitUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "687-936",
          "snippet": "static int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int\nxtSplitUp(tid_t tid,\n\t  struct inode *ip, struct xtsplit * split, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\txtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *rcmp;\n\txtpage_t *rcp;\t\t/* right child page */\n\ts64 rcbn;\t\t/* right child page block number */\n\tint skip;\t\t/* index of entry of insertion */\n\tint nextindex;\t\t/* next available entry index of p */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tint nsplit;\t\t/* number of pages split */\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tsmp = split->mp;\n\tsp = XT_PAGE(ip, smp);\n\n\t/* is inode xtree root extension/inline EA area free ? */\n\tif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\n\t    (le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\n\t    (JFS_IP(ip)->mode2 & INLINEEA)) {\n\t\tsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\n\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tBT_MARK_DIRTY(smp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page;\n\t\t *\n\t\t * action: xad insertion/extension;\n\t\t */\n\n\t\t/* if insert into middle, shift right remaining entries. */\n\t\tskip = split->index;\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\tif (skip < nextindex)\n\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t(nextindex - skip) * sizeof(xad_t));\n\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &sp->xad[skip];\n\t\tXT_PUTENTRY(xad, split->flag, split->off, split->len,\n\t\t\t    split->addr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t/* Don't log it if there are no links to the file */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * allocate new index blocks to cover index page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tif (split->pxdlist == NULL) {\n\t\tnsplit = btstack->nsplit;\n\t\tsplit->pxdlist = &pxdlist;\n\t\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\txlen = JFS_SBI(ip->i_sb)->nbperpage;\n\t\tfor (; nsplit > 0; nsplit--, pxd++) {\n\t\t\tif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\n\t\t\t    == 0) {\n\t\t\t\tPXDaddress(pxd, xaddr);\n\t\t\t\tPXDlength(pxd, xlen);\n\n\t\t\t\tpxdlist.maxnpxd++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* undo allocation */\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * Split leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * The split routines insert the new entry into the leaf page,\n\t * and acquire txLock as appropriate.\n\t * return <rp> pinned and its block number <rpbn>.\n\t */\n\trc = (sp->header.flag & BT_ROOT) ?\n\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\n\tXT_PUTPAGE(smp);\n\n\tif (rc)\n\t\treturn -EIO;\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 3 pages pinned at any time:\n\t * right child, left parent and right parent (when the parent splits)\n\t * to keep the child page pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages <rcp> pinned */\n\t\trcmp = rmp;\n\t\trcbn = rbn;\n\t\trcp = XT_PAGE(ip, rcmp);\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get/pin the parent page <sp> */\n\t\tXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tXT_PUTPAGE(rcmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * split or shift right remaining entries of the parent page\n\t\t */\n\t\tnextindex = le16_to_cpu(sp->header.nextindex);\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (nextindex == le16_to_cpu(sp->header.maxentry)) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->flag = XAD_NEW;\n\t\t\tsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\n\t\t\tsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\n\t\t\tsplit->addr = rcbn;\n\n\t\t\t/* unpin previous right child page */\n\t\t\tXT_PUTPAGE(rcmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * and acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rpbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    xtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    xtSplitPage(tid, ip, split, &rmp, &rbn);\n\t\t\tif (rc) {\n\t\t\t\tXT_PUTPAGE(smp);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(smp);\n\t\t\t/* keep new child page <rp> pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert in parent page\n\t\t */\n\t\telse {\n\t\t\t/*\n\t\t\t * insert router entry in parent for the right child\n\t\t\t * page from the first entry of the right child page:\n\t\t\t */\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page;\n\t\t\t *\n\t\t\t * action: router xad insertion;\n\t\t\t */\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\n\t\t\t/*\n\t\t\t * if insert into middle, shift right remaining entries\n\t\t\t */\n\t\t\tif (skip < nextindex)\n\t\t\t\tmemmove(&sp->xad[skip + 1], &sp->xad[skip],\n\t\t\t\t\t(nextindex -\n\t\t\t\t\t skip) << L2XTSLOTSIZE);\n\n\t\t\t/* insert the router entry */\n\t\t\txad = &sp->xad[skip];\n\t\t\tXT_PUTENTRY(xad, XAD_NEW,\n\t\t\t\t    offsetXAD(&rcp->xad[XTENTRYSTART]),\n\t\t\t\t    JFS_SBI(ip->i_sb)->nbperpage, rcbn);\n\n\t\t\t/* advance next available entry index. */\n\t\t\tle16_add_cpu(&sp->header.nextindex, 1);\n\n\t\t\t/* Don't log it if there are no links to the file */\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, smp,\n\t\t\t\t\t      tlckXTREE | tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(skip, (int)xtlck->lwm.offset) : skip;\n\t\t\t\txtlck->lwm.length =\n\t\t\t\t    le16_to_cpu(sp->header.nextindex) -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t}\n\n\t\t\t/* unpin parent page */\n\t\t\tXT_PUTPAGE(smp);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current right page */\n\tXT_PUTPAGE(rmp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "xlen"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "hint",
            "(s64) xlen",
            "&xaddr"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "xlen"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "xoff",
            "&next",
            "&cmp",
            "&btstack",
            "XT_INSERT"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"xtInsert: nxoff:0x%lx nxlen:0x%x\"",
            "(ulong) xoff",
            "xlen"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xtSearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "239-515",
    "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define XT_INSERT\t0x00000001"
    ],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "&p->xad[index]"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_PUSH",
          "args": [
            "btstack",
            "bn",
            "index"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"stack overrun!\\n\""
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_STACK_FULL",
          "args": [
            "btstack"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "&p->xad[base]"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.nextindex"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "&p->xad[index + 1]"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_CMP",
          "args": [
            "cmp",
            "xoff",
            "&p->xad[index]",
            "t64"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "xtStat.fastSearch"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "btstack"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "xtStat.search"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
  },
  {
    "function_name": "xtLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
    "lines": "146-219",
    "snippet": "int xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
      "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "xend - lstart",
            "llen"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xad"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xad"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xad"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"xtLookup: xtSearch returned %d\"",
            "rc"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtSearch",
          "args": [
            "ip",
            "lstart",
            "&next",
            "&cmp",
            "&btstack",
            "0"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "xtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "239-515",
          "snippet": "static int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nstatic int xtSearch(struct inode *ip, s64 xoff,\ts64 *nextp,\n\t\t    int *cmpp, struct btstack * btstack, int flag)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\t\t\t/* block number */\n\tstruct metapage *mp;\t/* page buffer */\n\txtpage_t *p;\t\t/* page */\n\txad_t *xad;\n\tint base, index, lim, btindex;\n\tstruct btframe *btsp;\n\tint nsplit = 0;\t\t/* number of pages to split */\n\ts64 t64;\n\ts64 next = 0;\n\n\tINCREMENT(xtStat.search);\n\n\tBT_CLR(btstack);\n\n\tbtstack->nsplit = 0;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* try sequential access heuristics with the previous\n\t\t * access entry in target leaf page:\n\t\t * once search narrowed down into the target leaf,\n\t\t * key must either match an entry in the leaf or\n\t\t * key entry does not exist in the tree;\n\t\t */\n//fastSearch:\n\t\tif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\n\t\t    (p->header.flag & BT_LEAF) &&\n\t\t    (index = jfs_ip->btindex) <\n\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\txad = &p->xad[index];\n\t\t\tt64 = offsetXAD(xad);\n\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\tgoto binarySearch;\n\t\t\t} else {\t/* (t64 + lengthXAD(xad)) <= xoff */\n\n\t\t\t\t/* try next sequential entry */\n\t\t\t\tindex++;\n\t\t\t\tif (index <\n\t\t\t\t    le16_to_cpu(p->header.nextindex)) {\n\t\t\t\t\txad++;\n\t\t\t\t\tt64 = offsetXAD(xad);\n\t\t\t\t\tif (xoff < t64 + lengthXAD(xad)) {\n\t\t\t\t\t\tif (xoff >= t64) {\n\t\t\t\t\t\t\t*cmpp = 0;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* miss: key falls between\n\t\t\t\t\t\t * previous and this entry\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*cmpp = 1;\n\t\t\t\t\t\tnext = t64;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* (xoff >= t64 + lengthXAD(xad));\n\t\t\t\t\t * matching entry may be further out:\n\t\t\t\t\t * stop heuristic search\n\t\t\t\t\t */\n\t\t\t\t\t/* stop sequential access heuristics */\n\t\t\t\t\tgoto binarySearch;\n\t\t\t\t}\n\n\t\t\t\t/* (index == p->header.nextindex);\n\t\t\t\t * miss: key entry does not exist in\n\t\t\t\t * the target leaf/tree\n\t\t\t\t */\n\t\t\t\t*cmpp = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if hit, return index of the entry found, and\n\t\t\t * if miss, where new entry with search key is\n\t\t\t * to be inserted;\n\t\t\t */\n\t\t      out:\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\t/* little-endian */\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = index;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* update sequential access heuristics */\n\t\t\tjfs_ip->btindex = index;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\tINCREMENT(xtStat.fastSearch);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* well, ... full search now */\n\t      binarySearch:\n\t\tlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\n\t\t/*\n\t\t * binary search with search key K on the current page\n\t\t */\n\t\tfor (base = XTENTRYSTART; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tXT_CMP(cmp, xoff, &p->xad[index], t64);\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\t*cmpp = cmp;\n\n\t\t\t\t\t/* compute number of pages to split */\n\t\t\t\t\tif (flag & XT_INSERT) {\n\t\t\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t\t\t    p->header.maxentry)\n\t\t\t\t\t\t\tnsplit++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnsplit = 0;\n\t\t\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save search result */\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\t/* init sequential access heuristics */\n\t\t\t\t\tbtindex = jfs_ip->btindex;\n\t\t\t\t\tif (index == btindex ||\n\t\t\t\t\t    index == btindex + 1)\n\t\t\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\t\t\telse\n\t\t\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\t\t\tjfs_ip->btindex = index;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tif (index < le16_to_cpu(p->header.nextindex)-1)\n\t\t\t\t\tnext = offsetXAD(&p->xad[index + 1]);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or maxentry index.\n\t\t */\n\t\tif (base < le16_to_cpu(p->header.nextindex))\n\t\t\tnext = offsetXAD(&p->xad[base]);\n\t\t/*\n\t\t * search miss - leaf page:\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t*cmpp = cmp;\n\n\t\t\t/* compute number of pages to split */\n\t\t\tif (flag & XT_INSERT) {\n\t\t\t\tif (p->header.nextindex ==\n\t\t\t\t    p->header.maxentry)\n\t\t\t\t\tnsplit++;\n\t\t\t\telse\n\t\t\t\t\tnsplit = 0;\n\t\t\t\tbtstack->nsplit = nsplit;\n\t\t\t}\n\n\t\t\t/* save search result */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\t/* init sequential access heuristics */\n\t\t\tbtindex = jfs_ip->btindex;\n\t\t\tif (base == btindex || base == btindex + 1)\n\t\t\t\tjfs_ip->btorder = BT_SEQUENTIAL;\n\t\t\telse\n\t\t\t\tjfs_ip->btorder = BT_RANDOM;\n\t\t\tjfs_ip->btindex = base;\n\n\t\t\tif (nextp)\n\t\t\t\t*nextp = next;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * search miss - non-leaf page:\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      next:\n\t\t/* update number of pages to split */\n\t\tif (p->header.nextindex == p->header.maxentry)\n\t\t\tnsplit++;\n\t\telse\n\t\t\tnsplit = 0;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\t\tXT_PUTPAGE(mp);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tbn = addressXAD(&p->xad[index]);\n\n\t\t/* unpin the parent page */\n\t\tXT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
  }
]