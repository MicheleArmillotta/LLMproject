[
  {
    "function_name": "init_pstore_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "463-480",
    "snippet": "static int __init init_pstore_fs(void)\n{\n\tint err = 0;\n\n\t/* Create a convenient mount point for people to access pstore */\n\tpstore_kobj = kobject_create_and_add(\"pstore\", fs_kobj);\n\tif (!pstore_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = register_filesystem(&pstore_fs_type);\n\tif (err < 0)\n\t\tkobject_put(pstore_kobj);\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type pstore_fs_type = {\n\t.name\t\t= \"pstore\",\n\t.mount\t\t= pstore_mount,\n\t.kill_sb\t= pstore_kill_sb,\n};",
      "static struct kobject *pstore_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "pstore_kobj"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&pstore_fs_type"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"pstore\"",
            "fs_kobj"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct file_system_type pstore_fs_type = {\n\t.name\t\t= \"pstore\",\n\t.mount\t\t= pstore_mount,\n\t.kill_sb\t= pstore_kill_sb,\n};\nstatic struct kobject *pstore_kobj;\n\nstatic int __init init_pstore_fs(void)\n{\n\tint err = 0;\n\n\t/* Create a convenient mount point for people to access pstore */\n\tpstore_kobj = kobject_create_and_add(\"pstore\", fs_kobj);\n\tif (!pstore_kobj) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = register_filesystem(&pstore_fs_type);\n\tif (err < 0)\n\t\tkobject_put(pstore_kobj);\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "pstore_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "449-453",
    "snippet": "static void pstore_kill_sb(struct super_block *sb)\n{\n\tkill_litter_super(sb);\n\tpstore_sb = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *pstore_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct super_block *pstore_sb;\n\nstatic void pstore_kill_sb(struct super_block *sb)\n{\n\tkill_litter_super(sb);\n\tpstore_sb = NULL;\n}"
  },
  {
    "function_name": "pstore_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "443-447",
    "snippet": "static struct dentry *pstore_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, pstore_fill_super);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "pstore_fill_super"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *pstore_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, pstore_fill_super);\n}"
  },
  {
    "function_name": "pstore_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "410-441",
    "snippet": "static int pstore_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\tsave_mount_options(sb, data);\n\n\tpstore_sb = sb;\n\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= PSTOREFS_MAGIC;\n\tsb->s_op\t\t= &pstore_ops;\n\tsb->s_time_gran\t\t= 1;\n\n\tparse_options(data);\n\n\tinode = pstore_get_inode(sb);\n\tif (inode) {\n\t\tinode->i_mode = S_IFDIR | 0755;\n\t\tinode->i_op = &pstore_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\tpstore_get_records(0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations pstore_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= pstore_unlink,\n};",
      "static const struct super_operations pstore_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= pstore_evict_inode,\n\t.remount_fs\t= pstore_remount,\n\t.show_options\t= generic_show_options,\n};",
      "static struct super_block *pstore_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstore_get_records",
          "args": [
            "0"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_get_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "471-529",
          "snippet": "void pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pstore_info *psinfo;",
            "static char *big_oops_buf;",
            "static size_t big_oops_buf_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstruct pstore_info *psinfo;\nstatic char *big_oops_buf;\nstatic size_t big_oops_buf_sz;\n\nvoid pstore_get_records(int quiet)\n{\n\tstruct pstore_info *psi = psinfo;\n\tchar\t\t\t*buf = NULL;\n\tssize_t\t\t\tsize;\n\tu64\t\t\tid;\n\tint\t\t\tcount;\n\tenum pstore_type_id\ttype;\n\tstruct timespec\t\ttime;\n\tint\t\t\tfailed = 0, rc;\n\tbool\t\t\tcompressed;\n\tint\t\t\tunzipped_len = -1;\n\n\tif (!psi)\n\t\treturn;\n\n\tmutex_lock(&psi->read_mutex);\n\tif (psi->open && psi->open(psi))\n\t\tgoto out;\n\n\twhile ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,\n\t\t\t\tpsi)) > 0) {\n\t\tif (compressed && (type == PSTORE_TYPE_DMESG)) {\n\t\t\tif (big_oops_buf)\n\t\t\t\tunzipped_len = pstore_decompress(buf,\n\t\t\t\t\t\t\tbig_oops_buf, size,\n\t\t\t\t\t\t\tbig_oops_buf_sz);\n\n\t\t\tif (unzipped_len > 0) {\n\t\t\t\tkfree(buf);\n\t\t\t\tbuf = big_oops_buf;\n\t\t\t\tsize = unzipped_len;\n\t\t\t\tcompressed = false;\n\t\t\t} else {\n\t\t\t\tpr_err(\"decompression failed;returned %d\\n\",\n\t\t\t\t       unzipped_len);\n\t\t\t\tcompressed = true;\n\t\t\t}\n\t\t}\n\t\trc = pstore_mkfile(type, psi->name, id, count, buf,\n\t\t\t\t  compressed, (size_t)size, time, psi);\n\t\tif (unzipped_len < 0) {\n\t\t\t/* Free buffer other than big oops */\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\t} else\n\t\t\tunzipped_len = -1;\n\t\tif (rc && (rc != -EEXIST || !quiet))\n\t\t\tfailed++;\n\t}\n\tif (psi->close)\n\t\tpsi->close(psi);\nout:\n\tmutex_unlock(&psi->read_mutex);\n\n\tif (failed)\n\t\tpr_warn(\"failed to load %d record(s) from '%s'\\n\",\n\t\t\tfailed, psi->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_get_inode",
          "args": [
            "sb"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "228-236",
          "snippet": "static struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "247-270",
          "snippet": "static void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations pstore_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= pstore_unlink,\n};\nstatic const struct super_operations pstore_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= pstore_evict_inode,\n\t.remount_fs\t= pstore_remount,\n\t.show_options\t= generic_show_options,\n};\nstatic struct super_block *pstore_sb;\n\nstatic int pstore_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode;\n\n\tsave_mount_options(sb, data);\n\n\tpstore_sb = sb;\n\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_blocksize\t\t= PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_CACHE_SHIFT;\n\tsb->s_magic\t\t= PSTOREFS_MAGIC;\n\tsb->s_op\t\t= &pstore_ops;\n\tsb->s_time_gran\t\t= 1;\n\n\tparse_options(data);\n\n\tinode = pstore_get_inode(sb);\n\tif (inode) {\n\t\tinode->i_mode = S_IFDIR | 0755;\n\t\tinode->i_op = &pstore_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\tpstore_get_records(0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pstore_mkfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "300-408",
    "snippet": "int pstore_mkfile(enum pstore_type_id type, char *psname, u64 id, int count,\n\t\t  char *data, bool compressed, size_t size,\n\t\t  struct timespec time, struct pstore_info *psi)\n{\n\tstruct dentry\t\t*root = pstore_sb->s_root;\n\tstruct dentry\t\t*dentry;\n\tstruct inode\t\t*inode;\n\tint\t\t\trc = 0;\n\tchar\t\t\tname[PSTORE_NAMELEN];\n\tstruct pstore_private\t*private, *pos;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_for_each_entry(pos, &allpstore, list) {\n\t\tif (pos->type == type &&\n\t\t    pos->id == id &&\n\t\t    pos->psi == psi) {\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENOMEM;\n\tinode = pstore_get_inode(pstore_sb);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_mode = S_IFREG | 0444;\n\tinode->i_fop = &pstore_file_operations;\n\tprivate = kmalloc(sizeof *private + size, GFP_KERNEL);\n\tif (!private)\n\t\tgoto fail_alloc;\n\tprivate->type = type;\n\tprivate->id = id;\n\tprivate->count = count;\n\tprivate->psi = psi;\n\n\tswitch (type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tscnprintf(name, sizeof(name), \"dmesg-%s-%lld%s\",\n\t\t\t  psname, id, compressed ? \".enc.z\" : \"\");\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tscnprintf(name, sizeof(name), \"console-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tscnprintf(name, sizeof(name), \"ftrace-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_MCE:\n\t\tscnprintf(name, sizeof(name), \"mce-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tscnprintf(name, sizeof(name), \"rtas-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tscnprintf(name, sizeof(name), \"powerpc-ofw-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tscnprintf(name, sizeof(name), \"powerpc-common-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tscnprintf(name, sizeof(name), \"pmsg-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_UNKNOWN:\n\t\tscnprintf(name, sizeof(name), \"unknown-%s-%lld\", psname, id);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(name, sizeof(name), \"type%d-%s-%lld\",\n\t\t\t  type, psname, id);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_alloc_name(root, name);\n\tif (!dentry)\n\t\tgoto fail_lockedalloc;\n\n\tmemcpy(private->data, data, size);\n\tinode->i_size = private->size = size;\n\n\tinode->i_private = private;\n\n\tif (time.tv_sec)\n\t\tinode->i_mtime = inode->i_ctime = time;\n\n\td_add(dentry, inode);\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_add(&private->list, &allpstore);\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\treturn 0;\n\nfail_lockedalloc:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\tkfree(private);\nfail_alloc:\n\tiput(inode);\n\nfail:\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define\tPSTORE_NAMELEN\t64"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(allpstore_lock);",
      "static LIST_HEAD(allpstore);",
      "static const struct file_operations pstore_file_operations = {\n\t.open\t\t= pstore_file_open,\n\t.read\t\t= pstore_file_read,\n\t.llseek\t\t= pstore_file_llseek,\n\t.release\t= seq_release,\n};",
      "static struct super_block *pstore_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "private"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&allpstore_lock",
            "flags"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&private->list",
            "&allpstore"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&allpstore_lock",
            "flags"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "private->data",
            "data",
            "size"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "root",
            "name"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->d_inode->i_mutex"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"type%d-%s-%lld\"",
            "type",
            "psname",
            "id"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"unknown-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"pmsg-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"powerpc-common-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"powerpc-ofw-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"rtas-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"mce-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"ftrace-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"console-%s-%lld\"",
            "psname",
            "id"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"dmesg-%s-%lld%s\"",
            "psname",
            "id",
            "compressed ? \".enc.z\" : \"\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof *private + size",
            "GFP_KERNEL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_get_inode",
          "args": [
            "pstore_sb"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "228-236",
          "snippet": "static struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&allpstore_lock",
            "flags"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&allpstore",
            "list"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&allpstore_lock",
            "flags"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define\tPSTORE_NAMELEN\t64\n\nstatic DEFINE_SPINLOCK(allpstore_lock);\nstatic LIST_HEAD(allpstore);\nstatic const struct file_operations pstore_file_operations = {\n\t.open\t\t= pstore_file_open,\n\t.read\t\t= pstore_file_read,\n\t.llseek\t\t= pstore_file_llseek,\n\t.release\t= seq_release,\n};\nstatic struct super_block *pstore_sb;\n\nint pstore_mkfile(enum pstore_type_id type, char *psname, u64 id, int count,\n\t\t  char *data, bool compressed, size_t size,\n\t\t  struct timespec time, struct pstore_info *psi)\n{\n\tstruct dentry\t\t*root = pstore_sb->s_root;\n\tstruct dentry\t\t*dentry;\n\tstruct inode\t\t*inode;\n\tint\t\t\trc = 0;\n\tchar\t\t\tname[PSTORE_NAMELEN];\n\tstruct pstore_private\t*private, *pos;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_for_each_entry(pos, &allpstore, list) {\n\t\tif (pos->type == type &&\n\t\t    pos->id == id &&\n\t\t    pos->psi == psi) {\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENOMEM;\n\tinode = pstore_get_inode(pstore_sb);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_mode = S_IFREG | 0444;\n\tinode->i_fop = &pstore_file_operations;\n\tprivate = kmalloc(sizeof *private + size, GFP_KERNEL);\n\tif (!private)\n\t\tgoto fail_alloc;\n\tprivate->type = type;\n\tprivate->id = id;\n\tprivate->count = count;\n\tprivate->psi = psi;\n\n\tswitch (type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tscnprintf(name, sizeof(name), \"dmesg-%s-%lld%s\",\n\t\t\t  psname, id, compressed ? \".enc.z\" : \"\");\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tscnprintf(name, sizeof(name), \"console-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tscnprintf(name, sizeof(name), \"ftrace-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_MCE:\n\t\tscnprintf(name, sizeof(name), \"mce-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tscnprintf(name, sizeof(name), \"rtas-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tscnprintf(name, sizeof(name), \"powerpc-ofw-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tscnprintf(name, sizeof(name), \"powerpc-common-%s-%lld\",\n\t\t\t  psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tscnprintf(name, sizeof(name), \"pmsg-%s-%lld\", psname, id);\n\t\tbreak;\n\tcase PSTORE_TYPE_UNKNOWN:\n\t\tscnprintf(name, sizeof(name), \"unknown-%s-%lld\", psname, id);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(name, sizeof(name), \"type%d-%s-%lld\",\n\t\t\t  type, psname, id);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\tdentry = d_alloc_name(root, name);\n\tif (!dentry)\n\t\tgoto fail_lockedalloc;\n\n\tmemcpy(private->data, data, size);\n\tinode->i_size = private->size = size;\n\n\tinode->i_private = private;\n\n\tif (time.tv_sec)\n\t\tinode->i_mtime = inode->i_ctime = time;\n\n\td_add(dentry, inode);\n\n\tspin_lock_irqsave(&allpstore_lock, flags);\n\tlist_add(&private->list, &allpstore);\n\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\treturn 0;\n\nfail_lockedalloc:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\tkfree(private);\nfail_alloc:\n\tiput(inode);\n\nfail:\n\treturn rc;\n}"
  },
  {
    "function_name": "pstore_is_mounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "290-293",
    "snippet": "int pstore_is_mounted(void)\n{\n\treturn pstore_sb != NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *pstore_sb;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct super_block *pstore_sb;\n\nint pstore_is_mounted(void)\n{\n\treturn pstore_sb != NULL;\n}"
  },
  {
    "function_name": "pstore_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "272-278",
    "snippet": "static int pstore_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tparse_options(data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "247-270",
          "snippet": "static void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int pstore_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tparse_options(data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "247-270",
    "snippet": "static void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstore_set_kmsg_bytes",
          "args": [
            "option"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_set_kmsg_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "83-86",
          "snippet": "void pstore_set_kmsg_bytes(int bytes)\n{\n\tkmsg_bytes = bytes;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long kmsg_bytes = 10240;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic unsigned long kmsg_bytes = 10240;\n\nvoid pstore_set_kmsg_bytes(int bytes)\n{\n\tkmsg_bytes = bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_kmsg_bytes, \"kmsg_bytes=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic void parse_options(char *options)\n{\n\tchar\t\t*p;\n\tsubstring_t\targs[MAX_OPT_ARGS];\n\tint\t\toption;\n\n\tif (!options)\n\t\treturn;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_kmsg_bytes:\n\t\t\tif (!match_int(&args[0], &option))\n\t\t\t\tpstore_set_kmsg_bytes(option);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pstore_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "228-236",
    "snippet": "static struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *pstore_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "pstore_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "209-221",
    "snippet": "static void pstore_evict_inode(struct inode *inode)\n{\n\tstruct pstore_private\t*p = inode->i_private;\n\tunsigned long\t\tflags;\n\n\tclear_inode(inode);\n\tif (p) {\n\t\tspin_lock_irqsave(&allpstore_lock, flags);\n\t\tlist_del(&p->list);\n\t\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\t\tkfree(p);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(allpstore_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&allpstore_lock",
            "flags"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&p->list"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&allpstore_lock",
            "flags"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(allpstore_lock);\n\nstatic void pstore_evict_inode(struct inode *inode)\n{\n\tstruct pstore_private\t*p = inode->i_private;\n\tunsigned long\t\tflags;\n\n\tclear_inode(inode);\n\tif (p) {\n\t\tspin_lock_irqsave(&allpstore_lock, flags);\n\t\tlist_del(&p->list);\n\t\tspin_unlock_irqrestore(&allpstore_lock, flags);\n\t\tkfree(p);\n\t}\n}"
  },
  {
    "function_name": "pstore_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "191-207",
    "snippet": "static int pstore_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct pstore_private *p = dentry->d_inode->i_private;\n\tint err;\n\n\terr = pstore_check_syslog_permissions(p);\n\tif (err)\n\t\treturn err;\n\n\tif (p->psi->erase)\n\t\tp->psi->erase(p->type, p->id, p->count,\n\t\t\t      dentry->d_inode->i_ctime, p->psi);\n\telse\n\t\treturn -EPERM;\n\n\treturn simple_unlink(dir, dentry);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "simple_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "305-313",
          "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->psi->erase",
          "args": [
            "p->type",
            "p->id",
            "p->count",
            "dentry->d_inode->i_ctime",
            "p->psi"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_check_syslog_permissions",
          "args": [
            "p"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_check_syslog_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "124-134",
          "snippet": "static int pstore_check_syslog_permissions(struct pstore_private *ps)\n{\n\tswitch (ps->type) {\n\tcase PSTORE_TYPE_DMESG:\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\tSYSLOG_FROM_READER);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int pstore_check_syslog_permissions(struct pstore_private *ps)\n{\n\tswitch (ps->type) {\n\tcase PSTORE_TYPE_DMESG:\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\tSYSLOG_FROM_READER);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int pstore_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct pstore_private *p = dentry->d_inode->i_private;\n\tint err;\n\n\terr = pstore_check_syslog_permissions(p);\n\tif (err)\n\t\treturn err;\n\n\tif (p->psi->erase)\n\t\tp->psi->erase(p->type, p->id, p->count,\n\t\t\t      dentry->d_inode->i_ctime, p->psi);\n\telse\n\t\treturn -EPERM;\n\n\treturn simple_unlink(dir, dentry);\n}"
  },
  {
    "function_name": "pstore_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "171-178",
    "snippet": "static loff_t pstore_file_llseek(struct file *file, loff_t off, int whence)\n{\n\tstruct seq_file *sf = file->private_data;\n\n\tif (sf->op)\n\t\treturn seq_lseek(file, off, whence);\n\treturn default_llseek(file, off, whence);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_llseek",
          "args": [
            "file",
            "off",
            "whence"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "default_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "200-252",
          "snippet": "loff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_lseek",
          "args": [
            "file",
            "off",
            "whence"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "seq_lseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "309-344",
          "snippet": "loff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tm->version = file->f_version;\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t/* with extreme prejudice... */\n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->version = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nloff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tm->version = file->f_version;\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t/* with extreme prejudice... */\n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->version = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic loff_t pstore_file_llseek(struct file *file, loff_t off, int whence)\n{\n\tstruct seq_file *sf = file->private_data;\n\n\tif (sf->op)\n\t\treturn seq_lseek(file, off, whence);\n\treturn default_llseek(file, off, whence);\n}"
  },
  {
    "function_name": "pstore_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "147-169",
    "snippet": "static int pstore_file_open(struct inode *inode, struct file *file)\n{\n\tstruct pstore_private *ps = inode->i_private;\n\tstruct seq_file *sf;\n\tint err;\n\tconst struct seq_operations *sops = NULL;\n\n\terr = pstore_check_syslog_permissions(ps);\n\tif (err)\n\t\treturn err;\n\n\tif (ps->type == PSTORE_TYPE_FTRACE)\n\t\tsops = &pstore_ftrace_seq_ops;\n\n\terr = seq_open(file, sops);\n\tif (err < 0)\n\t\treturn err;\n\n\tsf = file->private_data;\n\tsf->private = ps;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations pstore_ftrace_seq_ops = {\n\t.start\t= pstore_ftrace_seq_start,\n\t.next\t= pstore_ftrace_seq_next,\n\t.stop\t= pstore_ftrace_seq_stop,\n\t.show\t= pstore_ftrace_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "sops"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_check_syslog_permissions",
          "args": [
            "ps"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_check_syslog_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
          "lines": "124-134",
          "snippet": "static int pstore_check_syslog_permissions(struct pstore_private *ps)\n{\n\tswitch (ps->type) {\n\tcase PSTORE_TYPE_DMESG:\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\tSYSLOG_FROM_READER);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/syslog.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pstore.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int pstore_check_syslog_permissions(struct pstore_private *ps)\n{\n\tswitch (ps->type) {\n\tcase PSTORE_TYPE_DMESG:\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\tSYSLOG_FROM_READER);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations pstore_ftrace_seq_ops = {\n\t.start\t= pstore_ftrace_seq_start,\n\t.next\t= pstore_ftrace_seq_next,\n\t.stop\t= pstore_ftrace_seq_stop,\n\t.show\t= pstore_ftrace_seq_show,\n};\n\nstatic int pstore_file_open(struct inode *inode, struct file *file)\n{\n\tstruct pstore_private *ps = inode->i_private;\n\tstruct seq_file *sf;\n\tint err;\n\tconst struct seq_operations *sops = NULL;\n\n\terr = pstore_check_syslog_permissions(ps);\n\tif (err)\n\t\treturn err;\n\n\tif (ps->type == PSTORE_TYPE_FTRACE)\n\t\tsops = &pstore_ftrace_seq_ops;\n\n\terr = seq_open(file, sops);\n\tif (err < 0)\n\t\treturn err;\n\n\tsf = file->private_data;\n\tsf->private = ps;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pstore_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "136-145",
    "snippet": "static ssize_t pstore_file_read(struct file *file, char __user *userbuf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct pstore_private *ps = sf->private;\n\n\tif (ps->type == PSTORE_TYPE_FTRACE)\n\t\treturn seq_read(file, userbuf, count, ppos);\n\treturn simple_read_from_buffer(userbuf, count, ppos, ps->data, ps->size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "userbuf",
            "count",
            "ppos",
            "ps->data",
            "ps->size"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_read",
          "args": [
            "file",
            "userbuf",
            "count",
            "ppos"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "seq_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "158-298",
          "snippet": "ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tsize_t copied = 0;\n\tloff_t pos;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * seq_file->op->..m_start/m_stop/m_next may do special actions\n\t * or optimisations based on the file->f_version, so we want to\n\t * pass the file->f_version to those methods.\n\t *\n\t * seq_file->version is just copy of f_version, and seq_file\n\t * methods can treat it simply as file version.\n\t * It is copied in first and copied out after all operations.\n\t * It is convenient to have it as  part of structure to avoid the\n\t * need of passing another argument to all the seq_file methods.\n\t */\n\tm->version = file->f_version;\n\n\t/* Don't assume *ppos is where we left it */\n\tif (unlikely(*ppos != m->read_pos)) {\n\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->version = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = *ppos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t/* if not empty - flush it first */\n\tif (m->count) {\n\t\tn = min(m->count, size);\n\t\terr = copy_to_user(buf, m->buf + m->from, n);\n\t\tif (err)\n\t\t\tgoto Efault;\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t\tcopied += n;\n\t\tif (!m->count)\n\t\t\tm->index++;\n\t\tif (!size)\n\t\t\tgoto Done;\n\t}\n\t/* we need at least one record in buffer */\n\tpos = m->index;\n\tp = m->op->start(m, &pos);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (unlikely(err))\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) {\n\t\t\tp = m->op->next(m, p, &pos);\n\t\t\tm->index = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tif (m->count < m->size)\n\t\t\tgoto Fill;\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tm->version = 0;\n\t\tpos = m->index;\n\t\tp = m->op->start(m, &pos);\n\t}\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t/* they want more? let's try to get some more */\n\twhile (m->count < size) {\n\t\tsize_t offs = m->count;\n\t\tloff_t next = pos;\n\t\tp = m->op->next(m, p, &next);\n\t\tif (!p || IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\terr = m->op->show(m, p);\n\t\tif (seq_has_overflowed(m) || err) {\n\t\t\tm->count = offs;\n\t\t\tif (likely(err <= 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t}\n\tm->op->stop(m, p);\n\tn = min(m->count, size);\n\terr = copy_to_user(buf, m->buf, n);\n\tif (err)\n\t\tgoto Efault;\n\tcopied += n;\n\tm->count -= n;\n\tif (m->count)\n\t\tm->from = n;\n\telse\n\t\tpos++;\n\tm->index = pos;\nDone:\n\tif (!copied)\n\t\tcopied = err;\n\telse {\n\t\t*ppos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\nEfault:\n\terr = -EFAULT;\n\tgoto Done;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tsize_t copied = 0;\n\tloff_t pos;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * seq_file->op->..m_start/m_stop/m_next may do special actions\n\t * or optimisations based on the file->f_version, so we want to\n\t * pass the file->f_version to those methods.\n\t *\n\t * seq_file->version is just copy of f_version, and seq_file\n\t * methods can treat it simply as file version.\n\t * It is copied in first and copied out after all operations.\n\t * It is convenient to have it as  part of structure to avoid the\n\t * need of passing another argument to all the seq_file methods.\n\t */\n\tm->version = file->f_version;\n\n\t/* Don't assume *ppos is where we left it */\n\tif (unlikely(*ppos != m->read_pos)) {\n\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->version = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = *ppos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t/* if not empty - flush it first */\n\tif (m->count) {\n\t\tn = min(m->count, size);\n\t\terr = copy_to_user(buf, m->buf + m->from, n);\n\t\tif (err)\n\t\t\tgoto Efault;\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t\tcopied += n;\n\t\tif (!m->count)\n\t\t\tm->index++;\n\t\tif (!size)\n\t\t\tgoto Done;\n\t}\n\t/* we need at least one record in buffer */\n\tpos = m->index;\n\tp = m->op->start(m, &pos);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (unlikely(err))\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) {\n\t\t\tp = m->op->next(m, p, &pos);\n\t\t\tm->index = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tif (m->count < m->size)\n\t\t\tgoto Fill;\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tm->version = 0;\n\t\tpos = m->index;\n\t\tp = m->op->start(m, &pos);\n\t}\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t/* they want more? let's try to get some more */\n\twhile (m->count < size) {\n\t\tsize_t offs = m->count;\n\t\tloff_t next = pos;\n\t\tp = m->op->next(m, p, &next);\n\t\tif (!p || IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\terr = m->op->show(m, p);\n\t\tif (seq_has_overflowed(m) || err) {\n\t\t\tm->count = offs;\n\t\t\tif (likely(err <= 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t}\n\tm->op->stop(m, p);\n\tn = min(m->count, size);\n\terr = copy_to_user(buf, m->buf, n);\n\tif (err)\n\t\tgoto Efault;\n\tcopied += n;\n\tm->count -= n;\n\tif (m->count)\n\t\tm->from = n;\n\telse\n\t\tpos++;\n\tm->index = pos;\nDone:\n\tif (!copied)\n\t\tcopied = err;\n\telse {\n\t\t*ppos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\nEfault:\n\terr = -EFAULT;\n\tgoto Done;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic ssize_t pstore_file_read(struct file *file, char __user *userbuf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct pstore_private *ps = sf->private;\n\n\tif (ps->type == PSTORE_TYPE_FTRACE)\n\t\treturn seq_read(file, userbuf, count, ppos);\n\treturn simple_read_from_buffer(userbuf, count, ppos, ps->data, ps->size);\n}"
  },
  {
    "function_name": "pstore_check_syslog_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "124-134",
    "snippet": "static int pstore_check_syslog_permissions(struct pstore_private *ps)\n{\n\tswitch (ps->type) {\n\tcase PSTORE_TYPE_DMESG:\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\tSYSLOG_FROM_READER);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_syslog_permissions",
          "args": [
            "SYSLOG_ACTION_READ_ALL",
            "SYSLOG_FROM_READER"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int pstore_check_syslog_permissions(struct pstore_private *ps)\n{\n\tswitch (ps->type) {\n\tcase PSTORE_TYPE_DMESG:\n\tcase PSTORE_TYPE_CONSOLE:\n\t\treturn check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\tSYSLOG_FROM_READER);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "pstore_ftrace_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "104-115",
    "snippet": "static int pstore_ftrace_seq_show(struct seq_file *s, void *v)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data = v;\n\tstruct pstore_ftrace_record *rec = (void *)(ps->data + data->off);\n\n\tseq_printf(s, \"%d %08lx  %08lx  %pf <- %pF\\n\",\n\t\tpstore_ftrace_decode_cpu(rec), rec->ip, rec->parent_ip,\n\t\t(void *)rec->ip, (void *)rec->parent_ip);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%d %08lx  %08lx  %pf <- %pF\\n\"",
            "pstore_ftrace_decode_cpu(rec)",
            "rec->ip",
            "rec->parent_ip",
            "(void *)rec->ip",
            "(void *)rec->parent_ip"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstore_ftrace_decode_cpu",
          "args": [
            "rec"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_ftrace_decode_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/internal.h",
          "lines": "32-40",
          "snippet": "static inline unsigned int\npstore_ftrace_decode_cpu(struct pstore_ftrace_record *rec)\n{\n#ifndef PSTORE_CPU_IN_IP\n\treturn rec->cpu;\n#else\n\treturn rec->ip & PSTORE_CPU_IN_IP;\n#endif\n}",
          "includes": [
            "#include <linux/pstore.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define PSTORE_CPU_IN_IP 0x3",
            "#define PSTORE_CPU_IN_IP 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\n#define PSTORE_CPU_IN_IP 0x3\n#define PSTORE_CPU_IN_IP 0x1\n\nstatic inline unsigned int\npstore_ftrace_decode_cpu(struct pstore_ftrace_record *rec)\n{\n#ifndef PSTORE_CPU_IN_IP\n\treturn rec->cpu;\n#else\n\treturn rec->ip & PSTORE_CPU_IN_IP;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int pstore_ftrace_seq_show(struct seq_file *s, void *v)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data = v;\n\tstruct pstore_ftrace_record *rec = (void *)(ps->data + data->off);\n\n\tseq_printf(s, \"%d %08lx  %08lx  %pf <- %pF\\n\",\n\t\tpstore_ftrace_decode_cpu(rec), rec->ip, rec->parent_ip,\n\t\t(void *)rec->ip, (void *)rec->parent_ip);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pstore_ftrace_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "91-102",
    "snippet": "static void *pstore_ftrace_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data = v;\n\n\tdata->off += REC_SIZE;\n\tif (data->off + REC_SIZE > ps->size)\n\t\treturn NULL;\n\n\t(*pos)++;\n\treturn data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define REC_SIZE sizeof(struct pstore_ftrace_record)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define REC_SIZE sizeof(struct pstore_ftrace_record)\n\nstatic void *pstore_ftrace_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data = v;\n\n\tdata->off += REC_SIZE;\n\tif (data->off + REC_SIZE > ps->size)\n\t\treturn NULL;\n\n\t(*pos)++;\n\treturn data;\n}"
  },
  {
    "function_name": "pstore_ftrace_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "86-89",
    "snippet": "static void pstore_ftrace_seq_stop(struct seq_file *s, void *v)\n{\n\tkfree(v);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void pstore_ftrace_seq_stop(struct seq_file *s, void *v)\n{\n\tkfree(v);\n}"
  },
  {
    "function_name": "pstore_ftrace_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/inode.c",
    "lines": "66-84",
    "snippet": "static void *pstore_ftrace_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->off = ps->size % REC_SIZE;\n\tdata->off += *pos * REC_SIZE;\n\tif (data->off + REC_SIZE > ps->size) {\n\t\tkfree(data);\n\t\treturn NULL;\n\t}\n\n\treturn data;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/syslog.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/pstore.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched.h>",
      "#include <linux/parser.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/string.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define REC_SIZE sizeof(struct pstore_ftrace_record)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/syslog.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pstore.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/ramfs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define REC_SIZE sizeof(struct pstore_ftrace_record)\n\nstatic void *pstore_ftrace_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct pstore_private *ps = s->private;\n\tstruct pstore_ftrace_seq_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->off = ps->size % REC_SIZE;\n\tdata->off += *pos * REC_SIZE;\n\tif (data->off + REC_SIZE > ps->size) {\n\t\tkfree(data);\n\t\treturn NULL;\n\t}\n\n\treturn data;\n\n}"
  }
]