[
  {
    "function_name": "nlm4svc_proc_granted_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "431-442",
    "snippet": "static __be32\nnlm4svc_proc_granted_res(struct svc_rqst *rqstp, struct nlm_res  *argp,\n                                                void            *resp)\n{\n        if (!nlmsvc_ops)\n                return rpc_success;\n\n        dprintk(\"lockd: GRANTED_RES   called\\n\");\n\n        nlmsvc_grant_reply(&argp->cookie, argp->status);\n        return rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_grant_reply",
          "args": [
            "&argp->cookie",
            "argp->status"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_grant_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "863-884",
          "snippet": "void\nnlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"grant_reply: looking for cookie %x, s=%d \\n\",\n\t\t*(unsigned int *)(cookie->data), status);\n\tif (!(block = nlmsvc_find_block(cookie)))\n\t\treturn;\n\n\tif (block) {\n\t\tif (status == nlm_lck_denied_grace_period) {\n\t\t\t/* Try again in a couple of seconds */\n\t\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\t} else {\n\t\t\t/* Lock is now held by client, or has been rejected.\n\t\t\t * In both cases, the block should be removed. */\n\t\t\tnlmsvc_unlink_block(block);\n\t\t}\n\t}\n\tnlmsvc_release_block(block);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nvoid\nnlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"grant_reply: looking for cookie %x, s=%d \\n\",\n\t\t*(unsigned int *)(cookie->data), status);\n\tif (!(block = nlmsvc_find_block(cookie)))\n\t\treturn;\n\n\tif (block) {\n\t\tif (status == nlm_lck_denied_grace_period) {\n\t\t\t/* Try again in a couple of seconds */\n\t\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\t} else {\n\t\t\t/* Lock is now held by client, or has been rejected.\n\t\t\t * In both cases, the block should be removed. */\n\t\t\tnlmsvc_unlink_block(block);\n\t\t}\n\t}\n\tnlmsvc_release_block(block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: GRANTED_RES   called\\n\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_granted_res(struct svc_rqst *rqstp, struct nlm_res  *argp,\n                                                void            *resp)\n{\n        if (!nlmsvc_ops)\n                return rpc_success;\n\n        dprintk(\"lockd: GRANTED_RES   called\\n\");\n\n        nlmsvc_grant_reply(&argp->cookie, argp->status);\n        return rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_sm_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "411-426",
    "snippet": "static __be32\nnlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,\n\t\t\t\t\t      void\t        *resp)\n{\n\tdprintk(\"lockd: SM_NOTIFY     called\\n\");\n\n\tif (!nlm_privileged_requester(rqstp)) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_WARNING \"lockd: rejected NSM callback from %s\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn rpc_system_err;\n\t}\n\n\tnlm_host_rebooted(argp);\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_host_rebooted",
          "args": [
            "argp"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_host_rebooted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "542-566",
          "snippet": "void nlm_host_rebooted(const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *nsm;\n\tstruct nlm_host\t*host;\n\n\tnsm = nsm_reboot_lookup(info);\n\tif (unlikely(nsm == NULL))\n\t\treturn;\n\n\t/* Mark all hosts tied to this NSM state as having rebooted.\n\t * We run the loop repeatedly, because we drop the host table\n\t * lock for this.\n\t * To avoid processing a host several times, we match the nsmstate.\n\t */\n\twhile ((host = next_host_state(nlm_server_hosts, nsm, info)) != NULL) {\n\t\tnlmsvc_free_host_resources(host);\n\t\tnlmsvc_release_host(host);\n\t}\n\twhile ((host = next_host_state(nlm_client_hosts, nsm, info)) != NULL) {\n\t\tnlmclnt_recovery(host);\n\t\tnlmclnt_release_host(host);\n\t}\n\n\tnsm_release(nsm);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];\n\nvoid nlm_host_rebooted(const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *nsm;\n\tstruct nlm_host\t*host;\n\n\tnsm = nsm_reboot_lookup(info);\n\tif (unlikely(nsm == NULL))\n\t\treturn;\n\n\t/* Mark all hosts tied to this NSM state as having rebooted.\n\t * We run the loop repeatedly, because we drop the host table\n\t * lock for this.\n\t * To avoid processing a host several times, we match the nsmstate.\n\t */\n\twhile ((host = next_host_state(nlm_server_hosts, nsm, info)) != NULL) {\n\t\tnlmsvc_free_host_resources(host);\n\t\tnlmsvc_release_host(host);\n\t}\n\twhile ((host = next_host_state(nlm_client_hosts, nsm, info)) != NULL) {\n\t\tnlmclnt_recovery(host);\n\t\tnlmclnt_release_host(host);\n\t}\n\n\tnsm_release(nsm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: rejected NSM callback from %s\\n\"",
            "svc_print_addr(rqstp, buf, sizeof(buf))"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_print_addr",
          "args": [
            "rqstp",
            "buf",
            "sizeof(buf)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_privileged_requester",
          "args": [
            "rqstp"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: SM_NOTIFY     called\\n\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,\n\t\t\t\t\t      void\t        *resp)\n{\n\tdprintk(\"lockd: SM_NOTIFY     called\\n\");\n\n\tif (!nlm_privileged_requester(rqstp)) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_WARNING \"lockd: rejected NSM callback from %s\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn rpc_system_err;\n\t}\n\n\tnlm_host_rebooted(argp);\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_free_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "393-406",
    "snippet": "static __be32\nnlm4svc_proc_free_all(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void            *resp)\n{\n\tstruct nlm_host\t*host;\n\n\t/* Obtain client */\n\tif (nlm4svc_retrieve_args(rqstp, argp, &host, NULL))\n\t\treturn rpc_success;\n\n\tnlmsvc_free_host_resources(host);\n\tnlmsvc_release_host(host);\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_free_host_resources",
          "args": [
            "host"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_free_host_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "381-392",
          "snippet": "void\nnlmsvc_free_host_resources(struct nlm_host *host)\n{\n\tdprintk(\"lockd: nlmsvc_free_host_resources\\n\");\n\n\tif (nlm_traverse_files(host, nlmsvc_same_host, NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd: couldn't remove all locks held by %s\\n\",\n\t\t\thost->h_name);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nvoid\nnlmsvc_free_host_resources(struct nlm_host *host)\n{\n\tdprintk(\"lockd: nlmsvc_free_host_resources\\n\");\n\n\tif (nlm_traverse_files(host, nlmsvc_same_host, NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd: couldn't remove all locks held by %s\\n\",\n\t\t\thost->h_name);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "NULL"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_free_all(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void            *resp)\n{\n\tstruct nlm_host\t*host;\n\n\t/* Obtain client */\n\tif (nlm4svc_retrieve_args(rqstp, argp, &host, NULL))\n\t\treturn rpc_success;\n\n\tnlmsvc_free_host_resources(host);\n\tnlmsvc_release_host(host);\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_nm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "380-388",
    "snippet": "static __be32\nnlm4svc_proc_nm_lock(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t            struct nlm_res  *resp)\n{\n\tdprintk(\"lockd: NM_LOCK       called\\n\");\n\n\targp->monitor = 0;\t\t/* just clean the monitor flag */\n\treturn nlm4svc_proc_lock(rqstp, argp, resp);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm4svc_proc_lock",
          "args": [
            "rqstp",
            "argp",
            "resp"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_proc_lock_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "283-288",
          "snippet": "static __be32 nlm4svc_proc_lock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: LOCK_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_LOCK_RES, argp, nlm4svc_proc_lock);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_lock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: LOCK_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_LOCK_RES, argp, nlm4svc_proc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: NM_LOCK       called\\n\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_nm_lock(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t            struct nlm_res  *resp)\n{\n\tdprintk(\"lockd: NM_LOCK       called\\n\");\n\n\targp->monitor = 0;\t\t/* just clean the monitor flag */\n\treturn nlm4svc_proc_lock(rqstp, argp, resp);\n}"
  },
  {
    "function_name": "nlm4svc_proc_unshare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "347-375",
    "snippet": "static __be32\nnlm4svc_proc_unshare(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t            struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNSHARE       called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now try to lock the file */\n\tresp->status = nlmsvc_unshare_file(host, file, argp);\n\n\tdprintk(\"lockd: UNSHARE       status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "file"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: UNSHARE       status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_unshare_file",
          "args": [
            "host",
            "file",
            "argp"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unshare_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
          "lines": "67-86",
          "snippet": "__be32\nnlmsvc_unshare_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share, **shpp;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\n\tfor (shpp = &file->f_shares; (share = *shpp) != NULL;\n\t\t\t\t\tshpp = &share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\treturn nlm_granted;\n\t\t}\n\t}\n\n\t/* X/Open spec says return success even if there was no\n\t * corresponding share. */\n\treturn nlm_granted;\n}",
          "includes": [
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/unistd.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\n__be32\nnlmsvc_unshare_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share, **shpp;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\n\tfor (shpp = &file->f_shares; (share = *shpp) != NULL;\n\t\t\t\t\tshpp = &share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\treturn nlm_granted;\n\t\t}\n\t}\n\n\t/* X/Open spec says return success even if there was no\n\t * corresponding share. */\n\treturn nlm_granted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "&file"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: UNSHARE       called\\n\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_unshare(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t            struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNSHARE       called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now try to lock the file */\n\tresp->status = nlmsvc_unshare_file(host, file, argp);\n\n\tdprintk(\"lockd: UNSHARE       status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_share",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "314-342",
    "snippet": "static __be32\nnlm4svc_proc_share(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t          struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: SHARE         called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept new lock requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp)) && !argp->reclaim) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now try to create the share */\n\tresp->status = nlmsvc_share_file(host, file, argp);\n\n\tdprintk(\"lockd: SHARE         status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "file"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: SHARE         status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_share_file",
          "args": [
            "host",
            "file",
            "argp"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_share_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcshare.c",
          "lines": "26-62",
          "snippet": "__be32\nnlmsvc_share_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\tu8\t\t\t*ohdata;\n\n\tfor (share = file->f_shares; share; share = share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh))\n\t\t\tgoto update;\n\t\tif ((argp->fsm_access & share->s_mode)\n\t\t || (argp->fsm_mode   & share->s_access ))\n\t\t\treturn nlm_lck_denied;\n\t}\n\n\tshare = kmalloc(sizeof(*share) + oh->len,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (share == NULL)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Copy owner handle */\n\tohdata = (u8 *) (share + 1);\n\tmemcpy(ohdata, oh->data, oh->len);\n\n\tshare->s_file\t    = file;\n\tshare->s_host       = host;\n\tshare->s_owner.data = ohdata;\n\tshare->s_owner.len  = oh->len;\n\tshare->s_next       = file->f_shares;\n\tfile->f_shares      = share;\n\nupdate:\n\tshare->s_access = argp->fsm_access;\n\tshare->s_mode   = argp->fsm_mode;\n\treturn nlm_granted;\n}",
          "includes": [
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/unistd.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n\n__be32\nnlmsvc_share_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\tu8\t\t\t*ohdata;\n\n\tfor (share = file->f_shares; share; share = share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh))\n\t\t\tgoto update;\n\t\tif ((argp->fsm_access & share->s_mode)\n\t\t || (argp->fsm_mode   & share->s_access ))\n\t\t\treturn nlm_lck_denied;\n\t}\n\n\tshare = kmalloc(sizeof(*share) + oh->len,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (share == NULL)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Copy owner handle */\n\tohdata = (u8 *) (share + 1);\n\tmemcpy(ohdata, oh->data, oh->len);\n\n\tshare->s_file\t    = file;\n\tshare->s_host       = host;\n\tshare->s_owner.data = ohdata;\n\tshare->s_owner.len  = oh->len;\n\tshare->s_next       = file->f_shares;\n\tfile->f_shares      = share;\n\nupdate:\n\tshare->s_access = argp->fsm_access;\n\tshare->s_mode   = argp->fsm_mode;\n\treturn nlm_granted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "&file"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: SHARE         called\\n\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_share(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t          struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: SHARE         called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept new lock requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp)) && !argp->reclaim) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now try to create the share */\n\tresp->status = nlmsvc_share_file(host, file, argp);\n\n\tdprintk(\"lockd: SHARE         status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_granted_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "304-309",
    "snippet": "static __be32 nlm4svc_proc_granted_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n                                                void            *resp)\n{\n\tdprintk(\"lockd: GRANTED_MSG   called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_GRANTED_RES, argp, nlm4svc_proc_granted);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm4svc_callback",
          "args": [
            "rqstp",
            "NLMPROC_GRANTED_RES",
            "argp",
            "nlm4svc_proc_granted"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "246-274",
          "snippet": "static __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: GRANTED_MSG   called\\n\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_granted_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n                                                void            *resp)\n{\n\tdprintk(\"lockd: GRANTED_MSG   called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_GRANTED_RES, argp, nlm4svc_proc_granted);\n}"
  },
  {
    "function_name": "nlm4svc_proc_unlock_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "297-302",
    "snippet": "static __be32 nlm4svc_proc_unlock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n                                               void            *resp)\n{\n\tdprintk(\"lockd: UNLOCK_MSG    called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_UNLOCK_RES, argp, nlm4svc_proc_unlock);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm4svc_callback",
          "args": [
            "rqstp",
            "NLMPROC_UNLOCK_RES",
            "argp",
            "nlm4svc_proc_unlock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "246-274",
          "snippet": "static __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: UNLOCK_MSG    called\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_unlock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n                                               void            *resp)\n{\n\tdprintk(\"lockd: UNLOCK_MSG    called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_UNLOCK_RES, argp, nlm4svc_proc_unlock);\n}"
  },
  {
    "function_name": "nlm4svc_proc_cancel_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "290-295",
    "snippet": "static __be32 nlm4svc_proc_cancel_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t       void\t       *resp)\n{\n\tdprintk(\"lockd: CANCEL_MSG    called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_CANCEL_RES, argp, nlm4svc_proc_cancel);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm4svc_callback",
          "args": [
            "rqstp",
            "NLMPROC_CANCEL_RES",
            "argp",
            "nlm4svc_proc_cancel"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "246-274",
          "snippet": "static __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: CANCEL_MSG    called\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_cancel_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t       void\t       *resp)\n{\n\tdprintk(\"lockd: CANCEL_MSG    called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_CANCEL_RES, argp, nlm4svc_proc_cancel);\n}"
  },
  {
    "function_name": "nlm4svc_proc_lock_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "283-288",
    "snippet": "static __be32 nlm4svc_proc_lock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: LOCK_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_LOCK_RES, argp, nlm4svc_proc_lock);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm4svc_callback",
          "args": [
            "rqstp",
            "NLMPROC_LOCK_RES",
            "argp",
            "nlm4svc_proc_lock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "246-274",
          "snippet": "static __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: LOCK_MSG      called\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_lock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: LOCK_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_LOCK_RES, argp, nlm4svc_proc_lock);\n}"
  },
  {
    "function_name": "nlm4svc_proc_test_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "276-281",
    "snippet": "static __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm4svc_callback",
          "args": [
            "rqstp",
            "NLMPROC_TEST_RES",
            "argp",
            "nlm4svc_proc_test"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "246-274",
          "snippet": "static __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: TEST_MSG      called\\n\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}"
  },
  {
    "function_name": "nlm4svc_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "246-274",
    "snippet": "static __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_async_reply",
          "args": [
            "call",
            "proc",
            "&nlm4svc_callback_ops"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_async_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "378-384",
          "snippet": "int nlm_async_reply(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint nlm_async_reply(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_call",
          "args": [
            "call"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcproc.c",
          "lines": "264-270",
          "snippet": "void nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "rqstp",
            "argp",
            "&call->a_res"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_alloc_call",
          "args": [
            "host"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_alloc_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "194-213",
          "snippet": "struct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_lookup_host",
          "args": [
            "rqstp",
            "argp->lock.caller",
            "argp->lock.len"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_lookup_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "320-395",
          "snippet": "struct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t/* Move to head of hash chain. */\n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static unsigned long\t\tnrhosts;",
            "static DEFINE_MUTEX(nlm_host_mutex);",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t/* Move to head of hash chain. */\n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res  *))\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, argp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_callback_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "231-234",
    "snippet": "static void nlm4svc_callback_release(void *data)\n{\n\tnlmsvc_release_call(data);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_call",
          "args": [
            "data"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcproc.c",
          "lines": "264-270",
          "snippet": "void nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic void nlm4svc_callback_release(void *data)\n{\n\tnlmsvc_release_call(data);\n}"
  },
  {
    "function_name": "nlm4svc_callback_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "225-229",
    "snippet": "static void nlm4svc_callback_exit(struct rpc_task *task, void *data)\n{\n\tdprintk(\"lockd: %5u callback returned %d\\n\", task->tk_pid,\n\t\t\t-task->tk_status);\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %5u callback returned %d\\n\"",
            "task->tk_pid",
            "-task->tk_status"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic void nlm4svc_callback_exit(struct rpc_task *task, void *data)\n{\n\tdprintk(\"lockd: %5u callback returned %d\\n\", task->tk_pid,\n\t\t\t-task->tk_status);\n}"
  },
  {
    "function_name": "nlm4svc_proc_granted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "210-220",
    "snippet": "static __be32\nnlm4svc_proc_granted(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t            struct nlm_res  *resp)\n{\n\tresp->cookie = argp->cookie;\n\n\tdprintk(\"lockd: GRANTED       called\\n\");\n\tresp->status = nlmclnt_grant(svc_addr(rqstp), &argp->lock);\n\tdprintk(\"lockd: GRANTED       status %d\\n\", ntohl(resp->status));\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: GRANTED       status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_grant",
          "args": [
            "svc_addr(rqstp)",
            "&argp->lock"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntlock.c",
          "lines": "162-200",
          "snippet": "__be32 nlmclnt_grant(const struct sockaddr *addr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\tconst struct nfs_fh *fh = &lock->fh;\n\tstruct nlm_wait\t*block;\n\t__be32 res = nlm_lck_denied;\n\n\t/*\n\t * Look up blocked request based on arguments. \n\t * Warning: must not use cookie to match it!\n\t */\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tstruct file_lock *fl_blocked = block->b_lock;\n\n\t\tif (fl_blocked->fl_start != fl->fl_start)\n\t\t\tcontinue;\n\t\tif (fl_blocked->fl_end != fl->fl_end)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Careful! The NLM server will return the 32-bit \"pid\" that\n\t\t * we put on the wire: in this case the lockowner \"pid\".\n\t\t */\n\t\tif (fl_blocked->fl_u.nfs_fl.owner->pid != lock->svid)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(block->b_host), addr))\n\t\t\tcontinue;\n\t\tif (nfs_compare_fh(NFS_FH(file_inode(fl_blocked->fl_file)) ,fh) != 0)\n\t\t\tcontinue;\n\t\t/* Alright, we found a lock. Set the return status\n\t\t * and wake up the caller\n\t\t */\n\t\tblock->b_status = nlm_granted;\n\t\twake_up(&block->b_wait);\n\t\tres = nlm_granted;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\treturn res;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nlm_blocked);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_fs.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\n__be32 nlmclnt_grant(const struct sockaddr *addr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\tconst struct nfs_fh *fh = &lock->fh;\n\tstruct nlm_wait\t*block;\n\t__be32 res = nlm_lck_denied;\n\n\t/*\n\t * Look up blocked request based on arguments. \n\t * Warning: must not use cookie to match it!\n\t */\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tstruct file_lock *fl_blocked = block->b_lock;\n\n\t\tif (fl_blocked->fl_start != fl->fl_start)\n\t\t\tcontinue;\n\t\tif (fl_blocked->fl_end != fl->fl_end)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Careful! The NLM server will return the 32-bit \"pid\" that\n\t\t * we put on the wire: in this case the lockowner \"pid\".\n\t\t */\n\t\tif (fl_blocked->fl_u.nfs_fl.owner->pid != lock->svid)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(block->b_host), addr))\n\t\t\tcontinue;\n\t\tif (nfs_compare_fh(NFS_FH(file_inode(fl_blocked->fl_file)) ,fh) != 0)\n\t\t\tcontinue;\n\t\t/* Alright, we found a lock. Set the return status\n\t\t * and wake up the caller\n\t\t */\n\t\tblock->b_status = nlm_granted;\n\t\twake_up(&block->b_wait);\n\t\tres = nlm_granted;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: GRANTED       called\\n\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_granted(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t            struct nlm_res  *resp)\n{\n\tresp->cookie = argp->cookie;\n\n\tdprintk(\"lockd: GRANTED       called\\n\");\n\tresp->status = nlmclnt_grant(svc_addr(rqstp), &argp->lock);\n\tdprintk(\"lockd: GRANTED       status %d\\n\", ntohl(resp->status));\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "176-204",
    "snippet": "static __be32\nnlm4svc_proc_unlock(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t           struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNLOCK        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept new lock requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now try to remove the lock */\n\tresp->status = nlmsvc_unlock(SVC_NET(rqstp), file, &argp->lock);\n\n\tdprintk(\"lockd: UNLOCK        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "file"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: UNLOCK        status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlock",
          "args": [
            "SVC_NET(rqstp)",
            "file",
            "&argp->lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "562-581",
          "snippet": "__be32\nnlmsvc_unlock(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tint\terror;\n\n\tdprintk(\"lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\t/* First, cancel any lock that might be there */\n\tnlmsvc_cancel_blocked(net, file, lock);\n\n\tlock->fl.fl_type = F_UNLCK;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\n\treturn (error < 0)? nlm_lck_denied_nolocks : nlm_granted;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_unlock(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tint\terror;\n\n\tdprintk(\"lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\t/* First, cancel any lock that might be there */\n\tnlmsvc_cancel_blocked(net, file, lock);\n\n\tlock->fl.fl_type = F_UNLCK;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\n\treturn (error < 0)? nlm_lck_denied_nolocks : nlm_granted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "&file"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: UNLOCK        called\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_unlock(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t           struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNLOCK        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept new lock requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now try to remove the lock */\n\tresp->status = nlmsvc_unlock(SVC_NET(rqstp), file, &argp->lock);\n\n\tdprintk(\"lockd: UNLOCK        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "143-171",
    "snippet": "static __be32\nnlm4svc_proc_cancel(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t           struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: CANCEL        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Try to cancel request. */\n\tresp->status = nlmsvc_cancel_blocked(SVC_NET(rqstp), file, &argp->lock);\n\n\tdprintk(\"lockd: CANCEL        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "file"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: CANCEL        status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_cancel_blocked",
          "args": [
            "SVC_NET(rqstp)",
            "file",
            "&argp->lock"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_cancel_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "590-616",
          "snippet": "__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tvfs_cancel_lock(block->b_file->f_file,\n\t\t\t\t&block->b_call->a_args.lock.fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tvfs_cancel_lock(block->b_file->f_file,\n\t\t\t\t&block->b_call->a_args.lock.fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "&file"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: CANCEL        called\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_cancel(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t           struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: CANCEL        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Don't accept requests during grace period */\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Try to cancel request. */\n\tresp->status = nlmsvc_cancel_blocked(SVC_NET(rqstp), file, &argp->lock);\n\n\tdprintk(\"lockd: CANCEL        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_proc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "101-141",
    "snippet": "static __be32\nnlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t         struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: LOCK          called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n#if 0\n\t/* If supplied state doesn't match current state, we assume it's\n\t * an old request that time-warped somehow. Any error return would\n\t * do in this case because it's irrelevant anyway.\n\t *\n\t * NB: We don't retrieve the remote host's state yet.\n\t */\n\tif (host->h_nsmstate && host->h_nsmstate != argp->state) {\n\t\tresp->status = nlm_lck_denied_nolocks;\n\t} else\n#endif\n\n\t/* Now try to lock the file */\n\tresp->status = nlmsvc_lock(rqstp, file, host, &argp->lock,\n\t\t\t\t\targp->block, &argp->cookie,\n\t\t\t\t\targp->reclaim);\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: LOCK         status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "file"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: LOCK         status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_lock",
          "args": [
            "rqstp",
            "file",
            "host",
            "&argp->lock",
            "argp->block",
            "&argp->cookie",
            "argp->reclaim"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "397-499",
          "snippet": "__be32\nnlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t    struct nlm_host *host, struct nlm_lock *lock, int wait,\n\t    struct nlm_cookie *cookie, int reclaim)\n{\n\tstruct nlm_block\t*block = NULL;\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end,\n\t\t\t\twait);\n\n\t/* Lock file against concurrent access */\n\tmutex_lock(&file->f_mutex);\n\t/* Get existing block (in case client is busy-waiting)\n\t * or create new block\n\t */\n\tblock = nlmsvc_lookup_block(file, lock);\n\tif (block == NULL) {\n\t\tblock = nlmsvc_create_block(rqstp, host, file, lock, cookie);\n\t\tret = nlm_lck_denied_nolocks;\n\t\tif (block == NULL)\n\t\t\tgoto out;\n\t\tlock = &block->b_call->a_args.lock;\n\t} else\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tif (block->b_flags & B_QUEUED) {\n\t\tdprintk(\"lockd: nlmsvc_lock deferred block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\tif (block->b_granted) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\t}\n\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nlm_drop_reply;\n\t\tgoto out;\n\t}\n\n\tif (locks_in_grace(SVC_NET(rqstp)) && !reclaim) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\tif (reclaim && !locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\tif (!wait)\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tdprintk(\"lockd: vfs_lock_file returned %d\\n\", error);\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * If this is a blocking request for an\n\t\t\t * already pending lock request then we need\n\t\t\t * to put it back on lockd's block list\n\t\t\t */\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\tcase FILE_LOCK_DEFERRED:\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\t/* Filesystem lock operation is in progress\n\t\t\t   Add it to the queue waiting for callback */\n\t\t\tret = nlmsvc_defer_lock_rqst(rqstp, block);\n\t\t\tgoto out;\n\t\tcase -EDEADLK:\n\t\t\tret = nlm_deadlock;\n\t\t\tgoto out;\n\t\tdefault:\t\t\t/* includes ENOLCK */\n\t\t\tret = nlm_lck_denied_nolocks;\n\t\t\tgoto out;\n\t}\n\n\tret = nlm_lck_blocked;\n\n\t/* Append to list of blocked */\n\tnlmsvc_insert_block(block, NLM_NEVER);\nout:\n\tmutex_unlock(&file->f_mutex);\n\tnlmsvc_release_block(block);\n\tdprintk(\"lockd: nlmsvc_lock returned %u\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define nlm_deadlock\tnlm_lck_denied",
            "#define nlm_deadlock\tnlm4_deadlock"
          ],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define nlm_deadlock\tnlm_lck_denied\n#define nlm_deadlock\tnlm4_deadlock\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t    struct nlm_host *host, struct nlm_lock *lock, int wait,\n\t    struct nlm_cookie *cookie, int reclaim)\n{\n\tstruct nlm_block\t*block = NULL;\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end,\n\t\t\t\twait);\n\n\t/* Lock file against concurrent access */\n\tmutex_lock(&file->f_mutex);\n\t/* Get existing block (in case client is busy-waiting)\n\t * or create new block\n\t */\n\tblock = nlmsvc_lookup_block(file, lock);\n\tif (block == NULL) {\n\t\tblock = nlmsvc_create_block(rqstp, host, file, lock, cookie);\n\t\tret = nlm_lck_denied_nolocks;\n\t\tif (block == NULL)\n\t\t\tgoto out;\n\t\tlock = &block->b_call->a_args.lock;\n\t} else\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tif (block->b_flags & B_QUEUED) {\n\t\tdprintk(\"lockd: nlmsvc_lock deferred block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\tif (block->b_granted) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\t}\n\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nlm_drop_reply;\n\t\tgoto out;\n\t}\n\n\tif (locks_in_grace(SVC_NET(rqstp)) && !reclaim) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\tif (reclaim && !locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\tif (!wait)\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tdprintk(\"lockd: vfs_lock_file returned %d\\n\", error);\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * If this is a blocking request for an\n\t\t\t * already pending lock request then we need\n\t\t\t * to put it back on lockd's block list\n\t\t\t */\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\tcase FILE_LOCK_DEFERRED:\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\t/* Filesystem lock operation is in progress\n\t\t\t   Add it to the queue waiting for callback */\n\t\t\tret = nlmsvc_defer_lock_rqst(rqstp, block);\n\t\t\tgoto out;\n\t\tcase -EDEADLK:\n\t\t\tret = nlm_deadlock;\n\t\t\tgoto out;\n\t\tdefault:\t\t\t/* includes ENOLCK */\n\t\t\tret = nlm_lck_denied_nolocks;\n\t\t\tgoto out;\n\t}\n\n\tret = nlm_lck_blocked;\n\n\t/* Append to list of blocked */\n\tnlmsvc_insert_block(block, NLM_NEVER);\nout:\n\tmutex_unlock(&file->f_mutex);\n\tnlmsvc_release_block(block);\n\tdprintk(\"lockd: nlmsvc_lock returned %u\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "&file"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: LOCK          called\\n\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t         struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: LOCK          called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n#if 0\n\t/* If supplied state doesn't match current state, we assume it's\n\t * an old request that time-warped somehow. Any error return would\n\t * do in this case because it's irrelevant anyway.\n\t *\n\t * NB: We don't retrieve the remote host's state yet.\n\t */\n\tif (host->h_nsmstate && host->h_nsmstate != argp->state) {\n\t\tresp->status = nlm_lck_denied_nolocks;\n\t} else\n#endif\n\n\t/* Now try to lock the file */\n\tresp->status = nlmsvc_lock(rqstp, file, host, &argp->lock,\n\t\t\t\t\targp->block, &argp->cookie,\n\t\t\t\t\targp->reclaim);\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: LOCK         status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}"
  },
  {
    "function_name": "nlm4svc_proc_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "74-99",
    "snippet": "static __be32\nnlm4svc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t         struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: TEST4        called\\n\");\n\tresp->cookie = argp->cookie;\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now check for conflicting locks */\n\tresp->status = nlmsvc_testlock(rqstp, file, host, &argp->lock, &resp->lock, &resp->cookie);\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: TEST4        status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "file"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: TEST4        status %d\\n\"",
            "ntohl(resp->status)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "resp->status"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_testlock",
          "args": [
            "rqstp",
            "file",
            "host",
            "&argp->lock",
            "&resp->lock",
            "&resp->cookie"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_testlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "504-553",
          "snippet": "__be32\nnlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t\tstruct nlm_host *host, struct nlm_lock *lock,\n\t\tstruct nlm_lock *conflock, struct nlm_cookie *cookie)\n{\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\terror = vfs_test_lock(file->f_file, &lock->fl);\n\tif (error) {\n\t\t/* We can't currently deal with deferred test requests */\n\t\tif (error == FILE_LOCK_DEFERRED)\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tret = nlm_lck_denied_nolocks;\n\t\tgoto out;\n\t}\n\n\tif (lock->fl.fl_type == F_UNLCK) {\n\t\tret = nlm_granted;\n\t\tgoto out;\n\t}\n\n\tdprintk(\"lockd: conflicting lock(ty=%d, %Ld-%Ld)\\n\",\n\t\tlock->fl.fl_type, (long long)lock->fl.fl_start,\n\t\t(long long)lock->fl.fl_end);\n\tconflock->caller = \"somehost\";\t/* FIXME */\n\tconflock->len = strlen(conflock->caller);\n\tconflock->oh.len = 0;\t\t/* don't return OH info */\n\tconflock->svid = lock->fl.fl_pid;\n\tconflock->fl.fl_type = lock->fl.fl_type;\n\tconflock->fl.fl_start = lock->fl.fl_start;\n\tconflock->fl.fl_end = lock->fl.fl_end;\n\tlocks_release_private(&lock->fl);\n\tret = nlm_lck_denied;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t\tstruct nlm_host *host, struct nlm_lock *lock,\n\t\tstruct nlm_lock *conflock, struct nlm_cookie *cookie)\n{\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\terror = vfs_test_lock(file->f_file, &lock->fl);\n\tif (error) {\n\t\t/* We can't currently deal with deferred test requests */\n\t\tif (error == FILE_LOCK_DEFERRED)\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tret = nlm_lck_denied_nolocks;\n\t\tgoto out;\n\t}\n\n\tif (lock->fl.fl_type == F_UNLCK) {\n\t\tret = nlm_granted;\n\t\tgoto out;\n\t}\n\n\tdprintk(\"lockd: conflicting lock(ty=%d, %Ld-%Ld)\\n\",\n\t\tlock->fl.fl_type, (long long)lock->fl.fl_start,\n\t\t(long long)lock->fl.fl_end);\n\tconflock->caller = \"somehost\";\t/* FIXME */\n\tconflock->len = strlen(conflock->caller);\n\tconflock->oh.len = 0;\t\t/* don't return OH info */\n\tconflock->svid = lock->fl.fl_pid;\n\tconflock->fl.fl_type = lock->fl.fl_type;\n\tconflock->fl.fl_start = lock->fl.fl_start;\n\tconflock->fl.fl_end = lock->fl.fl_end;\n\tlocks_release_private(&lock->fl);\n\tret = nlm_lck_denied;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm4svc_retrieve_args",
          "args": [
            "rqstp",
            "argp",
            "&host",
            "&file"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_retrieve_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "21-59",
          "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: TEST4        called\\n\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t         struct nlm_res  *resp)\n{\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: TEST4        called\\n\");\n\tresp->cookie = argp->cookie;\n\n\t/* Obtain client and file */\n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t/* Now check for conflicting locks */\n\tresp->status = nlmsvc_testlock(rqstp, file, host, &argp->lock, &resp->lock, &resp->cookie);\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: TEST4        status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}"
  },
  {
    "function_name": "nlm4svc_proc_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "64-69",
    "snippet": "static __be32\nnlm4svc_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\tdprintk(\"lockd: NULL          called\\n\");\n\treturn rpc_success;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: NULL          called\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\tdprintk(\"lockd: NULL          called\\n\");\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "nlm4svc_retrieve_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
    "lines": "21-59",
    "snippet": "static __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}",
    "includes": [
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/lockd/share.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/time.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_host",
          "args": [
            "host"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "403-412",
          "snippet": "void nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\tatomic_dec(&host->h_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_lookup_file",
          "args": [
            "rqstp",
            "&file",
            "&lock->fh"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_lookup_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "82-139",
          "snippet": "__be32\nnlm_lookup_file(struct svc_rqst *rqstp, struct nlm_file **result,\n\t\t\t\t\tstruct nfs_fh *f)\n{\n\tstruct nlm_file\t*file;\n\tunsigned int\thash;\n\t__be32\t\tnfserr;\n\n\tnlm_debug_print_fh(\"nlm_lookup_file\", f);\n\n\thash = file_hash(f);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\thlist_for_each_entry(file, &nlm_files[hash], f_list)\n\t\tif (!nfs_compare_fh(&file->f_handle, f))\n\t\t\tgoto found;\n\n\tnlm_debug_print_fh(\"creating file for\", f);\n\n\tnfserr = nlm_lck_denied_nolocks;\n\tfile = kzalloc(sizeof(*file), GFP_KERNEL);\n\tif (!file)\n\t\tgoto out_unlock;\n\n\tmemcpy(&file->f_handle, f, sizeof(struct nfs_fh));\n\tmutex_init(&file->f_mutex);\n\tINIT_HLIST_NODE(&file->f_list);\n\tINIT_LIST_HEAD(&file->f_blocks);\n\n\t/* Open the file. Note that this must not sleep for too long, else\n\t * we would lock up lockd:-) So no NFS re-exports, folks.\n\t *\n\t * We have to make sure we have the right credential to open\n\t * the file.\n\t */\n\tif ((nfserr = nlmsvc_ops->fopen(rqstp, f, &file->f_file)) != 0) {\n\t\tdprintk(\"lockd: open failed (error %d)\\n\", nfserr);\n\t\tgoto out_free;\n\t}\n\n\thlist_add_head(&file->f_list, &nlm_files[hash]);\n\nfound:\n\tdprintk(\"lockd: found file %p (count %d)\\n\", file, file->f_count);\n\t*result = file;\n\tfile->f_count++;\n\tnfserr = 0;\n\nout_unlock:\n\tmutex_unlock(&nlm_file_mutex);\n\treturn nfserr;\n\nout_free:\n\tkfree(file);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_files[FILE_NRHASH];",
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_files[FILE_NRHASH];\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\n__be32\nnlm_lookup_file(struct svc_rqst *rqstp, struct nlm_file **result,\n\t\t\t\t\tstruct nfs_fh *f)\n{\n\tstruct nlm_file\t*file;\n\tunsigned int\thash;\n\t__be32\t\tnfserr;\n\n\tnlm_debug_print_fh(\"nlm_lookup_file\", f);\n\n\thash = file_hash(f);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\thlist_for_each_entry(file, &nlm_files[hash], f_list)\n\t\tif (!nfs_compare_fh(&file->f_handle, f))\n\t\t\tgoto found;\n\n\tnlm_debug_print_fh(\"creating file for\", f);\n\n\tnfserr = nlm_lck_denied_nolocks;\n\tfile = kzalloc(sizeof(*file), GFP_KERNEL);\n\tif (!file)\n\t\tgoto out_unlock;\n\n\tmemcpy(&file->f_handle, f, sizeof(struct nfs_fh));\n\tmutex_init(&file->f_mutex);\n\tINIT_HLIST_NODE(&file->f_list);\n\tINIT_LIST_HEAD(&file->f_blocks);\n\n\t/* Open the file. Note that this must not sleep for too long, else\n\t * we would lock up lockd:-) So no NFS re-exports, folks.\n\t *\n\t * We have to make sure we have the right credential to open\n\t * the file.\n\t */\n\tif ((nfserr = nlmsvc_ops->fopen(rqstp, f, &file->f_file)) != 0) {\n\t\tdprintk(\"lockd: open failed (error %d)\\n\", nfserr);\n\t\tgoto out_free;\n\t}\n\n\thlist_add_head(&file->f_list, &nlm_files[hash]);\n\nfound:\n\tdprintk(\"lockd: found file %p (count %d)\\n\", file, file->f_count);\n\t*result = file;\n\tfile->f_count++;\n\tnfserr = 0;\n\nout_unlock:\n\tmutex_unlock(&nlm_file_mutex);\n\treturn nfserr;\n\nout_free:\n\tkfree(file);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsm_monitor",
          "args": [
            "host"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "nsm_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/mon.c",
          "lines": "188-232",
          "snippet": "int nsm_monitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint\t\tstatus;\n\tstruct rpc_clnt *clnt;\n\tconst char *nodename = NULL;\n\n\tdprintk(\"lockd: nsm_monitor(%s)\\n\", nsm->sm_name);\n\n\tif (nsm->sm_monitored)\n\t\treturn 0;\n\n\tif (host->h_rpcclnt)\n\t\tnodename = host->h_rpcclnt->cl_nodename;\n\n\t/*\n\t * Choose whether to record the caller_name or IP address of\n\t * this peer in the local rpc.statd's database.\n\t */\n\tnsm->sm_mon_name = nsm_use_hostnames ? nsm->sm_name : nsm->sm_addrbuf;\n\n\tclnt = nsm_client_get(host->net, nodename);\n\tif (IS_ERR(clnt)) {\n\t\tstatus = PTR_ERR(clnt);\n\t\tdprintk(\"lockd: failed to create NSM upcall transport, \"\n\t\t\t\t\"status=%d, net=%p\\n\", status, host->net);\n\t\treturn status;\n\t}\n\n\tstatus = nsm_mon_unmon(nsm, NSMPROC_MON, &res, clnt);\n\tif (unlikely(res.status != 0))\n\t\tstatus = -EIO;\n\tif (unlikely(status < 0)) {\n\t\tpr_notice_ratelimited(\"lockd: cannot monitor %s\\n\", nsm->sm_name);\n\t\treturn status;\n\t}\n\n\tnsm->sm_monitored = 1;\n\tif (unlikely(nsm_local_state != res.state)) {\n\t\tnsm_local_state = res.state;\n\t\tdprintk(\"lockd: NSM state changed to %d\\n\", nsm_local_state);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/ktime.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <asm/unaligned.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint nsm_monitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint\t\tstatus;\n\tstruct rpc_clnt *clnt;\n\tconst char *nodename = NULL;\n\n\tdprintk(\"lockd: nsm_monitor(%s)\\n\", nsm->sm_name);\n\n\tif (nsm->sm_monitored)\n\t\treturn 0;\n\n\tif (host->h_rpcclnt)\n\t\tnodename = host->h_rpcclnt->cl_nodename;\n\n\t/*\n\t * Choose whether to record the caller_name or IP address of\n\t * this peer in the local rpc.statd's database.\n\t */\n\tnsm->sm_mon_name = nsm_use_hostnames ? nsm->sm_name : nsm->sm_addrbuf;\n\n\tclnt = nsm_client_get(host->net, nodename);\n\tif (IS_ERR(clnt)) {\n\t\tstatus = PTR_ERR(clnt);\n\t\tdprintk(\"lockd: failed to create NSM upcall transport, \"\n\t\t\t\t\"status=%d, net=%p\\n\", status, host->net);\n\t\treturn status;\n\t}\n\n\tstatus = nsm_mon_unmon(nsm, NSMPROC_MON, &res, clnt);\n\tif (unlikely(res.status != 0))\n\t\tstatus = -EIO;\n\tif (unlikely(status < 0)) {\n\t\tpr_notice_ratelimited(\"lockd: cannot monitor %s\\n\", nsm->sm_name);\n\t\treturn status;\n\t}\n\n\tnsm->sm_monitored = 1;\n\tif (unlikely(nsm_local_state != res.state)) {\n\t\tnsm_local_state = res.state;\n\t\tdprintk(\"lockd: NSM state changed to %d\\n\", nsm_local_state);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_lookup_host",
          "args": [
            "rqstp",
            "lock->caller",
            "lock->len"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_lookup_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "320-395",
          "snippet": "struct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t/* Move to head of hash chain. */\n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];",
            "static unsigned long\t\tnrhosts;",
            "static DEFINE_MUTEX(nlm_host_mutex);",
            "static void\t\t\tnlm_gc_hosts(struct net *net);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic unsigned long\t\tnrhosts;\nstatic DEFINE_MUTEX(nlm_host_mutex);\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t/* Same address. Share an NSM handle if we already have one */\n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t/* Move to head of hash chain. */\n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t/* nfsd callbacks must have been installed for this procedure */\n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t/* Obtain host handle */\n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t/* Obtain file pointer. Not used by FREE_ALL call. */\n\tif (filp != NULL) {\n\t\tif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t/* Set up the missing parts of the file_lock structure */\n\t\tlock->fl.fl_file  = file->f_file;\n\t\tlock->fl.fl_owner = (fl_owner_t) host;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}"
  }
]