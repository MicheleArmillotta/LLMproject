[
  {
    "function_name": "reiserfs_proc_info_global_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "476-483",
    "snippet": "int reiserfs_proc_info_global_done(void)\n{\n\tif (proc_info_root != NULL) {\n\t\tproc_info_root = NULL;\n\t\tremove_proc_entry(proc_info_root_name, NULL);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_info_root = NULL;",
      "static const char proc_info_root_name[] = \"fs/reiserfs\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "proc_info_root_name",
            "NULL"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_info_root = NULL;\nstatic const char proc_info_root_name[] = \"fs/reiserfs\";\n\nint reiserfs_proc_info_global_done(void)\n{\n\tif (proc_info_root != NULL) {\n\t\tproc_info_root = NULL;\n\t\tremove_proc_entry(proc_info_root_name, NULL);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_proc_info_global_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "463-474",
    "snippet": "int reiserfs_proc_info_global_init(void)\n{\n\tif (proc_info_root == NULL) {\n\t\tproc_info_root = proc_mkdir(proc_info_root_name, NULL);\n\t\tif (!proc_info_root) {\n\t\t\treiserfs_warning(NULL, \"cannot create /proc/%s\",\n\t\t\t\t\t proc_info_root_name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_info_root = NULL;",
      "static const char proc_info_root_name[] = \"fs/reiserfs\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"cannot create /proc/%s\"",
            "proc_info_root_name"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "proc_info_root_name",
            "NULL"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_info_root = NULL;\nstatic const char proc_info_root_name[] = \"fs/reiserfs\";\n\nint reiserfs_proc_info_global_init(void)\n{\n\tif (proc_info_root == NULL) {\n\t\tproc_info_root = proc_mkdir(proc_info_root_name, NULL);\n\t\tif (!proc_info_root) {\n\t\t\treiserfs_warning(NULL, \"cannot create /proc/%s\",\n\t\t\t\t\t proc_info_root_name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_proc_info_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "444-461",
    "snippet": "int reiserfs_proc_info_done(struct super_block *sb)\n{\n\tstruct proc_dir_entry *de = REISERFS_SB(sb)->procdir;\n\tif (de) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tchar *s;\n\n\t\t/* Some block devices use /'s */\n\t\tstrlcpy(b, sb->s_id, BDEVNAME_SIZE);\n\t\ts = strchr(b, '/');\n\t\tif (s)\n\t\t\t*s = '!';\n\n\t\tremove_proc_subtree(b, proc_info_root);\n\t\tREISERFS_SB(sb)->procdir = NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_info_root = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_subtree",
          "args": [
            "b",
            "proc_info_root"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "557-601",
          "snippet": "int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nint remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "b",
            "'/'"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "b",
            "sb->s_id",
            "BDEVNAME_SIZE"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_info_root = NULL;\n\nint reiserfs_proc_info_done(struct super_block *sb)\n{\n\tstruct proc_dir_entry *de = REISERFS_SB(sb)->procdir;\n\tif (de) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tchar *s;\n\n\t\t/* Some block devices use /'s */\n\t\tstrlcpy(b, sb->s_id, BDEVNAME_SIZE);\n\t\ts = strchr(b, '/');\n\t\tif (s)\n\t\t\t*s = '!';\n\n\t\tremove_proc_subtree(b, proc_info_root);\n\t\tREISERFS_SB(sb)->procdir = NULL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_proc_info_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "416-442",
    "snippet": "int reiserfs_proc_info_init(struct super_block *sb)\n{\n\tchar b[BDEVNAME_SIZE];\n\tchar *s;\n\n\t/* Some block devices use /'s */\n\tstrlcpy(b, sb->s_id, BDEVNAME_SIZE);\n\ts = strchr(b, '/');\n\tif (s)\n\t\t*s = '!';\n\n\tspin_lock_init(&__PINFO(sb).lock);\n\tREISERFS_SB(sb)->procdir = proc_mkdir_data(b, 0, proc_info_root, sb);\n\tif (REISERFS_SB(sb)->procdir) {\n\t\tadd_file(sb, \"version\", show_version);\n\t\tadd_file(sb, \"super\", show_super);\n\t\tadd_file(sb, \"per-level\", show_per_level);\n\t\tadd_file(sb, \"bitmap\", show_bitmap);\n\t\tadd_file(sb, \"on-disk-super\", show_on_disk_super);\n\t\tadd_file(sb, \"oidmap\", show_oidmap);\n\t\tadd_file(sb, \"journal\", show_journal);\n\t\treturn 0;\n\t}\n\treiserfs_warning(sb, \"cannot create /proc/%s/%s\",\n\t\t\t proc_info_root_name, b);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_info_root = NULL;",
      "static const char proc_info_root_name[] = \"fs/reiserfs\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"cannot create /proc/%s/%s\"",
            "proc_info_root_name",
            "b"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_file",
          "args": [
            "sb",
            "\"journal\"",
            "show_journal"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
          "lines": "409-414",
          "snippet": "static void add_file(struct super_block *sb, char *name,\n\t\t     int (*func) (struct seq_file *, void *))\n{\n\tproc_create_data(name, 0, REISERFS_SB(sb)->procdir,\n\t\t\t &r_file_operations, func);\n}",
          "includes": [
            "#include <linux/proc_fs.h>",
            "#include <linux/init.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations r_file_operations = {\n\t.open = r_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct file_operations r_file_operations = {\n\t.open = r_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void add_file(struct super_block *sb, char *name,\n\t\t     int (*func) (struct seq_file *, void *))\n{\n\tproc_create_data(name, 0, REISERFS_SB(sb)->procdir,\n\t\t\t &r_file_operations, func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir_data",
          "args": [
            "b",
            "0",
            "proc_info_root",
            "sb"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "420-441",
          "snippet": "struct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, void *data)\n{\n\tstruct proc_dir_entry *ent;\n\n\tif (mode == 0)\n\t\tmode = S_IRUGO | S_IXUGO;\n\n\tent = __proc_create(&parent, name, S_IFDIR | mode, 2);\n\tif (ent) {\n\t\tent->data = data;\n\t\tent->proc_fops = &proc_dir_operations;\n\t\tent->proc_iops = &proc_dir_inode_operations;\n\t\tparent->nlink++;\n\t\tif (proc_register(parent, ent) < 0) {\n\t\t\tkfree(ent);\n\t\t\tparent->nlink--;\n\t\t\tent = NULL;\n\t\t}\n\t}\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations proc_dir_operations = {\n\t.llseek\t\t\t= generic_file_llseek,\n\t.read\t\t\t= generic_read_dir,\n\t.iterate\t\t= proc_readdir,\n};",
            "static const struct inode_operations proc_dir_inode_operations = {\n\t.lookup\t\t= proc_lookup,\n\t.getattr\t= proc_getattr,\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct file_operations proc_dir_operations = {\n\t.llseek\t\t\t= generic_file_llseek,\n\t.read\t\t\t= generic_read_dir,\n\t.iterate\t\t= proc_readdir,\n};\nstatic const struct inode_operations proc_dir_inode_operations = {\n\t.lookup\t\t= proc_lookup,\n\t.getattr\t= proc_getattr,\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, void *data)\n{\n\tstruct proc_dir_entry *ent;\n\n\tif (mode == 0)\n\t\tmode = S_IRUGO | S_IXUGO;\n\n\tent = __proc_create(&parent, name, S_IFDIR | mode, 2);\n\tif (ent) {\n\t\tent->data = data;\n\t\tent->proc_fops = &proc_dir_operations;\n\t\tent->proc_iops = &proc_dir_inode_operations;\n\t\tparent->nlink++;\n\t\tif (proc_register(parent, ent) < 0) {\n\t\t\tkfree(ent);\n\t\t\tparent->nlink--;\n\t\t\tent = NULL;\n\t\t}\n\t}\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&__PINFO(sb).lock"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PINFO",
          "args": [
            "sb"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "b",
            "'/'"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "b",
            "sb->s_id",
            "BDEVNAME_SIZE"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_info_root = NULL;\nstatic const char proc_info_root_name[] = \"fs/reiserfs\";\n\nint reiserfs_proc_info_init(struct super_block *sb)\n{\n\tchar b[BDEVNAME_SIZE];\n\tchar *s;\n\n\t/* Some block devices use /'s */\n\tstrlcpy(b, sb->s_id, BDEVNAME_SIZE);\n\ts = strchr(b, '/');\n\tif (s)\n\t\t*s = '!';\n\n\tspin_lock_init(&__PINFO(sb).lock);\n\tREISERFS_SB(sb)->procdir = proc_mkdir_data(b, 0, proc_info_root, sb);\n\tif (REISERFS_SB(sb)->procdir) {\n\t\tadd_file(sb, \"version\", show_version);\n\t\tadd_file(sb, \"super\", show_super);\n\t\tadd_file(sb, \"per-level\", show_per_level);\n\t\tadd_file(sb, \"bitmap\", show_bitmap);\n\t\tadd_file(sb, \"on-disk-super\", show_on_disk_super);\n\t\tadd_file(sb, \"oidmap\", show_oidmap);\n\t\tadd_file(sb, \"journal\", show_journal);\n\t\treturn 0;\n\t}\n\treiserfs_warning(sb, \"cannot create /proc/%s/%s\",\n\t\t\t proc_info_root_name, b);\n\treturn 1;\n}"
  },
  {
    "function_name": "add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "409-414",
    "snippet": "static void add_file(struct super_block *sb, char *name,\n\t\t     int (*func) (struct seq_file *, void *))\n{\n\tproc_create_data(name, 0, REISERFS_SB(sb)->procdir,\n\t\t\t &r_file_operations, func);\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations r_file_operations = {\n\t.open = r_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "name",
            "0",
            "REISERFS_SB(sb)->procdir",
            "&r_file_operations",
            "func"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct file_operations r_file_operations = {\n\t.open = r_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void add_file(struct super_block *sb, char *name,\n\t\t     int (*func) (struct seq_file *, void *))\n{\n\tproc_create_data(name, 0, REISERFS_SB(sb)->procdir,\n\t\t\t &r_file_operations, func);\n}"
  },
  {
    "function_name": "r_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "393-397",
    "snippet": "static int r_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, PDE_DATA(inode), \n\t\t\t\tproc_get_parent_data(inode));\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "PDE_DATA(inode)",
            "proc_get_parent_data(inode)"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_get_parent_data",
          "args": [
            "inode"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "proc_get_parent_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "604-608",
          "snippet": "void *proc_get_parent_data(const struct inode *inode)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\treturn de->parent->data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nvoid *proc_get_parent_data(const struct inode *inode)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\treturn de->parent->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int r_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, PDE_DATA(inode), \n\t\t\t\tproc_get_parent_data(inode));\n}"
  },
  {
    "function_name": "show_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "300-391",
    "snippet": "static int show_journal(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = r->s_rs;\n\tstruct journal_params *jp = &rs->s_v1.s_journal;\n\tchar b[BDEVNAME_SIZE];\n\n\tseq_printf(m,\t\t/* on-disk fields */\n\t\t   \"jp_journal_1st_block: \\t%i\\n\"\n\t\t   \"jp_journal_dev: \\t%s[%x]\\n\"\n\t\t   \"jp_journal_size: \\t%i\\n\"\n\t\t   \"jp_journal_trans_max: \\t%i\\n\"\n\t\t   \"jp_journal_magic: \\t%i\\n\"\n\t\t   \"jp_journal_max_batch: \\t%i\\n\"\n\t\t   \"jp_journal_max_commit_age: \\t%i\\n\"\n\t\t   \"jp_journal_max_trans_age: \\t%i\\n\"\n\t\t   /* incore fields */\n\t\t   \"j_1st_reserved_block: \\t%i\\n\"\n\t\t   \"j_state: \\t%li\\n\"\n\t\t   \"j_trans_id: \\t%u\\n\"\n\t\t   \"j_mount_id: \\t%lu\\n\"\n\t\t   \"j_start: \\t%lu\\n\"\n\t\t   \"j_len: \\t%lu\\n\"\n\t\t   \"j_len_alloc: \\t%lu\\n\"\n\t\t   \"j_wcount: \\t%i\\n\"\n\t\t   \"j_bcount: \\t%lu\\n\"\n\t\t   \"j_first_unflushed_offset: \\t%lu\\n\"\n\t\t   \"j_last_flush_trans_id: \\t%u\\n\"\n\t\t   \"j_trans_start_time: \\t%li\\n\"\n\t\t   \"j_list_bitmap_index: \\t%i\\n\"\n\t\t   \"j_must_wait: \\t%i\\n\"\n\t\t   \"j_next_full_flush: \\t%i\\n\"\n\t\t   \"j_next_async_flush: \\t%i\\n\"\n\t\t   \"j_cnode_used: \\t%i\\n\" \"j_cnode_free: \\t%i\\n\" \"\\n\"\n\t\t   /* reiserfs_proc_info_data_t.journal fields */\n\t\t   \"in_journal: \\t%12lu\\n\"\n\t\t   \"in_journal_bitmap: \\t%12lu\\n\"\n\t\t   \"in_journal_reusable: \\t%12lu\\n\"\n\t\t   \"lock_journal: \\t%12lu\\n\"\n\t\t   \"lock_journal_wait: \\t%12lu\\n\"\n\t\t   \"journal_begin: \\t%12lu\\n\"\n\t\t   \"journal_relock_writers: \\t%12lu\\n\"\n\t\t   \"journal_relock_wcount: \\t%12lu\\n\"\n\t\t   \"mark_dirty: \\t%12lu\\n\"\n\t\t   \"mark_dirty_already: \\t%12lu\\n\"\n\t\t   \"mark_dirty_notjournal: \\t%12lu\\n\"\n\t\t   \"restore_prepared: \\t%12lu\\n\"\n\t\t   \"prepare: \\t%12lu\\n\"\n\t\t   \"prepare_retry: \\t%12lu\\n\",\n\t\t   DJP(jp_journal_1st_block),\n\t\t   bdevname(SB_JOURNAL(sb)->j_dev_bd, b),\n\t\t   DJP(jp_journal_dev),\n\t\t   DJP(jp_journal_size),\n\t\t   DJP(jp_journal_trans_max),\n\t\t   DJP(jp_journal_magic),\n\t\t   DJP(jp_journal_max_batch),\n\t\t   SB_JOURNAL(sb)->j_max_commit_age,\n\t\t   DJP(jp_journal_max_trans_age),\n\t\t   JF(j_1st_reserved_block),\n\t\t   JF(j_state),\n\t\t   JF(j_trans_id),\n\t\t   JF(j_mount_id),\n\t\t   JF(j_start),\n\t\t   JF(j_len),\n\t\t   JF(j_len_alloc),\n\t\t   atomic_read(&r->s_journal->j_wcount),\n\t\t   JF(j_bcount),\n\t\t   JF(j_first_unflushed_offset),\n\t\t   JF(j_last_flush_trans_id),\n\t\t   JF(j_trans_start_time),\n\t\t   JF(j_list_bitmap_index),\n\t\t   JF(j_must_wait),\n\t\t   JF(j_next_full_flush),\n\t\t   JF(j_next_async_flush),\n\t\t   JF(j_cnode_used),\n\t\t   JF(j_cnode_free),\n\t\t   SFPJ(in_journal),\n\t\t   SFPJ(in_journal_bitmap),\n\t\t   SFPJ(in_journal_reusable),\n\t\t   SFPJ(lock_journal),\n\t\t   SFPJ(lock_journal_wait),\n\t\t   SFPJ(journal_being),\n\t\t   SFPJ(journal_relock_writers),\n\t\t   SFPJ(journal_relock_wcount),\n\t\t   SFPJ(mark_dirty),\n\t\t   SFPJ(mark_dirty_already),\n\t\t   SFPJ(mark_dirty_notjournal),\n\t\t   SFPJ(restore_prepared), SFPJ(prepare), SFPJ(prepare_retry)\n\t    );\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "/* on-disk fields */\"jp_journal_1st_block: \\t%i\\n\"\n\t\t   \"jp_journal_dev: \\t%s[%x]\\n\"\n\t\t   \"jp_journal_size: \\t%i\\n\"\n\t\t   \"jp_journal_trans_max: \\t%i\\n\"\n\t\t   \"jp_journal_magic: \\t%i\\n\"\n\t\t   \"jp_journal_max_batch: \\t%i\\n\"\n\t\t   \"jp_journal_max_commit_age: \\t%i\\n\"\n\t\t   \"jp_journal_max_trans_age: \\t%i\\n\"\n\t\t   /* incore fields */\n\t\t   \"j_1st_reserved_block: \\t%i\\n\"\n\t\t   \"j_state: \\t%li\\n\"\n\t\t   \"j_trans_id: \\t%u\\n\"\n\t\t   \"j_mount_id: \\t%lu\\n\"\n\t\t   \"j_start: \\t%lu\\n\"\n\t\t   \"j_len: \\t%lu\\n\"\n\t\t   \"j_len_alloc: \\t%lu\\n\"\n\t\t   \"j_wcount: \\t%i\\n\"\n\t\t   \"j_bcount: \\t%lu\\n\"\n\t\t   \"j_first_unflushed_offset: \\t%lu\\n\"\n\t\t   \"j_last_flush_trans_id: \\t%u\\n\"\n\t\t   \"j_trans_start_time: \\t%li\\n\"\n\t\t   \"j_list_bitmap_index: \\t%i\\n\"\n\t\t   \"j_must_wait: \\t%i\\n\"\n\t\t   \"j_next_full_flush: \\t%i\\n\"\n\t\t   \"j_next_async_flush: \\t%i\\n\"\n\t\t   \"j_cnode_used: \\t%i\\n\" \"j_cnode_free: \\t%i\\n\" \"\\n\"\n\t\t   /* reiserfs_proc_info_data_t.journal fields */\n\t\t   \"in_journal: \\t%12lu\\n\"\n\t\t   \"in_journal_bitmap: \\t%12lu\\n\"\n\t\t   \"in_journal_reusable: \\t%12lu\\n\"\n\t\t   \"lock_journal: \\t%12lu\\n\"\n\t\t   \"lock_journal_wait: \\t%12lu\\n\"\n\t\t   \"journal_begin: \\t%12lu\\n\"\n\t\t   \"journal_relock_writers: \\t%12lu\\n\"\n\t\t   \"journal_relock_wcount: \\t%12lu\\n\"\n\t\t   \"mark_dirty: \\t%12lu\\n\"\n\t\t   \"mark_dirty_already: \\t%12lu\\n\"\n\t\t   \"mark_dirty_notjournal: \\t%12lu\\n\"\n\t\t   \"restore_prepared: \\t%12lu\\n\"\n\t\t   \"prepare: \\t%12lu\\n\"\n\t\t   \"prepare_retry: \\t%12lu\\n\"",
            "DJP(jp_journal_1st_block)",
            "bdevname(SB_JOURNAL(sb)->j_dev_bd, b)",
            "DJP(jp_journal_dev)",
            "DJP(jp_journal_size)",
            "DJP(jp_journal_trans_max)",
            "DJP(jp_journal_magic)",
            "DJP(jp_journal_max_batch)",
            "SB_JOURNAL(sb)->j_max_commit_age",
            "DJP(jp_journal_max_trans_age)",
            "JF(j_1st_reserved_block)",
            "JF(j_state)",
            "JF(j_trans_id)",
            "JF(j_mount_id)",
            "JF(j_start)",
            "JF(j_len)",
            "JF(j_len_alloc)",
            "atomic_read(&r->s_journal->j_wcount)",
            "JF(j_bcount)",
            "JF(j_first_unflushed_offset)",
            "JF(j_last_flush_trans_id)",
            "JF(j_trans_start_time)",
            "JF(j_list_bitmap_index)",
            "JF(j_must_wait)",
            "JF(j_next_full_flush)",
            "JF(j_next_async_flush)",
            "JF(j_cnode_used)",
            "JF(j_cnode_free)",
            "SFPJ(in_journal)",
            "SFPJ(in_journal_bitmap)",
            "SFPJ(in_journal_reusable)",
            "SFPJ(lock_journal)",
            "SFPJ(lock_journal_wait)",
            "SFPJ(journal_being)",
            "SFPJ(journal_relock_writers)",
            "SFPJ(journal_relock_wcount)",
            "SFPJ(mark_dirty)",
            "SFPJ(mark_dirty_already)",
            "SFPJ(mark_dirty_notjournal)",
            "SFPJ(restore_prepared)",
            "SFPJ(prepare)",
            "SFPJ(prepare_retry)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "prepare_retry"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "prepare"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "restore_prepared"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "mark_dirty_notjournal"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "mark_dirty_already"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "mark_dirty"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "journal_relock_wcount"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "journal_relock_writers"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "journal_being"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "lock_journal_wait"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "lock_journal"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "in_journal_reusable"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "in_journal_bitmap"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPJ",
          "args": [
            "in_journal"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JF",
          "args": [
            "j_cnode_free"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&r->s_journal->j_wcount"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_max_trans_age"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_max_batch"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_magic"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_trans_max"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_size"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_dev"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "SB_JOURNAL(sb)->j_dev_bd",
            "b"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJP",
          "args": [
            "jp_journal_1st_block"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_journal(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = r->s_rs;\n\tstruct journal_params *jp = &rs->s_v1.s_journal;\n\tchar b[BDEVNAME_SIZE];\n\n\tseq_printf(m,\t\t/* on-disk fields */\n\t\t   \"jp_journal_1st_block: \\t%i\\n\"\n\t\t   \"jp_journal_dev: \\t%s[%x]\\n\"\n\t\t   \"jp_journal_size: \\t%i\\n\"\n\t\t   \"jp_journal_trans_max: \\t%i\\n\"\n\t\t   \"jp_journal_magic: \\t%i\\n\"\n\t\t   \"jp_journal_max_batch: \\t%i\\n\"\n\t\t   \"jp_journal_max_commit_age: \\t%i\\n\"\n\t\t   \"jp_journal_max_trans_age: \\t%i\\n\"\n\t\t   /* incore fields */\n\t\t   \"j_1st_reserved_block: \\t%i\\n\"\n\t\t   \"j_state: \\t%li\\n\"\n\t\t   \"j_trans_id: \\t%u\\n\"\n\t\t   \"j_mount_id: \\t%lu\\n\"\n\t\t   \"j_start: \\t%lu\\n\"\n\t\t   \"j_len: \\t%lu\\n\"\n\t\t   \"j_len_alloc: \\t%lu\\n\"\n\t\t   \"j_wcount: \\t%i\\n\"\n\t\t   \"j_bcount: \\t%lu\\n\"\n\t\t   \"j_first_unflushed_offset: \\t%lu\\n\"\n\t\t   \"j_last_flush_trans_id: \\t%u\\n\"\n\t\t   \"j_trans_start_time: \\t%li\\n\"\n\t\t   \"j_list_bitmap_index: \\t%i\\n\"\n\t\t   \"j_must_wait: \\t%i\\n\"\n\t\t   \"j_next_full_flush: \\t%i\\n\"\n\t\t   \"j_next_async_flush: \\t%i\\n\"\n\t\t   \"j_cnode_used: \\t%i\\n\" \"j_cnode_free: \\t%i\\n\" \"\\n\"\n\t\t   /* reiserfs_proc_info_data_t.journal fields */\n\t\t   \"in_journal: \\t%12lu\\n\"\n\t\t   \"in_journal_bitmap: \\t%12lu\\n\"\n\t\t   \"in_journal_reusable: \\t%12lu\\n\"\n\t\t   \"lock_journal: \\t%12lu\\n\"\n\t\t   \"lock_journal_wait: \\t%12lu\\n\"\n\t\t   \"journal_begin: \\t%12lu\\n\"\n\t\t   \"journal_relock_writers: \\t%12lu\\n\"\n\t\t   \"journal_relock_wcount: \\t%12lu\\n\"\n\t\t   \"mark_dirty: \\t%12lu\\n\"\n\t\t   \"mark_dirty_already: \\t%12lu\\n\"\n\t\t   \"mark_dirty_notjournal: \\t%12lu\\n\"\n\t\t   \"restore_prepared: \\t%12lu\\n\"\n\t\t   \"prepare: \\t%12lu\\n\"\n\t\t   \"prepare_retry: \\t%12lu\\n\",\n\t\t   DJP(jp_journal_1st_block),\n\t\t   bdevname(SB_JOURNAL(sb)->j_dev_bd, b),\n\t\t   DJP(jp_journal_dev),\n\t\t   DJP(jp_journal_size),\n\t\t   DJP(jp_journal_trans_max),\n\t\t   DJP(jp_journal_magic),\n\t\t   DJP(jp_journal_max_batch),\n\t\t   SB_JOURNAL(sb)->j_max_commit_age,\n\t\t   DJP(jp_journal_max_trans_age),\n\t\t   JF(j_1st_reserved_block),\n\t\t   JF(j_state),\n\t\t   JF(j_trans_id),\n\t\t   JF(j_mount_id),\n\t\t   JF(j_start),\n\t\t   JF(j_len),\n\t\t   JF(j_len_alloc),\n\t\t   atomic_read(&r->s_journal->j_wcount),\n\t\t   JF(j_bcount),\n\t\t   JF(j_first_unflushed_offset),\n\t\t   JF(j_last_flush_trans_id),\n\t\t   JF(j_trans_start_time),\n\t\t   JF(j_list_bitmap_index),\n\t\t   JF(j_must_wait),\n\t\t   JF(j_next_full_flush),\n\t\t   JF(j_next_async_flush),\n\t\t   JF(j_cnode_used),\n\t\t   JF(j_cnode_free),\n\t\t   SFPJ(in_journal),\n\t\t   SFPJ(in_journal_bitmap),\n\t\t   SFPJ(in_journal_reusable),\n\t\t   SFPJ(lock_journal),\n\t\t   SFPJ(lock_journal_wait),\n\t\t   SFPJ(journal_being),\n\t\t   SFPJ(journal_relock_writers),\n\t\t   SFPJ(journal_relock_wcount),\n\t\t   SFPJ(mark_dirty),\n\t\t   SFPJ(mark_dirty_already),\n\t\t   SFPJ(mark_dirty_notjournal),\n\t\t   SFPJ(restore_prepared), SFPJ(prepare), SFPJ(prepare_retry)\n\t    );\n\treturn 0;\n}"
  },
  {
    "function_name": "show_oidmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "269-298",
    "snippet": "static int show_oidmap(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = sb_info->s_rs;\n\tunsigned int mapsize = le16_to_cpu(rs->s_v1.s_oid_cursize);\n\tunsigned long total_used = 0;\n\tint i;\n\n\tfor (i = 0; i < mapsize; ++i) {\n\t\t__u32 right;\n\n\t\tright = (i == mapsize - 1) ? MAX_KEY_OBJECTID : MAP(i + 1);\n\t\tseq_printf(m, \"%s: [ %x .. %x )\\n\",\n\t\t\t   (i & 1) ? \"free\" : \"used\", MAP(i), right);\n\t\tif (!(i & 1)) {\n\t\t\ttotal_used += right - MAP(i);\n\t\t}\n\t}\n#if defined( REISERFS_USE_OIDMAPF )\n\tif (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {\n\t\tloff_t size = file_inode(sb_info->oidmap.mapf)->i_size;\n\t\ttotal_used += size / sizeof(reiserfs_oidinterval_d_t);\n\t}\n#endif\n\tseq_printf(m, \"total: \\t%i [%i/%i] used: %lu [exact]\\n\",\n\t\t   mapsize,\n\t\t   mapsize, le16_to_cpu(rs->s_v1.s_oid_maxsize), total_used);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"total: \\t%i [%i/%i] used: %lu [exact]\\n\"",
            "mapsize",
            "mapsize",
            "le16_to_cpu(rs->s_v1.s_oid_maxsize)",
            "total_used"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rs->s_v1.s_oid_maxsize"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "sb_info->oidmap.mapf"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAP",
          "args": [
            "i"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_BMAP_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "83-87",
          "snippet": "static inline struct nilfs_inode_info *\nNILFS_BMAP_I(const struct nilfs_bmap *bmap)\n{\n\treturn container_of(bmap, struct nilfs_inode_info, i_bmap_data);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *\nNILFS_BMAP_I(const struct nilfs_bmap *bmap)\n{\n\treturn container_of(bmap, struct nilfs_inode_info, i_bmap_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_oidmap(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = sb_info->s_rs;\n\tunsigned int mapsize = le16_to_cpu(rs->s_v1.s_oid_cursize);\n\tunsigned long total_used = 0;\n\tint i;\n\n\tfor (i = 0; i < mapsize; ++i) {\n\t\t__u32 right;\n\n\t\tright = (i == mapsize - 1) ? MAX_KEY_OBJECTID : MAP(i + 1);\n\t\tseq_printf(m, \"%s: [ %x .. %x )\\n\",\n\t\t\t   (i & 1) ? \"free\" : \"used\", MAP(i), right);\n\t\tif (!(i & 1)) {\n\t\t\ttotal_used += right - MAP(i);\n\t\t}\n\t}\n#if defined( REISERFS_USE_OIDMAPF )\n\tif (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {\n\t\tloff_t size = file_inode(sb_info->oidmap.mapf)->i_size;\n\t\ttotal_used += size / sizeof(reiserfs_oidinterval_d_t);\n\t}\n#endif\n\tseq_printf(m, \"total: \\t%i [%i/%i] used: %lu [exact]\\n\",\n\t\t   mapsize,\n\t\t   mapsize, le16_to_cpu(rs->s_v1.s_oid_maxsize), total_used);\n\treturn 0;\n}"
  },
  {
    "function_name": "show_on_disk_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "225-267",
    "snippet": "static int show_on_disk_super(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = sb_info->s_rs;\n\tint hash_code = DFL(s_hash_function_code);\n\t__u32 flags = DJF(s_flags);\n\n\tseq_printf(m, \"block_count: \\t%i\\n\"\n\t\t   \"free_blocks: \\t%i\\n\"\n\t\t   \"root_block: \\t%i\\n\"\n\t\t   \"blocksize: \\t%i\\n\"\n\t\t   \"oid_maxsize: \\t%i\\n\"\n\t\t   \"oid_cursize: \\t%i\\n\"\n\t\t   \"umount_state: \\t%i\\n\"\n\t\t   \"magic: \\t%10.10s\\n\"\n\t\t   \"fs_state: \\t%i\\n\"\n\t\t   \"hash: \\t%s\\n\"\n\t\t   \"tree_height: \\t%i\\n\"\n\t\t   \"bmap_nr: \\t%i\\n\"\n\t\t   \"version: \\t%i\\n\"\n\t\t   \"flags: \\t%x[%s]\\n\"\n\t\t   \"reserved_for_journal: \\t%i\\n\",\n\t\t   DFL(s_block_count),\n\t\t   DFL(s_free_blocks),\n\t\t   DFL(s_root_block),\n\t\t   DF(s_blocksize),\n\t\t   DF(s_oid_maxsize),\n\t\t   DF(s_oid_cursize),\n\t\t   DF(s_umount_state),\n\t\t   rs->s_v1.s_magic,\n\t\t   DF(s_fs_state),\n\t\t   hash_code == TEA_HASH ? \"tea\" :\n\t\t   (hash_code == YURA_HASH) ? \"rupasov\" :\n\t\t   (hash_code == R5_HASH) ? \"r5\" :\n\t\t   (hash_code == UNSET_HASH) ? \"unset\" : \"unknown\",\n\t\t   DF(s_tree_height),\n\t\t   DF(s_bmap_nr),\n\t\t   DF(s_version), flags, (flags & reiserfs_attrs_cleared)\n\t\t   ? \"attrs_cleared\" : \"\", DF(s_reserved_for_journal));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"block_count: \\t%i\\n\"\n\t\t   \"free_blocks: \\t%i\\n\"\n\t\t   \"root_block: \\t%i\\n\"\n\t\t   \"blocksize: \\t%i\\n\"\n\t\t   \"oid_maxsize: \\t%i\\n\"\n\t\t   \"oid_cursize: \\t%i\\n\"\n\t\t   \"umount_state: \\t%i\\n\"\n\t\t   \"magic: \\t%10.10s\\n\"\n\t\t   \"fs_state: \\t%i\\n\"\n\t\t   \"hash: \\t%s\\n\"\n\t\t   \"tree_height: \\t%i\\n\"\n\t\t   \"bmap_nr: \\t%i\\n\"\n\t\t   \"version: \\t%i\\n\"\n\t\t   \"flags: \\t%x[%s]\\n\"\n\t\t   \"reserved_for_journal: \\t%i\\n\"",
            "DFL(s_block_count)",
            "DFL(s_free_blocks)",
            "DFL(s_root_block)",
            "DF(s_blocksize)",
            "DF(s_oid_maxsize)",
            "DF(s_oid_cursize)",
            "DF(s_umount_state)",
            "rs->s_v1.s_magic",
            "DF(s_fs_state)",
            "hash_code == TEA_HASH ? \"tea\" :\n\t\t   (hash_code == YURA_HASH) ? \"rupasov\" :\n\t\t   (hash_code == R5_HASH) ? \"r5\" :\n\t\t   (hash_code == UNSET_HASH) ? \"unset\" : \"unknown\"",
            "DF(s_tree_height)",
            "DF(s_bmap_nr)",
            "DF(s_version)",
            "flags",
            "(flags & reiserfs_attrs_cleared)\n\t\t   ? \"attrs_cleared\" : \"\"",
            "DF(s_reserved_for_journal)"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DF",
          "args": [
            "s_reserved_for_journal"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DFL",
          "args": [
            "s_root_block"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DFL",
          "args": [
            "s_free_blocks"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DFL",
          "args": [
            "s_block_count"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DJF",
          "args": [
            "s_flags"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DFL",
          "args": [
            "s_hash_function_code"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_on_disk_super(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\n\tstruct reiserfs_super_block *rs = sb_info->s_rs;\n\tint hash_code = DFL(s_hash_function_code);\n\t__u32 flags = DJF(s_flags);\n\n\tseq_printf(m, \"block_count: \\t%i\\n\"\n\t\t   \"free_blocks: \\t%i\\n\"\n\t\t   \"root_block: \\t%i\\n\"\n\t\t   \"blocksize: \\t%i\\n\"\n\t\t   \"oid_maxsize: \\t%i\\n\"\n\t\t   \"oid_cursize: \\t%i\\n\"\n\t\t   \"umount_state: \\t%i\\n\"\n\t\t   \"magic: \\t%10.10s\\n\"\n\t\t   \"fs_state: \\t%i\\n\"\n\t\t   \"hash: \\t%s\\n\"\n\t\t   \"tree_height: \\t%i\\n\"\n\t\t   \"bmap_nr: \\t%i\\n\"\n\t\t   \"version: \\t%i\\n\"\n\t\t   \"flags: \\t%x[%s]\\n\"\n\t\t   \"reserved_for_journal: \\t%i\\n\",\n\t\t   DFL(s_block_count),\n\t\t   DFL(s_free_blocks),\n\t\t   DFL(s_root_block),\n\t\t   DF(s_blocksize),\n\t\t   DF(s_oid_maxsize),\n\t\t   DF(s_oid_cursize),\n\t\t   DF(s_umount_state),\n\t\t   rs->s_v1.s_magic,\n\t\t   DF(s_fs_state),\n\t\t   hash_code == TEA_HASH ? \"tea\" :\n\t\t   (hash_code == YURA_HASH) ? \"rupasov\" :\n\t\t   (hash_code == R5_HASH) ? \"r5\" :\n\t\t   (hash_code == UNSET_HASH) ? \"unset\" : \"unknown\",\n\t\t   DF(s_tree_height),\n\t\t   DF(s_bmap_nr),\n\t\t   DF(s_version), flags, (flags & reiserfs_attrs_cleared)\n\t\t   ? \"attrs_cleared\" : \"\", DF(s_reserved_for_journal));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "192-223",
    "snippet": "static int show_bitmap(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\n\tseq_printf(m, \"free_block: %lu\\n\"\n\t\t   \"  scan_bitmap:\"\n\t\t   \"          wait\"\n\t\t   \"          bmap\"\n\t\t   \"         retry\"\n\t\t   \"        stolen\"\n\t\t   \"  journal_hint\"\n\t\t   \"journal_nohint\"\n\t\t   \"\\n\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \"\\n\",\n\t\t   SFP(free_block),\n\t\t   SFPF(call),\n\t\t   SFPF(wait),\n\t\t   SFPF(bmap),\n\t\t   SFPF(retry),\n\t\t   SFPF(stolen),\n\t\t   SFPF(in_journal_hint), SFPF(in_journal_nohint));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"free_block: %lu\\n\"\n\t\t   \"  scan_bitmap:\"\n\t\t   \"          wait\"\n\t\t   \"          bmap\"\n\t\t   \"         retry\"\n\t\t   \"        stolen\"\n\t\t   \"  journal_hint\"\n\t\t   \"journal_nohint\"\n\t\t   \"\\n\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \"\\n\"",
            "SFP(free_block)",
            "SFPF(call)",
            "SFPF(wait)",
            "SFPF(bmap)",
            "SFPF(retry)",
            "SFPF(stolen)",
            "SFPF(in_journal_hint)",
            "SFPF(in_journal_nohint)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "in_journal_nohint"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "in_journal_hint"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "stolen"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "retry"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "bmap"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "wait"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPF",
          "args": [
            "call"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "free_block"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_bitmap(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\n\tseq_printf(m, \"free_block: %lu\\n\"\n\t\t   \"  scan_bitmap:\"\n\t\t   \"          wait\"\n\t\t   \"          bmap\"\n\t\t   \"         retry\"\n\t\t   \"        stolen\"\n\t\t   \"  journal_hint\"\n\t\t   \"journal_nohint\"\n\t\t   \"\\n\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \" %14lu\"\n\t\t   \"\\n\",\n\t\t   SFP(free_block),\n\t\t   SFPF(call),\n\t\t   SFPF(wait),\n\t\t   SFPF(bmap),\n\t\t   SFPF(retry),\n\t\t   SFPF(stolen),\n\t\t   SFPF(in_journal_hint), SFPF(in_journal_nohint));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_per_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "133-190",
    "snippet": "static int show_per_level(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\tint level;\n\n\tseq_printf(m, \"level\\t\"\n\t\t   \"     balances\"\n\t\t   \" [sbk:  reads\"\n\t\t   \"   fs_changed\"\n\t\t   \"   restarted]\"\n\t\t   \"   free space\"\n\t\t   \"        items\"\n\t\t   \"   can_remove\"\n\t\t   \"         lnum\"\n\t\t   \"         rnum\"\n\t\t   \"       lbytes\"\n\t\t   \"       rbytes\"\n\t\t   \"     get_neig\"\n\t\t   \" get_neig_res\" \"  need_l_neig\" \"  need_r_neig\" \"\\n\");\n\n\tfor (level = 0; level < MAX_HEIGHT; ++level) {\n\t\tseq_printf(m, \"%i\\t\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \"\\n\",\n\t\t\t   level,\n\t\t\t   SFPL(balance_at),\n\t\t\t   SFPL(sbk_read_at),\n\t\t\t   SFPL(sbk_fs_changed),\n\t\t\t   SFPL(sbk_restarted),\n\t\t\t   SFPL(free_at),\n\t\t\t   SFPL(items_at),\n\t\t\t   SFPL(can_node_be_removed),\n\t\t\t   SFPL(lnum),\n\t\t\t   SFPL(rnum),\n\t\t\t   SFPL(lbytes),\n\t\t\t   SFPL(rbytes),\n\t\t\t   SFPL(get_neighbors),\n\t\t\t   SFPL(get_neighbors_restart),\n\t\t\t   SFPL(need_l_neighbor), SFPL(need_r_neighbor)\n\t\t    );\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%i\\t\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \"\\n\"",
            "level",
            "SFPL(balance_at)",
            "SFPL(sbk_read_at)",
            "SFPL(sbk_fs_changed)",
            "SFPL(sbk_restarted)",
            "SFPL(free_at)",
            "SFPL(items_at)",
            "SFPL(can_node_be_removed)",
            "SFPL(lnum)",
            "SFPL(rnum)",
            "SFPL(lbytes)",
            "SFPL(rbytes)",
            "SFPL(get_neighbors)",
            "SFPL(get_neighbors_restart)",
            "SFPL(need_l_neighbor)",
            "SFPL(need_r_neighbor)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "need_r_neighbor"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "need_l_neighbor"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "get_neighbors_restart"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "get_neighbors"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "rbytes"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "lbytes"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "rnum"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "lnum"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "can_node_be_removed"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "items_at"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "free_at"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "sbk_restarted"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "sbk_fs_changed"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "sbk_read_at"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFPL",
          "args": [
            "balance_at"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_per_level(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\tint level;\n\n\tseq_printf(m, \"level\\t\"\n\t\t   \"     balances\"\n\t\t   \" [sbk:  reads\"\n\t\t   \"   fs_changed\"\n\t\t   \"   restarted]\"\n\t\t   \"   free space\"\n\t\t   \"        items\"\n\t\t   \"   can_remove\"\n\t\t   \"         lnum\"\n\t\t   \"         rnum\"\n\t\t   \"       lbytes\"\n\t\t   \"       rbytes\"\n\t\t   \"     get_neig\"\n\t\t   \" get_neig_res\" \"  need_l_neig\" \"  need_r_neig\" \"\\n\");\n\n\tfor (level = 0; level < MAX_HEIGHT; ++level) {\n\t\tseq_printf(m, \"%i\\t\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12li\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \" %12lu\"\n\t\t\t   \"\\n\",\n\t\t\t   level,\n\t\t\t   SFPL(balance_at),\n\t\t\t   SFPL(sbk_read_at),\n\t\t\t   SFPL(sbk_fs_changed),\n\t\t\t   SFPL(sbk_restarted),\n\t\t\t   SFPL(free_at),\n\t\t\t   SFPL(items_at),\n\t\t\t   SFPL(can_node_be_removed),\n\t\t\t   SFPL(lnum),\n\t\t\t   SFPL(rnum),\n\t\t\t   SFPL(lbytes),\n\t\t\t   SFPL(rbytes),\n\t\t\t   SFPL(get_neighbors),\n\t\t\t   SFPL(get_neighbors_restart),\n\t\t\t   SFPL(need_l_neighbor), SFPL(need_r_neighbor)\n\t\t    );\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "show_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "70-131",
    "snippet": "static int show_super(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\n\tseq_printf(m, \"state: \\t%s\\n\"\n\t\t   \"mount options: \\t%s%s%s%s%s%s%s%s%s%s%s\\n\"\n\t\t   \"gen. counter: \\t%i\\n\"\n\t\t   \"s_disk_reads: \\t%i\\n\"\n\t\t   \"s_disk_writes: \\t%i\\n\"\n\t\t   \"s_fix_nodes: \\t%i\\n\"\n\t\t   \"s_do_balance: \\t%i\\n\"\n\t\t   \"s_unneeded_left_neighbor: \\t%i\\n\"\n\t\t   \"s_good_search_by_key_reada: \\t%i\\n\"\n\t\t   \"s_bmaps: \\t%i\\n\"\n\t\t   \"s_bmaps_without_search: \\t%i\\n\"\n\t\t   \"s_direct2indirect: \\t%i\\n\"\n\t\t   \"s_indirect2direct: \\t%i\\n\"\n\t\t   \"\\n\"\n\t\t   \"max_hash_collisions: \\t%i\\n\"\n\t\t   \"breads: \\t%lu\\n\"\n\t\t   \"bread_misses: \\t%lu\\n\"\n\t\t   \"search_by_key: \\t%lu\\n\"\n\t\t   \"search_by_key_fs_changed: \\t%lu\\n\"\n\t\t   \"search_by_key_restarted: \\t%lu\\n\"\n\t\t   \"insert_item_restarted: \\t%lu\\n\"\n\t\t   \"paste_into_item_restarted: \\t%lu\\n\"\n\t\t   \"cut_from_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_solid_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_item_restarted: \\t%lu\\n\"\n\t\t   \"leaked_oid: \\t%lu\\n\"\n\t\t   \"leaves_removable: \\t%lu\\n\",\n\t\t   SF(s_mount_state) == REISERFS_VALID_FS ?\n\t\t   \"REISERFS_VALID_FS\" : \"REISERFS_ERROR_FS\",\n\t\t   reiserfs_r5_hash(sb) ? \"FORCE_R5 \" : \"\",\n\t\t   reiserfs_rupasov_hash(sb) ? \"FORCE_RUPASOV \" : \"\",\n\t\t   reiserfs_tea_hash(sb) ? \"FORCE_TEA \" : \"\",\n\t\t   reiserfs_hash_detect(sb) ? \"DETECT_HASH \" : \"\",\n\t\t   reiserfs_no_border(sb) ? \"NO_BORDER \" : \"BORDER \",\n\t\t   reiserfs_no_unhashed_relocation(sb) ?\n\t\t   \"NO_UNHASHED_RELOCATION \" : \"\",\n\t\t   reiserfs_hashed_relocation(sb) ? \"UNHASHED_RELOCATION \" : \"\",\n\t\t   reiserfs_test4(sb) ? \"TEST4 \" : \"\",\n\t\t   have_large_tails(sb) ? \"TAILS \" : have_small_tails(sb) ?\n\t\t   \"SMALL_TAILS \" : \"NO_TAILS \",\n\t\t   replay_only(sb) ? \"REPLAY_ONLY \" : \"\",\n\t\t   convert_reiserfs(sb) ? \"CONV \" : \"\",\n\t\t   atomic_read(&r->s_generation_counter),\n\t\t   SF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),\n\t\t   SF(s_do_balance), SF(s_unneeded_left_neighbor),\n\t\t   SF(s_good_search_by_key_reada), SF(s_bmaps),\n\t\t   SF(s_bmaps_without_search), SF(s_direct2indirect),\n\t\t   SF(s_indirect2direct), SFP(max_hash_collisions), SFP(breads),\n\t\t   SFP(bread_miss), SFP(search_by_key),\n\t\t   SFP(search_by_key_fs_changed), SFP(search_by_key_restarted),\n\t\t   SFP(insert_item_restarted), SFP(paste_into_item_restarted),\n\t\t   SFP(cut_from_item_restarted),\n\t\t   SFP(delete_solid_item_restarted), SFP(delete_item_restarted),\n\t\t   SFP(leaked_oid), SFP(leaves_removable));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"state: \\t%s\\n\"\n\t\t   \"mount options: \\t%s%s%s%s%s%s%s%s%s%s%s\\n\"\n\t\t   \"gen. counter: \\t%i\\n\"\n\t\t   \"s_disk_reads: \\t%i\\n\"\n\t\t   \"s_disk_writes: \\t%i\\n\"\n\t\t   \"s_fix_nodes: \\t%i\\n\"\n\t\t   \"s_do_balance: \\t%i\\n\"\n\t\t   \"s_unneeded_left_neighbor: \\t%i\\n\"\n\t\t   \"s_good_search_by_key_reada: \\t%i\\n\"\n\t\t   \"s_bmaps: \\t%i\\n\"\n\t\t   \"s_bmaps_without_search: \\t%i\\n\"\n\t\t   \"s_direct2indirect: \\t%i\\n\"\n\t\t   \"s_indirect2direct: \\t%i\\n\"\n\t\t   \"\\n\"\n\t\t   \"max_hash_collisions: \\t%i\\n\"\n\t\t   \"breads: \\t%lu\\n\"\n\t\t   \"bread_misses: \\t%lu\\n\"\n\t\t   \"search_by_key: \\t%lu\\n\"\n\t\t   \"search_by_key_fs_changed: \\t%lu\\n\"\n\t\t   \"search_by_key_restarted: \\t%lu\\n\"\n\t\t   \"insert_item_restarted: \\t%lu\\n\"\n\t\t   \"paste_into_item_restarted: \\t%lu\\n\"\n\t\t   \"cut_from_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_solid_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_item_restarted: \\t%lu\\n\"\n\t\t   \"leaked_oid: \\t%lu\\n\"\n\t\t   \"leaves_removable: \\t%lu\\n\"",
            "SF(s_mount_state) == REISERFS_VALID_FS ?\n\t\t   \"REISERFS_VALID_FS\" : \"REISERFS_ERROR_FS\"",
            "reiserfs_r5_hash(sb) ? \"FORCE_R5 \" : \"\"",
            "reiserfs_rupasov_hash(sb) ? \"FORCE_RUPASOV \" : \"\"",
            "reiserfs_tea_hash(sb) ? \"FORCE_TEA \" : \"\"",
            "reiserfs_hash_detect(sb) ? \"DETECT_HASH \" : \"\"",
            "reiserfs_no_border(sb) ? \"NO_BORDER \" : \"BORDER \"",
            "reiserfs_no_unhashed_relocation(sb) ?\n\t\t   \"NO_UNHASHED_RELOCATION \" : \"\"",
            "reiserfs_hashed_relocation(sb) ? \"UNHASHED_RELOCATION \" : \"\"",
            "reiserfs_test4(sb) ? \"TEST4 \" : \"\"",
            "have_large_tails(sb) ? \"TAILS \" : have_small_tails(sb) ?\n\t\t   \"SMALL_TAILS \" : \"NO_TAILS \"",
            "replay_only(sb) ? \"REPLAY_ONLY \" : \"\"",
            "convert_reiserfs(sb) ? \"CONV \" : \"\"",
            "atomic_read(&r->s_generation_counter)",
            "SF(s_disk_reads)",
            "SF(s_disk_writes)",
            "SF(s_fix_nodes)",
            "SF(s_do_balance)",
            "SF(s_unneeded_left_neighbor)",
            "SF(s_good_search_by_key_reada)",
            "SF(s_bmaps)",
            "SF(s_bmaps_without_search)",
            "SF(s_direct2indirect)",
            "SF(s_indirect2direct)",
            "SFP(max_hash_collisions)",
            "SFP(breads)",
            "SFP(bread_miss)",
            "SFP(search_by_key)",
            "SFP(search_by_key_fs_changed)",
            "SFP(search_by_key_restarted)",
            "SFP(insert_item_restarted)",
            "SFP(paste_into_item_restarted)",
            "SFP(cut_from_item_restarted)",
            "SFP(delete_solid_item_restarted)",
            "SFP(delete_item_restarted)",
            "SFP(leaked_oid)",
            "SFP(leaves_removable)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "leaves_removable"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "leaked_oid"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "delete_item_restarted"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "delete_solid_item_restarted"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "cut_from_item_restarted"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "paste_into_item_restarted"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "insert_item_restarted"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "search_by_key_restarted"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "search_by_key_fs_changed"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "search_by_key"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "bread_miss"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "breads"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SFP",
          "args": [
            "max_hash_collisions"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_indirect2direct"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_direct2indirect"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_bmaps_without_search"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_bmaps"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_good_search_by_key_reada"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_unneeded_left_neighbor"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_do_balance"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_fix_nodes"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_disk_writes"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_disk_reads"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&r->s_generation_counter"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_reiserfs",
          "args": [
            "sb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replay_only",
          "args": [
            "sb"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_small_tails",
          "args": [
            "sb"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_large_tails",
          "args": [
            "sb"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_test4",
          "args": [
            "sb"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_hashed_relocation",
          "args": [
            "sb"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_no_unhashed_relocation",
          "args": [
            "sb"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_no_border",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_hash_detect",
          "args": [
            "sb"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_tea_hash",
          "args": [
            "sb"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_rupasov_hash",
          "args": [
            "sb"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_r5_hash",
          "args": [
            "sb"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SF",
          "args": [
            "s_mount_state"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_super(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tstruct reiserfs_sb_info *r = REISERFS_SB(sb);\n\n\tseq_printf(m, \"state: \\t%s\\n\"\n\t\t   \"mount options: \\t%s%s%s%s%s%s%s%s%s%s%s\\n\"\n\t\t   \"gen. counter: \\t%i\\n\"\n\t\t   \"s_disk_reads: \\t%i\\n\"\n\t\t   \"s_disk_writes: \\t%i\\n\"\n\t\t   \"s_fix_nodes: \\t%i\\n\"\n\t\t   \"s_do_balance: \\t%i\\n\"\n\t\t   \"s_unneeded_left_neighbor: \\t%i\\n\"\n\t\t   \"s_good_search_by_key_reada: \\t%i\\n\"\n\t\t   \"s_bmaps: \\t%i\\n\"\n\t\t   \"s_bmaps_without_search: \\t%i\\n\"\n\t\t   \"s_direct2indirect: \\t%i\\n\"\n\t\t   \"s_indirect2direct: \\t%i\\n\"\n\t\t   \"\\n\"\n\t\t   \"max_hash_collisions: \\t%i\\n\"\n\t\t   \"breads: \\t%lu\\n\"\n\t\t   \"bread_misses: \\t%lu\\n\"\n\t\t   \"search_by_key: \\t%lu\\n\"\n\t\t   \"search_by_key_fs_changed: \\t%lu\\n\"\n\t\t   \"search_by_key_restarted: \\t%lu\\n\"\n\t\t   \"insert_item_restarted: \\t%lu\\n\"\n\t\t   \"paste_into_item_restarted: \\t%lu\\n\"\n\t\t   \"cut_from_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_solid_item_restarted: \\t%lu\\n\"\n\t\t   \"delete_item_restarted: \\t%lu\\n\"\n\t\t   \"leaked_oid: \\t%lu\\n\"\n\t\t   \"leaves_removable: \\t%lu\\n\",\n\t\t   SF(s_mount_state) == REISERFS_VALID_FS ?\n\t\t   \"REISERFS_VALID_FS\" : \"REISERFS_ERROR_FS\",\n\t\t   reiserfs_r5_hash(sb) ? \"FORCE_R5 \" : \"\",\n\t\t   reiserfs_rupasov_hash(sb) ? \"FORCE_RUPASOV \" : \"\",\n\t\t   reiserfs_tea_hash(sb) ? \"FORCE_TEA \" : \"\",\n\t\t   reiserfs_hash_detect(sb) ? \"DETECT_HASH \" : \"\",\n\t\t   reiserfs_no_border(sb) ? \"NO_BORDER \" : \"BORDER \",\n\t\t   reiserfs_no_unhashed_relocation(sb) ?\n\t\t   \"NO_UNHASHED_RELOCATION \" : \"\",\n\t\t   reiserfs_hashed_relocation(sb) ? \"UNHASHED_RELOCATION \" : \"\",\n\t\t   reiserfs_test4(sb) ? \"TEST4 \" : \"\",\n\t\t   have_large_tails(sb) ? \"TAILS \" : have_small_tails(sb) ?\n\t\t   \"SMALL_TAILS \" : \"NO_TAILS \",\n\t\t   replay_only(sb) ? \"REPLAY_ONLY \" : \"\",\n\t\t   convert_reiserfs(sb) ? \"CONV \" : \"\",\n\t\t   atomic_read(&r->s_generation_counter),\n\t\t   SF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),\n\t\t   SF(s_do_balance), SF(s_unneeded_left_neighbor),\n\t\t   SF(s_good_search_by_key_reada), SF(s_bmaps),\n\t\t   SF(s_bmaps_without_search), SF(s_direct2indirect),\n\t\t   SF(s_indirect2direct), SFP(max_hash_collisions), SFP(breads),\n\t\t   SFP(bread_miss), SFP(search_by_key),\n\t\t   SFP(search_by_key_fs_changed), SFP(search_by_key_restarted),\n\t\t   SFP(insert_item_restarted), SFP(paste_into_item_restarted),\n\t\t   SFP(cut_from_item_restarted),\n\t\t   SFP(delete_solid_item_restarted), SFP(delete_item_restarted),\n\t\t   SFP(leaked_oid), SFP(leaves_removable));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/procfs.c",
    "lines": "26-47",
    "snippet": "static int show_version(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tchar *format;\n\n\tif (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6)) {\n\t\tformat = \"3.6\";\n\t} else if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5)) {\n\t\tformat = \"3.5\";\n\t} else {\n\t\tformat = \"unknown\";\n\t}\n\n\tseq_printf(m, \"%s format\\twith checks %s\\n\", format,\n#if defined( CONFIG_REISERFS_CHECK )\n\t\t   \"on\"\n#else\n\t\t   \"off\"\n#endif\n\t    );\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include <linux/init.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s format\\twith checks %s\\n\"",
            "format",
            "#if defined(CONFIG_REISERFS_CHECK"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int show_version(struct seq_file *m, void *unused)\n{\n\tstruct super_block *sb = m->private;\n\tchar *format;\n\n\tif (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6)) {\n\t\tformat = \"3.6\";\n\t} else if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5)) {\n\t\tformat = \"3.5\";\n\t} else {\n\t\tformat = \"unknown\";\n\t}\n\n\tseq_printf(m, \"%s format\\twith checks %s\\n\", format,\n#if defined( CONFIG_REISERFS_CHECK )\n\t\t   \"on\"\n#else\n\t\t   \"off\"\n#endif\n\t    );\n\treturn 0;\n}"
  }
]