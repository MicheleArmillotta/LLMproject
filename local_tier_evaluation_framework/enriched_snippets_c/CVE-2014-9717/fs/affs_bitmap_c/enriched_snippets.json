[
  {
    "function_name": "affs_free_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
    "lines": "352-364",
    "snippet": "void affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_bitmap"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "sbi->s_bmap_bh"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}"
  },
  {
    "function_name": "affs_init_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
    "lines": "243-350",
    "snippet": "int affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & MS_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= MS_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= MS_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t/* Don't try read the extension if this is the last block,\n\t\t * but we also need the right bm pointer below\n\t\t */\n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t/* Mark unused bits in the last word as allocated */\n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t//if (old != new) {\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t/* fix checksum */\n\t\t\t//new -= old;\n\t\t\t//old = be32_to_cpu(*(__be32 *)bh->b_data);\n\t\t\t//*(__be32 *)bh->b_data = cpu_to_be32(old - new);\n\t\t\t//mark_buffer_dirty(bh);\n\t\t//}\n\t\t/* correct offset for the bitmap count below */\n\t\t//offset++;\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t/* recalculate bitmap count for last block */\n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bmap_bh"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memweight",
          "args": [
            "bh->b_data + 4",
            "sb->s_blocksize - 4"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "-affs_checksum_block(sb, bh)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_checksum_block",
          "args": [
            "sb",
            "bh"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "affs_checksum_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "335-346",
          "snippet": "u32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nu32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "((__be32 *)bh->b_data)[offset]"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"last word: %d %d %d\\n\"",
            "offset",
            "offset / 32 + 1",
            "mask"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot read bitmap extension\\n\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "be32_to_cpu(bmap_blk[blk])"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "bmap_blk[blk]"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memweight",
          "args": [
            "bh->b_data + 4",
            "sb->s_blocksize - 4"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"read bitmap block %d: %d\\n\"",
            "blk",
            "bm->bm_key"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Bitmap %u invalid - mounting %s read only.\\n\"",
            "bm->bm_key",
            "sb->s_id"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot read bitmap\\n\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "bmap_blk[blk]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Bitmap allocation failed\\n\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Bitmap invalid - mounting %s read only\\n\"",
            "sb->s_id"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_TAIL",
          "args": [
            "sb",
            "sbi->s_root_bh"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nint affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & MS_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= MS_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= MS_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t/* Don't try read the extension if this is the last block,\n\t\t * but we also need the right bm pointer below\n\t\t */\n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t/* Mark unused bits in the last word as allocated */\n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t//if (old != new) {\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t/* fix checksum */\n\t\t\t//new -= old;\n\t\t\t//old = be32_to_cpu(*(__be32 *)bh->b_data);\n\t\t\t//*(__be32 *)bh->b_data = cpu_to_be32(old - new);\n\t\t\t//mark_buffer_dirty(bh);\n\t\t//}\n\t\t/* correct offset for the bitmap count below */\n\t\t//offset++;\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t/* recalculate bitmap count for last block */\n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}"
  },
  {
    "function_name": "affs_alloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
    "lines": "113-241",
    "snippet": "u32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"failed\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_error",
          "args": [
            "sb",
            "\"affs_read_block\"",
            "\"Cannot read bitmap block %u\"",
            "bm->bm_key"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "affs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "442-456",
          "snippet": "void\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%d\\n\"",
            "blk"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "affs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "74-89",
          "snippet": "void affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp + mask"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)bh->b_data"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp & ~mask"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "tmp & mask"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "352-364",
          "snippet": "void affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*data"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*data"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "bm->bm_key"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"affs_balloc\"",
            "\"invalid goal %d\"",
            "goal"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%d\\n\"",
            "AFFS_I(inode)->i_lastalloc+1"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"balloc(inode=%lu,goal=%u): \"",
            "inode->i_ino",
            "goal"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
    "lines": "37-102",
    "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_error",
          "args": [
            "sb",
            "\"affs_free_block\"",
            "\"Block %u outside partition\"",
            "block"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "affs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "442-456",
          "snippet": "void\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"affs_free_block\"",
            "\"Trying to free block %u which is already free\"",
            "block"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "affs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "74-89",
          "snippet": "void affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp - mask"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)bh->b_data"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp | mask"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*data"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "bm->bm_key"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%u)\\n\"",
            "__func__",
            "block"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
  },
  {
    "function_name": "affs_count_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
    "lines": "13-35",
    "snippet": "u32\naffs_count_free_blocks(struct super_block *sb)\n{\n\tstruct affs_bm_info *bm;\n\tu32 free;\n\tint i;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tmutex_lock(&AFFS_SB(sb)->s_bmlock);\n\n\tbm = AFFS_SB(sb)->s_bitmap;\n\tfree = 0;\n\tfor (i = AFFS_SB(sb)->s_bmap_count; i > 0; bm++, i--)\n\t\tfree += bm->bm_free;\n\n\tmutex_unlock(&AFFS_SB(sb)->s_bmlock);\n\n\treturn free;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&AFFS_SB(sb)->s_bmlock"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&AFFS_SB(sb)->s_bmlock"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s()\\n\"",
            "__func__"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_count_free_blocks(struct super_block *sb)\n{\n\tstruct affs_bm_info *bm;\n\tu32 free;\n\tint i;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tmutex_lock(&AFFS_SB(sb)->s_bmlock);\n\n\tbm = AFFS_SB(sb)->s_bitmap;\n\tfree = 0;\n\tfor (i = AFFS_SB(sb)->s_bmap_count; i > 0; bm++, i--)\n\t\tfree += bm->bm_free;\n\n\tmutex_unlock(&AFFS_SB(sb)->s_bmlock);\n\n\treturn free;\n}"
  }
]