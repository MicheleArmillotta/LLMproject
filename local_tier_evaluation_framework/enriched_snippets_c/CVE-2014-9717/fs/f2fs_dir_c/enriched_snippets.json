[
  {
    "function_name": "f2fs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "746-788",
    "snippet": "static int f2fs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned long npages = dir_blocks(inode);\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tstruct page *dentry_page = NULL;\n\tstruct file_ra_state *ra = &file->f_ra;\n\tunsigned int n = ((unsigned long)ctx->pos / NR_DENTRY_IN_BLOCK);\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn f2fs_read_inline_dir(file, ctx);\n\n\t/* readahead for multi pages of dir */\n\tif (npages - n > 1 && !ra_has_index(ra, n))\n\t\tpage_cache_sync_readahead(inode->i_mapping, ra, file, n,\n\t\t\t\tmin(npages - n, (pgoff_t)MAX_DIR_RA_PAGES));\n\n\tfor (; n < npages; n++) {\n\t\tdentry_page = get_lock_data_page(inode, n);\n\t\tif (IS_ERR(dentry_page))\n\t\t\tcontinue;\n\n\t\tdentry_blk = kmap(dentry_page);\n\n\t\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\n\t\tif (f2fs_fill_dentries(ctx, &d, n * NR_DENTRY_IN_BLOCK))\n\t\t\tgoto stop;\n\n\t\tctx->pos = (n + 1) * NR_DENTRY_IN_BLOCK;\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t\tdentry_page = NULL;\n\t}\nstop:\n\tif (dentry_page && !IS_ERR(dentry_page)) {\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "dentry_page",
            "1"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dentry_page"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dentry_page"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_fill_dentries",
          "args": [
            "ctx",
            "&d",
            "n * NR_DENTRY_IN_BLOCK"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_fill_dentries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "716-744",
          "snippet": "bool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\t\t\t\tunsigned int start_pos)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->file_type < F2FS_FT_MAX)\n\t\t\td_type = f2fs_filetype_table[de->file_type];\n\t\telse\n\t\t\td_type = DT_UNKNOWN;\n\t\tif (!dir_emit(ctx, d->filename[bit_pos],\n\t\t\t\t\tle16_to_cpu(de->name_len),\n\t\t\t\t\tle32_to_cpu(de->ino), d_type))\n\t\t\treturn true;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tctx->pos = start_pos + bit_pos;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char f2fs_filetype_table[F2FS_FT_MAX] = {\n\t[F2FS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[F2FS_FT_REG_FILE]\t= DT_REG,\n\t[F2FS_FT_DIR]\t\t= DT_DIR,\n\t[F2FS_FT_CHRDEV]\t= DT_CHR,\n\t[F2FS_FT_BLKDEV]\t= DT_BLK,\n\t[F2FS_FT_FIFO]\t\t= DT_FIFO,\n\t[F2FS_FT_SOCK]\t\t= DT_SOCK,\n\t[F2FS_FT_SYMLINK]\t= DT_LNK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nunsigned char f2fs_filetype_table[F2FS_FT_MAX] = {\n\t[F2FS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[F2FS_FT_REG_FILE]\t= DT_REG,\n\t[F2FS_FT_DIR]\t\t= DT_DIR,\n\t[F2FS_FT_CHRDEV]\t= DT_CHR,\n\t[F2FS_FT_BLKDEV]\t= DT_BLK,\n\t[F2FS_FT_FIFO]\t\t= DT_FIFO,\n\t[F2FS_FT_SOCK]\t\t= DT_SOCK,\n\t[F2FS_FT_SYMLINK]\t= DT_LNK,\n};\n\nbool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\t\t\t\tunsigned int start_pos)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->file_type < F2FS_FT_MAX)\n\t\t\td_type = f2fs_filetype_table[de->file_type];\n\t\telse\n\t\t\td_type = DT_UNKNOWN;\n\t\tif (!dir_emit(ctx, d->filename[bit_pos],\n\t\t\t\t\tle16_to_cpu(de->name_len),\n\t\t\t\t\tle32_to_cpu(de->ino), d_type))\n\t\t\treturn true;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tctx->pos = start_pos + bit_pos;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_dentry_ptr",
          "args": [
            "&d",
            "(void *)dentry_blk",
            "1"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "make_dentry_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "238-254",
          "snippet": "static inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "dentry_page"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_data_page",
          "args": [
            "inode",
            "n"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "433-491",
          "snippet": "struct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "inode->i_mapping",
            "ra",
            "file",
            "n",
            "min(npages - n, (pgoff_t)MAX_DIR_RA_PAGES)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "npages - n",
            "(pgoff_t)MAX_DIR_RA_PAGES"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "244-251",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_has_index",
          "args": [
            "ra",
            "n"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_read_inline_dir",
          "args": [
            "file",
            "ctx"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_read_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "500-523",
          "snippet": "int f2fs_read_inline_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct f2fs_inline_dentry *inline_dentry = NULL;\n\tstruct page *ipage = NULL;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (ctx->pos == NR_INLINE_DENTRY)\n\t\treturn 0;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\n\tif (!f2fs_fill_dentries(ctx, &d, 0))\n\t\tctx->pos = NR_INLINE_DENTRY;\n\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_read_inline_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct f2fs_inline_dentry *inline_dentry = NULL;\n\tstruct page *ipage = NULL;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (ctx->pos == NR_INLINE_DENTRY)\n\t\treturn 0;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\n\tif (!f2fs_fill_dentries(ctx, &d, 0))\n\t\tctx->pos = NR_INLINE_DENTRY;\n\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "inode"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_blocks",
          "args": [
            "inode"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "dir_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "18-22",
          "snippet": "static unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned long npages = dir_blocks(inode);\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tstruct page *dentry_page = NULL;\n\tstruct file_ra_state *ra = &file->f_ra;\n\tunsigned int n = ((unsigned long)ctx->pos / NR_DENTRY_IN_BLOCK);\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn f2fs_read_inline_dir(file, ctx);\n\n\t/* readahead for multi pages of dir */\n\tif (npages - n > 1 && !ra_has_index(ra, n))\n\t\tpage_cache_sync_readahead(inode->i_mapping, ra, file, n,\n\t\t\t\tmin(npages - n, (pgoff_t)MAX_DIR_RA_PAGES));\n\n\tfor (; n < npages; n++) {\n\t\tdentry_page = get_lock_data_page(inode, n);\n\t\tif (IS_ERR(dentry_page))\n\t\t\tcontinue;\n\n\t\tdentry_blk = kmap(dentry_page);\n\n\t\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\n\t\tif (f2fs_fill_dentries(ctx, &d, n * NR_DENTRY_IN_BLOCK))\n\t\t\tgoto stop;\n\n\t\tctx->pos = (n + 1) * NR_DENTRY_IN_BLOCK;\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t\tdentry_page = NULL;\n\t}\nstop:\n\tif (dentry_page && !IS_ERR(dentry_page)) {\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_fill_dentries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "716-744",
    "snippet": "bool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\t\t\t\tunsigned int start_pos)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->file_type < F2FS_FT_MAX)\n\t\t\td_type = f2fs_filetype_table[de->file_type];\n\t\telse\n\t\t\td_type = DT_UNKNOWN;\n\t\tif (!dir_emit(ctx, d->filename[bit_pos],\n\t\t\t\t\tle16_to_cpu(de->name_len),\n\t\t\t\t\tle32_to_cpu(de->ino), d_type))\n\t\t\treturn true;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tctx->pos = start_pos + bit_pos;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned char f2fs_filetype_table[F2FS_FT_MAX] = {\n\t[F2FS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[F2FS_FT_REG_FILE]\t= DT_REG,\n\t[F2FS_FT_DIR]\t\t= DT_DIR,\n\t[F2FS_FT_CHRDEV]\t= DT_CHR,\n\t[F2FS_FT_BLKDEV]\t= DT_BLK,\n\t[F2FS_FT_FIFO]\t\t= DT_FIFO,\n\t[F2FS_FT_SOCK]\t\t= DT_SOCK,\n\t[F2FS_FT_SYMLINK]\t= DT_LNK,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "le16_to_cpu(de->name_len)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->name_len"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "d->filename[bit_pos]",
            "le16_to_cpu(de->name_len)",
            "le32_to_cpu(de->ino)",
            "d_type"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit_le",
          "args": [
            "d->bitmap",
            "d->max",
            "bit_pos"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nunsigned char f2fs_filetype_table[F2FS_FT_MAX] = {\n\t[F2FS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[F2FS_FT_REG_FILE]\t= DT_REG,\n\t[F2FS_FT_DIR]\t\t= DT_DIR,\n\t[F2FS_FT_CHRDEV]\t= DT_CHR,\n\t[F2FS_FT_BLKDEV]\t= DT_BLK,\n\t[F2FS_FT_FIFO]\t\t= DT_FIFO,\n\t[F2FS_FT_SOCK]\t\t= DT_SOCK,\n\t[F2FS_FT_SYMLINK]\t= DT_LNK,\n};\n\nbool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\t\t\t\tunsigned int start_pos)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->file_type < F2FS_FT_MAX)\n\t\t\td_type = f2fs_filetype_table[de->file_type];\n\t\telse\n\t\t\td_type = DT_UNKNOWN;\n\t\tif (!dir_emit(ctx, d->filename[bit_pos],\n\t\t\t\t\tle16_to_cpu(de->name_len),\n\t\t\t\t\tle32_to_cpu(de->ino), d_type))\n\t\t\treturn true;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tctx->pos = start_pos + bit_pos;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "f2fs_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "678-714",
    "snippet": "bool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\tfor (bidx = 0; bidx < nblock; bidx++) {\n\t\tdentry_page = get_lock_data_page(dir, bidx);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdentry_blk = kmap_atomic(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\t\tkunmap_atomic(dentry_blk);\n\n\t\tf2fs_put_page(dentry_page, 1);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "dentry_page",
            "1"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dentry_blk"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit_le",
          "args": [
            "&dentry_blk->dentry_bitmap",
            "NR_DENTRY_IN_BLOCK",
            "bit_pos"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dentry_page"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_data_page",
          "args": [
            "dir",
            "bidx"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "433-491",
          "snippet": "struct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_empty_inline_dir",
          "args": [
            "dir"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_empty_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "476-498",
          "snippet": "bool f2fs_empty_inline_dir(struct inode *dir)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos = 2;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn false;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\tNR_INLINE_DENTRY,\n\t\t\t\t\tbit_pos);\n\n\tf2fs_put_page(ipage, 1);\n\n\tif (bit_pos < NR_INLINE_DENTRY)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_empty_inline_dir(struct inode *dir)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos = 2;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn false;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\tNR_INLINE_DENTRY,\n\t\t\t\t\tbit_pos);\n\n\tf2fs_put_page(ipage, 1);\n\n\tif (bit_pos < NR_INLINE_DENTRY)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "dir"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_blocks",
          "args": [
            "dir"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "dir_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "18-22",
          "snippet": "static unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\tfor (bidx = 0; bidx < nblock; bidx++) {\n\t\tdentry_page = get_lock_data_page(dir, bidx);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdentry_blk = kmap_atomic(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\t\tkunmap_atomic(dentry_blk);\n\n\t\tf2fs_put_page(dentry_page, 1);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "f2fs_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "638-676",
    "snippet": "void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_dirty_pages",
          "args": [
            "dir"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dec_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "876-885",
          "snippet": "static inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_hole",
          "args": [
            "dir",
            "page->index",
            "page->index + 1"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "677-698",
          "snippet": "int truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_drop_nlink",
          "args": [
            "dir",
            "inode",
            "NULL"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "605-632",
          "snippet": "void f2fs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(dir);\n\t\tif (page)\n\t\t\tupdate_inode(dir, page);\n\t\telse\n\t\t\tupdate_inode_page(dir);\n\t}\n\tinode->i_ctime = CURRENT_TIME;\n\n\tdrop_nlink(inode);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(inode);\n\t\ti_size_write(inode, 0);\n\t}\n\tup_write(&F2FS_I(inode)->i_sem);\n\tupdate_inode_page(inode);\n\n\tif (inode->i_nlink == 0)\n\t\tadd_orphan_inode(sbi, inode->i_ino);\n\telse\n\t\trelease_orphan_inode(sbi);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(dir);\n\t\tif (page)\n\t\t\tupdate_inode(dir, page);\n\t\telse\n\t\t\tupdate_inode_page(dir);\n\t}\n\tinode->i_ctime = CURRENT_TIME;\n\n\tdrop_nlink(inode);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(inode);\n\t\ti_size_write(inode, 0);\n\t}\n\tup_write(&F2FS_I(inode)->i_sem);\n\tupdate_inode_page(inode);\n\n\tif (inode->i_nlink == 0)\n\t\tadd_orphan_inode(sbi, inode->i_ino);\n\telse\n\t\trelease_orphan_inode(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit_le",
          "args": [
            "&dentry_blk->dentry_bitmap",
            "NR_DENTRY_IN_BLOCK",
            "0"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_le",
          "args": [
            "bit_pos + i",
            "&dentry_blk->dentry_bitmap"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_delete_inline_entry",
          "args": [
            "dentry",
            "page",
            "dir",
            "inode"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_delete_inline_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "449-474",
          "snippet": "void f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tunsigned int bit_pos;\n\tint i;\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, NODE);\n\n\tinline_dentry = inline_data_addr(page);\n\tbit_pos = dentry - inline_dentry->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_clear_bit_le(bit_pos + i,\n\t\t\t\t&inline_dentry->dentry_bitmap);\n\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, page);\n\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tunsigned int bit_pos;\n\tint i;\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, NODE);\n\n\tinline_dentry = inline_data_addr(page);\n\tbit_pos = dentry - inline_dentry->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_clear_bit_le(bit_pos + i,\n\t\t\t\t&inline_dentry->dentry_bitmap);\n\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, page);\n\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "dir"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "le16_to_cpu(dentry->name_len)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dentry->name_len"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}"
  },
  {
    "function_name": "f2fs_drop_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "605-632",
    "snippet": "void f2fs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(dir);\n\t\tif (page)\n\t\t\tupdate_inode(dir, page);\n\t\telse\n\t\t\tupdate_inode_page(dir);\n\t}\n\tinode->i_ctime = CURRENT_TIME;\n\n\tdrop_nlink(inode);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(inode);\n\t\ti_size_write(inode, 0);\n\t}\n\tup_write(&F2FS_I(inode)->i_sem);\n\tupdate_inode_page(inode);\n\n\tif (inode->i_nlink == 0)\n\t\tadd_orphan_inode(sbi, inode->i_ino);\n\telse\n\t\trelease_orphan_inode(sbi);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_orphan_inode",
          "args": [
            "sbi"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "release_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "433-441",
          "snippet": "void release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_orphan_inode",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "add_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "443-447",
          "snippet": "void add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "dir",
            "page"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(dir);\n\t\tif (page)\n\t\t\tupdate_inode(dir, page);\n\t\telse\n\t\t\tupdate_inode_page(dir);\n\t}\n\tinode->i_ctime = CURRENT_TIME;\n\n\tdrop_nlink(inode);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(inode);\n\t\ti_size_write(inode, 0);\n\t}\n\tup_write(&F2FS_I(inode)->i_sem);\n\tupdate_inode_page(inode);\n\n\tif (inode->i_nlink == 0)\n\t\tadd_orphan_inode(sbi, inode->i_ino);\n\telse\n\t\trelease_orphan_inode(sbi);\n}"
  },
  {
    "function_name": "f2fs_do_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "584-603",
    "snippet": "int f2fs_do_tmpfile(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page;\n\tint err = 0;\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, NULL, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\t/* we don't need to mark_inode_dirty now */\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_NEW_INODE"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "inode",
            "page"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_inode_metadata",
          "args": [
            "inode",
            "dir",
            "NULL",
            "NULL"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "init_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "373-433",
          "snippet": "struct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_do_tmpfile(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page;\n\tint err = 0;\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, NULL, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\t/* we don't need to mark_inode_dirty now */\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "__f2fs_add_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "481-582",
    "snippet": "int __f2fs_add_link(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tunsigned int bit_pos;\n\tunsigned int level;\n\tunsigned int current_depth;\n\tunsigned long bidx, block;\n\tf2fs_hash_t dentry_hash;\n\tstruct f2fs_dir_entry *de;\n\tunsigned int nbucket, nblock;\n\tsize_t namelen = name->len;\n\tstruct page *dentry_page = NULL;\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir)) {\n\t\terr = f2fs_add_inline_entry(dir, name, inode);\n\t\tif (!err || err != -EAGAIN)\n\t\t\treturn err;\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\tdentry_hash = f2fs_dentry_hash(name);\n\tlevel = 0;\n\tcurrent_depth = F2FS_I(dir)->i_current_depth;\n\tif (F2FS_I(dir)->chash == dentry_hash) {\n\t\tlevel = F2FS_I(dir)->clevel;\n\t\tF2FS_I(dir)->chash = 0;\n\t}\n\nstart:\n\tif (unlikely(current_depth == MAX_DIR_HASH_DEPTH))\n\t\treturn -ENOSPC;\n\n\t/* Increase the depth, if required */\n\tif (level == current_depth)\n\t\t++current_depth;\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t(le32_to_cpu(dentry_hash) % nbucket));\n\n\tfor (block = bidx; block <= (bidx + nblock - 1); block++) {\n\t\tdentry_page = get_new_data_page(dir, NULL, block, true);\n\t\tif (IS_ERR(dentry_page))\n\t\t\treturn PTR_ERR(dentry_page);\n\n\t\tdentry_blk = kmap(dentry_page);\n\t\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_DENTRY_IN_BLOCK);\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\tgoto add_dentry;\n\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\t/* Move to next level to find the empty slot for new dentry */\n\t++level;\n\tgoto start;\nadd_dentry:\n\tf2fs_wait_on_page_writeback(dentry_page, DATA);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = dentry_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(dentry_page);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, current_depth);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode_page(dir);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\tkunmap(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "dentry_page",
            "1"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dentry_page"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(dir)",
            "FI_UPDATE_DIR"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dir"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "dir"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(dir)",
            "FI_UPDATE_DIR"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_parent_metadata",
          "args": [
            "dir",
            "inode",
            "current_depth"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "update_parent_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "435-455",
          "snippet": "void update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tinc_nlink(dir);\n\t\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t\t}\n\t\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\n\t}\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth) {\n\t\tF2FS_I(dir)->i_current_depth = current_depth;\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK))\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tinc_nlink(dir);\n\t\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t\t}\n\t\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\n\t}\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth) {\n\t\tF2FS_I(dir)->i_current_depth = current_depth;\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK))\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "inode",
            "page"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "dentry_page"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit_le",
          "args": [
            "bit_pos + i",
            "&dentry_blk->dentry_bitmap"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "62-66",
          "snippet": "void set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};\n\nvoid set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry_blk->filename[bit_pos]",
            "name->name",
            "name->len"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "namelen"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_inode_metadata",
          "args": [
            "inode",
            "dir",
            "name",
            "NULL"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "init_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "373-433",
          "snippet": "struct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "dentry_page",
            "DATA"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dentry_page"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "room_for_filename",
          "args": [
            "&dentry_blk->dentry_bitmap",
            "slots",
            "NR_DENTRY_IN_BLOCK"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "room_for_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "457-475",
          "snippet": "int room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "dentry_page"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_data_page",
          "args": [
            "dir",
            "NULL",
            "block",
            "true"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "501-559",
          "snippet": "struct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_block_index",
          "args": [
            "level",
            "F2FS_I(dir)->i_dir_level",
            "(le32_to_cpu(dentry_hash) % nbucket)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "dir_block_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "68-78",
          "snippet": "static unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dentry_hash"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blocks",
          "args": [
            "level"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "32-38",
          "snippet": "static unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_buckets",
          "args": [
            "level",
            "F2FS_I(dir)->i_dir_level"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "dir_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "24-30",
          "snippet": "static unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current_depth == MAX_DIR_HASH_DEPTH"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_hash",
          "args": [
            "name"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/hash.c",
          "lines": "73-104",
          "snippet": "f2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/cryptohash.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/pagemap.h>\n#include <linux/cryptohash.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nf2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_inline_entry",
          "args": [
            "dir",
            "name",
            "inode"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_inline_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "382-447",
          "snippet": "int f2fs_add_inline_entry(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos;\n\tf2fs_hash_t name_hash;\n\tstruct f2fs_dir_entry *de;\n\tsize_t namelen = name->len;\n\tstruct f2fs_inline_dentry *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tname_hash = f2fs_dentry_hash(name);\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_INLINE_DENTRY);\n\tif (bit_pos >= NR_INLINE_DENTRY) {\n\t\terr = f2fs_convert_inline_dir(dir, ipage, dentry_blk);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, ipage);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = name_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(ipage);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, 0);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode(dir, ipage);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\nout:\n\tf2fs_put_page(ipage, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_add_inline_entry(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos;\n\tf2fs_hash_t name_hash;\n\tstruct f2fs_dir_entry *de;\n\tsize_t namelen = name->len;\n\tstruct f2fs_inline_dentry *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tname_hash = f2fs_dentry_hash(name);\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_INLINE_DENTRY);\n\tif (bit_pos >= NR_INLINE_DENTRY) {\n\t\terr = f2fs_convert_inline_dir(dir, ipage, dentry_blk);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, ipage);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = name_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(ipage);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, 0);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode(dir, ipage);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\nout:\n\tf2fs_put_page(ipage, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "dir"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "namelen"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint __f2fs_add_link(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tunsigned int bit_pos;\n\tunsigned int level;\n\tunsigned int current_depth;\n\tunsigned long bidx, block;\n\tf2fs_hash_t dentry_hash;\n\tstruct f2fs_dir_entry *de;\n\tunsigned int nbucket, nblock;\n\tsize_t namelen = name->len;\n\tstruct page *dentry_page = NULL;\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir)) {\n\t\terr = f2fs_add_inline_entry(dir, name, inode);\n\t\tif (!err || err != -EAGAIN)\n\t\t\treturn err;\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\tdentry_hash = f2fs_dentry_hash(name);\n\tlevel = 0;\n\tcurrent_depth = F2FS_I(dir)->i_current_depth;\n\tif (F2FS_I(dir)->chash == dentry_hash) {\n\t\tlevel = F2FS_I(dir)->clevel;\n\t\tF2FS_I(dir)->chash = 0;\n\t}\n\nstart:\n\tif (unlikely(current_depth == MAX_DIR_HASH_DEPTH))\n\t\treturn -ENOSPC;\n\n\t/* Increase the depth, if required */\n\tif (level == current_depth)\n\t\t++current_depth;\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t(le32_to_cpu(dentry_hash) % nbucket));\n\n\tfor (block = bidx; block <= (bidx + nblock - 1); block++) {\n\t\tdentry_page = get_new_data_page(dir, NULL, block, true);\n\t\tif (IS_ERR(dentry_page))\n\t\t\treturn PTR_ERR(dentry_page);\n\n\t\tdentry_blk = kmap(dentry_page);\n\t\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_DENTRY_IN_BLOCK);\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\tgoto add_dentry;\n\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\t/* Move to next level to find the empty slot for new dentry */\n\t++level;\n\tgoto start;\nadd_dentry:\n\tf2fs_wait_on_page_writeback(dentry_page, DATA);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = dentry_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(dentry_page);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, current_depth);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode_page(dir);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\tkunmap(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "room_for_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "457-475",
    "snippet": "int room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit_le",
          "args": [
            "bitmap",
            "max_slots",
            "zero_start"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit_le",
          "args": [
            "bitmap",
            "max_slots",
            "bit_start"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}"
  },
  {
    "function_name": "update_parent_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "435-455",
    "snippet": "void update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tinc_nlink(dir);\n\t\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t\t}\n\t\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\n\t}\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth) {\n\t\tF2FS_I(dir)->i_current_depth = current_depth;\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK))\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(dir)",
            "FI_UPDATE_DIR"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tinc_nlink(dir);\n\t\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t\t}\n\t\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\n\t}\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth) {\n\t\tF2FS_I(dir)->i_current_depth = current_depth;\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK))\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n}"
  },
  {
    "function_name": "init_inode_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "373-433",
    "snippet": "struct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_inode_page",
          "args": [
            "inode"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "remove_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "890-914",
          "snippet": "void remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dirty_dir_inode",
          "args": [
            "inode"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "remove_dirty_dir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "741-769",
          "snippet": "void remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_blocks",
          "args": [
            "inode",
            "0",
            "false"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "482-540",
          "snippet": "int truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&inode->i_data",
            "0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_orphan_inode",
          "args": [
            "F2FS_I_SB(dir)",
            "inode->i_ino"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "remove_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "449-453",
          "snippet": "void remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* remove orphan entry from orphan list */\n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* remove orphan entry from orphan list */\n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_lost_pino",
          "args": [
            "inode"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dent_inode",
          "args": [
            "name",
            "page"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "init_dent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "297-308",
          "snippet": "static void init_dent_inode(const struct qstr *name, struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t/* copy name info. to this inode page */\n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(name->len);\n\tmemcpy(ri->i_name, name->name, name->len);\n\tset_page_dirty(ipage);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_dent_inode(const struct qstr *name, struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t/* copy name info. to this inode page */\n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(name->len);\n\tmemcpy(ri->i_name, name->name, name->len);\n\tset_page_dirty(ipage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cold_node",
          "args": [
            "inode",
            "page"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "set_cold_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "392-402",
          "snippet": "static inline void set_cold_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int flag = le32_to_cpu(rn->footer.flag);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflag &= ~(0x1 << COLD_BIT_SHIFT);\n\telse\n\t\tflag |= (0x1 << COLD_BIT_SHIFT);\n\trn->footer.flag = cpu_to_le32(flag);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_cold_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int flag = le32_to_cpu(rn->footer.flag);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflag &= ~(0x1 << COLD_BIT_SHIFT);\n\telse\n\t\tflag |= (0x1 << COLD_BIT_SHIFT);\n\trn->footer.flag = cpu_to_le32(flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(dir)",
            "inode->i_ino"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_init_security",
          "args": [
            "inode",
            "dir",
            "name",
            "page"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.h",
          "lines": "146-150",
          "snippet": "static inline int f2fs_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr, struct page *ipage)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline int f2fs_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr, struct page *ipage)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_init_acl",
          "args": [
            "inode",
            "dir",
            "page",
            "dpage"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "383-406",
          "snippet": "int f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error = 0;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nint f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error = 0;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_empty_dir",
          "args": [
            "inode",
            "dir",
            "page"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "347-371",
          "snippet": "static int make_empty_dir(struct inode *inode,\n\t\tstruct inode *parent, struct page *page)\n{\n\tstruct page *dentry_page;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn make_empty_inline_dir(inode, parent, page);\n\n\tdentry_page = get_new_data_page(inode, page, 0, true);\n\tif (IS_ERR(dentry_page))\n\t\treturn PTR_ERR(dentry_page);\n\n\tdentry_blk = kmap_atomic(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tkunmap_atomic(dentry_blk);\n\n\tset_page_dirty(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int make_empty_dir(struct inode *inode,\n\t\tstruct inode *parent, struct page *page)\n{\n\tstruct page *dentry_page;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn make_empty_inline_dir(inode, parent, page);\n\n\tdentry_page = get_new_data_page(inode, page, 0, true);\n\tif (IS_ERR(dentry_page))\n\t\treturn PTR_ERR(dentry_page);\n\n\tdentry_blk = kmap_atomic(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tkunmap_atomic(dentry_blk);\n\n\tset_page_dirty(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode_page",
          "args": [
            "inode"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "916-925",
          "snippet": "struct page *new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t/* allocate inode page for new inode */\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t/* caller should f2fs_put_page(page, 1); */\n\treturn new_node_page(&dn, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t/* allocate inode page for new inode */\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t/* caller should f2fs_put_page(page, 1); */\n\treturn new_node_page(&dn, 0, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "make_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "347-371",
    "snippet": "static int make_empty_dir(struct inode *inode,\n\t\tstruct inode *parent, struct page *page)\n{\n\tstruct page *dentry_page;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn make_empty_inline_dir(inode, parent, page);\n\n\tdentry_page = get_new_data_page(inode, page, 0, true);\n\tif (IS_ERR(dentry_page))\n\t\treturn PTR_ERR(dentry_page);\n\n\tdentry_blk = kmap_atomic(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tkunmap_atomic(dentry_blk);\n\n\tset_page_dirty(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "dentry_page",
            "1"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "dentry_page"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dentry_blk"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_make_empty_dir",
          "args": [
            "inode",
            "parent",
            "&d"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "do_make_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "324-345",
          "snippet": "void do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\n\tde = &d->dentry[0];\n\tde->name_len = cpu_to_le16(1);\n\tde->hash_code = 0;\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tmemcpy(d->filename[0], \".\", 1);\n\tset_de_type(de, inode);\n\n\tde = &d->dentry[1];\n\tde->hash_code = 0;\n\tde->name_len = cpu_to_le16(2);\n\tde->ino = cpu_to_le32(parent->i_ino);\n\tmemcpy(d->filename[1], \"..\", 2);\n\tset_de_type(de, inode);\n\n\ttest_and_set_bit_le(0, (void *)d->bitmap);\n\ttest_and_set_bit_le(1, (void *)d->bitmap);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\n\tde = &d->dentry[0];\n\tde->name_len = cpu_to_le16(1);\n\tde->hash_code = 0;\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tmemcpy(d->filename[0], \".\", 1);\n\tset_de_type(de, inode);\n\n\tde = &d->dentry[1];\n\tde->hash_code = 0;\n\tde->name_len = cpu_to_le16(2);\n\tde->ino = cpu_to_le32(parent->i_ino);\n\tmemcpy(d->filename[1], \"..\", 2);\n\tset_de_type(de, inode);\n\n\ttest_and_set_bit_le(0, (void *)d->bitmap);\n\ttest_and_set_bit_le(1, (void *)d->bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_dentry_ptr",
          "args": [
            "&d",
            "(void *)dentry_blk",
            "1"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "make_dentry_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "238-254",
          "snippet": "static inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dentry_page"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_data_page",
          "args": [
            "inode",
            "page",
            "0",
            "true"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "501-559",
          "snippet": "struct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_empty_inline_dir",
          "args": [
            "inode",
            "parent",
            "page"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "310-329",
          "snippet": "int make_empty_inline_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\t\t\tstruct page *ipage)\n{\n\tstruct f2fs_inline_dentry *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 2);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tset_page_dirty(ipage);\n\n\t/* update i_size to MAX_INLINE_DATA */\n\tif (i_size_read(inode) < MAX_INLINE_DATA) {\n\t\ti_size_write(inode, MAX_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint make_empty_inline_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\t\t\tstruct page *ipage)\n{\n\tstruct f2fs_inline_dentry *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 2);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tset_page_dirty(ipage);\n\n\t/* update i_size to MAX_INLINE_DATA */\n\tif (i_size_read(inode) < MAX_INLINE_DATA) {\n\t\ti_size_write(inode, MAX_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int make_empty_dir(struct inode *inode,\n\t\tstruct inode *parent, struct page *page)\n{\n\tstruct page *dentry_page;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn make_empty_inline_dir(inode, parent, page);\n\n\tdentry_page = get_new_data_page(inode, page, 0, true);\n\tif (IS_ERR(dentry_page))\n\t\treturn PTR_ERR(dentry_page);\n\n\tdentry_blk = kmap_atomic(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tkunmap_atomic(dentry_blk);\n\n\tset_page_dirty(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_make_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "324-345",
    "snippet": "void do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\n\tde = &d->dentry[0];\n\tde->name_len = cpu_to_le16(1);\n\tde->hash_code = 0;\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tmemcpy(d->filename[0], \".\", 1);\n\tset_de_type(de, inode);\n\n\tde = &d->dentry[1];\n\tde->hash_code = 0;\n\tde->name_len = cpu_to_le16(2);\n\tde->ino = cpu_to_le32(parent->i_ino);\n\tmemcpy(d->filename[1], \"..\", 2);\n\tset_de_type(de, inode);\n\n\ttest_and_set_bit_le(0, (void *)d->bitmap);\n\ttest_and_set_bit_le(1, (void *)d->bitmap);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_set_bit_le",
          "args": [
            "1",
            "(void *)d->bitmap"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit_le",
          "args": [
            "0",
            "(void *)d->bitmap"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "62-66",
          "snippet": "void set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};\n\nvoid set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "d->filename[1]",
            "\"..\"",
            "2"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "parent->i_ino"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "d->filename[0]",
            "\".\"",
            "1"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\n\tde = &d->dentry[0];\n\tde->name_len = cpu_to_le16(1);\n\tde->hash_code = 0;\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tmemcpy(d->filename[0], \".\", 1);\n\tset_de_type(de, inode);\n\n\tde = &d->dentry[1];\n\tde->hash_code = 0;\n\tde->name_len = cpu_to_le16(2);\n\tde->ino = cpu_to_le32(parent->i_ino);\n\tmemcpy(d->filename[1], \"..\", 2);\n\tset_de_type(de, inode);\n\n\ttest_and_set_bit_le(0, (void *)d->bitmap);\n\ttest_and_set_bit_le(1, (void *)d->bitmap);\n}"
  },
  {
    "function_name": "update_dent_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "310-322",
    "snippet": "int update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dent_inode",
          "args": [
            "name",
            "page"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "init_dent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "297-308",
          "snippet": "static void init_dent_inode(const struct qstr *name, struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t/* copy name info. to this inode page */\n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(name->len);\n\tmemcpy(ri->i_name, name->name, name->len);\n\tset_page_dirty(ipage);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_dent_inode(const struct qstr *name, struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t/* copy name info. to this inode page */\n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(name->len);\n\tmemcpy(ri->i_name, name->name, name->len);\n\tset_page_dirty(ipage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(inode)",
            "inode->i_ino"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_dent_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "297-308",
    "snippet": "static void init_dent_inode(const struct qstr *name, struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t/* copy name info. to this inode page */\n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(name->len);\n\tmemcpy(ri->i_name, name->name, name->len);\n\tset_page_dirty(ipage);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "ipage"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ri->i_name",
            "name->name",
            "name->len"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "name->len"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_INODE",
          "args": [
            "ipage"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "ipage",
            "NODE"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void init_dent_inode(const struct qstr *name, struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t/* copy name info. to this inode page */\n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(name->len);\n\tmemcpy(ri->i_name, name->name, name->len);\n\tset_page_dirty(ipage);\n}"
  },
  {
    "function_name": "f2fs_set_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "281-295",
    "snippet": "void f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tf2fs_dentry_kunmap(dir, page);\n\tset_page_dirty(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tf2fs_put_page(page, 1);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "dir",
            "page"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "62-66",
          "snippet": "void set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};\n\nvoid set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "type"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "dir"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tf2fs_dentry_kunmap(dir, page);\n\tset_page_dirty(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tf2fs_put_page(page, 1);\n}"
  },
  {
    "function_name": "f2fs_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "265-279",
    "snippet": "ino_t f2fs_inode_by_name(struct inode *dir, struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\n\tde = f2fs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->ino);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "dir",
            "page"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_find_entry",
          "args": [
            "dir",
            "qstr",
            "&page"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "213-243",
          "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nino_t f2fs_inode_by_name(struct inode *dir, struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\n\tde = f2fs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->ino);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "f2fs_parent_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "245-263",
    "snippet": "struct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\tstruct page *page;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_block *dentry_blk;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_parent_inline_dir(dir, p);\n\n\tpage = get_lock_data_page(dir, 0);\n\tif (IS_ERR(page))\n\t\treturn NULL;\n\n\tdentry_blk = kmap(page);\n\tde = &dentry_blk->dentry[1];\n\t*p = page;\n\tunlock_page(page);\n\treturn de;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_data_page",
          "args": [
            "dir",
            "0"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "433-491",
          "snippet": "struct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_parent_inline_dir",
          "args": [
            "dir",
            "p"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_parent_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "291-308",
          "snippet": "struct f2fs_dir_entry *f2fs_parent_inline_dir(struct inode *dir,\n\t\t\t\t\t\t\tstruct page **p)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tde = &dentry_blk->dentry[1];\n\t*p = ipage;\n\tunlock_page(ipage);\n\treturn de;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_parent_inline_dir(struct inode *dir,\n\t\t\t\t\t\t\tstruct page **p)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tde = &dentry_blk->dentry[1];\n\t*p = ipage;\n\tunlock_page(ipage);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "dir"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\tstruct page *page;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_block *dentry_blk;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_parent_inline_dir(dir, p);\n\n\tpage = get_lock_data_page(dir, 0);\n\tif (IS_ERR(page))\n\t\treturn NULL;\n\n\tdentry_blk = kmap(page);\n\tde = &dentry_blk->dentry[1];\n\t*p = page;\n\tunlock_page(page);\n\treturn de;\n}"
  },
  {
    "function_name": "f2fs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "213-243",
    "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dir"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_level",
          "args": [
            "dir",
            "level",
            "child",
            "name_hash",
            "res_page"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "161-205",
          "snippet": "static struct f2fs_dir_entry *find_in_level(struct inode *dir,\n\t\t\tunsigned int level, struct qstr *name,\n\t\t\tf2fs_hash_t namehash, struct page **res_page)\n{\n\tint s = GET_DENTRY_SLOTS(name->len);\n\tunsigned int nbucket, nblock;\n\tunsigned int bidx, end_block;\n\tstruct page *dentry_page;\n\tstruct f2fs_dir_entry *de = NULL;\n\tbool room = false;\n\tint max_slots;\n\n\tf2fs_bug_on(F2FS_I_SB(dir), level > MAX_DIR_HASH_DEPTH);\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t\tle32_to_cpu(namehash) % nbucket);\n\tend_block = bidx + nblock;\n\n\tfor (; bidx < end_block; bidx++) {\n\t\t/* no need to allocate new dentry pages to all the indices */\n\t\tdentry_page = find_data_page(dir, bidx, true);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\troom = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = find_in_block(dentry_page, name, &max_slots, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\n\t\tif (max_slots >= s)\n\t\t\troom = true;\n\t\tf2fs_put_page(dentry_page, 0);\n\t}\n\n\tif (!de && room && F2FS_I(dir)->chash != namehash) {\n\t\tF2FS_I(dir)->chash = namehash;\n\t\tF2FS_I(dir)->clevel = level;\n\t}\n\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct f2fs_dir_entry *find_in_level(struct inode *dir,\n\t\t\tunsigned int level, struct qstr *name,\n\t\t\tf2fs_hash_t namehash, struct page **res_page)\n{\n\tint s = GET_DENTRY_SLOTS(name->len);\n\tunsigned int nbucket, nblock;\n\tunsigned int bidx, end_block;\n\tstruct page *dentry_page;\n\tstruct f2fs_dir_entry *de = NULL;\n\tbool room = false;\n\tint max_slots;\n\n\tf2fs_bug_on(F2FS_I_SB(dir), level > MAX_DIR_HASH_DEPTH);\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t\tle32_to_cpu(namehash) % nbucket);\n\tend_block = bidx + nblock;\n\n\tfor (; bidx < end_block; bidx++) {\n\t\t/* no need to allocate new dentry pages to all the indices */\n\t\tdentry_page = find_data_page(dir, bidx, true);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\troom = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = find_in_block(dentry_page, name, &max_slots, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\n\t\tif (max_slots >= s)\n\t\t\troom = true;\n\t\tf2fs_put_page(dentry_page, 0);\n\t}\n\n\tif (!de && room && F2FS_I(dir)->chash != namehash) {\n\t\tF2FS_I(dir)->chash = namehash;\n\t\tF2FS_I(dir)->clevel = level;\n\t}\n\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_hash",
          "args": [
            "child"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/hash.c",
          "lines": "73-104",
          "snippet": "f2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/cryptohash.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/pagemap.h>\n#include <linux/cryptohash.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nf2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_inline_dir",
          "args": [
            "dir",
            "child",
            "res_page"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "259-289",
          "snippet": "struct f2fs_dir_entry *find_in_inline_dir(struct inode *dir,\n\t\t\t\tstruct qstr *name, struct page **res_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dir->i_sb);\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\tstruct page *ipage;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\tde = find_target_dentry(name, NULL, &d);\n\n\tunlock_page(ipage);\n\tif (de)\n\t\t*res_page = ipage;\n\telse\n\t\tf2fs_put_page(ipage, 0);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(sbi, d.max < 0);\n\treturn de;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *find_in_inline_dir(struct inode *dir,\n\t\t\t\tstruct qstr *name, struct page **res_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dir->i_sb);\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\tstruct page *ipage;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\tde = find_target_dentry(name, NULL, &d);\n\n\tunlock_page(ipage);\n\tif (de)\n\t\t*res_page = ipage;\n\telse\n\t\tf2fs_put_page(ipage, 0);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(sbi, d.max < 0);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "dir"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_blocks",
          "args": [
            "dir"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dir_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "18-22",
          "snippet": "static unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
  },
  {
    "function_name": "find_in_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "161-205",
    "snippet": "static struct f2fs_dir_entry *find_in_level(struct inode *dir,\n\t\t\tunsigned int level, struct qstr *name,\n\t\t\tf2fs_hash_t namehash, struct page **res_page)\n{\n\tint s = GET_DENTRY_SLOTS(name->len);\n\tunsigned int nbucket, nblock;\n\tunsigned int bidx, end_block;\n\tstruct page *dentry_page;\n\tstruct f2fs_dir_entry *de = NULL;\n\tbool room = false;\n\tint max_slots;\n\n\tf2fs_bug_on(F2FS_I_SB(dir), level > MAX_DIR_HASH_DEPTH);\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t\tle32_to_cpu(namehash) % nbucket);\n\tend_block = bidx + nblock;\n\n\tfor (; bidx < end_block; bidx++) {\n\t\t/* no need to allocate new dentry pages to all the indices */\n\t\tdentry_page = find_data_page(dir, bidx, true);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\troom = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = find_in_block(dentry_page, name, &max_slots, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\n\t\tif (max_slots >= s)\n\t\t\troom = true;\n\t\tf2fs_put_page(dentry_page, 0);\n\t}\n\n\tif (!de && room && F2FS_I(dir)->chash != namehash) {\n\t\tF2FS_I(dir)->chash = namehash;\n\t\tF2FS_I(dir)->clevel = level;\n\t}\n\n\treturn de;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dir"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "dentry_page",
            "0"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_block",
          "args": [
            "dentry_page",
            "name",
            "&max_slots",
            "res_page"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "92-116",
          "snippet": "static struct f2fs_dir_entry *find_in_block(struct page *dentry_page,\n\t\t\t\tstruct qstr *name, int *max_slots,\n\t\t\t\tstruct page **res_page)\n{\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = (struct f2fs_dentry_block *)kmap(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tde = find_target_dentry(name, max_slots, &d);\n\n\tif (de)\n\t\t*res_page = dentry_page;\n\telse\n\t\tkunmap(dentry_page);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(F2FS_P_SB(dentry_page), d.max < 0);\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct f2fs_dir_entry *find_in_block(struct page *dentry_page,\n\t\t\t\tstruct qstr *name, int *max_slots,\n\t\t\t\tstruct page **res_page)\n{\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = (struct f2fs_dentry_block *)kmap(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tde = find_target_dentry(name, max_slots, &d);\n\n\tif (de)\n\t\t*res_page = dentry_page;\n\telse\n\t\tkunmap(dentry_page);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(F2FS_P_SB(dentry_page), d.max < 0);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry_page"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_data_page",
          "args": [
            "dir",
            "bidx",
            "true"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "find_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "375-426",
          "snippet": "struct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_block_index",
          "args": [
            "level",
            "F2FS_I(dir)->i_dir_level",
            "le32_to_cpu(namehash) % nbucket"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dir_block_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "68-78",
          "snippet": "static unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "namehash"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blocks",
          "args": [
            "level"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "32-38",
          "snippet": "static unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_buckets",
          "args": [
            "level",
            "F2FS_I(dir)->i_dir_level"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "dir_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "24-30",
          "snippet": "static unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_I_SB(dir)",
            "level > MAX_DIR_HASH_DEPTH"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "name->len"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct f2fs_dir_entry *find_in_level(struct inode *dir,\n\t\t\tunsigned int level, struct qstr *name,\n\t\t\tf2fs_hash_t namehash, struct page **res_page)\n{\n\tint s = GET_DENTRY_SLOTS(name->len);\n\tunsigned int nbucket, nblock;\n\tunsigned int bidx, end_block;\n\tstruct page *dentry_page;\n\tstruct f2fs_dir_entry *de = NULL;\n\tbool room = false;\n\tint max_slots;\n\n\tf2fs_bug_on(F2FS_I_SB(dir), level > MAX_DIR_HASH_DEPTH);\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t\tle32_to_cpu(namehash) % nbucket);\n\tend_block = bidx + nblock;\n\n\tfor (; bidx < end_block; bidx++) {\n\t\t/* no need to allocate new dentry pages to all the indices */\n\t\tdentry_page = find_data_page(dir, bidx, true);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\troom = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = find_in_block(dentry_page, name, &max_slots, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\n\t\tif (max_slots >= s)\n\t\t\troom = true;\n\t\tf2fs_put_page(dentry_page, 0);\n\t}\n\n\tif (!de && room && F2FS_I(dir)->chash != namehash) {\n\t\tF2FS_I(dir)->chash = namehash;\n\t\tF2FS_I(dir)->clevel = level;\n\t}\n\n\treturn de;\n}"
  },
  {
    "function_name": "find_target_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "118-159",
    "snippet": "struct f2fs_dir_entry *find_target_dentry(struct qstr *name, int *max_slots,\n\t\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tf2fs_hash_t namehash = f2fs_dentry_hash(name);\n\tint max_len = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tif (bit_pos == 0)\n\t\t\t\tmax_len = 1;\n\t\t\telse if (!test_bit_le(bit_pos - 1, d->bitmap))\n\t\t\t\tmax_len++;\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tde = &d->dentry[bit_pos];\n\t\tif (early_match_name(name->len, namehash, de) &&\n\t\t\t!memcmp(d->filename[bit_pos], name->name, name->len))\n\t\t\tgoto found;\n\n\t\tif (max_slots && *max_slots >= 0 && max_len > *max_slots) {\n\t\t\t*max_slots = max_len;\n\t\t\tmax_len = 0;\n\t\t}\n\n\t\t/* remain bug on condition */\n\t\tif (unlikely(!de->name_len))\n\t\t\td->max = -1;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "le16_to_cpu(de->name_len)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->name_len"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!de->name_len"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "d->filename[bit_pos]",
            "name->name",
            "name->len"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_match_name",
          "args": [
            "name->len",
            "namehash",
            "de"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "early_match_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "80-90",
          "snippet": "static bool early_match_name(size_t namelen, f2fs_hash_t namehash,\n\t\t\t\tstruct f2fs_dir_entry *de)\n{\n\tif (le16_to_cpu(de->name_len) != namelen)\n\t\treturn false;\n\n\tif (de->hash_code != namehash)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool early_match_name(size_t namelen, f2fs_hash_t namehash,\n\t\t\t\tstruct f2fs_dir_entry *de)\n{\n\tif (le16_to_cpu(de->name_len) != namelen)\n\t\treturn false;\n\n\tif (de->hash_code != namehash)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit_le",
          "args": [
            "bit_pos - 1",
            "d->bitmap"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit_le",
          "args": [
            "bit_pos",
            "d->bitmap"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_hash",
          "args": [
            "name"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/hash.c",
          "lines": "73-104",
          "snippet": "f2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/cryptohash.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/pagemap.h>\n#include <linux/cryptohash.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nf2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *find_target_dentry(struct qstr *name, int *max_slots,\n\t\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tf2fs_hash_t namehash = f2fs_dentry_hash(name);\n\tint max_len = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tif (bit_pos == 0)\n\t\t\t\tmax_len = 1;\n\t\t\telse if (!test_bit_le(bit_pos - 1, d->bitmap))\n\t\t\t\tmax_len++;\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tde = &d->dentry[bit_pos];\n\t\tif (early_match_name(name->len, namehash, de) &&\n\t\t\t!memcmp(d->filename[bit_pos], name->name, name->len))\n\t\t\tgoto found;\n\n\t\tif (max_slots && *max_slots >= 0 && max_len > *max_slots) {\n\t\t\t*max_slots = max_len;\n\t\t\tmax_len = 0;\n\t\t}\n\n\t\t/* remain bug on condition */\n\t\tif (unlikely(!de->name_len))\n\t\t\td->max = -1;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}"
  },
  {
    "function_name": "find_in_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "92-116",
    "snippet": "static struct f2fs_dir_entry *find_in_block(struct page *dentry_page,\n\t\t\t\tstruct qstr *name, int *max_slots,\n\t\t\t\tstruct page **res_page)\n{\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = (struct f2fs_dentry_block *)kmap(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tde = find_target_dentry(name, max_slots, &d);\n\n\tif (de)\n\t\t*res_page = dentry_page;\n\telse\n\t\tkunmap(dentry_page);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(F2FS_P_SB(dentry_page), d.max < 0);\n\treturn de;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_P_SB(dentry_page)",
            "d.max < 0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "dentry_page"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dentry_page"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_target_dentry",
          "args": [
            "name",
            "max_slots",
            "&d"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "find_target_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "118-159",
          "snippet": "struct f2fs_dir_entry *find_target_dentry(struct qstr *name, int *max_slots,\n\t\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tf2fs_hash_t namehash = f2fs_dentry_hash(name);\n\tint max_len = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tif (bit_pos == 0)\n\t\t\t\tmax_len = 1;\n\t\t\telse if (!test_bit_le(bit_pos - 1, d->bitmap))\n\t\t\t\tmax_len++;\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tde = &d->dentry[bit_pos];\n\t\tif (early_match_name(name->len, namehash, de) &&\n\t\t\t!memcmp(d->filename[bit_pos], name->name, name->len))\n\t\t\tgoto found;\n\n\t\tif (max_slots && *max_slots >= 0 && max_len > *max_slots) {\n\t\t\t*max_slots = max_len;\n\t\t\tmax_len = 0;\n\t\t}\n\n\t\t/* remain bug on condition */\n\t\tif (unlikely(!de->name_len))\n\t\t\td->max = -1;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *find_target_dentry(struct qstr *name, int *max_slots,\n\t\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tf2fs_hash_t namehash = f2fs_dentry_hash(name);\n\tint max_len = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tif (bit_pos == 0)\n\t\t\t\tmax_len = 1;\n\t\t\telse if (!test_bit_le(bit_pos - 1, d->bitmap))\n\t\t\t\tmax_len++;\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tde = &d->dentry[bit_pos];\n\t\tif (early_match_name(name->len, namehash, de) &&\n\t\t\t!memcmp(d->filename[bit_pos], name->name, name->len))\n\t\t\tgoto found;\n\n\t\tif (max_slots && *max_slots >= 0 && max_len > *max_slots) {\n\t\t\t*max_slots = max_len;\n\t\t\tmax_len = 0;\n\t\t}\n\n\t\t/* remain bug on condition */\n\t\tif (unlikely(!de->name_len))\n\t\t\td->max = -1;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_dentry_ptr",
          "args": [
            "&d",
            "(void *)dentry_blk",
            "1"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "make_dentry_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "238-254",
          "snippet": "static inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "dentry_page"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct f2fs_dir_entry *find_in_block(struct page *dentry_page,\n\t\t\t\tstruct qstr *name, int *max_slots,\n\t\t\t\tstruct page **res_page)\n{\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = (struct f2fs_dentry_block *)kmap(dentry_page);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 1);\n\tde = find_target_dentry(name, max_slots, &d);\n\n\tif (de)\n\t\t*res_page = dentry_page;\n\telse\n\t\tkunmap(dentry_page);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(F2FS_P_SB(dentry_page), d.max < 0);\n\treturn de;\n}"
  },
  {
    "function_name": "early_match_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "80-90",
    "snippet": "static bool early_match_name(size_t namelen, f2fs_hash_t namehash,\n\t\t\t\tstruct f2fs_dir_entry *de)\n{\n\tif (le16_to_cpu(de->name_len) != namelen)\n\t\treturn false;\n\n\tif (de->hash_code != namehash)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->name_len"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool early_match_name(size_t namelen, f2fs_hash_t namehash,\n\t\t\t\tstruct f2fs_dir_entry *de)\n{\n\tif (le16_to_cpu(de->name_len) != namelen)\n\t\treturn false;\n\n\tif (de->hash_code != namehash)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "dir_block_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "68-78",
    "snippet": "static unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bucket_blocks",
          "args": [
            "level"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "32-38",
          "snippet": "static unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_buckets",
          "args": [
            "i",
            "dir_level"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "dir_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "24-30",
          "snippet": "static unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}"
  },
  {
    "function_name": "set_de_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "62-66",
    "snippet": "void set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define S_SHIFT 12"
    ],
    "globals_used": [
      "static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};\n\nvoid set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
  },
  {
    "function_name": "bucket_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "32-38",
    "snippet": "static unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}"
  },
  {
    "function_name": "dir_buckets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "24-30",
    "snippet": "static unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 1 << (level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}"
  },
  {
    "function_name": "dir_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
    "lines": "18-22",
    "snippet": "static unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_CACHE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n}"
  }
]