[
  {
    "function_name": "ceph_snap_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "974-977",
    "snippet": "void ceph_snap_exit(void)\n{\n\tceph_put_snap_context(empty_snapc);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ceph_snap_context *empty_snapc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "empty_snapc"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nvoid ceph_snap_exit(void)\n{\n\tceph_put_snap_context(empty_snapc);\n}"
  },
  {
    "function_name": "ceph_snap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "965-972",
    "snippet": "int __init ceph_snap_init(void)\n{\n\tempty_snapc = ceph_create_snap_context(0, GFP_NOFS);\n\tif (!empty_snapc)\n\t\treturn -ENOMEM;\n\tempty_snapc->seq = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ceph_snap_context *empty_snapc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_create_snap_context",
          "args": [
            "0",
            "GFP_NOFS"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nint __init ceph_snap_init(void)\n{\n\tempty_snapc = ceph_create_snap_context(0, GFP_NOFS);\n\tif (!empty_snapc)\n\t\treturn -ENOMEM;\n\tempty_snapc->seq = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_handle_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "805-963",
    "snippet": "void ceph_handle_snap(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tint mds = session->s_mds;\n\tu64 split;\n\tint op;\n\tint trace_len;\n\tstruct ceph_snap_realm *realm = NULL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *e = p + msg->front.iov_len;\n\tstruct ceph_mds_snap_head *h;\n\tint num_split_inos, num_split_realms;\n\t__le64 *split_inos = NULL, *split_realms = NULL;\n\tint i;\n\tint locked_rwsem = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = p;\n\top = le32_to_cpu(h->op);\n\tsplit = le64_to_cpu(h->split);   /* non-zero if we are splitting an\n\t\t\t\t\t  * existing realm */\n\tnum_split_inos = le32_to_cpu(h->num_split_inos);\n\tnum_split_realms = le32_to_cpu(h->num_split_realms);\n\ttrace_len = le32_to_cpu(h->trace_len);\n\tp += sizeof(*h);\n\n\tdout(\"handle_snap from mds%d op %s split %llx tracelen %d\\n\", mds,\n\t     ceph_snap_op_name(op), split, trace_len);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tmutex_unlock(&session->s_mutex);\n\n\tdown_write(&mdsc->snap_rwsem);\n\tlocked_rwsem = 1;\n\n\tif (op == CEPH_SNAP_OP_SPLIT) {\n\t\tstruct ceph_mds_snap_realm *ri;\n\n\t\t/*\n\t\t * A \"split\" breaks part of an existing realm off into\n\t\t * a new realm.  The MDS provides a list of inodes\n\t\t * (with caps) and child realms that belong to the new\n\t\t * child.\n\t\t */\n\t\tsplit_inos = p;\n\t\tp += sizeof(u64) * num_split_inos;\n\t\tsplit_realms = p;\n\t\tp += sizeof(u64) * num_split_realms;\n\t\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\t\t/* we will peek at realm info here, but will _not_\n\t\t * advance p, as the realm update will occur below in\n\t\t * ceph_update_snap_trace. */\n\t\tri = p;\n\n\t\trealm = ceph_lookup_snap_realm(mdsc, split);\n\t\tif (!realm) {\n\t\t\trealm = ceph_create_snap_realm(mdsc, split);\n\t\t\tif (IS_ERR(realm))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdout(\"splitting snap_realm %llx %p\\n\", realm->ino, realm);\n\t\tfor (i = 0; i < num_split_inos; i++) {\n\t\t\tstruct ceph_vino vino = {\n\t\t\t\t.ino = le64_to_cpu(split_inos[i]),\n\t\t\t\t.snap = CEPH_NOSNAP,\n\t\t\t};\n\t\t\tstruct inode *inode = ceph_find_inode(sb, vino);\n\t\t\tstruct ceph_inode_info *ci;\n\t\t\tstruct ceph_snap_realm *oldrealm;\n\n\t\t\tif (!inode)\n\t\t\t\tcontinue;\n\t\t\tci = ceph_inode(inode);\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_snap_realm)\n\t\t\t\tgoto skip_inode;\n\t\t\t/*\n\t\t\t * If this inode belongs to a realm that was\n\t\t\t * created after our new realm, we experienced\n\t\t\t * a race (due to another split notifications\n\t\t\t * arriving from a different MDS).  So skip\n\t\t\t * this inode.\n\t\t\t */\n\t\t\tif (ci->i_snap_realm->created >\n\t\t\t    le64_to_cpu(ri->created)) {\n\t\t\t\tdout(\" leaving %p in newer realm %llx %p\\n\",\n\t\t\t\t     inode, ci->i_snap_realm->ino,\n\t\t\t\t     ci->i_snap_realm);\n\t\t\t\tgoto skip_inode;\n\t\t\t}\n\t\t\tdout(\" will move %p to split realm %llx %p\\n\",\n\t\t\t     inode, realm->ino, realm);\n\t\t\t/*\n\t\t\t * Move the inode to the new realm\n\t\t\t */\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\toldrealm = ci->i_snap_realm;\n\t\t\tci->i_snap_realm = realm;\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\tceph_get_snap_realm(mdsc, realm);\n\t\t\tceph_put_snap_realm(mdsc, oldrealm);\n\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\nskip_inode:\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tiput(inode);\n\t\t}\n\n\t\t/* we may have taken some of the old realm's children. */\n\t\tfor (i = 0; i < num_split_realms; i++) {\n\t\t\tstruct ceph_snap_realm *child =\n\t\t\t\t__lookup_snap_realm(mdsc,\n\t\t\t\t\t   le64_to_cpu(split_realms[i]));\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\t\t\tadjust_snap_realm_parent(mdsc, child, realm->ino);\n\t\t}\n\t}\n\n\t/*\n\t * update using the provided snap trace. if we are deleting a\n\t * snap, we can avoid queueing cap_snaps.\n\t */\n\tceph_update_snap_trace(mdsc, p, e,\n\t\t\t       op == CEPH_SNAP_OP_DESTROY, NULL);\n\n\tif (op == CEPH_SNAP_OP_SPLIT)\n\t\t/* we took a reference when we created the realm, above */\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\t__cleanup_empty_realms(mdsc);\n\n\tup_write(&mdsc->snap_rwsem);\n\n\tflush_snaps(mdsc);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt snap message from mds%d\\n\", mds);\n\tceph_msg_dump(msg);\nout:\n\tif (locked_rwsem)\n\t\tup_write(&mdsc->snap_rwsem);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_dump",
          "args": [
            "msg"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"corrupt snap message from mds%d\\n\"",
            "mds"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_snaps",
          "args": [
            "mdsc"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "764-791",
          "snippet": "static void flush_snaps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\tstruct ceph_mds_session *session = NULL;\n\n\tdout(\"flush_snaps\\n\");\n\tspin_lock(&mdsc->snap_flush_lock);\n\twhile (!list_empty(&mdsc->snap_flush_list)) {\n\t\tci = list_first_entry(&mdsc->snap_flush_list,\n\t\t\t\tstruct ceph_inode_info, i_snap_flush_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tspin_unlock(&mdsc->snap_flush_lock);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->snap_flush_lock);\n\t}\n\tspin_unlock(&mdsc->snap_flush_lock);\n\n\tif (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n\tdout(\"flush_snaps done\\n\");\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void flush_snaps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\tstruct ceph_mds_session *session = NULL;\n\n\tdout(\"flush_snaps\\n\");\n\tspin_lock(&mdsc->snap_flush_lock);\n\twhile (!list_empty(&mdsc->snap_flush_list)) {\n\t\tci = list_first_entry(&mdsc->snap_flush_list,\n\t\t\t\tstruct ceph_inode_info, i_snap_flush_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tspin_unlock(&mdsc->snap_flush_lock);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->snap_flush_lock);\n\t}\n\tspin_unlock(&mdsc->snap_flush_lock);\n\n\tif (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n\tdout(\"flush_snaps done\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_empty_realms",
          "args": [
            "mdsc"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_empty_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "229-243",
          "snippet": "static void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_update_snap_trace",
          "args": [
            "mdsc",
            "p",
            "e",
            "op == CEPH_SNAP_OP_DESTROY",
            "NULL"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_update_snap_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "640-755",
          "snippet": "int ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nint ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_snap_realm_parent",
          "args": [
            "mdsc",
            "child",
            "realm->ino"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_snap_realm_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "260-286",
          "snippet": "static int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\",\n\t     realm->ino, realm, realm->parent_ino, realm->parent,\n\t     parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\",\n\t     realm->ino, realm, realm->parent_ino, realm->parent,\n\t     parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_snap_realm",
          "args": [
            "mdsc",
            "le64_to_cpu(split_realms[i])"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "135-153",
          "snippet": "static struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"lookup_snap_realm %llx %p\\n\", r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"lookup_snap_realm %llx %p\\n\", r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "split_realms[i]"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "62-78",
          "snippet": "void ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"get_realm %p %d -> %d\\n\", realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)+1);\n\t/*\n\t * since we _only_ increment realm refs or empty the empty\n\t * list with snap_rwsem held, adjusting the empty list here is\n\t * safe.  we do need to protect against concurrent empty list\n\t * additions, however.\n\t */\n\tif (atomic_inc_return(&realm->nref) == 1) {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_del_init(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"get_realm %p %d -> %d\\n\", realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)+1);\n\t/*\n\t * since we _only_ increment realm refs or empty the empty\n\t * list with snap_rwsem held, adjusting the empty list here is\n\t * safe.  we do need to protect against concurrent empty list\n\t * additions, however.\n\t */\n\tif (atomic_inc_return(&realm->nref) == 1) {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_del_init(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ci->i_snap_realm_item",
            "&realm->inodes_with_caps"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_snap_realm_item"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" will move %p to split realm %llx %p\\n\"",
            "inode",
            "realm->ino",
            "realm"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" leaving %p in newer realm %llx %p\\n\"",
            "inode",
            "ci->i_snap_realm->ino",
            "ci->i_snap_realm"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_find_inode",
          "args": [
            "sb",
            "vino"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "429-434",
          "snippet": "static inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"splitting snap_realm %llx %p\\n\"",
            "realm->ino",
            "realm"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realm"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_create_snap_realm",
          "args": [
            "mdsc",
            "split"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_create_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "107-128",
          "snippet": "static struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_lookup_snap_realm",
          "args": [
            "mdsc",
            "split"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lookup_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "155-163",
          "snippet": "struct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "e",
            "sizeof(*ri)",
            "bad"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_snap from mds%d op %s split %llx tracelen %d\\n\"",
            "mds",
            "ceph_snap_op_name(op)",
            "split",
            "trace_len"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap_op_name",
          "args": [
            "op"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "h->trace_len"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_handle_snap(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tint mds = session->s_mds;\n\tu64 split;\n\tint op;\n\tint trace_len;\n\tstruct ceph_snap_realm *realm = NULL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *e = p + msg->front.iov_len;\n\tstruct ceph_mds_snap_head *h;\n\tint num_split_inos, num_split_realms;\n\t__le64 *split_inos = NULL, *split_realms = NULL;\n\tint i;\n\tint locked_rwsem = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = p;\n\top = le32_to_cpu(h->op);\n\tsplit = le64_to_cpu(h->split);   /* non-zero if we are splitting an\n\t\t\t\t\t  * existing realm */\n\tnum_split_inos = le32_to_cpu(h->num_split_inos);\n\tnum_split_realms = le32_to_cpu(h->num_split_realms);\n\ttrace_len = le32_to_cpu(h->trace_len);\n\tp += sizeof(*h);\n\n\tdout(\"handle_snap from mds%d op %s split %llx tracelen %d\\n\", mds,\n\t     ceph_snap_op_name(op), split, trace_len);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tmutex_unlock(&session->s_mutex);\n\n\tdown_write(&mdsc->snap_rwsem);\n\tlocked_rwsem = 1;\n\n\tif (op == CEPH_SNAP_OP_SPLIT) {\n\t\tstruct ceph_mds_snap_realm *ri;\n\n\t\t/*\n\t\t * A \"split\" breaks part of an existing realm off into\n\t\t * a new realm.  The MDS provides a list of inodes\n\t\t * (with caps) and child realms that belong to the new\n\t\t * child.\n\t\t */\n\t\tsplit_inos = p;\n\t\tp += sizeof(u64) * num_split_inos;\n\t\tsplit_realms = p;\n\t\tp += sizeof(u64) * num_split_realms;\n\t\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\t\t/* we will peek at realm info here, but will _not_\n\t\t * advance p, as the realm update will occur below in\n\t\t * ceph_update_snap_trace. */\n\t\tri = p;\n\n\t\trealm = ceph_lookup_snap_realm(mdsc, split);\n\t\tif (!realm) {\n\t\t\trealm = ceph_create_snap_realm(mdsc, split);\n\t\t\tif (IS_ERR(realm))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdout(\"splitting snap_realm %llx %p\\n\", realm->ino, realm);\n\t\tfor (i = 0; i < num_split_inos; i++) {\n\t\t\tstruct ceph_vino vino = {\n\t\t\t\t.ino = le64_to_cpu(split_inos[i]),\n\t\t\t\t.snap = CEPH_NOSNAP,\n\t\t\t};\n\t\t\tstruct inode *inode = ceph_find_inode(sb, vino);\n\t\t\tstruct ceph_inode_info *ci;\n\t\t\tstruct ceph_snap_realm *oldrealm;\n\n\t\t\tif (!inode)\n\t\t\t\tcontinue;\n\t\t\tci = ceph_inode(inode);\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_snap_realm)\n\t\t\t\tgoto skip_inode;\n\t\t\t/*\n\t\t\t * If this inode belongs to a realm that was\n\t\t\t * created after our new realm, we experienced\n\t\t\t * a race (due to another split notifications\n\t\t\t * arriving from a different MDS).  So skip\n\t\t\t * this inode.\n\t\t\t */\n\t\t\tif (ci->i_snap_realm->created >\n\t\t\t    le64_to_cpu(ri->created)) {\n\t\t\t\tdout(\" leaving %p in newer realm %llx %p\\n\",\n\t\t\t\t     inode, ci->i_snap_realm->ino,\n\t\t\t\t     ci->i_snap_realm);\n\t\t\t\tgoto skip_inode;\n\t\t\t}\n\t\t\tdout(\" will move %p to split realm %llx %p\\n\",\n\t\t\t     inode, realm->ino, realm);\n\t\t\t/*\n\t\t\t * Move the inode to the new realm\n\t\t\t */\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\toldrealm = ci->i_snap_realm;\n\t\t\tci->i_snap_realm = realm;\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\tceph_get_snap_realm(mdsc, realm);\n\t\t\tceph_put_snap_realm(mdsc, oldrealm);\n\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\nskip_inode:\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tiput(inode);\n\t\t}\n\n\t\t/* we may have taken some of the old realm's children. */\n\t\tfor (i = 0; i < num_split_realms; i++) {\n\t\t\tstruct ceph_snap_realm *child =\n\t\t\t\t__lookup_snap_realm(mdsc,\n\t\t\t\t\t   le64_to_cpu(split_realms[i]));\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\t\t\tadjust_snap_realm_parent(mdsc, child, realm->ino);\n\t\t}\n\t}\n\n\t/*\n\t * update using the provided snap trace. if we are deleting a\n\t * snap, we can avoid queueing cap_snaps.\n\t */\n\tceph_update_snap_trace(mdsc, p, e,\n\t\t\t       op == CEPH_SNAP_OP_DESTROY, NULL);\n\n\tif (op == CEPH_SNAP_OP_SPLIT)\n\t\t/* we took a reference when we created the realm, above */\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\t__cleanup_empty_realms(mdsc);\n\n\tup_write(&mdsc->snap_rwsem);\n\n\tflush_snaps(mdsc);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt snap message from mds%d\\n\", mds);\n\tceph_msg_dump(msg);\nout:\n\tif (locked_rwsem)\n\t\tup_write(&mdsc->snap_rwsem);\n\treturn;\n}"
  },
  {
    "function_name": "flush_snaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "764-791",
    "snippet": "static void flush_snaps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\tstruct ceph_mds_session *session = NULL;\n\n\tdout(\"flush_snaps\\n\");\n\tspin_lock(&mdsc->snap_flush_lock);\n\twhile (!list_empty(&mdsc->snap_flush_list)) {\n\t\tci = list_first_entry(&mdsc->snap_flush_list,\n\t\t\t\tstruct ceph_inode_info, i_snap_flush_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tspin_unlock(&mdsc->snap_flush_lock);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->snap_flush_lock);\n\t}\n\tspin_unlock(&mdsc->snap_flush_lock);\n\n\tif (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n\tdout(\"flush_snaps done\\n\");\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flush_snaps done\\n\""
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "session"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_flush_snaps",
          "args": [
            "ci",
            "&session",
            "0"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1257-1375",
          "snippet": "void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mdsc->snap_flush_list",
            "structceph_inode_info",
            "i_snap_flush_item"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->snap_flush_list"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flush_snaps\\n\""
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void flush_snaps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\tstruct ceph_mds_session *session = NULL;\n\n\tdout(\"flush_snaps\\n\");\n\tspin_lock(&mdsc->snap_flush_lock);\n\twhile (!list_empty(&mdsc->snap_flush_list)) {\n\t\tci = list_first_entry(&mdsc->snap_flush_list,\n\t\t\t\tstruct ceph_inode_info, i_snap_flush_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tspin_unlock(&mdsc->snap_flush_lock);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->snap_flush_lock);\n\t}\n\tspin_unlock(&mdsc->snap_flush_lock);\n\n\tif (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n\tdout(\"flush_snaps done\\n\");\n}"
  },
  {
    "function_name": "ceph_update_snap_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "640-755",
    "snippet": "int ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"update_snap_trace error %d\\n\"",
            "err"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "first_realm"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realm"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_empty_realms",
          "args": [
            "mdsc"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_empty_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "229-243",
          "snippet": "static void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_realm_cap_snaps",
          "args": [
            "realm"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "queue_realm_cap_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "599-631",
          "snippet": "static void queue_realm_cap_snaps(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *lastinode = NULL;\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"queue_realm_cap_snaps %p %llx inodes\\n\", realm, realm->ino);\n\n\tspin_lock(&realm->inodes_with_caps_lock);\n\tlist_for_each_entry(ci, &realm->inodes_with_caps,\n\t\t\t    i_snap_realm_item) {\n\t\tstruct inode *inode = igrab(&ci->vfs_inode);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tiput(lastinode);\n\t\tlastinode = inode;\n\t\tceph_queue_cap_snap(ci);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t}\n\tspin_unlock(&realm->inodes_with_caps_lock);\n\tiput(lastinode);\n\n\tlist_for_each_entry(child, &realm->children, child_item) {\n\t\tdout(\"queue_realm_cap_snaps %p %llx queue child %p %llx\\n\",\n\t\t     realm, realm->ino, child, child->ino);\n\t\tlist_del_init(&child->dirty_item);\n\t\tlist_add(&child->dirty_item, &realm->dirty_item);\n\t}\n\n\tlist_del_init(&realm->dirty_item);\n\tdout(\"queue_realm_cap_snaps %p %llx done\\n\", realm, realm->ino);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void queue_realm_cap_snaps(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *lastinode = NULL;\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"queue_realm_cap_snaps %p %llx inodes\\n\", realm, realm->ino);\n\n\tspin_lock(&realm->inodes_with_caps_lock);\n\tlist_for_each_entry(ci, &realm->inodes_with_caps,\n\t\t\t    i_snap_realm_item) {\n\t\tstruct inode *inode = igrab(&ci->vfs_inode);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tiput(lastinode);\n\t\tlastinode = inode;\n\t\tceph_queue_cap_snap(ci);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t}\n\tspin_unlock(&realm->inodes_with_caps_lock);\n\tiput(lastinode);\n\n\tlist_for_each_entry(child, &realm->children, child_item) {\n\t\tdout(\"queue_realm_cap_snaps %p %llx queue child %p %llx\\n\",\n\t\t     realm, realm->ino, child, child->ino);\n\t\tlist_del_init(&child->dirty_item);\n\t\tlist_add(&child->dirty_item, &realm->dirty_item);\n\t}\n\n\tlist_del_init(&realm->dirty_item);\n\tdout(\"queue_realm_cap_snaps %p %llx done\\n\", realm, realm->ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dirty_realms",
            "structceph_snap_realm",
            "dirty_item"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dirty_realms"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_snap_realms",
          "args": [
            "realm"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_snap_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "406-415",
          "snippet": "static void rebuild_snap_realms(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"rebuild_snap_realms %llx %p\\n\", realm->ino, realm);\n\tbuild_snap_context(realm);\n\n\tlist_for_each_entry(child, &realm->children, child_item)\n\t\trebuild_snap_realms(child);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void rebuild_snap_realms(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"rebuild_snap_realms %llx %p\\n\", realm->ino, realm);\n\tbuild_snap_context(realm);\n\n\tlist_for_each_entry(child, &realm->children, child_item)\n\t\trebuild_snap_realms(child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"done with %llx %p, invalidated=%d, %p %p\\n\"",
            "realm->ino",
            "realm",
            "invalidate",
            "p",
            "e"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"update_snap_trace %llx %p seq %lld unchanged\\n\"",
            "realm->ino",
            "realm",
            "realm->seq"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"update_snap_trace %llx %p seq %lld new\\n\"",
            "realm->ino",
            "realm",
            "realm->seq"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&realm->dirty_item",
            "&dirty_realms"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_array",
          "args": [
            "&realm->prior_parent_snaps",
            "prior_parent_snaps",
            "realm->num_prior_parent_snaps"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "dup_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "422-437",
          "snippet": "static int dup_array(u64 **dst, __le64 *src, u32 num)\n{\n\tu32 i;\n\n\tkfree(*dst);\n\tif (num) {\n\t\t*dst = kcalloc(num, sizeof(u64), GFP_NOFS);\n\t\tif (!*dst)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < num; i++)\n\t\t\t(*dst)[i] = get_unaligned_le64(src + i);\n\t} else {\n\t\t*dst = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int dup_array(u64 **dst, __le64 *src, u32 num)\n{\n\tu32 i;\n\n\tkfree(*dst);\n\tif (num) {\n\t\t*dst = kcalloc(num, sizeof(u64), GFP_NOFS);\n\t\tif (!*dst)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < num; i++)\n\t\t\t(*dst)[i] = get_unaligned_le64(src + i);\n\t} else {\n\t\t*dst = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ri->num_prior_parent_snaps"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ri->parent_since"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"update_snap_trace updating %llx %p %lld -> %lld\\n\"",
            "realm->ino",
            "realm",
            "realm->seq",
            "le64_to_cpu(ri->seq)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_snap_realm_parent",
          "args": [
            "mdsc",
            "realm",
            "le64_to_cpu(ri->parent)"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_snap_realm_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "260-286",
          "snippet": "static int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\",\n\t     realm->ino, realm, realm->parent_ino, realm->parent,\n\t     parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\",\n\t     realm->ino, realm, realm->parent_ino, realm->parent,\n\t     parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "realm"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realm"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_create_snap_realm",
          "args": [
            "mdsc",
            "le64_to_cpu(ri->ino)"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_create_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "107-128",
          "snippet": "static struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_lookup_snap_realm",
          "args": [
            "mdsc",
            "le64_to_cpu(ri->ino)"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lookup_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "155-163",
          "snippet": "struct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "e",
            "sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps))",
            "bad"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "e",
            "sizeof(*ri)",
            "bad"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"update_snap_trace deletion=%d\\n\"",
            "deletion"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dirty_realms"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nint ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "queue_realm_cap_snaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "599-631",
    "snippet": "static void queue_realm_cap_snaps(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *lastinode = NULL;\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"queue_realm_cap_snaps %p %llx inodes\\n\", realm, realm->ino);\n\n\tspin_lock(&realm->inodes_with_caps_lock);\n\tlist_for_each_entry(ci, &realm->inodes_with_caps,\n\t\t\t    i_snap_realm_item) {\n\t\tstruct inode *inode = igrab(&ci->vfs_inode);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tiput(lastinode);\n\t\tlastinode = inode;\n\t\tceph_queue_cap_snap(ci);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t}\n\tspin_unlock(&realm->inodes_with_caps_lock);\n\tiput(lastinode);\n\n\tlist_for_each_entry(child, &realm->children, child_item) {\n\t\tdout(\"queue_realm_cap_snaps %p %llx queue child %p %llx\\n\",\n\t\t     realm, realm->ino, child, child->ino);\n\t\tlist_del_init(&child->dirty_item);\n\t\tlist_add(&child->dirty_item, &realm->dirty_item);\n\t}\n\n\tlist_del_init(&realm->dirty_item);\n\tdout(\"queue_realm_cap_snaps %p %llx done\\n\", realm, realm->ino);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_realm_cap_snaps %p %llx done\\n\"",
            "realm",
            "realm->ino"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&realm->dirty_item"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&child->dirty_item",
            "&realm->dirty_item"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&child->dirty_item"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_realm_cap_snaps %p %llx queue child %p %llx\\n\"",
            "realm",
            "realm->ino",
            "child",
            "child->ino"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&realm->children",
            "child_item"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "lastinode"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_cap_snap",
          "args": [
            "ci"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "454-554",
          "snippet": "void ceph_queue_cap_snap(struct ceph_inode_info *ci)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap_snap *capsnap;\n\tint used, dirty;\n\n\tcapsnap = kzalloc(sizeof(*capsnap), GFP_NOFS);\n\tif (!capsnap) {\n\t\tpr_err(\"ENOMEM allocating ceph_cap_snap on %p\\n\", inode);\n\t\treturn;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\t/*\n\t * If there is a write in progress, treat that as a dirty Fw,\n\t * even though it hasn't completed yet; by the time we finish\n\t * up this capsnap it will be.\n\t */\n\tif (used & CEPH_CAP_FILE_WR)\n\t\tdirty |= CEPH_CAP_FILE_WR;\n\n\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t/* there is no point in queuing multiple \"pending\" cap_snaps,\n\t\t   as no new writes are allowed to start when pending, so any\n\t\t   writes in progress now were started before the previous\n\t\t   cap_snap.  lucky us. */\n\t\tdout(\"queue_cap_snap %p already pending\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (ci->i_snap_realm->cached_context == empty_snapc) {\n\t\tdout(\"queue_cap_snap %p empty snapc\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (dirty & (CEPH_CAP_AUTH_EXCL|CEPH_CAP_XATTR_EXCL|\n\t\t\t    CEPH_CAP_FILE_EXCL|CEPH_CAP_FILE_WR)) {\n\t\tstruct ceph_snap_context *snapc = ci->i_head_snapc;\n\n\t\t/*\n\t\t * if we are a sync write, we may need to go to the snaprealm\n\t\t * to get the current snapc.\n\t\t */\n\t\tif (!snapc)\n\t\t\tsnapc = ci->i_snap_realm->cached_context;\n\n\t\tdout(\"queue_cap_snap %p cap_snap %p queuing under %p %s\\n\",\n\t\t     inode, capsnap, snapc, ceph_cap_string(dirty));\n\t\tihold(inode);\n\n\t\tatomic_set(&capsnap->nref, 1);\n\t\tcapsnap->ci = ci;\n\t\tINIT_LIST_HEAD(&capsnap->ci_item);\n\t\tINIT_LIST_HEAD(&capsnap->flushing_item);\n\n\t\tcapsnap->follows = snapc->seq;\n\t\tcapsnap->issued = __ceph_caps_issued(ci, NULL);\n\t\tcapsnap->dirty = dirty;\n\n\t\tcapsnap->mode = inode->i_mode;\n\t\tcapsnap->uid = inode->i_uid;\n\t\tcapsnap->gid = inode->i_gid;\n\n\t\tif (dirty & CEPH_CAP_XATTR_EXCL) {\n\t\t\t__ceph_build_xattrs_blob(ci);\n\t\t\tcapsnap->xattr_blob =\n\t\t\t\tceph_buffer_get(ci->i_xattrs.blob);\n\t\t\tcapsnap->xattr_version = ci->i_xattrs.version;\n\t\t} else {\n\t\t\tcapsnap->xattr_blob = NULL;\n\t\t\tcapsnap->xattr_version = 0;\n\t\t}\n\n\t\tcapsnap->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\t\t/* dirty page count moved from _head to this cap_snap;\n\t\t   all subsequent writes page dirties occur _after_ this\n\t\t   snapshot. */\n\t\tcapsnap->dirty_pages = ci->i_wrbuffer_ref_head;\n\t\tci->i_wrbuffer_ref_head = 0;\n\t\tcapsnap->context = snapc;\n\t\tci->i_head_snapc =\n\t\t\tceph_get_snap_context(ci->i_snap_realm->cached_context);\n\t\tdout(\" new snapc is %p\\n\", ci->i_head_snapc);\n\t\tlist_add_tail(&capsnap->ci_item, &ci->i_cap_snaps);\n\n\t\tif (used & CEPH_CAP_FILE_WR) {\n\t\t\tdout(\"queue_cap_snap %p cap_snap %p snapc %p\"\n\t\t\t     \" seq %llu used WR, now pending\\n\", inode,\n\t\t\t     capsnap, snapc, snapc->seq);\n\t\t\tcapsnap->writing = 1;\n\t\t} else {\n\t\t\t/* note mtime, size NOW. */\n\t\t\t__ceph_finish_cap_snap(ci, capsnap);\n\t\t}\n\t} else {\n\t\tdout(\"queue_cap_snap %p nothing dirty|writing\\n\", inode);\n\t\tkfree(capsnap);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ceph_snap_context *empty_snapc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nvoid ceph_queue_cap_snap(struct ceph_inode_info *ci)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap_snap *capsnap;\n\tint used, dirty;\n\n\tcapsnap = kzalloc(sizeof(*capsnap), GFP_NOFS);\n\tif (!capsnap) {\n\t\tpr_err(\"ENOMEM allocating ceph_cap_snap on %p\\n\", inode);\n\t\treturn;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\t/*\n\t * If there is a write in progress, treat that as a dirty Fw,\n\t * even though it hasn't completed yet; by the time we finish\n\t * up this capsnap it will be.\n\t */\n\tif (used & CEPH_CAP_FILE_WR)\n\t\tdirty |= CEPH_CAP_FILE_WR;\n\n\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t/* there is no point in queuing multiple \"pending\" cap_snaps,\n\t\t   as no new writes are allowed to start when pending, so any\n\t\t   writes in progress now were started before the previous\n\t\t   cap_snap.  lucky us. */\n\t\tdout(\"queue_cap_snap %p already pending\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (ci->i_snap_realm->cached_context == empty_snapc) {\n\t\tdout(\"queue_cap_snap %p empty snapc\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (dirty & (CEPH_CAP_AUTH_EXCL|CEPH_CAP_XATTR_EXCL|\n\t\t\t    CEPH_CAP_FILE_EXCL|CEPH_CAP_FILE_WR)) {\n\t\tstruct ceph_snap_context *snapc = ci->i_head_snapc;\n\n\t\t/*\n\t\t * if we are a sync write, we may need to go to the snaprealm\n\t\t * to get the current snapc.\n\t\t */\n\t\tif (!snapc)\n\t\t\tsnapc = ci->i_snap_realm->cached_context;\n\n\t\tdout(\"queue_cap_snap %p cap_snap %p queuing under %p %s\\n\",\n\t\t     inode, capsnap, snapc, ceph_cap_string(dirty));\n\t\tihold(inode);\n\n\t\tatomic_set(&capsnap->nref, 1);\n\t\tcapsnap->ci = ci;\n\t\tINIT_LIST_HEAD(&capsnap->ci_item);\n\t\tINIT_LIST_HEAD(&capsnap->flushing_item);\n\n\t\tcapsnap->follows = snapc->seq;\n\t\tcapsnap->issued = __ceph_caps_issued(ci, NULL);\n\t\tcapsnap->dirty = dirty;\n\n\t\tcapsnap->mode = inode->i_mode;\n\t\tcapsnap->uid = inode->i_uid;\n\t\tcapsnap->gid = inode->i_gid;\n\n\t\tif (dirty & CEPH_CAP_XATTR_EXCL) {\n\t\t\t__ceph_build_xattrs_blob(ci);\n\t\t\tcapsnap->xattr_blob =\n\t\t\t\tceph_buffer_get(ci->i_xattrs.blob);\n\t\t\tcapsnap->xattr_version = ci->i_xattrs.version;\n\t\t} else {\n\t\t\tcapsnap->xattr_blob = NULL;\n\t\t\tcapsnap->xattr_version = 0;\n\t\t}\n\n\t\tcapsnap->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\t\t/* dirty page count moved from _head to this cap_snap;\n\t\t   all subsequent writes page dirties occur _after_ this\n\t\t   snapshot. */\n\t\tcapsnap->dirty_pages = ci->i_wrbuffer_ref_head;\n\t\tci->i_wrbuffer_ref_head = 0;\n\t\tcapsnap->context = snapc;\n\t\tci->i_head_snapc =\n\t\t\tceph_get_snap_context(ci->i_snap_realm->cached_context);\n\t\tdout(\" new snapc is %p\\n\", ci->i_head_snapc);\n\t\tlist_add_tail(&capsnap->ci_item, &ci->i_cap_snaps);\n\n\t\tif (used & CEPH_CAP_FILE_WR) {\n\t\t\tdout(\"queue_cap_snap %p cap_snap %p snapc %p\"\n\t\t\t     \" seq %llu used WR, now pending\\n\", inode,\n\t\t\t     capsnap, snapc, snapc->seq);\n\t\t\tcapsnap->writing = 1;\n\t\t} else {\n\t\t\t/* note mtime, size NOW. */\n\t\t\t__ceph_finish_cap_snap(ci, capsnap);\n\t\t}\n\t} else {\n\t\tdout(\"queue_cap_snap %p nothing dirty|writing\\n\", inode);\n\t\tkfree(capsnap);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ci",
            "&realm->inodes_with_caps",
            "i_snap_realm_item"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_realm_cap_snaps %p %llx inodes\\n\"",
            "realm",
            "realm->ino"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void queue_realm_cap_snaps(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *lastinode = NULL;\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"queue_realm_cap_snaps %p %llx inodes\\n\", realm, realm->ino);\n\n\tspin_lock(&realm->inodes_with_caps_lock);\n\tlist_for_each_entry(ci, &realm->inodes_with_caps,\n\t\t\t    i_snap_realm_item) {\n\t\tstruct inode *inode = igrab(&ci->vfs_inode);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tiput(lastinode);\n\t\tlastinode = inode;\n\t\tceph_queue_cap_snap(ci);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t}\n\tspin_unlock(&realm->inodes_with_caps_lock);\n\tiput(lastinode);\n\n\tlist_for_each_entry(child, &realm->children, child_item) {\n\t\tdout(\"queue_realm_cap_snaps %p %llx queue child %p %llx\\n\",\n\t\t     realm, realm->ino, child, child->ino);\n\t\tlist_del_init(&child->dirty_item);\n\t\tlist_add(&child->dirty_item, &realm->dirty_item);\n\t}\n\n\tlist_del_init(&realm->dirty_item);\n\tdout(\"queue_realm_cap_snaps %p %llx done\\n\", realm, realm->ino);\n}"
  },
  {
    "function_name": "__ceph_finish_cap_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "564-593",
    "snippet": "int __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = inode->i_size;\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode->i_ctime;\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", inode, capsnap,\n\t\t     capsnap->context, capsnap->context->seq,\n\t\t     ceph_cap_string(capsnap->dirty), capsnap->size,\n\t\t     capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     inode, capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;  /* caller may want to ceph_flush_snaps */\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ci->i_snap_flush_item",
            "&mdsc->snap_flush_list"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\"",
            "inode",
            "capsnap",
            "capsnap->context",
            "capsnap->context->seq",
            "ceph_cap_string(capsnap->dirty)",
            "capsnap->size"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "capsnap->dirty"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\"",
            "inode",
            "capsnap",
            "capsnap->context",
            "capsnap->context->seq",
            "ceph_cap_string(capsnap->dirty)",
            "capsnap->size",
            "capsnap->dirty_pages"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "capsnap->writing"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = inode->i_size;\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode->i_ctime;\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", inode, capsnap,\n\t\t     capsnap->context, capsnap->context->seq,\n\t\t     ceph_cap_string(capsnap->dirty), capsnap->size,\n\t\t     capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     inode, capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;  /* caller may want to ceph_flush_snaps */\n}"
  },
  {
    "function_name": "ceph_queue_cap_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "454-554",
    "snippet": "void ceph_queue_cap_snap(struct ceph_inode_info *ci)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap_snap *capsnap;\n\tint used, dirty;\n\n\tcapsnap = kzalloc(sizeof(*capsnap), GFP_NOFS);\n\tif (!capsnap) {\n\t\tpr_err(\"ENOMEM allocating ceph_cap_snap on %p\\n\", inode);\n\t\treturn;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\t/*\n\t * If there is a write in progress, treat that as a dirty Fw,\n\t * even though it hasn't completed yet; by the time we finish\n\t * up this capsnap it will be.\n\t */\n\tif (used & CEPH_CAP_FILE_WR)\n\t\tdirty |= CEPH_CAP_FILE_WR;\n\n\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t/* there is no point in queuing multiple \"pending\" cap_snaps,\n\t\t   as no new writes are allowed to start when pending, so any\n\t\t   writes in progress now were started before the previous\n\t\t   cap_snap.  lucky us. */\n\t\tdout(\"queue_cap_snap %p already pending\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (ci->i_snap_realm->cached_context == empty_snapc) {\n\t\tdout(\"queue_cap_snap %p empty snapc\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (dirty & (CEPH_CAP_AUTH_EXCL|CEPH_CAP_XATTR_EXCL|\n\t\t\t    CEPH_CAP_FILE_EXCL|CEPH_CAP_FILE_WR)) {\n\t\tstruct ceph_snap_context *snapc = ci->i_head_snapc;\n\n\t\t/*\n\t\t * if we are a sync write, we may need to go to the snaprealm\n\t\t * to get the current snapc.\n\t\t */\n\t\tif (!snapc)\n\t\t\tsnapc = ci->i_snap_realm->cached_context;\n\n\t\tdout(\"queue_cap_snap %p cap_snap %p queuing under %p %s\\n\",\n\t\t     inode, capsnap, snapc, ceph_cap_string(dirty));\n\t\tihold(inode);\n\n\t\tatomic_set(&capsnap->nref, 1);\n\t\tcapsnap->ci = ci;\n\t\tINIT_LIST_HEAD(&capsnap->ci_item);\n\t\tINIT_LIST_HEAD(&capsnap->flushing_item);\n\n\t\tcapsnap->follows = snapc->seq;\n\t\tcapsnap->issued = __ceph_caps_issued(ci, NULL);\n\t\tcapsnap->dirty = dirty;\n\n\t\tcapsnap->mode = inode->i_mode;\n\t\tcapsnap->uid = inode->i_uid;\n\t\tcapsnap->gid = inode->i_gid;\n\n\t\tif (dirty & CEPH_CAP_XATTR_EXCL) {\n\t\t\t__ceph_build_xattrs_blob(ci);\n\t\t\tcapsnap->xattr_blob =\n\t\t\t\tceph_buffer_get(ci->i_xattrs.blob);\n\t\t\tcapsnap->xattr_version = ci->i_xattrs.version;\n\t\t} else {\n\t\t\tcapsnap->xattr_blob = NULL;\n\t\t\tcapsnap->xattr_version = 0;\n\t\t}\n\n\t\tcapsnap->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\t\t/* dirty page count moved from _head to this cap_snap;\n\t\t   all subsequent writes page dirties occur _after_ this\n\t\t   snapshot. */\n\t\tcapsnap->dirty_pages = ci->i_wrbuffer_ref_head;\n\t\tci->i_wrbuffer_ref_head = 0;\n\t\tcapsnap->context = snapc;\n\t\tci->i_head_snapc =\n\t\t\tceph_get_snap_context(ci->i_snap_realm->cached_context);\n\t\tdout(\" new snapc is %p\\n\", ci->i_head_snapc);\n\t\tlist_add_tail(&capsnap->ci_item, &ci->i_cap_snaps);\n\n\t\tif (used & CEPH_CAP_FILE_WR) {\n\t\t\tdout(\"queue_cap_snap %p cap_snap %p snapc %p\"\n\t\t\t     \" seq %llu used WR, now pending\\n\", inode,\n\t\t\t     capsnap, snapc, snapc->seq);\n\t\t\tcapsnap->writing = 1;\n\t\t} else {\n\t\t\t/* note mtime, size NOW. */\n\t\t\t__ceph_finish_cap_snap(ci, capsnap);\n\t\t}\n\t} else {\n\t\tdout(\"queue_cap_snap %p nothing dirty|writing\\n\", inode);\n\t\tkfree(capsnap);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ceph_snap_context *empty_snapc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "capsnap"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_cap_snap %p nothing dirty|writing\\n\"",
            "inode"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_finish_cap_snap",
          "args": [
            "ci",
            "capsnap"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_finish_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "564-593",
          "snippet": "int __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = inode->i_size;\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode->i_ctime;\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", inode, capsnap,\n\t\t     capsnap->context, capsnap->context->seq,\n\t\t     ceph_cap_string(capsnap->dirty), capsnap->size,\n\t\t     capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     inode, capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;  /* caller may want to ceph_flush_snaps */\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = inode->i_size;\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode->i_ctime;\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", inode, capsnap,\n\t\t     capsnap->context, capsnap->context->seq,\n\t\t     ceph_cap_string(capsnap->dirty), capsnap->size,\n\t\t     capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     inode, capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;  /* caller may want to ceph_flush_snaps */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_cap_snap %p cap_snap %p snapc %p\"\n\t\t\t     \" seq %llu used WR, now pending\\n\"",
            "inode",
            "capsnap",
            "snapc",
            "snapc->seq"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&capsnap->ci_item",
            "&ci->i_cap_snaps"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" new snapc is %p\\n\"",
            "ci->i_head_snapc"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "ci->i_snap_realm->cached_context"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_get",
          "args": [
            "ci->i_xattrs.blob"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_build_xattrs_blob",
          "args": [
            "ci"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_build_xattrs_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "675-715",
          "snippet": "void __ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t/* adjust buffer len; it may be larger than we need */\n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nvoid __ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t/* adjust buffer len; it may be larger than we need */\n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&capsnap->flushing_item"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&capsnap->ci_item"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&capsnap->nref",
            "1"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_cap_snap %p cap_snap %p queuing under %p %s\\n\"",
            "inode",
            "capsnap",
            "snapc",
            "ceph_cap_string(dirty)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "dirty"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "capsnap"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_cap_snap %p empty snapc\\n\"",
            "inode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "capsnap"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"queue_cap_snap %p already pending\\n\"",
            "inode"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_have_pending_cap_snap",
          "args": [
            "ci"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_have_pending_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "712-717",
          "snippet": "static inline bool __ceph_have_pending_cap_snap(struct ceph_inode_info *ci)\n{\n\treturn !list_empty(&ci->i_cap_snaps) &&\n\t\tlist_entry(ci->i_cap_snaps.prev, struct ceph_cap_snap,\n\t\t\t   ci_item)->writing;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool __ceph_have_pending_cap_snap(struct ceph_inode_info *ci)\n{\n\treturn !list_empty(&ci->i_cap_snaps) &&\n\t\tlist_entry(ci->i_cap_snaps.prev, struct ceph_cap_snap,\n\t\t\t   ci_item)->writing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ENOMEM allocating ceph_cap_snap on %p\\n\"",
            "inode"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*capsnap)",
            "GFP_NOFS"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *empty_snapc;\n\nvoid ceph_queue_cap_snap(struct ceph_inode_info *ci)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap_snap *capsnap;\n\tint used, dirty;\n\n\tcapsnap = kzalloc(sizeof(*capsnap), GFP_NOFS);\n\tif (!capsnap) {\n\t\tpr_err(\"ENOMEM allocating ceph_cap_snap on %p\\n\", inode);\n\t\treturn;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\t/*\n\t * If there is a write in progress, treat that as a dirty Fw,\n\t * even though it hasn't completed yet; by the time we finish\n\t * up this capsnap it will be.\n\t */\n\tif (used & CEPH_CAP_FILE_WR)\n\t\tdirty |= CEPH_CAP_FILE_WR;\n\n\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t/* there is no point in queuing multiple \"pending\" cap_snaps,\n\t\t   as no new writes are allowed to start when pending, so any\n\t\t   writes in progress now were started before the previous\n\t\t   cap_snap.  lucky us. */\n\t\tdout(\"queue_cap_snap %p already pending\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (ci->i_snap_realm->cached_context == empty_snapc) {\n\t\tdout(\"queue_cap_snap %p empty snapc\\n\", inode);\n\t\tkfree(capsnap);\n\t} else if (dirty & (CEPH_CAP_AUTH_EXCL|CEPH_CAP_XATTR_EXCL|\n\t\t\t    CEPH_CAP_FILE_EXCL|CEPH_CAP_FILE_WR)) {\n\t\tstruct ceph_snap_context *snapc = ci->i_head_snapc;\n\n\t\t/*\n\t\t * if we are a sync write, we may need to go to the snaprealm\n\t\t * to get the current snapc.\n\t\t */\n\t\tif (!snapc)\n\t\t\tsnapc = ci->i_snap_realm->cached_context;\n\n\t\tdout(\"queue_cap_snap %p cap_snap %p queuing under %p %s\\n\",\n\t\t     inode, capsnap, snapc, ceph_cap_string(dirty));\n\t\tihold(inode);\n\n\t\tatomic_set(&capsnap->nref, 1);\n\t\tcapsnap->ci = ci;\n\t\tINIT_LIST_HEAD(&capsnap->ci_item);\n\t\tINIT_LIST_HEAD(&capsnap->flushing_item);\n\n\t\tcapsnap->follows = snapc->seq;\n\t\tcapsnap->issued = __ceph_caps_issued(ci, NULL);\n\t\tcapsnap->dirty = dirty;\n\n\t\tcapsnap->mode = inode->i_mode;\n\t\tcapsnap->uid = inode->i_uid;\n\t\tcapsnap->gid = inode->i_gid;\n\n\t\tif (dirty & CEPH_CAP_XATTR_EXCL) {\n\t\t\t__ceph_build_xattrs_blob(ci);\n\t\t\tcapsnap->xattr_blob =\n\t\t\t\tceph_buffer_get(ci->i_xattrs.blob);\n\t\t\tcapsnap->xattr_version = ci->i_xattrs.version;\n\t\t} else {\n\t\t\tcapsnap->xattr_blob = NULL;\n\t\t\tcapsnap->xattr_version = 0;\n\t\t}\n\n\t\tcapsnap->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\t\t/* dirty page count moved from _head to this cap_snap;\n\t\t   all subsequent writes page dirties occur _after_ this\n\t\t   snapshot. */\n\t\tcapsnap->dirty_pages = ci->i_wrbuffer_ref_head;\n\t\tci->i_wrbuffer_ref_head = 0;\n\t\tcapsnap->context = snapc;\n\t\tci->i_head_snapc =\n\t\t\tceph_get_snap_context(ci->i_snap_realm->cached_context);\n\t\tdout(\" new snapc is %p\\n\", ci->i_head_snapc);\n\t\tlist_add_tail(&capsnap->ci_item, &ci->i_cap_snaps);\n\n\t\tif (used & CEPH_CAP_FILE_WR) {\n\t\t\tdout(\"queue_cap_snap %p cap_snap %p snapc %p\"\n\t\t\t     \" seq %llu used WR, now pending\\n\", inode,\n\t\t\t     capsnap, snapc, snapc->seq);\n\t\t\tcapsnap->writing = 1;\n\t\t} else {\n\t\t\t/* note mtime, size NOW. */\n\t\t\t__ceph_finish_cap_snap(ci, capsnap);\n\t\t}\n\t} else {\n\t\tdout(\"queue_cap_snap %p nothing dirty|writing\\n\", inode);\n\t\tkfree(capsnap);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n}"
  },
  {
    "function_name": "dup_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "422-437",
    "snippet": "static int dup_array(u64 **dst, __le64 *src, u32 num)\n{\n\tu32 i;\n\n\tkfree(*dst);\n\tif (num) {\n\t\t*dst = kcalloc(num, sizeof(u64), GFP_NOFS);\n\t\tif (!*dst)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < num; i++)\n\t\t\t(*dst)[i] = get_unaligned_le64(src + i);\n\t} else {\n\t\t*dst = NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_unaligned_le64",
          "args": [
            "src + i"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num",
            "sizeof(u64)",
            "GFP_NOFS"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*dst"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int dup_array(u64 **dst, __le64 *src, u32 num)\n{\n\tu32 i;\n\n\tkfree(*dst);\n\tif (num) {\n\t\t*dst = kcalloc(num, sizeof(u64), GFP_NOFS);\n\t\tif (!*dst)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < num; i++)\n\t\t\t(*dst)[i] = get_unaligned_le64(src + i);\n\t} else {\n\t\t*dst = NULL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rebuild_snap_realms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "406-415",
    "snippet": "static void rebuild_snap_realms(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"rebuild_snap_realms %llx %p\\n\", realm->ino, realm);\n\tbuild_snap_context(realm);\n\n\tlist_for_each_entry(child, &realm->children, child_item)\n\t\trebuild_snap_realms(child);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rebuild_snap_realms",
          "args": [
            "child"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_snap_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "406-415",
          "snippet": "static void rebuild_snap_realms(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"rebuild_snap_realms %llx %p\\n\", realm->ino, realm);\n\tbuild_snap_context(realm);\n\n\tlist_for_each_entry(child, &realm->children, child_item)\n\t\trebuild_snap_realms(child);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&realm->children",
            "child_item"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_snap_context",
          "args": [
            "realm"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "build_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "304-401",
          "snippet": "static int build_snap_context(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *parent = realm->parent;\n\tstruct ceph_snap_context *snapc;\n\tint err = 0;\n\tu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\n\n\t/*\n\t * build parent context, if it hasn't been built.\n\t * conservatively estimate that all parent snaps might be\n\t * included by us.\n\t */\n\tif (parent) {\n\t\tif (!parent->cached_context) {\n\t\t\terr = build_snap_context(parent);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tnum += parent->cached_context->num_snaps;\n\t}\n\n\t/* do i actually need to update?  not if my context seq\n\t   matches realm seq, and my parents' does to.  (this works\n\t   because we rebuild_snap_realms() works _downward_ in\n\t   hierarchy after each update.) */\n\tif (realm->cached_context &&\n\t    realm->cached_context->seq == realm->seq &&\n\t    (!parent ||\n\t     realm->cached_context->seq >= parent->cached_context->seq)) {\n\t\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\"\n\t\t     \" (unchanged)\\n\",\n\t\t     realm->ino, realm, realm->cached_context,\n\t\t     realm->cached_context->seq,\n\t\t     (unsigned int) realm->cached_context->num_snaps);\n\t\treturn 0;\n\t}\n\n\tif (num == 0 && realm->seq == empty_snapc->seq) {\n\t\tceph_get_snap_context(empty_snapc);\n\t\tsnapc = empty_snapc;\n\t\tgoto done;\n\t}\n\n\t/* alloc new snap context */\n\terr = -ENOMEM;\n\tif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\n\t\tgoto fail;\n\tsnapc = ceph_create_snap_context(num, GFP_NOFS);\n\tif (!snapc)\n\t\tgoto fail;\n\n\t/* build (reverse sorted) snap vector */\n\tnum = 0;\n\tsnapc->seq = realm->seq;\n\tif (parent) {\n\t\tu32 i;\n\n\t\t/* include any of parent's snaps occurring _after_ my\n\t\t   parent became my parent */\n\t\tfor (i = 0; i < parent->cached_context->num_snaps; i++)\n\t\t\tif (parent->cached_context->snaps[i] >=\n\t\t\t    realm->parent_since)\n\t\t\t\tsnapc->snaps[num++] =\n\t\t\t\t\tparent->cached_context->snaps[i];\n\t\tif (parent->cached_context->seq > snapc->seq)\n\t\t\tsnapc->seq = parent->cached_context->seq;\n\t}\n\tmemcpy(snapc->snaps + num, realm->snaps,\n\t       sizeof(u64)*realm->num_snaps);\n\tnum += realm->num_snaps;\n\tmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\n\t       sizeof(u64)*realm->num_prior_parent_snaps);\n\tnum += realm->num_prior_parent_snaps;\n\n\tsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\n\tsnapc->num_snaps = num;\n\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\\n\",\n\t     realm->ino, realm, snapc, snapc->seq,\n\t     (unsigned int) snapc->num_snaps);\n\ndone:\n\tceph_put_snap_context(realm->cached_context);\n\trealm->cached_context = snapc;\n\treturn 0;\n\nfail:\n\t/*\n\t * if we fail, clear old (incorrect) cached_context... hopefully\n\t * we'll have better luck building it later\n\t */\n\tif (realm->cached_context) {\n\t\tceph_put_snap_context(realm->cached_context);\n\t\trealm->cached_context = NULL;\n\t}\n\tpr_err(\"build_snap_context %llx %p fail %d\\n\", realm->ino,\n\t       realm, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);",
            "static struct ceph_snap_context *empty_snapc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\nstatic struct ceph_snap_context *empty_snapc;\n\nstatic int build_snap_context(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *parent = realm->parent;\n\tstruct ceph_snap_context *snapc;\n\tint err = 0;\n\tu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\n\n\t/*\n\t * build parent context, if it hasn't been built.\n\t * conservatively estimate that all parent snaps might be\n\t * included by us.\n\t */\n\tif (parent) {\n\t\tif (!parent->cached_context) {\n\t\t\terr = build_snap_context(parent);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tnum += parent->cached_context->num_snaps;\n\t}\n\n\t/* do i actually need to update?  not if my context seq\n\t   matches realm seq, and my parents' does to.  (this works\n\t   because we rebuild_snap_realms() works _downward_ in\n\t   hierarchy after each update.) */\n\tif (realm->cached_context &&\n\t    realm->cached_context->seq == realm->seq &&\n\t    (!parent ||\n\t     realm->cached_context->seq >= parent->cached_context->seq)) {\n\t\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\"\n\t\t     \" (unchanged)\\n\",\n\t\t     realm->ino, realm, realm->cached_context,\n\t\t     realm->cached_context->seq,\n\t\t     (unsigned int) realm->cached_context->num_snaps);\n\t\treturn 0;\n\t}\n\n\tif (num == 0 && realm->seq == empty_snapc->seq) {\n\t\tceph_get_snap_context(empty_snapc);\n\t\tsnapc = empty_snapc;\n\t\tgoto done;\n\t}\n\n\t/* alloc new snap context */\n\terr = -ENOMEM;\n\tif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\n\t\tgoto fail;\n\tsnapc = ceph_create_snap_context(num, GFP_NOFS);\n\tif (!snapc)\n\t\tgoto fail;\n\n\t/* build (reverse sorted) snap vector */\n\tnum = 0;\n\tsnapc->seq = realm->seq;\n\tif (parent) {\n\t\tu32 i;\n\n\t\t/* include any of parent's snaps occurring _after_ my\n\t\t   parent became my parent */\n\t\tfor (i = 0; i < parent->cached_context->num_snaps; i++)\n\t\t\tif (parent->cached_context->snaps[i] >=\n\t\t\t    realm->parent_since)\n\t\t\t\tsnapc->snaps[num++] =\n\t\t\t\t\tparent->cached_context->snaps[i];\n\t\tif (parent->cached_context->seq > snapc->seq)\n\t\t\tsnapc->seq = parent->cached_context->seq;\n\t}\n\tmemcpy(snapc->snaps + num, realm->snaps,\n\t       sizeof(u64)*realm->num_snaps);\n\tnum += realm->num_snaps;\n\tmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\n\t       sizeof(u64)*realm->num_prior_parent_snaps);\n\tnum += realm->num_prior_parent_snaps;\n\n\tsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\n\tsnapc->num_snaps = num;\n\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\\n\",\n\t     realm->ino, realm, snapc, snapc->seq,\n\t     (unsigned int) snapc->num_snaps);\n\ndone:\n\tceph_put_snap_context(realm->cached_context);\n\trealm->cached_context = snapc;\n\treturn 0;\n\nfail:\n\t/*\n\t * if we fail, clear old (incorrect) cached_context... hopefully\n\t * we'll have better luck building it later\n\t */\n\tif (realm->cached_context) {\n\t\tceph_put_snap_context(realm->cached_context);\n\t\trealm->cached_context = NULL;\n\t}\n\tpr_err(\"build_snap_context %llx %p fail %d\\n\", realm->ino,\n\t       realm, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"rebuild_snap_realms %llx %p\\n\"",
            "realm->ino",
            "realm"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void rebuild_snap_realms(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *child;\n\n\tdout(\"rebuild_snap_realms %llx %p\\n\", realm->ino, realm);\n\tbuild_snap_context(realm);\n\n\tlist_for_each_entry(child, &realm->children, child_item)\n\t\trebuild_snap_realms(child);\n}"
  },
  {
    "function_name": "build_snap_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "304-401",
    "snippet": "static int build_snap_context(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *parent = realm->parent;\n\tstruct ceph_snap_context *snapc;\n\tint err = 0;\n\tu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\n\n\t/*\n\t * build parent context, if it hasn't been built.\n\t * conservatively estimate that all parent snaps might be\n\t * included by us.\n\t */\n\tif (parent) {\n\t\tif (!parent->cached_context) {\n\t\t\terr = build_snap_context(parent);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tnum += parent->cached_context->num_snaps;\n\t}\n\n\t/* do i actually need to update?  not if my context seq\n\t   matches realm seq, and my parents' does to.  (this works\n\t   because we rebuild_snap_realms() works _downward_ in\n\t   hierarchy after each update.) */\n\tif (realm->cached_context &&\n\t    realm->cached_context->seq == realm->seq &&\n\t    (!parent ||\n\t     realm->cached_context->seq >= parent->cached_context->seq)) {\n\t\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\"\n\t\t     \" (unchanged)\\n\",\n\t\t     realm->ino, realm, realm->cached_context,\n\t\t     realm->cached_context->seq,\n\t\t     (unsigned int) realm->cached_context->num_snaps);\n\t\treturn 0;\n\t}\n\n\tif (num == 0 && realm->seq == empty_snapc->seq) {\n\t\tceph_get_snap_context(empty_snapc);\n\t\tsnapc = empty_snapc;\n\t\tgoto done;\n\t}\n\n\t/* alloc new snap context */\n\terr = -ENOMEM;\n\tif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\n\t\tgoto fail;\n\tsnapc = ceph_create_snap_context(num, GFP_NOFS);\n\tif (!snapc)\n\t\tgoto fail;\n\n\t/* build (reverse sorted) snap vector */\n\tnum = 0;\n\tsnapc->seq = realm->seq;\n\tif (parent) {\n\t\tu32 i;\n\n\t\t/* include any of parent's snaps occurring _after_ my\n\t\t   parent became my parent */\n\t\tfor (i = 0; i < parent->cached_context->num_snaps; i++)\n\t\t\tif (parent->cached_context->snaps[i] >=\n\t\t\t    realm->parent_since)\n\t\t\t\tsnapc->snaps[num++] =\n\t\t\t\t\tparent->cached_context->snaps[i];\n\t\tif (parent->cached_context->seq > snapc->seq)\n\t\t\tsnapc->seq = parent->cached_context->seq;\n\t}\n\tmemcpy(snapc->snaps + num, realm->snaps,\n\t       sizeof(u64)*realm->num_snaps);\n\tnum += realm->num_snaps;\n\tmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\n\t       sizeof(u64)*realm->num_prior_parent_snaps);\n\tnum += realm->num_prior_parent_snaps;\n\n\tsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\n\tsnapc->num_snaps = num;\n\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\\n\",\n\t     realm->ino, realm, snapc, snapc->seq,\n\t     (unsigned int) snapc->num_snaps);\n\ndone:\n\tceph_put_snap_context(realm->cached_context);\n\trealm->cached_context = snapc;\n\treturn 0;\n\nfail:\n\t/*\n\t * if we fail, clear old (incorrect) cached_context... hopefully\n\t * we'll have better luck building it later\n\t */\n\tif (realm->cached_context) {\n\t\tceph_put_snap_context(realm->cached_context);\n\t\trealm->cached_context = NULL;\n\t}\n\tpr_err(\"build_snap_context %llx %p fail %d\\n\", realm->ino,\n\t       realm, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);",
      "static struct ceph_snap_context *empty_snapc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"build_snap_context %llx %p fail %d\\n\"",
            "realm->ino",
            "realm",
            "err"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "realm->cached_context"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "realm->cached_context"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"build_snap_context %llx %p: %p seq %lld (%u snaps)\\n\"",
            "realm->ino",
            "realm",
            "snapc",
            "snapc->seq",
            "(unsigned int) snapc->num_snaps"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "snapc->snaps",
            "num",
            "sizeof(u64)",
            "cmpu64_rev",
            "NULL"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "snapc->snaps + num",
            "realm->prior_parent_snaps",
            "sizeof(u64)*realm->num_prior_parent_snaps"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "snapc->snaps + num",
            "realm->snaps",
            "sizeof(u64)*realm->num_snaps"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_create_snap_context",
          "args": [
            "num",
            "GFP_NOFS"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "empty_snapc"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"build_snap_context %llx %p: %p seq %lld (%u snaps)\"\n\t\t     \" (unchanged)\\n\"",
            "realm->ino",
            "realm",
            "realm->cached_context",
            "realm->cached_context->seq",
            "(unsigned int) realm->cached_context->num_snaps"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_snap_context",
          "args": [
            "parent"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "build_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "304-401",
          "snippet": "static int build_snap_context(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *parent = realm->parent;\n\tstruct ceph_snap_context *snapc;\n\tint err = 0;\n\tu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\n\n\t/*\n\t * build parent context, if it hasn't been built.\n\t * conservatively estimate that all parent snaps might be\n\t * included by us.\n\t */\n\tif (parent) {\n\t\tif (!parent->cached_context) {\n\t\t\terr = build_snap_context(parent);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tnum += parent->cached_context->num_snaps;\n\t}\n\n\t/* do i actually need to update?  not if my context seq\n\t   matches realm seq, and my parents' does to.  (this works\n\t   because we rebuild_snap_realms() works _downward_ in\n\t   hierarchy after each update.) */\n\tif (realm->cached_context &&\n\t    realm->cached_context->seq == realm->seq &&\n\t    (!parent ||\n\t     realm->cached_context->seq >= parent->cached_context->seq)) {\n\t\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\"\n\t\t     \" (unchanged)\\n\",\n\t\t     realm->ino, realm, realm->cached_context,\n\t\t     realm->cached_context->seq,\n\t\t     (unsigned int) realm->cached_context->num_snaps);\n\t\treturn 0;\n\t}\n\n\tif (num == 0 && realm->seq == empty_snapc->seq) {\n\t\tceph_get_snap_context(empty_snapc);\n\t\tsnapc = empty_snapc;\n\t\tgoto done;\n\t}\n\n\t/* alloc new snap context */\n\terr = -ENOMEM;\n\tif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\n\t\tgoto fail;\n\tsnapc = ceph_create_snap_context(num, GFP_NOFS);\n\tif (!snapc)\n\t\tgoto fail;\n\n\t/* build (reverse sorted) snap vector */\n\tnum = 0;\n\tsnapc->seq = realm->seq;\n\tif (parent) {\n\t\tu32 i;\n\n\t\t/* include any of parent's snaps occurring _after_ my\n\t\t   parent became my parent */\n\t\tfor (i = 0; i < parent->cached_context->num_snaps; i++)\n\t\t\tif (parent->cached_context->snaps[i] >=\n\t\t\t    realm->parent_since)\n\t\t\t\tsnapc->snaps[num++] =\n\t\t\t\t\tparent->cached_context->snaps[i];\n\t\tif (parent->cached_context->seq > snapc->seq)\n\t\t\tsnapc->seq = parent->cached_context->seq;\n\t}\n\tmemcpy(snapc->snaps + num, realm->snaps,\n\t       sizeof(u64)*realm->num_snaps);\n\tnum += realm->num_snaps;\n\tmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\n\t       sizeof(u64)*realm->num_prior_parent_snaps);\n\tnum += realm->num_prior_parent_snaps;\n\n\tsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\n\tsnapc->num_snaps = num;\n\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\\n\",\n\t     realm->ino, realm, snapc, snapc->seq,\n\t     (unsigned int) snapc->num_snaps);\n\ndone:\n\tceph_put_snap_context(realm->cached_context);\n\trealm->cached_context = snapc;\n\treturn 0;\n\nfail:\n\t/*\n\t * if we fail, clear old (incorrect) cached_context... hopefully\n\t * we'll have better luck building it later\n\t */\n\tif (realm->cached_context) {\n\t\tceph_put_snap_context(realm->cached_context);\n\t\trealm->cached_context = NULL;\n\t}\n\tpr_err(\"build_snap_context %llx %p fail %d\\n\", realm->ino,\n\t       realm, err);\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\nstatic struct ceph_snap_context *empty_snapc;\n\nstatic int build_snap_context(struct ceph_snap_realm *realm)\n{\n\tstruct ceph_snap_realm *parent = realm->parent;\n\tstruct ceph_snap_context *snapc;\n\tint err = 0;\n\tu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\n\n\t/*\n\t * build parent context, if it hasn't been built.\n\t * conservatively estimate that all parent snaps might be\n\t * included by us.\n\t */\n\tif (parent) {\n\t\tif (!parent->cached_context) {\n\t\t\terr = build_snap_context(parent);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tnum += parent->cached_context->num_snaps;\n\t}\n\n\t/* do i actually need to update?  not if my context seq\n\t   matches realm seq, and my parents' does to.  (this works\n\t   because we rebuild_snap_realms() works _downward_ in\n\t   hierarchy after each update.) */\n\tif (realm->cached_context &&\n\t    realm->cached_context->seq == realm->seq &&\n\t    (!parent ||\n\t     realm->cached_context->seq >= parent->cached_context->seq)) {\n\t\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\"\n\t\t     \" (unchanged)\\n\",\n\t\t     realm->ino, realm, realm->cached_context,\n\t\t     realm->cached_context->seq,\n\t\t     (unsigned int) realm->cached_context->num_snaps);\n\t\treturn 0;\n\t}\n\n\tif (num == 0 && realm->seq == empty_snapc->seq) {\n\t\tceph_get_snap_context(empty_snapc);\n\t\tsnapc = empty_snapc;\n\t\tgoto done;\n\t}\n\n\t/* alloc new snap context */\n\terr = -ENOMEM;\n\tif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\n\t\tgoto fail;\n\tsnapc = ceph_create_snap_context(num, GFP_NOFS);\n\tif (!snapc)\n\t\tgoto fail;\n\n\t/* build (reverse sorted) snap vector */\n\tnum = 0;\n\tsnapc->seq = realm->seq;\n\tif (parent) {\n\t\tu32 i;\n\n\t\t/* include any of parent's snaps occurring _after_ my\n\t\t   parent became my parent */\n\t\tfor (i = 0; i < parent->cached_context->num_snaps; i++)\n\t\t\tif (parent->cached_context->snaps[i] >=\n\t\t\t    realm->parent_since)\n\t\t\t\tsnapc->snaps[num++] =\n\t\t\t\t\tparent->cached_context->snaps[i];\n\t\tif (parent->cached_context->seq > snapc->seq)\n\t\t\tsnapc->seq = parent->cached_context->seq;\n\t}\n\tmemcpy(snapc->snaps + num, realm->snaps,\n\t       sizeof(u64)*realm->num_snaps);\n\tnum += realm->num_snaps;\n\tmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\n\t       sizeof(u64)*realm->num_prior_parent_snaps);\n\tnum += realm->num_prior_parent_snaps;\n\n\tsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\n\tsnapc->num_snaps = num;\n\tdout(\"build_snap_context %llx %p: %p seq %lld (%u snaps)\\n\",\n\t     realm->ino, realm, snapc, snapc->seq,\n\t     (unsigned int) snapc->num_snaps);\n\ndone:\n\tceph_put_snap_context(realm->cached_context);\n\trealm->cached_context = snapc;\n\treturn 0;\n\nfail:\n\t/*\n\t * if we fail, clear old (incorrect) cached_context... hopefully\n\t * we'll have better luck building it later\n\t */\n\tif (realm->cached_context) {\n\t\tceph_put_snap_context(realm->cached_context);\n\t\trealm->cached_context = NULL;\n\t}\n\tpr_err(\"build_snap_context %llx %p fail %d\\n\", realm->ino,\n\t       realm, err);\n\treturn err;\n}"
  },
  {
    "function_name": "cmpu64_rev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "289-296",
    "snippet": "static int cmpu64_rev(const void *a, const void *b)\n{\n\tif (*(u64 *)a < *(u64 *)b)\n\t\treturn 1;\n\tif (*(u64 *)a > *(u64 *)b)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int cmpu64_rev(const void *a, const void *b)\n{\n\tif (*(u64 *)a < *(u64 *)b)\n\t\treturn 1;\n\tif (*(u64 *)a > *(u64 *)b)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "adjust_snap_realm_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "260-286",
    "snippet": "static int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\",\n\t     realm->ino, realm, realm->parent_ino, realm->parent,\n\t     parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&realm->child_item",
            "&parent->children"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "realm->parent"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&realm->child_item"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\"",
            "realm->ino",
            "realm",
            "realm->parent_ino",
            "realm->parent",
            "parentino",
            "parent"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_create_snap_realm",
          "args": [
            "mdsc",
            "parentino"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_create_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "107-128",
          "snippet": "static struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_lookup_snap_realm",
          "args": [
            "mdsc",
            "parentino"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lookup_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "155-163",
          "snippet": "struct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\n\t\t\t\t    struct ceph_snap_realm *realm,\n\t\t\t\t    u64 parentino)\n{\n\tstruct ceph_snap_realm *parent;\n\n\tif (realm->parent_ino == parentino)\n\t\treturn 0;\n\n\tparent = ceph_lookup_snap_realm(mdsc, parentino);\n\tif (!parent) {\n\t\tparent = ceph_create_snap_realm(mdsc, parentino);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t}\n\tdout(\"adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\\n\",\n\t     realm->ino, realm, realm->parent_ino, realm->parent,\n\t     parentino, parent);\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\tceph_put_snap_realm(mdsc, realm->parent);\n\t}\n\trealm->parent_ino = parentino;\n\trealm->parent = parent;\n\tlist_add(&realm->child_item, &parent->children);\n\treturn 1;\n}"
  },
  {
    "function_name": "ceph_cleanup_empty_realms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "245-250",
    "snippet": "void ceph_cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tdown_write(&mdsc->snap_rwsem);\n\t__cleanup_empty_realms(mdsc);\n\tup_write(&mdsc->snap_rwsem);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_empty_realms",
          "args": [
            "mdsc"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_empty_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "229-243",
          "snippet": "static void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tdown_write(&mdsc->snap_rwsem);\n\t__cleanup_empty_realms(mdsc);\n\tup_write(&mdsc->snap_rwsem);\n}"
  },
  {
    "function_name": "__cleanup_empty_realms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "229-243",
    "snippet": "static void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__destroy_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "171-187",
          "snippet": "static void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&realm->empty_item"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mdsc->snap_empty",
            "structceph_snap_realm",
            "empty_item"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->snap_empty"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_snap_realm *realm;\n\n\tspin_lock(&mdsc->snap_empty_lock);\n\twhile (!list_empty(&mdsc->snap_empty)) {\n\t\trealm = list_first_entry(&mdsc->snap_empty,\n\t\t\t\t   struct ceph_snap_realm, empty_item);\n\t\tlist_del(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t}\n\tspin_unlock(&mdsc->snap_empty_lock);\n}"
  },
  {
    "function_name": "ceph_put_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "204-220",
    "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&realm->empty_item",
            "&mdsc->snap_empty"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__destroy_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "171-187",
          "snippet": "static void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write_trylock",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&realm->nref"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_snap_realm %llx %p %d -> %d\\n\"",
            "realm->ino",
            "realm",
            "atomic_read(&realm->nref)",
            "atomic_read(&realm->nref)-1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&realm->nref"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&realm->nref"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
  },
  {
    "function_name": "__put_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "192-199",
    "snippet": "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm)\n{\n\tdout(\"__put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (atomic_dec_and_test(&realm->nref))\n\t\t__destroy_snap_realm(mdsc, realm);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "171-187",
          "snippet": "static void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&realm->nref"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__put_snap_realm %llx %p %d -> %d\\n\"",
            "realm->ino",
            "realm",
            "atomic_read(&realm->nref)",
            "atomic_read(&realm->nref)-1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&realm->nref"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&realm->nref"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm)\n{\n\tdout(\"__put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (atomic_dec_and_test(&realm->nref))\n\t\t__destroy_snap_realm(mdsc, realm);\n}"
  },
  {
    "function_name": "__destroy_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "171-187",
    "snippet": "static void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "realm"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "realm->cached_context"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "realm->snaps"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "realm->prior_parent_snaps"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_snap_realm",
          "args": [
            "mdsc",
            "realm->parent"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "192-199",
          "snippet": "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm)\n{\n\tdout(\"__put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (atomic_dec_and_test(&realm->nref))\n\t\t__destroy_snap_realm(mdsc, realm);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm)\n{\n\tdout(\"__put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (atomic_dec_and_test(&realm->nref))\n\t\t__destroy_snap_realm(mdsc, realm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&realm->child_item"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&realm->node",
            "&mdsc->snap_realms"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__destroy_snap_realm %p %llx\\n\"",
            "realm",
            "realm->ino"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic void __destroy_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"__destroy_snap_realm %p %llx\\n\", realm, realm->ino);\n\n\trb_erase(&realm->node, &mdsc->snap_realms);\n\n\tif (realm->parent) {\n\t\tlist_del_init(&realm->child_item);\n\t\t__put_snap_realm(mdsc, realm->parent);\n\t}\n\n\tkfree(realm->prior_parent_snaps);\n\tkfree(realm->snaps);\n\tceph_put_snap_context(realm->cached_context);\n\tkfree(realm);\n}"
  },
  {
    "function_name": "ceph_lookup_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "155-163",
    "snippet": "struct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_get_snap_realm",
          "args": [
            "mdsc",
            "r"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "62-78",
          "snippet": "void ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"get_realm %p %d -> %d\\n\", realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)+1);\n\t/*\n\t * since we _only_ increment realm refs or empty the empty\n\t * list with snap_rwsem held, adjusting the empty list here is\n\t * safe.  we do need to protect against concurrent empty list\n\t * additions, however.\n\t */\n\tif (atomic_inc_return(&realm->nref) == 1) {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_del_init(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"get_realm %p %d -> %d\\n\", realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)+1);\n\t/*\n\t * since we _only_ increment realm refs or empty the empty\n\t * list with snap_rwsem held, adjusting the empty list here is\n\t * safe.  we do need to protect against concurrent empty list\n\t * additions, however.\n\t */\n\tif (atomic_inc_return(&realm->nref) == 1) {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_del_init(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_snap_realm",
          "args": [
            "mdsc",
            "ino"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "135-153",
          "snippet": "static struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"lookup_snap_realm %llx %p\\n\", r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"lookup_snap_realm %llx %p\\n\", r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}"
  },
  {
    "function_name": "__lookup_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "135-153",
    "snippet": "static struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"lookup_snap_realm %llx %p\\n\", r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"lookup_snap_realm %llx %p\\n\"",
            "r->ino",
            "r"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structceph_snap_realm",
            "node"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_realm *__lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   u64 ino)\n{\n\tstruct rb_node *n = mdsc->snap_realms.rb_node;\n\tstruct ceph_snap_realm *r;\n\n\twhile (n) {\n\t\tr = rb_entry(n, struct ceph_snap_realm, node);\n\t\tif (ino < r->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > r->ino)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tdout(\"lookup_snap_realm %llx %p\\n\", r->ino, r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ceph_create_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "107-128",
    "snippet": "static struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"create_snap_realm %llx %p\\n\"",
            "realm->ino",
            "realm"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_snap_realm",
          "args": [
            "&mdsc->snap_realms",
            "realm"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "80-100",
          "snippet": "static void __insert_snap_realm(struct rb_root *root,\n\t\t\t\tstruct ceph_snap_realm *new)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_snap_realm *r = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tr = rb_entry(parent, struct ceph_snap_realm, node);\n\t\tif (new->ino < r->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->ino > r->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->node, parent, p);\n\trb_insert_color(&new->node, root);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __insert_snap_realm(struct rb_root *root,\n\t\t\t\tstruct ceph_snap_realm *new)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_snap_realm *r = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tr = rb_entry(parent, struct ceph_snap_realm, node);\n\t\tif (new->ino < r->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->ino > r->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->node, parent, p);\n\trb_insert_color(&new->node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&realm->inodes_with_caps"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&realm->dirty_item"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&realm->empty_item"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&realm->child_item"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&realm->children"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&realm->nref",
            "1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*realm)",
            "GFP_NOFS"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nstatic struct ceph_snap_realm *ceph_create_snap_realm(\n\tstruct ceph_mds_client *mdsc,\n\tu64 ino)\n{\n\tstruct ceph_snap_realm *realm;\n\n\trealm = kzalloc(sizeof(*realm), GFP_NOFS);\n\tif (!realm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&realm->nref, 1);    /* for caller */\n\trealm->ino = ino;\n\tINIT_LIST_HEAD(&realm->children);\n\tINIT_LIST_HEAD(&realm->child_item);\n\tINIT_LIST_HEAD(&realm->empty_item);\n\tINIT_LIST_HEAD(&realm->dirty_item);\n\tINIT_LIST_HEAD(&realm->inodes_with_caps);\n\tspin_lock_init(&realm->inodes_with_caps_lock);\n\t__insert_snap_realm(&mdsc->snap_realms, realm);\n\tdout(\"create_snap_realm %llx %p\\n\", realm->ino, realm);\n\treturn realm;\n}"
  },
  {
    "function_name": "__insert_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "80-100",
    "snippet": "static void __insert_snap_realm(struct rb_root *root,\n\t\t\t\tstruct ceph_snap_realm *new)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_snap_realm *r = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tr = rb_entry(parent, struct ceph_snap_realm, node);\n\t\tif (new->ino < r->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->ino > r->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->node, parent, p);\n\trb_insert_color(&new->node, root);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->node",
            "root"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->node",
            "parent",
            "p"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structceph_snap_realm",
            "node"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __insert_snap_realm(struct rb_root *root,\n\t\t\t\tstruct ceph_snap_realm *new)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_snap_realm *r = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tr = rb_entry(parent, struct ceph_snap_realm, node);\n\t\tif (new->ino < r->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->ino > r->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->node, parent, p);\n\trb_insert_color(&new->node, root);\n}"
  },
  {
    "function_name": "ceph_get_snap_realm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
    "lines": "62-78",
    "snippet": "void ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"get_realm %p %d -> %d\\n\", realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)+1);\n\t/*\n\t * since we _only_ increment realm refs or empty the empty\n\t * list with snap_rwsem held, adjusting the empty list here is\n\t * safe.  we do need to protect against concurrent empty list\n\t * additions, however.\n\t */\n\tif (atomic_inc_return(&realm->nref) == 1) {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_del_init(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&realm->empty_item"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&realm->nref"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_realm %p %d -> %d\\n\"",
            "realm",
            "atomic_read(&realm->nref)",
            "atomic_read(&realm->nref)+1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&realm->nref"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&realm->nref"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_get_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"get_realm %p %d -> %d\\n\", realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)+1);\n\t/*\n\t * since we _only_ increment realm refs or empty the empty\n\t * list with snap_rwsem held, adjusting the empty list here is\n\t * safe.  we do need to protect against concurrent empty list\n\t * additions, however.\n\t */\n\tif (atomic_inc_return(&realm->nref) == 1) {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_del_init(&realm->empty_item);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
  }
]