[
  {
    "function_name": "ovl_copyattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "179-183",
    "snippet": "static inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n\nstatic inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}"
  },
  {
    "function_name": "ovl_do_whiteout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "127-132",
    "snippet": "static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_whiteout(dir, dentry);\n\tpr_debug(\"whiteout(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"whiteout(%pd2) = %i\\n\"",
            "dentry",
            "err"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_whiteout",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4395-4406",
          "snippet": "int vfs_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\treturn dir->i_op->mknod(dir, dentry,\n\t\t\t\tS_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\treturn dir->i_op->mknod(dir, dentry,\n\t\t\t\tS_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_whiteout(dir, dentry);\n\tpr_debug(\"whiteout(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "109-125",
    "snippet": "static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
      "struct file *ovl_path_open(struct path *path, int flags);",
      "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"...rename2(%pd2, %pd2, ...) = %i\\n\"",
            "olddentry",
            "newdentry",
            "err"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_rename",
          "args": [
            "olddir",
            "olddentry",
            "newdir",
            "newdentry",
            "NULL",
            "flags"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4106-4237",
          "snippet": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rename2(%pd2, %pd2, 0x%x)\\n\"",
            "olddentry",
            "newdentry",
            "flags"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "102-107",
    "snippet": "static inline int ovl_do_removexattr(struct dentry *dentry, const char *name)\n{\n\tint err = vfs_removexattr(dentry, name);\n\tpr_debug(\"removexattr(%pd2, \\\"%s\\\") = %i\\n\", dentry, name, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "int ovl_removexattr(struct dentry *dentry, const char *name);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"removexattr(%pd2, \\\"%s\\\") = %i\\n\"",
            "dentry",
            "name",
            "err"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "286-314",
          "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nint ovl_removexattr(struct dentry *dentry, const char *name);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_removexattr(struct dentry *dentry, const char *name)\n{\n\tint err = vfs_removexattr(dentry, name);\n\tpr_debug(\"removexattr(%pd2, \\\"%s\\\") = %i\\n\", dentry, name, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "93-100",
    "snippet": "static inline int ovl_do_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tint err = vfs_setxattr(dentry, name, value, size, flags);\n\tpr_debug(\"setxattr(%pd2, \\\"%s\\\", \\\"%*s\\\", 0x%x) = %i\\n\",\n\t\t dentry, name, (int) size, (char *) value, flags, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
      "struct file *ovl_path_open(struct path *path, int flags);",
      "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
      "ssize_t ovl_getxattr(struct dentry *dentry, const char *name,\n\t\t     void *value, size_t size);",
      "ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);",
      "int ovl_removexattr(struct dentry *dentry, const char *name);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"setxattr(%pd2, \\\"%s\\\", \\\"%*s\\\", 0x%x) = %i\\n\"",
            "dentry",
            "name",
            "(int) size",
            "(char *) value",
            "flags",
            "err"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nssize_t ovl_getxattr(struct dentry *dentry, const char *name,\n\t\t     void *value, size_t size);\nssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);\nint ovl_removexattr(struct dentry *dentry, const char *name);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tint err = vfs_setxattr(dentry, name, value, size, flags);\n\tpr_debug(\"setxattr(%pd2, \\\"%s\\\", \\\"%*s\\\", 0x%x) = %i\\n\",\n\t\t dentry, name, (int) size, (char *) value, flags, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "84-91",
    "snippet": "static inline int ovl_do_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t\t const char *oldname, bool debug)\n{\n\tint err = vfs_symlink(dir, dentry, oldname);\n\tif (debug)\n\t\tpr_debug(\"symlink(\\\"%s\\\", %pd2) = %i\\n\", oldname, dentry, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"symlink(\\\"%s\\\", %pd2) = %i\\n\"",
            "oldname",
            "dentry",
            "err"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_symlink",
          "args": [
            "dir",
            "dentry",
            "oldname"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3848-3866",
          "snippet": "int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t\t const char *oldname, bool debug)\n{\n\tint err = vfs_symlink(dir, dentry, oldname);\n\tif (debug)\n\t\tpr_debug(\"symlink(\\\"%s\\\", %pd2) = %i\\n\", oldname, dentry, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "73-82",
    "snippet": "static inline int ovl_do_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, dev_t dev, bool debug)\n{\n\tint err = vfs_mknod(dir, dentry, mode, dev);\n\tif (debug) {\n\t\tpr_debug(\"mknod(%pd2, 0%o, 0%o) = %i\\n\",\n\t\t\t dentry, mode, dev, err);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"mknod(%pd2, 0%o, 0%o) = %i\\n\"",
            "dentry",
            "mode",
            "dev",
            "err"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mknod",
          "args": [
            "dir",
            "dentry",
            "mode",
            "dev"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3423-3448",
          "snippet": "int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, dev_t dev, bool debug)\n{\n\tint err = vfs_mknod(dir, dentry, mode, dev);\n\tif (debug) {\n\t\tpr_debug(\"mknod(%pd2, 0%o, 0%o) = %i\\n\",\n\t\t\t dentry, mode, dev, err);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "64-71",
    "snippet": "static inline int ovl_do_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, bool debug)\n{\n\tint err = vfs_mkdir(dir, dentry, mode);\n\tif (debug)\n\t\tpr_debug(\"mkdir(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"mkdir(%pd2, 0%o) = %i\\n\"",
            "dentry",
            "mode",
            "err"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkdir",
          "args": [
            "dir",
            "dentry",
            "mode"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3515-3538",
          "snippet": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, bool debug)\n{\n\tint err = vfs_mkdir(dir, dentry, mode);\n\tif (debug)\n\t\tpr_debug(\"mkdir(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "55-62",
    "snippet": "static inline int ovl_do_create(struct inode *dir, struct dentry *dentry,\n\t\t\t     umode_t mode, bool debug)\n{\n\tint err = vfs_create(dir, dentry, mode, true);\n\tif (debug)\n\t\tpr_debug(\"create(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"create(%pd2, 0%o) = %i\\n\"",
            "dentry",
            "mode",
            "err"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_create",
          "args": [
            "dir",
            "dentry",
            "mode",
            "true"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2547-2565",
          "snippet": "int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_create(struct inode *dir, struct dentry *dentry,\n\t\t\t     umode_t mode, bool debug)\n{\n\tint err = vfs_create(dir, dentry, mode, true);\n\tif (debug)\n\t\tpr_debug(\"create(%pd2, 0%o) = %i\\n\", dentry, mode, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "44-53",
    "snippet": "static inline int ovl_do_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t      struct dentry *new_dentry, bool debug)\n{\n\tint err = vfs_link(old_dentry, dir, new_dentry, NULL);\n\tif (debug) {\n\t\tpr_debug(\"link(%pd2, %pd2) = %i\\n\",\n\t\t\t old_dentry, new_dentry, err);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,\n\t\t\t\tstruct kstat *stat, const char *link);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"link(%pd2, %pd2) = %i\\n\"",
            "old_dentry",
            "new_dentry",
            "err"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_link",
          "args": [
            "old_dentry",
            "dir",
            "new_dentry",
            "NULL"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3924-3975",
          "snippet": "int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,\n\t\t\t\tstruct kstat *stat, const char *link);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t      struct dentry *new_dentry, bool debug)\n{\n\tint err = vfs_link(old_dentry, dir, new_dentry, NULL);\n\tif (debug) {\n\t\tpr_debug(\"link(%pd2, %pd2) = %i\\n\",\n\t\t\t old_dentry, new_dentry, err);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "37-42",
    "snippet": "static inline int ovl_do_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_unlink(dir, dentry, NULL);\n\tpr_debug(\"unlink(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"unlink(%pd2) = %i\\n\"",
            "dentry",
            "err"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_unlink",
          "args": [
            "dir",
            "dentry",
            "NULL"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3715-3752",
          "snippet": "int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_unlink(dir, dentry, NULL);\n\tpr_debug(\"unlink(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_do_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
    "lines": "30-35",
    "snippet": "static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_rmdir(dir, dentry);\n\tpr_debug(\"rmdir(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
      "u64 ovl_dentry_version_get(struct dentry *dentry);",
      "void ovl_dentry_version_inc(struct dentry *dentry);",
      "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
      "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
      "struct dentry *ovl_dentry_real(struct dentry *dentry);",
      "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
      "struct dentry *ovl_workdir(struct dentry *dentry);",
      "int ovl_want_write(struct dentry *dentry);",
      "void ovl_drop_write(struct dentry *dentry);",
      "bool ovl_dentry_is_opaque(struct dentry *dentry);",
      "bool ovl_is_whiteout(struct dentry *dentry);",
      "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
      "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
      "int ovl_copy_up(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rmdir(%pd2) = %i\\n\"",
            "dentry",
            "err"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3596-3632",
          "snippet": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint err = vfs_rmdir(dir, dentry);\n\tpr_debug(\"rmdir(%pd2) = %i\\n\", dentry, err);\n\treturn err;\n}"
  }
]