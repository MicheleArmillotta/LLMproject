[
  {
    "function_name": "sync_inode_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1513-1521",
    "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
  },
  {
    "function_name": "sync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1498-1501",
    "snippet": "int sync_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn writeback_single_inode(inode, &inode_to_bdi(inode)->wb, wbc);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_single_inode",
          "args": [
            "inode",
            "&inode_to_bdi(inode)->wb",
            "wbc"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "554-607",
          "snippet": "static int\nwriteback_single_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t       struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\tspin_lock(&wb->list_lock);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int\nwriteback_single_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t       struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\tspin_lock(&wb->list_lock);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn writeback_single_inode(inode, &inode_to_bdi(inode)->wb, wbc);\n}"
  },
  {
    "function_name": "write_inode_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1469-1484",
    "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_single_inode",
          "args": [
            "inode",
            "wb",
            "&wbc"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "554-607",
          "snippet": "static int\nwriteback_single_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t       struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\tspin_lock(&wb->list_lock);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int\nwriteback_single_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t       struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\tspin_lock(&wb->list_lock);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_writeback_dirty",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
  },
  {
    "function_name": "sync_inodes_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1434-1456",
    "snippet": "void sync_inodes_sb(struct super_block *sb)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\n\t/* Nothing to do? */\n\tif (sb->s_bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_queue_work(sb->s_bdi, &work);\n\twait_for_completion(&done);\n\n\twait_sb_inodes(sb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_sb_inodes",
          "args": [
            "sb"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "wait_sb_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1288-1339",
          "snippet": "static void wait_sb_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tspin_lock(&inode_sb_list_lock);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback,\n\t * because there may have been pages dirtied before our sync\n\t * call, but which had writeout started before we write it out.\n\t * In which case, the inode may not be on the dirty list, but\n\t * we still have to wait for that writeout.\n\t */\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\n\t\t    (mapping->nrpages == 0)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfilemap_fdatawait(mapping);\n\n\t\tcond_resched();\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wait_sb_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tspin_lock(&inode_sb_list_lock);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback,\n\t * because there may have been pages dirtied before our sync\n\t * call, but which had writeout started before we write it out.\n\t * In which case, the inode may not be on the dirty list, but\n\t * we still have to wait for that writeout.\n\t */\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\n\t\t    (mapping->nrpages == 0)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfilemap_fdatawait(mapping);\n\n\t\tcond_resched();\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_queue_work",
          "args": [
            "sb->s_bdi",
            "&work"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sync_inodes_sb(struct super_block *sb)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\n\t/* Nothing to do? */\n\tif (sb->s_bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_queue_work(sb->s_bdi, &work);\n\twait_for_completion(&done);\n\n\twait_sb_inodes(sb);\n}"
  },
  {
    "function_name": "try_to_writeback_inodes_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1421-1424",
    "snippet": "int try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn try_to_writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_writeback_inodes_sb_nr",
          "args": [
            "sb",
            "get_nr_dirty_pages()",
            "reason"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_writeback_inodes_sb_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1397-1410",
          "snippet": "int try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "974-979",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn try_to_writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}"
  },
  {
    "function_name": "try_to_writeback_inodes_sb_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1397-1410",
    "snippet": "int try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_inodes_sb_nr",
          "args": [
            "sb",
            "nr",
            "reason"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_writeback_inodes_sb_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1397-1410",
          "snippet": "int try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_in_progress",
          "args": [
            "sb->s_bdi"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "63-66",
          "snippet": "int writeback_in_progress(struct backing_dev_info *bdi)\n{\n\treturn test_bit(BDI_writeback_running, &bdi->state);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint writeback_in_progress(struct backing_dev_info *bdi)\n{\n\treturn test_bit(BDI_writeback_running, &bdi->state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}"
  },
  {
    "function_name": "writeback_inodes_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1382-1385",
    "snippet": "void writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_inodes_sb_nr",
          "args": [
            "sb",
            "get_nr_dirty_pages()",
            "reason"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_writeback_inodes_sb_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1397-1410",
          "snippet": "int try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint try_to_writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t\t  unsigned long nr,\n\t\t\t\t  enum wb_reason reason)\n{\n\tif (writeback_in_progress(sb->s_bdi))\n\t\treturn 1;\n\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn 0;\n\n\twriteback_inodes_sb_nr(sb, nr, reason);\n\tup_read(&sb->s_umount);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "974-979",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}"
  },
  {
    "function_name": "writeback_inodes_sb_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1351-1370",
    "snippet": "void writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t    unsigned long nr,\n\t\t\t    enum wb_reason reason)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\n\tif (sb->s_bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\tbdi_queue_work(sb->s_bdi, &work);\n\twait_for_completion(&done);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_queue_work",
          "args": [
            "sb->s_bdi",
            "&work"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t    unsigned long nr,\n\t\t\t    enum wb_reason reason)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\n\tif (sb->s_bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\tbdi_queue_work(sb->s_bdi, &work);\n\twait_for_completion(&done);\n}"
  },
  {
    "function_name": "wait_sb_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1288-1339",
    "snippet": "static void wait_sb_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tspin_lock(&inode_sb_list_lock);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback,\n\t * because there may have been pages dirtied before our sync\n\t * call, but which had writeout started before we write it out.\n\t * In which case, the inode may not be on the dirty list, but\n\t * we still have to wait for that writeout.\n\t */\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\n\t\t    (mapping->nrpages == 0)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfilemap_fdatawait(mapping);\n\n\t\tcond_resched();\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old_inode"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "mapping"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "inode",
            "&sb->s_inodes",
            "i_sb_list"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wait_sb_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tspin_lock(&inode_sb_list_lock);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback,\n\t * because there may have been pages dirtied before our sync\n\t * call, but which had writeout started before we write it out.\n\t * In which case, the inode may not be on the dirty list, but\n\t * we still have to wait for that writeout.\n\t */\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\n\t\t    (mapping->nrpages == 0)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfilemap_fdatawait(mapping);\n\n\t\tcond_resched();\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}"
  },
  {
    "function_name": "__mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1181-1285",
    "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_wakeup_thread_delayed",
          "args": [
            "bdi"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_inode_enqueue",
          "args": [
            "inode"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_wb_list",
            "dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "&bdi->wb"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!test_bit(BDI_registered, &bdi->state)",
            "\"bdi-%s not registered\\n\"",
            "bdi->name"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BDI_registered",
            "&bdi->state"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_cap_writeback_dirty",
          "args": [
            "bdi"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdi->wb.list_lock"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_dump___mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block_dump"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_inode",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->dirty_inode",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_inode_start",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_mark_inode_dirty",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
  },
  {
    "function_name": "block_dump___mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1134-1154",
    "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "inode->i_ino",
            "name",
            "inode->i_sb->s_id"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "inode->i_sb->s_id",
            "\"bdev\""
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "wakeup_flusher_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1118-1132",
    "snippet": "void wakeup_flusher_threads(long nr_pages, enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\tif (!nr_pages)\n\t\tnr_pages = get_nr_dirty_pages();\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {\n\t\tif (!bdi_has_dirty_io(bdi))\n\t\t\tcontinue;\n\t\t__bdi_start_writeback(bdi, nr_pages, false, reason);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bdi_start_writeback",
          "args": [
            "bdi",
            "nr_pages",
            "false",
            "reason"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "__bdi_start_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "125-148",
          "snippet": "static void\n__bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t      bool range_cyclic, enum wb_reason reason)\n{\n\tstruct wb_writeback_work *work;\n\n\t/*\n\t * This is WB_SYNC_NONE writeback, so if allocation fails just\n\t * wakeup the thread for old dirty data writeback\n\t */\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\ttrace_writeback_nowork(bdi);\n\t\tbdi_wakeup_thread(bdi);\n\t\treturn;\n\t}\n\n\twork->sync_mode\t= WB_SYNC_NONE;\n\twork->nr_pages\t= nr_pages;\n\twork->range_cyclic = range_cyclic;\n\twork->reason\t= reason;\n\n\tbdi_queue_work(bdi, work);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void\n__bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t      bool range_cyclic, enum wb_reason reason)\n{\n\tstruct wb_writeback_work *work;\n\n\t/*\n\t * This is WB_SYNC_NONE writeback, so if allocation fails just\n\t * wakeup the thread for old dirty data writeback\n\t */\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\ttrace_writeback_nowork(bdi);\n\t\tbdi_wakeup_thread(bdi);\n\t\treturn;\n\t}\n\n\twork->sync_mode\t= WB_SYNC_NONE;\n\twork->nr_pages\t= nr_pages;\n\twork->range_cyclic = range_cyclic;\n\twork->reason\t= reason;\n\n\tbdi_queue_work(bdi, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_has_dirty_io",
          "args": [
            "bdi"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "bdi",
            "&bdi_list",
            "bdi_list"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "974-979",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wakeup_flusher_threads(long nr_pages, enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\tif (!nr_pages)\n\t\tnr_pages = get_nr_dirty_pages();\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {\n\t\tif (!bdi_has_dirty_io(bdi))\n\t\t\tcontinue;\n\t\t__bdi_start_writeback(bdi, nr_pages, false, reason);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "bdi_writeback_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1073-1112",
    "snippet": "void bdi_writeback_workfn(struct work_struct *work)\n{\n\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct bdi_writeback, dwork);\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tlong pages_written;\n\n\tset_worker_desc(\"flush-%s\", dev_name(bdi->dev));\n\tcurrent->flags |= PF_SWAPWRITE;\n\n\tif (likely(!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(BDI_registered, &bdi->state))) {\n\t\t/*\n\t\t * The normal path.  Keep writing back @bdi until its\n\t\t * work_list is empty.  Note that this path is also taken\n\t\t * if @bdi is shutting down even when we're running off the\n\t\t * rescuer as work_list needs to be drained.\n\t\t */\n\t\tdo {\n\t\t\tpages_written = wb_do_writeback(wb);\n\t\t\ttrace_writeback_pages_written(pages_written);\n\t\t} while (!list_empty(&bdi->work_list));\n\t} else {\n\t\t/*\n\t\t * bdi_wq can't get enough workers and we're running off\n\t\t * the emergency worker.  Don't hog it.  Hopefully, 1024 is\n\t\t * enough for efficient IO.\n\t\t */\n\t\tpages_written = writeback_inodes_wb(&bdi->wb, 1024,\n\t\t\t\t\t\t    WB_REASON_FORKER_THREAD);\n\t\ttrace_writeback_pages_written(pages_written);\n\t}\n\n\tif (!list_empty(&bdi->work_list))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\telse if (wb_has_dirty_io(wb) && dirty_writeback_interval)\n\t\tbdi_wakeup_thread_delayed(bdi);\n\n\tcurrent->flags &= ~PF_SWAPWRITE;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_wakeup_thread_delayed",
          "args": [
            "bdi"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "bdi_wq",
            "&wb->dwork",
            "0"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bdi->work_list"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_pages_written",
          "args": [
            "pages_written"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_inodes_wb",
          "args": [
            "&bdi->wb",
            "1024",
            "WB_REASON_FORKER_THREAD"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_inodes_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "796-813",
          "snippet": "static long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work.nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work.nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_pages_written",
          "args": [
            "pages_written"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_do_writeback",
          "args": [
            "wb"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "wb_do_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1036-1067",
          "snippet": "static long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(BDI_writeback_running, &wb->bdi->state);\n\twhile ((work = get_next_work_item(bdi)) != NULL) {\n\n\t\ttrace_writeback_exec(bdi, work);\n\n\t\twrote += wb_writeback(wb, work);\n\n\t\t/*\n\t\t * Notify the caller of completion if this is a synchronous\n\t\t * work item, otherwise just free it.\n\t\t */\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\telse\n\t\t\tkfree(work);\n\t}\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(BDI_writeback_running, &wb->bdi->state);\n\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(BDI_writeback_running, &wb->bdi->state);\n\twhile ((work = get_next_work_item(bdi)) != NULL) {\n\n\t\ttrace_writeback_exec(bdi, work);\n\n\t\twrote += wb_writeback(wb, work);\n\n\t\t/*\n\t\t * Notify the caller of completion if this is a synchronous\n\t\t * work item, otherwise just free it.\n\t\t */\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\telse\n\t\t\tkfree(work);\n\t}\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(BDI_writeback_running, &wb->bdi->state);\n\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(BDI_registered, &bdi->state)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BDI_registered",
            "&bdi->state"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_is_workqueue_rescuer",
          "args": [],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_worker_desc",
          "args": [
            "\"flush-%s\"",
            "dev_name(bdi->dev)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "bdi->dev"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_delayed_work(work)",
            "structbdi_writeback",
            "dwork"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid bdi_writeback_workfn(struct work_struct *work)\n{\n\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct bdi_writeback, dwork);\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tlong pages_written;\n\n\tset_worker_desc(\"flush-%s\", dev_name(bdi->dev));\n\tcurrent->flags |= PF_SWAPWRITE;\n\n\tif (likely(!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(BDI_registered, &bdi->state))) {\n\t\t/*\n\t\t * The normal path.  Keep writing back @bdi until its\n\t\t * work_list is empty.  Note that this path is also taken\n\t\t * if @bdi is shutting down even when we're running off the\n\t\t * rescuer as work_list needs to be drained.\n\t\t */\n\t\tdo {\n\t\t\tpages_written = wb_do_writeback(wb);\n\t\t\ttrace_writeback_pages_written(pages_written);\n\t\t} while (!list_empty(&bdi->work_list));\n\t} else {\n\t\t/*\n\t\t * bdi_wq can't get enough workers and we're running off\n\t\t * the emergency worker.  Don't hog it.  Hopefully, 1024 is\n\t\t * enough for efficient IO.\n\t\t */\n\t\tpages_written = writeback_inodes_wb(&bdi->wb, 1024,\n\t\t\t\t\t\t    WB_REASON_FORKER_THREAD);\n\t\ttrace_writeback_pages_written(pages_written);\n\t}\n\n\tif (!list_empty(&bdi->work_list))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\telse if (wb_has_dirty_io(wb) && dirty_writeback_interval)\n\t\tbdi_wakeup_thread_delayed(bdi);\n\n\tcurrent->flags &= ~PF_SWAPWRITE;\n}"
  },
  {
    "function_name": "wb_do_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "1036-1067",
    "snippet": "static long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(BDI_writeback_running, &wb->bdi->state);\n\twhile ((work = get_next_work_item(bdi)) != NULL) {\n\n\t\ttrace_writeback_exec(bdi, work);\n\n\t\twrote += wb_writeback(wb, work);\n\n\t\t/*\n\t\t * Notify the caller of completion if this is a synchronous\n\t\t * work item, otherwise just free it.\n\t\t */\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\telse\n\t\t\tkfree(work);\n\t}\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(BDI_writeback_running, &wb->bdi->state);\n\n\treturn wrote;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BDI_writeback_running",
            "&wb->bdi->state"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_check_background_flush",
          "args": [
            "wb"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "wb_check_background_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "981-997",
          "snippet": "static long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (over_bground_thresh(wb->bdi)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (over_bground_thresh(wb->bdi)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_check_old_data_flush",
          "args": [
            "wb"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "wb_check_old_data_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "999-1031",
          "snippet": "static long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "work->done"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sync_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "231-239",
          "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "work"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "857-950",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_exec",
          "args": [
            "bdi",
            "work"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_work_item",
          "args": [
            "bdi"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_work_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "955-968",
          "snippet": "static struct wb_writeback_work *\nget_next_work_item(struct backing_dev_info *bdi)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!list_empty(&bdi->work_list)) {\n\t\twork = list_entry(bdi->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&bdi->wb_lock);\n\treturn work;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct wb_writeback_work *\nget_next_work_item(struct backing_dev_info *bdi)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!list_empty(&bdi->work_list)) {\n\t\twork = list_entry(bdi->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&bdi->wb_lock);\n\treturn work;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BDI_writeback_running",
            "&wb->bdi->state"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(BDI_writeback_running, &wb->bdi->state);\n\twhile ((work = get_next_work_item(bdi)) != NULL) {\n\n\t\ttrace_writeback_exec(bdi, work);\n\n\t\twrote += wb_writeback(wb, work);\n\n\t\t/*\n\t\t * Notify the caller of completion if this is a synchronous\n\t\t * work item, otherwise just free it.\n\t\t */\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\telse\n\t\t\tkfree(work);\n\t}\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(BDI_writeback_running, &wb->bdi->state);\n\n\treturn wrote;\n}"
  },
  {
    "function_name": "wb_check_old_data_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "999-1031",
    "snippet": "static long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "&work"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "857-950",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "974-979",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "expired"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_writeback_interval * 10"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wb_check_background_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "981-997",
    "snippet": "static long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (over_bground_thresh(wb->bdi)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "&work"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "857-950",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "over_bground_thresh",
          "args": [
            "wb->bdi"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "over_bground_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "815-830",
          "snippet": "static bool over_bground_thresh(struct backing_dev_info *bdi)\n{\n\tunsigned long background_thresh, dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\n\tif (global_page_state(NR_FILE_DIRTY) +\n\t    global_page_state(NR_UNSTABLE_NFS) > background_thresh)\n\t\treturn true;\n\n\tif (bdi_stat(bdi, BDI_RECLAIMABLE) >\n\t\t\t\tbdi_dirty_limit(bdi, background_thresh))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool over_bground_thresh(struct backing_dev_info *bdi)\n{\n\tunsigned long background_thresh, dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\n\tif (global_page_state(NR_FILE_DIRTY) +\n\t    global_page_state(NR_UNSTABLE_NFS) > background_thresh)\n\t\treturn true;\n\n\tif (bdi_stat(bdi, BDI_RECLAIMABLE) >\n\t\t\t\tbdi_dirty_limit(bdi, background_thresh))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (over_bground_thresh(wb->bdi)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_nr_dirty_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "974-979",
    "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_nr_dirty_inodes",
          "args": [],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "98-103",
          "snippet": "long get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_page_state(NR_FILE_DIRTY) +\n\t\tglobal_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
  },
  {
    "function_name": "get_next_work_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "955-968",
    "snippet": "static struct wb_writeback_work *\nget_next_work_item(struct backing_dev_info *bdi)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!list_empty(&bdi->work_list)) {\n\t\twork = list_entry(bdi->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&bdi->wb_lock);\n\treturn work;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bdi->wb_lock"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->list"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "bdi->work_list.next",
            "structwb_writeback_work",
            "list"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bdi->work_list"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bdi->wb_lock"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct wb_writeback_work *\nget_next_work_item(struct backing_dev_info *bdi)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!list_empty(&bdi->work_list)) {\n\t\twork = list_entry(bdi->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&bdi->wb_lock);\n\treturn work;\n}"
  },
  {
    "function_name": "wb_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "857-950",
    "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sleep_on_writeback",
          "args": [
            "inode"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sleep_on_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "388-401",
          "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_more_io.prev"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "85-88",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_wait",
          "args": [
            "wb->bdi",
            "work"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_more_io"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_update_bandwidth",
          "args": [
            "wb",
            "wb_start"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "wb_update_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "836-840",
          "snippet": "static void wb_update_bandwidth(struct bdi_writeback *wb,\n\t\t\t\tunsigned long start_time)\n{\n\t__bdi_update_bandwidth(wb->bdi, 0, 0, 0, 0, 0, start_time);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_update_bandwidth(struct bdi_writeback *wb,\n\t\t\t\tunsigned long start_time)\n{\n\t__bdi_update_bandwidth(wb->bdi, 0, 0, 0, 0, 0, start_time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_written",
          "args": [
            "wb->bdi",
            "work"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__writeback_inodes_wb",
          "args": [
            "wb",
            "work"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_inodes_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "762-794",
          "snippet": "static long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback_sb_inodes",
          "args": [
            "work->sb",
            "wb",
            "work"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_sb_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "645-760",
          "snippet": "static long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\twrite_chunk = writeback_chunk_size(wb->bdi, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\t\tspin_lock(&wb->list_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcond_resched_lock(&wb->list_lock);\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\twrite_chunk = writeback_chunk_size(wb->bdi, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\t\tspin_lock(&wb->list_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcond_resched_lock(&wb->list_lock);\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_io",
          "args": [
            "wb",
            "work"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "queue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "328-338",
          "snippet": "static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\ttrace_writeback_queue_io(wb, work, moved);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EXPIRE_DIRTY_ATIME 0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\ttrace_writeback_queue_io(wb, work, moved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_start",
          "args": [
            "wb->bdi",
            "work"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_expire_interval * 10"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "over_bground_thresh",
          "args": [
            "wb->bdi"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "over_bground_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "815-830",
          "snippet": "static bool over_bground_thresh(struct backing_dev_info *bdi)\n{\n\tunsigned long background_thresh, dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\n\tif (global_page_state(NR_FILE_DIRTY) +\n\t    global_page_state(NR_UNSTABLE_NFS) > background_thresh)\n\t\treturn true;\n\n\tif (bdi_stat(bdi, BDI_RECLAIMABLE) >\n\t\t\t\tbdi_dirty_limit(bdi, background_thresh))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool over_bground_thresh(struct backing_dev_info *bdi)\n{\n\tunsigned long background_thresh, dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\n\tif (global_page_state(NR_FILE_DIRTY) +\n\t    global_page_state(NR_UNSTABLE_NFS) > background_thresh)\n\t\treturn true;\n\n\tif (bdi_stat(bdi, BDI_RECLAIMABLE) >\n\t\t\t\tbdi_dirty_limit(bdi, background_thresh))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->bdi->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !over_bground_thresh(wb->bdi))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb->bdi, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb->bdi, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\tif (!list_empty(&wb->b_more_io))  {\n\t\t\ttrace_writeback_wait(wb->bdi, work);\n\t\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\t/* This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\t}\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work->nr_pages;\n}"
  },
  {
    "function_name": "wb_update_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "836-840",
    "snippet": "static void wb_update_bandwidth(struct bdi_writeback *wb,\n\t\t\t\tunsigned long start_time)\n{\n\t__bdi_update_bandwidth(wb->bdi, 0, 0, 0, 0, 0, start_time);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bdi_update_bandwidth",
          "args": [
            "wb->bdi",
            "0",
            "0",
            "0",
            "0",
            "0",
            "start_time"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_update_bandwidth(struct bdi_writeback *wb,\n\t\t\t\tunsigned long start_time)\n{\n\t__bdi_update_bandwidth(wb->bdi, 0, 0, 0, 0, 0, start_time);\n}"
  },
  {
    "function_name": "over_bground_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "815-830",
    "snippet": "static bool over_bground_thresh(struct backing_dev_info *bdi)\n{\n\tunsigned long background_thresh, dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\n\tif (global_page_state(NR_FILE_DIRTY) +\n\t    global_page_state(NR_UNSTABLE_NFS) > background_thresh)\n\t\treturn true;\n\n\tif (bdi_stat(bdi, BDI_RECLAIMABLE) >\n\t\t\t\tbdi_dirty_limit(bdi, background_thresh))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_dirty_limit",
          "args": [
            "bdi",
            "background_thresh"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_stat",
          "args": [
            "bdi",
            "BDI_RECLAIMABLE"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_dirty_limits",
          "args": [
            "&background_thresh",
            "&dirty_thresh"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool over_bground_thresh(struct backing_dev_info *bdi)\n{\n\tunsigned long background_thresh, dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\n\tif (global_page_state(NR_FILE_DIRTY) +\n\t    global_page_state(NR_UNSTABLE_NFS) > background_thresh)\n\t\treturn true;\n\n\tif (bdi_stat(bdi, BDI_RECLAIMABLE) >\n\t\t\t\tbdi_dirty_limit(bdi, background_thresh))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "writeback_inodes_wb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "796-813",
    "snippet": "static long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work.nr_pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__writeback_inodes_wb",
          "args": [
            "wb",
            "&work"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_inodes_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "762-794",
          "snippet": "static long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_io",
          "args": [
            "wb",
            "&work"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "queue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "328-338",
          "snippet": "static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\ttrace_writeback_queue_io(wb, work, moved);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EXPIRE_DIRTY_ATIME 0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\ttrace_writeback_queue_io(wb, work, moved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_io"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\n\treturn nr_pages - work.nr_pages;\n}"
  },
  {
    "function_name": "__writeback_inodes_wb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "762-794",
    "snippet": "static long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_is_before_jiffies",
          "args": [
            "start_time + HZ / 10UL"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_sb_inodes",
          "args": [
            "sb",
            "wb",
            "work"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_sb_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "645-760",
          "snippet": "static long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\twrite_chunk = writeback_chunk_size(wb->bdi, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\t\tspin_lock(&wb->list_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcond_resched_lock(&wb->list_lock);\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\twrite_chunk = writeback_chunk_size(wb->bdi, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\t\tspin_lock(&wb->list_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcond_resched_lock(&wb->list_lock);\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_tail",
          "args": [
            "inode",
            "wb"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "redirty_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "209-220",
          "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_super",
          "args": [
            "sb"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_io.prev"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "85-88",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_io"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}"
  },
  {
    "function_name": "writeback_sb_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "645-760",
    "snippet": "static long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\twrite_chunk = writeback_chunk_size(wb->bdi, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\t\tspin_lock(&wb->list_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcond_resched_lock(&wb->list_lock);\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_is_before_jiffies",
          "args": [
            "start_time + HZ / 10UL"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sync_complete",
          "args": [
            "inode"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sync_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "231-239",
          "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_inode",
          "args": [
            "inode",
            "wb",
            "&wbc"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "411-466",
          "snippet": "static void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tlist_move(&inode->i_wb_list, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tlist_del_init(&inode->i_wb_list);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tlist_move(&inode->i_wb_list, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tlist_del_init(&inode->i_wb_list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__writeback_single_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "473-544",
          "snippet": "static int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (((dirty & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) &&\n\t     (inode->i_state & I_DIRTY_TIME)) ||\n\t    (inode->i_state & I_DIRTY_TIME_EXPIRED)) {\n\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\ttrace_writeback_lazytime(inode);\n\t}\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (((dirty & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) &&\n\t     (inode->i_state & I_DIRTY_TIME)) ||\n\t    (inode->i_state & I_DIRTY_TIME_EXPIRED)) {\n\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\ttrace_writeback_lazytime(inode);\n\t}\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback_chunk_size",
          "args": [
            "wb->bdi",
            "work"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "609-638",
          "snippet": "static long writeback_chunk_size(struct backing_dev_info *bdi,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(bdi->avg_write_bandwidth / 2,\n\t\t\t    global_dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_CACHE_SHIFT - 10))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_CACHE_SHIFT - 10))\n\nstatic long writeback_chunk_size(struct backing_dev_info *bdi,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(bdi->avg_write_bandwidth / 2,\n\t\t\t    global_dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sleep_on_writeback",
          "args": [
            "inode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sleep_on_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "388-401",
          "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_sb_inodes_requeue",
          "args": [
            "inode"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requeue_io",
          "args": [
            "inode",
            "wb"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "225-229",
          "snippet": "static void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tlist_move(&inode->i_wb_list, &wb->b_more_io);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tlist_move(&inode->i_wb_list, &wb->b_more_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_tail",
          "args": [
            "inode",
            "wb"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "redirty_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "209-220",
          "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_io.prev"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "85-88",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_io"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\twrite_chunk = writeback_chunk_size(wb->bdi, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\t\tspin_lock(&wb->list_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tcond_resched_lock(&wb->list_lock);\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}"
  },
  {
    "function_name": "writeback_chunk_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "609-638",
    "snippet": "static long writeback_chunk_size(struct backing_dev_info *bdi,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(bdi->avg_write_bandwidth / 2,\n\t\t\t    global_dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_CACHE_SHIFT - 10))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "pages + MIN_WRITEBACK_PAGES",
            "MIN_WRITEBACK_PAGES"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pages",
            "work->nr_pages"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_CACHE_SHIFT - 10))\n\nstatic long writeback_chunk_size(struct backing_dev_info *bdi,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(bdi->avg_write_bandwidth / 2,\n\t\t\t    global_dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}"
  },
  {
    "function_name": "writeback_single_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "554-607",
    "snippet": "static int\nwriteback_single_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t       struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\tspin_lock(&wb->list_lock);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sync_complete",
          "args": [
            "inode"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sync_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "231-239",
          "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__writeback_single_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "473-544",
          "snippet": "static int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (((dirty & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) &&\n\t     (inode->i_state & I_DIRTY_TIME)) ||\n\t    (inode->i_state & I_DIRTY_TIME_EXPIRED)) {\n\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\ttrace_writeback_lazytime(inode);\n\t}\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (((dirty & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) &&\n\t     (inode->i_state & I_DIRTY_TIME)) ||\n\t    (inode->i_state & I_DIRTY_TIME_EXPIRED)) {\n\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\ttrace_writeback_lazytime(inode);\n\t}\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "inode->i_mapping",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_SYNC"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inode_wait_for_writeback",
          "args": [
            "inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_wait_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "357-371",
          "snippet": "static void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_WILL_FREE"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & (I_WILL_FREE|I_FREEING))"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int\nwriteback_single_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t       struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\tspin_lock(&wb->list_lock);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__writeback_single_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "473-544",
    "snippet": "static int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (((dirty & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) &&\n\t     (inode->i_state & I_DIRTY_TIME)) ||\n\t    (inode->i_state & I_DIRTY_TIME_EXPIRED)) {\n\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\ttrace_writeback_lazytime(inode);\n\t}\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_writeback_single_inode",
          "args": [
            "inode",
            "wbc",
            "nr_to_write"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_lazytime",
          "args": [
            "inode"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "mapping"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_single_inode_start",
          "args": [
            "inode",
            "wbc",
            "nr_to_write"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_SYNC)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (((dirty & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) &&\n\t     (inode->i_state & I_DIRTY_TIME)) ||\n\t    (inode->i_state & I_DIRTY_TIME_EXPIRED)) {\n\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\ttrace_writeback_lazytime(inode);\n\t}\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}"
  },
  {
    "function_name": "requeue_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "411-466",
    "snippet": "static void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tlist_move(&inode->i_wb_list, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tlist_del_init(&inode->i_wb_list);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_wb_list",
            "&wb->b_dirty_time"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_tail",
          "args": [
            "inode",
            "wb"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "redirty_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "209-220",
          "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_io",
          "args": [
            "inode",
            "wb"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "225-229",
          "snippet": "static void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tlist_move(&inode->i_wb_list, &wb->b_more_io);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tlist_move(&inode->i_wb_list, &wb->b_more_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "inode->i_mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tlist_move(&inode->i_wb_list, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tlist_del_init(&inode->i_wb_list);\n\t}\n}"
  },
  {
    "function_name": "inode_sleep_on_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "388-401",
    "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wqh",
            "&wait"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wqh",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "inode->i_lock"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
  },
  {
    "function_name": "inode_wait_for_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "376-381",
    "snippet": "void inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inode_wait_for_writeback",
          "args": [
            "inode"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_wait_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "357-371",
          "snippet": "static void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "__inode_wait_for_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "357-371",
    "snippet": "static void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_bit",
          "args": [
            "wqh",
            "&wq",
            "bit_wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wq",
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "inode->i_lock"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "inode->i_lock"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
  },
  {
    "function_name": "write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "340-351",
    "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_writeback_write_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_op->write_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "340-351",
          "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_write_inode_start",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "328-338",
    "snippet": "static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\ttrace_writeback_queue_io(wb, work, moved);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define EXPIRE_DIRTY_ATIME 0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_writeback_queue_io",
          "args": [
            "wb",
            "work",
            "moved"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_expired_inodes",
          "args": [
            "&wb->b_dirty_time",
            "&wb->b_io",
            "EXPIRE_DIRTY_ATIME",
            "work"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "move_expired_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "262-315",
          "snippet": "static int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if ((work->reason == WB_REASON_SYNC) == 0) {\n\t\texpire_time = jiffies - (HZ * 86400);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_wb_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_wb_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EXPIRE_DIRTY_ATIME 0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if ((work->reason == WB_REASON_SYNC) == 0) {\n\t\texpire_time = jiffies - (HZ * 86400);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_wb_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_wb_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&wb->b_more_io",
            "&wb->b_io"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&wb->list_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\ttrace_writeback_queue_io(wb, work, moved);\n}"
  },
  {
    "function_name": "move_expired_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "262-315",
    "snippet": "static int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if ((work->reason == WB_REASON_SYNC) == 0) {\n\t\texpire_time = jiffies - (HZ * 86400);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_wb_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_wb_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define EXPIRE_DIRTY_ATIME 0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_wb_list",
            "dispatch_queue"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "pos"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "85-88",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_prev_safe",
          "args": [
            "pos",
            "node",
            "&tmp"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&tmp",
            "dispatch_queue"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_is_blkdev_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "sb_is_blkdev_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "692-695",
          "snippet": "int sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *blockdev_superblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct super_block *blockdev_superblock;\n\nint sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "__I_DIRTY_TIME_EXPIRED",
            "&inode->i_state"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_wb_list",
            "&tmp"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dirtied_after",
          "args": [
            "inode",
            "*older_than_this"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dirtied_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "241-254",
          "snippet": "static bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if ((work->reason == WB_REASON_SYNC) == 0) {\n\t\texpire_time = jiffies - (HZ * 86400);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_wb_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_wb_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}"
  },
  {
    "function_name": "inode_dirtied_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "241-254",
    "snippet": "static bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before_eq",
          "args": [
            "inode->dirtied_when",
            "jiffies"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "inode->dirtied_when",
            "t"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "inode_sync_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "231-239",
    "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_add_lru",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "405-411",
          "snippet": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
  },
  {
    "function_name": "requeue_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "225-229",
    "snippet": "static void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tlist_move(&inode->i_wb_list, &wb->b_more_io);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_wb_list",
            "&wb->b_more_io"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&wb->list_lock"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tlist_move(&inode->i_wb_list, &wb->b_more_io);\n}"
  },
  {
    "function_name": "redirty_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "209-220",
    "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_wb_list",
            "&wb->b_dirty"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "inode->dirtied_when",
            "tail->dirtied_when"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_dirty.next"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "85-88",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_dirty"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&wb->list_lock"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tlist_move(&inode->i_wb_list, &wb->b_dirty);\n}"
  },
  {
    "function_name": "inode_wb_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "191-198",
    "snippet": "void inode_wb_list_del(struct inode *inode)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\n\tspin_lock(&bdi->wb.list_lock);\n\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&bdi->wb.list_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdi->wb.list_lock"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdi->wb.list_lock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_wb_list_del(struct inode *inode)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\n\tspin_lock(&bdi->wb.list_lock);\n\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&bdi->wb.list_lock);\n}"
  },
  {
    "function_name": "bdi_start_background_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "178-186",
    "snippet": "void bdi_start_background_writeback(struct backing_dev_info *bdi)\n{\n\t/*\n\t * We just wake up the flusher thread. It will perform background\n\t * writeback as soon as there is no other work to do.\n\t */\n\ttrace_writeback_wake_background(bdi);\n\tbdi_wakeup_thread(bdi);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_wakeup_thread",
          "args": [
            "bdi"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_wakeup_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "100-106",
          "snippet": "static void bdi_wakeup_thread(struct backing_dev_info *bdi)\n{\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (test_bit(BDI_registered, &bdi->state))\n\t\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_wakeup_thread(struct backing_dev_info *bdi)\n{\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (test_bit(BDI_registered, &bdi->state))\n\t\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_wake_background",
          "args": [
            "bdi"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid bdi_start_background_writeback(struct backing_dev_info *bdi)\n{\n\t/*\n\t * We just wake up the flusher thread. It will perform background\n\t * writeback as soon as there is no other work to do.\n\t */\n\ttrace_writeback_wake_background(bdi);\n\tbdi_wakeup_thread(bdi);\n}"
  },
  {
    "function_name": "bdi_start_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "162-166",
    "snippet": "void bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t\tenum wb_reason reason)\n{\n\t__bdi_start_writeback(bdi, nr_pages, true, reason);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bdi_start_writeback",
          "args": [
            "bdi",
            "nr_pages",
            "true",
            "reason"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__bdi_start_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "125-148",
          "snippet": "static void\n__bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t      bool range_cyclic, enum wb_reason reason)\n{\n\tstruct wb_writeback_work *work;\n\n\t/*\n\t * This is WB_SYNC_NONE writeback, so if allocation fails just\n\t * wakeup the thread for old dirty data writeback\n\t */\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\ttrace_writeback_nowork(bdi);\n\t\tbdi_wakeup_thread(bdi);\n\t\treturn;\n\t}\n\n\twork->sync_mode\t= WB_SYNC_NONE;\n\twork->nr_pages\t= nr_pages;\n\twork->range_cyclic = range_cyclic;\n\twork->reason\t= reason;\n\n\tbdi_queue_work(bdi, work);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void\n__bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t      bool range_cyclic, enum wb_reason reason)\n{\n\tstruct wb_writeback_work *work;\n\n\t/*\n\t * This is WB_SYNC_NONE writeback, so if allocation fails just\n\t * wakeup the thread for old dirty data writeback\n\t */\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\ttrace_writeback_nowork(bdi);\n\t\tbdi_wakeup_thread(bdi);\n\t\treturn;\n\t}\n\n\twork->sync_mode\t= WB_SYNC_NONE;\n\twork->nr_pages\t= nr_pages;\n\twork->range_cyclic = range_cyclic;\n\twork->reason\t= reason;\n\n\tbdi_queue_work(bdi, work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t\tenum wb_reason reason)\n{\n\t__bdi_start_writeback(bdi, nr_pages, true, reason);\n}"
  },
  {
    "function_name": "__bdi_start_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "125-148",
    "snippet": "static void\n__bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t      bool range_cyclic, enum wb_reason reason)\n{\n\tstruct wb_writeback_work *work;\n\n\t/*\n\t * This is WB_SYNC_NONE writeback, so if allocation fails just\n\t * wakeup the thread for old dirty data writeback\n\t */\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\ttrace_writeback_nowork(bdi);\n\t\tbdi_wakeup_thread(bdi);\n\t\treturn;\n\t}\n\n\twork->sync_mode\t= WB_SYNC_NONE;\n\twork->nr_pages\t= nr_pages;\n\twork->range_cyclic = range_cyclic;\n\twork->reason\t= reason;\n\n\tbdi_queue_work(bdi, work);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_queue_work",
          "args": [
            "bdi",
            "work"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_wakeup_thread",
          "args": [
            "bdi"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_wakeup_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "100-106",
          "snippet": "static void bdi_wakeup_thread(struct backing_dev_info *bdi)\n{\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (test_bit(BDI_registered, &bdi->state))\n\t\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_wakeup_thread(struct backing_dev_info *bdi)\n{\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (test_bit(BDI_registered, &bdi->state))\n\t\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_nowork",
          "args": [
            "bdi"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*work)",
            "GFP_ATOMIC"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void\n__bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,\n\t\t      bool range_cyclic, enum wb_reason reason)\n{\n\tstruct wb_writeback_work *work;\n\n\t/*\n\t * This is WB_SYNC_NONE writeback, so if allocation fails just\n\t * wakeup the thread for old dirty data writeback\n\t */\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\ttrace_writeback_nowork(bdi);\n\t\tbdi_wakeup_thread(bdi);\n\t\treturn;\n\t}\n\n\twork->sync_mode\t= WB_SYNC_NONE;\n\twork->nr_pages\t= nr_pages;\n\twork->range_cyclic = range_cyclic;\n\twork->reason\t= reason;\n\n\tbdi_queue_work(bdi, work);\n}"
  },
  {
    "function_name": "bdi_queue_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "108-123",
    "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bdi->wb_lock"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "bdi_wq",
            "&bdi->wb.dwork",
            "0"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->list",
            "&bdi->work_list"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "work->done"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sync_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "231-239",
          "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BDI_registered",
            "&bdi->state"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bdi->wb_lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_queue",
          "args": [
            "bdi",
            "work"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
  },
  {
    "function_name": "bdi_wakeup_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "100-106",
    "snippet": "static void bdi_wakeup_thread(struct backing_dev_info *bdi)\n{\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (test_bit(BDI_registered, &bdi->state))\n\t\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bdi->wb_lock"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "bdi_wq",
            "&bdi->wb.dwork",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BDI_registered",
            "&bdi->state"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bdi->wb_lock"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_wakeup_thread(struct backing_dev_info *bdi)\n{\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (test_bit(BDI_registered, &bdi->state))\n\t\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
  },
  {
    "function_name": "wb_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "85-88",
    "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head",
            "structinode",
            "i_wb_list"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_wb_list);\n}"
  },
  {
    "function_name": "inode_to_bdi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "69-82",
    "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_get_backing_dev_info",
          "args": [
            "I_BDEV(inode)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_is_blkdev_sb",
          "args": [
            "sb"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "sb_is_blkdev_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "692-695",
          "snippet": "int sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *blockdev_superblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct super_block *blockdev_superblock;\n\nint sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
  },
  {
    "function_name": "writeback_in_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
    "lines": "63-66",
    "snippet": "int writeback_in_progress(struct backing_dev_info *bdi)\n{\n\treturn test_bit(BDI_writeback_running, &bdi->state);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BDI_writeback_running",
            "&bdi->state"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint writeback_in_progress(struct backing_dev_info *bdi)\n{\n\treturn test_bit(BDI_writeback_running, &bdi->state);\n}"
  }
]