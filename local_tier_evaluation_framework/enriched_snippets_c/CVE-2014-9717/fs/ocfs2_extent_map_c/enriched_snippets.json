[
  {
    "function_name": "ocfs2_read_virt_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "927-992",
    "snippet": "int ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t/*\n\t\t * If the caller passed us bhs, they should have come\n\t\t * from a previous readahead call to this function.  Thus,\n\t\t * they should have the right b_blocknr.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(inode)",
            "p_block",
            "count",
            "bhs + done",
            "flags",
            "validate"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bhs[done + i]->b_blocknr != (p_block + i)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Inode #%llu contains a hole at offset %llu\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "inode",
            "v_block + done",
            "&p_block",
            "&p_count",
            "NULL"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(flags & OCFS2_BH_READAHEAD)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_read_virt_blocks",
          "args": [
            "inode",
            "(unsigned long long)v_block",
            "nr",
            "bhs",
            "flags",
            "validate"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t/*\n\t\t * If the caller passed us bhs, they should have come\n\t\t * from a previous readahead call to this function.  Thus,\n\t\t * they should have the right b_blocknr.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_seek_data_hole_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "833-925",
    "snippet": "int ocfs2_seek_data_hole_offset(struct file *file, loff_t *offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\tunsigned int is_last = 0, is_data = 0;\n\tu16 cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 cpos, cend, clen, hole_size;\n\tu64 extoff, extlen;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tBUG_ON(whence != SEEK_DATA && whence != SEEK_HOLE);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tif (*offset >= i_size_read(inode)) {\n\t\tret = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\t*offset = i_size_read(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tclen = 0;\n\tcpos = *offset >> cs_bits;\n\tcend = ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\twhile (cpos < cend && !is_last) {\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos, &hole_size,\n\t\t\t\t\t\t &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tclen = hole_size;\n\t\t\tis_data = 0;\n\t\t} else {\n\t\t\tclen = le16_to_cpu(rec.e_leaf_clusters) -\n\t\t\t\t(cpos - le32_to_cpu(rec.e_cpos));\n\t\t\tis_data = (rec.e_flags & OCFS2_EXT_UNWRITTEN) ?  0 : 1;\n\t\t}\n\n\t\tif ((!is_data && whence == SEEK_HOLE) ||\n\t\t    (is_data && whence == SEEK_DATA)) {\n\t\t\tif (extoff > *offset)\n\t\t\t\t*offset = extoff;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!is_last)\n\t\t\tcpos += clen;\n\t}\n\n\tif (whence == SEEK_HOLE) {\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\t\textlen = clen;\n\t\textlen <<=  cs_bits;\n\n\t\tif ((extoff + extlen) > i_size_read(inode))\n\t\t\textlen = i_size_read(inode) - extoff;\n\t\textoff += extlen;\n\t\tif (extoff > *offset)\n\t\t\t*offset = extoff;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -ENXIO;\n\nout_unlock:\n\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.e_cpos"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec.e_leaf_clusters"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters_nocache",
          "args": [
            "inode",
            "di_bh",
            "cpos",
            "&hole_size",
            "&rec",
            "&is_last"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "410-526",
          "snippet": "static int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "i_size_read(inode)"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "0"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "whence != SEEK_DATA && whence != SEEK_HOLE"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_seek_data_hole_offset(struct file *file, loff_t *offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\tunsigned int is_last = 0, is_data = 0;\n\tu16 cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 cpos, cend, clen, hole_size;\n\tu64 extoff, extlen;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tBUG_ON(whence != SEEK_DATA && whence != SEEK_HOLE);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tif (*offset >= i_size_read(inode)) {\n\t\tret = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\t*offset = i_size_read(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tclen = 0;\n\tcpos = *offset >> cs_bits;\n\tcend = ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\twhile (cpos < cend && !is_last) {\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos, &hole_size,\n\t\t\t\t\t\t &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tclen = hole_size;\n\t\t\tis_data = 0;\n\t\t} else {\n\t\t\tclen = le16_to_cpu(rec.e_leaf_clusters) -\n\t\t\t\t(cpos - le32_to_cpu(rec.e_cpos));\n\t\t\tis_data = (rec.e_flags & OCFS2_EXT_UNWRITTEN) ?  0 : 1;\n\t\t}\n\n\t\tif ((!is_data && whence == SEEK_HOLE) ||\n\t\t    (is_data && whence == SEEK_DATA)) {\n\t\t\tif (extoff > *offset)\n\t\t\t\t*offset = extoff;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!is_last)\n\t\t\tcpos += clen;\n\t}\n\n\tif (whence == SEEK_HOLE) {\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\t\textlen = clen;\n\t\textlen <<=  cs_bits;\n\n\t\tif ((extoff + extlen) > i_size_read(inode))\n\t\t\textlen = i_size_read(inode) - extoff;\n\t\textoff += extlen;\n\t\tif (extoff > *offset)\n\t\t\t*offset = extoff;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -ENXIO;\n\nout_unlock:\n\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "749-831",
    "snippet": "int ocfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t u64 map_start, u64 map_len)\n{\n\tint ret, is_last;\n\tu32 mapping_end, cpos;\n\tunsigned int hole_size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu64 len_bytes, phys_bytes, virt_bytes;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tret = fiemap_check_flags(fieinfo, OCFS2_FIEMAP_FLAGS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\t/*\n\t * Handle inline-data and fast symlink separately.\n\t */\n\tif ((OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    ocfs2_inode_is_fast_symlink(inode)) {\n\t\tret = ocfs2_fiemap_inline(inode, di_bh, fieinfo, map_start);\n\t\tgoto out_unlock;\n\t}\n\n\tcpos = map_start >> osb->s_clustersize_bits;\n\tmapping_end = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t       map_start + map_len);\n\tis_last = 0;\n\twhile (cpos < mapping_end && !is_last) {\n\t\tu32 fe_flags;\n\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos,\n\t\t\t\t\t\t &hole_size, &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tcpos += hole_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfe_flags = 0;\n\t\tif (rec.e_flags & OCFS2_EXT_UNWRITTEN)\n\t\t\tfe_flags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tif (rec.e_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tfe_flags |= FIEMAP_EXTENT_SHARED;\n\t\tif (is_last)\n\t\t\tfe_flags |= FIEMAP_EXTENT_LAST;\n\t\tlen_bytes = (u64)le16_to_cpu(rec.e_leaf_clusters) << osb->s_clustersize_bits;\n\t\tphys_bytes = le64_to_cpu(rec.e_blkno) << osb->sb->s_blocksize_bits;\n\t\tvirt_bytes = (u64)le32_to_cpu(rec.e_cpos) << osb->s_clustersize_bits;\n\n\t\tret = fiemap_fill_next_extent(fieinfo, virt_bytes, phys_bytes,\n\t\t\t\t\t      len_bytes, fe_flags);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcpos = le32_to_cpu(rec.e_cpos)+ le16_to_cpu(rec.e_leaf_clusters);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout_unlock:\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_FIEMAP_FLAGS\t(FIEMAP_FLAG_SYNC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec.e_leaf_clusters"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.e_cpos"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "virt_bytes",
            "phys_bytes",
            "len_bytes",
            "fe_flags"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec.e_blkno"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters_nocache",
          "args": [
            "inode",
            "di_bh",
            "cpos",
            "&hole_size",
            "&rec",
            "&is_last"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "410-526",
          "snippet": "static int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "map_start + map_len"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fiemap_inline",
          "args": [
            "inode",
            "di_bh",
            "fieinfo",
            "map_start"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fiemap_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "713-745",
          "snippet": "static int ocfs2_fiemap_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t       struct fiemap_extent_info *fieinfo,\n\t\t\t       u64 map_start)\n{\n\tint ret;\n\tunsigned int id_count;\n\tstruct ocfs2_dinode *di;\n\tu64 phys;\n\tu32 flags = FIEMAP_EXTENT_DATA_INLINE|FIEMAP_EXTENT_LAST;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\tid_count = ocfs2_fast_symlink_chars(inode->i_sb);\n\telse\n\t\tid_count = le16_to_cpu(di->id2.i_data.id_count);\n\n\tif (map_start < id_count) {\n\t\tphys = oi->ip_blkno << inode->i_sb->s_blocksize_bits;\n\t\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\t\tphys += offsetof(struct ocfs2_dinode, id2.i_symlink);\n\t\telse\n\t\t\tphys += offsetof(struct ocfs2_dinode,\n\t\t\t\t\t id2.i_data.id_data);\n\n\t\tret = fiemap_fill_next_extent(fieinfo, 0, phys, id_count,\n\t\t\t\t\t      flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_fiemap_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t       struct fiemap_extent_info *fieinfo,\n\t\t\t       u64 map_start)\n{\n\tint ret;\n\tunsigned int id_count;\n\tstruct ocfs2_dinode *di;\n\tu64 phys;\n\tu32 flags = FIEMAP_EXTENT_DATA_INLINE|FIEMAP_EXTENT_LAST;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\tid_count = ocfs2_fast_symlink_chars(inode->i_sb);\n\telse\n\t\tid_count = le16_to_cpu(di->id2.i_data.id_count);\n\n\tif (map_start < id_count) {\n\t\tphys = oi->ip_blkno << inode->i_sb->s_blocksize_bits;\n\t\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\t\tphys += offsetof(struct ocfs2_dinode, id2.i_symlink);\n\t\telse\n\t\t\tphys += offsetof(struct ocfs2_dinode,\n\t\t\t\t\t id2.i_data.id_data);\n\n\t\tret = fiemap_fill_next_extent(fieinfo, 0, phys, id_count,\n\t\t\t\t\t      flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/symlink.h",
          "lines": "35-39",
          "snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "0"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fiemap_check_flags",
          "args": [
            "fieinfo",
            "OCFS2_FIEMAP_FLAGS"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "138-148",
          "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#define OCFS2_FIEMAP_FLAGS\t(FIEMAP_FLAG_SYNC)\n\nint ocfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t u64 map_start, u64 map_len)\n{\n\tint ret, is_last;\n\tu32 mapping_end, cpos;\n\tunsigned int hole_size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu64 len_bytes, phys_bytes, virt_bytes;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tret = fiemap_check_flags(fieinfo, OCFS2_FIEMAP_FLAGS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\t/*\n\t * Handle inline-data and fast symlink separately.\n\t */\n\tif ((OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    ocfs2_inode_is_fast_symlink(inode)) {\n\t\tret = ocfs2_fiemap_inline(inode, di_bh, fieinfo, map_start);\n\t\tgoto out_unlock;\n\t}\n\n\tcpos = map_start >> osb->s_clustersize_bits;\n\tmapping_end = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t       map_start + map_len);\n\tis_last = 0;\n\twhile (cpos < mapping_end && !is_last) {\n\t\tu32 fe_flags;\n\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos,\n\t\t\t\t\t\t &hole_size, &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tcpos += hole_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfe_flags = 0;\n\t\tif (rec.e_flags & OCFS2_EXT_UNWRITTEN)\n\t\t\tfe_flags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tif (rec.e_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tfe_flags |= FIEMAP_EXTENT_SHARED;\n\t\tif (is_last)\n\t\t\tfe_flags |= FIEMAP_EXTENT_LAST;\n\t\tlen_bytes = (u64)le16_to_cpu(rec.e_leaf_clusters) << osb->s_clustersize_bits;\n\t\tphys_bytes = le64_to_cpu(rec.e_blkno) << osb->sb->s_blocksize_bits;\n\t\tvirt_bytes = (u64)le32_to_cpu(rec.e_cpos) << osb->s_clustersize_bits;\n\n\t\tret = fiemap_fill_next_extent(fieinfo, virt_bytes, phys_bytes,\n\t\t\t\t\t      len_bytes, fe_flags);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcpos = le32_to_cpu(rec.e_cpos)+ le16_to_cpu(rec.e_leaf_clusters);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout_unlock:\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fiemap_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "713-745",
    "snippet": "static int ocfs2_fiemap_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t       struct fiemap_extent_info *fieinfo,\n\t\t\t       u64 map_start)\n{\n\tint ret;\n\tunsigned int id_count;\n\tstruct ocfs2_dinode *di;\n\tu64 phys;\n\tu32 flags = FIEMAP_EXTENT_DATA_INLINE|FIEMAP_EXTENT_LAST;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\tid_count = ocfs2_fast_symlink_chars(inode->i_sb);\n\telse\n\t\tid_count = le16_to_cpu(di->id2.i_data.id_count);\n\n\tif (map_start < id_count) {\n\t\tphys = oi->ip_blkno << inode->i_sb->s_blocksize_bits;\n\t\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\t\tphys += offsetof(struct ocfs2_dinode, id2.i_symlink);\n\t\telse\n\t\t\tphys += offsetof(struct ocfs2_dinode,\n\t\t\t\t\t id2.i_data.id_data);\n\n\t\tret = fiemap_fill_next_extent(fieinfo, 0, phys, id_count,\n\t\t\t\t\t      flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "0",
            "phys",
            "id_count",
            "flags"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/symlink.h",
          "lines": "35-39",
          "snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->id2.i_data.id_count"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fast_symlink_chars",
          "args": [
            "inode->i_sb"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fast_symlink_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1480-1483",
          "snippet": "static inline int ocfs2_fast_symlink_chars(int blocksize)\n{\n\treturn blocksize - offsetof(struct ocfs2_dinode, id2.i_symlink);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_fast_symlink_chars(int blocksize)\n{\n\treturn blocksize - offsetof(struct ocfs2_dinode, id2.i_symlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_fiemap_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t       struct fiemap_extent_info *fieinfo,\n\t\t\t       u64 map_start)\n{\n\tint ret;\n\tunsigned int id_count;\n\tstruct ocfs2_dinode *di;\n\tu64 phys;\n\tu32 flags = FIEMAP_EXTENT_DATA_INLINE|FIEMAP_EXTENT_LAST;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\tid_count = ocfs2_fast_symlink_chars(inode->i_sb);\n\telse\n\t\tid_count = le16_to_cpu(di->id2.i_data.id_count);\n\n\tif (map_start < id_count) {\n\t\tphys = oi->ip_blkno << inode->i_sb->s_blocksize_bits;\n\t\tif (ocfs2_inode_is_fast_symlink(inode))\n\t\t\tphys += offsetof(struct ocfs2_dinode, id2.i_symlink);\n\t\telse\n\t\t\tphys += offsetof(struct ocfs2_dinode,\n\t\t\t\t\t id2.i_data.id_data);\n\n\t\tret = fiemap_fill_next_extent(fieinfo, 0, phys, id_count,\n\t\t\t\t\t      flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_extent_map_get_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "671-705",
    "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "bpc - 1"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "num_clusters"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "bpc - 1"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "extent_flags"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "v_blkno"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "608-665",
    "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_insert_rec",
          "args": [
            "inode",
            "&rec"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_insert_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "227-286",
          "snippet": "void ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_relative_extent_offsets",
          "args": [
            "inode->i_sb",
            "v_cluster",
            "&rec",
            "p_cluster",
            "num_clusters"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_relative_extent_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "528-541",
          "snippet": "static void ocfs2_relative_extent_offsets(struct super_block *sb,\n\t\t\t\t\t  u32 v_cluster,\n\t\t\t\t\t  struct ocfs2_extent_rec *rec,\n\t\t\t\t\t  u32 *p_cluster, u32 *num_clusters)\n\n{\n\tu32 coff = v_cluster - le32_to_cpu(rec->e_cpos);\n\n\t*p_cluster = ocfs2_blocks_to_clusters(sb, le64_to_cpu(rec->e_blkno));\n\t*p_cluster = *p_cluster + coff;\n\n\tif (num_clusters)\n\t\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters) - coff;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_relative_extent_offsets(struct super_block *sb,\n\t\t\t\t\t  u32 v_cluster,\n\t\t\t\t\t  struct ocfs2_extent_rec *rec,\n\t\t\t\t\t  u32 *p_cluster, u32 *num_clusters)\n\n{\n\tu32 coff = v_cluster - le32_to_cpu(rec->e_cpos);\n\n\t*p_cluster = ocfs2_blocks_to_clusters(sb, le64_to_cpu(rec->e_blkno));\n\t*p_cluster = *p_cluster + coff;\n\n\tif (num_clusters)\n\t\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters) - coff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters_nocache",
          "args": [
            "inode",
            "di_bh",
            "v_cluster",
            "&hole_len",
            "&rec",
            "NULL"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "410-526",
          "snippet": "static int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_lookup",
          "args": [
            "inode",
            "v_cluster",
            "p_cluster",
            "num_clusters",
            "extent_flags"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "83-109",
          "snippet": "static int ocfs2_extent_map_lookup(struct inode *inode, unsigned int cpos,\n\t\t\t\t   unsigned int *phys, unsigned int *len,\n\t\t\t\t   unsigned int *flags)\n{\n\tunsigned int coff;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map_item *emi;\n\n\tspin_lock(&oi->ip_lock);\n\n\t__ocfs2_extent_map_lookup(&oi->ip_extent_map, cpos, &emi);\n\tif (emi) {\n\t\tcoff = cpos - emi->ei_cpos;\n\t\t*phys = emi->ei_phys + coff;\n\t\tif (len)\n\t\t\t*len = emi->ei_clusters - coff;\n\t\tif (flags)\n\t\t\t*flags = emi->ei_flags;\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\n\tif (emi == NULL)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extent_map_lookup(struct inode *inode, unsigned int cpos,\n\t\t\t\t   unsigned int *phys, unsigned int *len,\n\t\t\t\t   unsigned int *flags)\n{\n\tunsigned int coff;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map_item *emi;\n\n\tspin_lock(&oi->ip_lock);\n\n\t__ocfs2_extent_map_lookup(&oi->ip_extent_map, cpos, &emi);\n\tif (emi) {\n\t\tcoff = cpos - emi->ei_cpos;\n\t\t*phys = emi->ei_phys + coff;\n\t\tif (len)\n\t\t\t*len = emi->ei_clusters - coff;\n\t\tif (flags)\n\t\t\t*flags = emi->ei_flags;\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\n\tif (emi == NULL)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_get_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "543-606",
    "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "le64_to_cpu(rec->e_blkno)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\"",
            "inode->i_ino",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "v_cluster < le32_to_cpu(rec->e_cpos)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "v_cluster"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_leaf",
          "args": [
            "INODE_CACHE(inode)",
            "el",
            "v_cluster",
            "&eb_bh"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1917-1933",
          "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_relative_extent_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "528-541",
    "snippet": "static void ocfs2_relative_extent_offsets(struct super_block *sb,\n\t\t\t\t\t  u32 v_cluster,\n\t\t\t\t\t  struct ocfs2_extent_rec *rec,\n\t\t\t\t\t  u32 *p_cluster, u32 *num_clusters)\n\n{\n\tu32 coff = v_cluster - le32_to_cpu(rec->e_cpos);\n\n\t*p_cluster = ocfs2_blocks_to_clusters(sb, le64_to_cpu(rec->e_blkno));\n\t*p_cluster = *p_cluster + coff;\n\n\tif (num_clusters)\n\t\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters) - coff;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "sb",
            "le64_to_cpu(rec->e_blkno)"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_relative_extent_offsets(struct super_block *sb,\n\t\t\t\t\t  u32 v_cluster,\n\t\t\t\t\t  struct ocfs2_extent_rec *rec,\n\t\t\t\t\t  u32 *p_cluster, u32 *num_clusters)\n\n{\n\tu32 coff = v_cluster - le32_to_cpu(rec->e_cpos);\n\n\t*p_cluster = ocfs2_blocks_to_clusters(sb, le64_to_cpu(rec->e_blkno));\n\t*p_cluster = *p_cluster + coff;\n\n\tif (num_clusters)\n\t\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters) - coff;\n}"
  },
  {
    "function_name": "ocfs2_get_clusters_nocache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "410-526",
    "snippet": "static int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_last_eb_is_empty",
          "args": [
            "inode",
            "di"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_last_eb_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "288-324",
          "snippet": "static int ocfs2_last_eb_is_empty(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tint ret, next_free;\n\tu64 last_eb_blk = le64_to_cpu(di->i_last_eb_blk);\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_read_extent_block(INODE_CACHE(inode), last_eb_blk, &eb_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\tel = &eb->h_list;\n\n\tif (el->l_tree_depth) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0])))\n\t\tret = 1;\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_last_eb_is_empty(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tint ret, next_free;\n\tu64 last_eb_blk = le64_to_cpu(di->i_last_eb_blk);\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_read_extent_block(INODE_CACHE(inode), last_eb_blk, &eb_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\tel = &eb->h_list;\n\n\tif (el->l_tree_depth) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0])))\n\t\tret = 1;\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\"",
            "inode->i_ino",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "v_cluster < le32_to_cpu(rec->e_cpos)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_hole_clusters",
          "args": [
            "INODE_CACHE(inode)",
            "el",
            "eb_bh",
            "v_cluster",
            "&len"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_hole_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "357-408",
          "snippet": "int ocfs2_figure_hole_clusters(struct ocfs2_caching_info *ci,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct buffer_head *eb_bh,\n\t\t\t       u32 v_cluster,\n\t\t\t       u32 *num_clusters)\n{\n\tint ret, i;\n\tstruct buffer_head *next_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb, *next_eb;\n\n\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\n\tif (i == le16_to_cpu(el->l_next_free_rec) && eb_bh) {\n\t\teb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t\t/*\n\t\t * Check the next leaf for any extents.\n\t\t */\n\n\t\tif (le64_to_cpu(eb->h_next_leaf_blk) == 0ULL)\n\t\t\tgoto no_more_extents;\n\n\t\tret = ocfs2_read_extent_block(ci,\n\t\t\t\t\t      le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t      &next_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnext_eb = (struct ocfs2_extent_block *)next_eb_bh->b_data;\n\t\tel = &next_eb->h_list;\n\t\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\t}\n\nno_more_extents:\n\tif (i == le16_to_cpu(el->l_next_free_rec)) {\n\t\t/*\n\t\t * We're at the end of our existing allocation. Just\n\t\t * return the maximum number of clusters we could\n\t\t * possibly allocate.\n\t\t */\n\t\t*num_clusters = UINT_MAX - v_cluster;\n\t} else {\n\t\t*num_clusters = le32_to_cpu(el->l_recs[i].e_cpos) - v_cluster;\n\t}\n\n\tret = 0;\nout:\n\tbrelse(next_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_figure_hole_clusters(struct ocfs2_caching_info *ci,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct buffer_head *eb_bh,\n\t\t\t       u32 v_cluster,\n\t\t\t       u32 *num_clusters)\n{\n\tint ret, i;\n\tstruct buffer_head *next_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb, *next_eb;\n\n\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\n\tif (i == le16_to_cpu(el->l_next_free_rec) && eb_bh) {\n\t\teb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t\t/*\n\t\t * Check the next leaf for any extents.\n\t\t */\n\n\t\tif (le64_to_cpu(eb->h_next_leaf_blk) == 0ULL)\n\t\t\tgoto no_more_extents;\n\n\t\tret = ocfs2_read_extent_block(ci,\n\t\t\t\t\t      le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t      &next_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnext_eb = (struct ocfs2_extent_block *)next_eb_bh->b_data;\n\t\tel = &next_eb->h_list;\n\t\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\t}\n\nno_more_extents:\n\tif (i == le16_to_cpu(el->l_next_free_rec)) {\n\t\t/*\n\t\t * We're at the end of our existing allocation. Just\n\t\t * return the maximum number of clusters we could\n\t\t * possibly allocate.\n\t\t */\n\t\t*num_clusters = UINT_MAX - v_cluster;\n\t} else {\n\t\t*num_clusters = le32_to_cpu(el->l_recs[i].e_cpos) - v_cluster;\n\t}\n\n\tret = 0;\nout:\n\tbrelse(next_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "v_cluster"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_leaf",
          "args": [
            "INODE_CACHE(inode)",
            "el",
            "v_cluster",
            "&eb_bh"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1917-1933",
          "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret_rec",
            "0",
            "sizeof(*ret_rec)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_clusters_nocache(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh,\n\t\t\t\t      u32 v_cluster, unsigned int *hole_len,\n\t\t\t\t      struct ocfs2_extent_rec *ret_rec,\n\t\t\t\t      unsigned int *is_last)\n{\n\tint i, ret, tree_height, len;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_extent_block *uninitialized_var(eb);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct buffer_head *eb_bh = NULL;\n\n\tmemset(ret_rec, 0, sizeof(*ret_rec));\n\tif (is_last)\n\t\t*is_last = 0;\n\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\tel = &di->id2.i_list;\n\ttree_height = le16_to_cpu(el->l_tree_depth);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\t/*\n\t\t * Holes can be larger than the maximum size of an\n\t\t * extent, so we return their lengths in a separate\n\t\t * field.\n\t\t */\n\t\tif (hole_len) {\n\t\t\tret = ocfs2_figure_hole_clusters(INODE_CACHE(inode),\n\t\t\t\t\t\t\t el, eb_bh,\n\t\t\t\t\t\t\t v_cluster, &len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*hole_len = len;\n\t\t}\n\t\tgoto out_hole;\n\t}\n\n\trec = &el->l_recs[i];\n\n\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\tif (!rec->e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0)\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*ret_rec = *rec;\n\n\t/*\n\t * Checking for last extent is potentially expensive - we\n\t * might have to look at the next leaf over to see if it's\n\t * empty.\n\t *\n\t * The first two checks are to see whether the caller even\n\t * cares for this information, and if the extent is at least\n\t * the last in it's list.\n\t *\n\t * If those hold true, then the extent is last if any of the\n\t * additional conditions hold true:\n\t *  - Extent list is in-inode\n\t *  - Extent list is right-most\n\t *  - Extent list is 2nd to rightmost, with empty right-most\n\t */\n\tif (is_last) {\n\t\tif (i == (le16_to_cpu(el->l_next_free_rec) - 1)) {\n\t\t\tif (tree_height == 0)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_blkno == di->i_last_eb_blk)\n\t\t\t\t*is_last = 1;\n\t\t\telse if (eb->h_next_leaf_blk == di->i_last_eb_blk) {\n\t\t\t\tret = ocfs2_last_eb_is_empty(inode, di);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ret == 1)\n\t\t\t\t\t*is_last = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout_hole:\n\tret = 0;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_figure_hole_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "357-408",
    "snippet": "int ocfs2_figure_hole_clusters(struct ocfs2_caching_info *ci,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct buffer_head *eb_bh,\n\t\t\t       u32 v_cluster,\n\t\t\t       u32 *num_clusters)\n{\n\tint ret, i;\n\tstruct buffer_head *next_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb, *next_eb;\n\n\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\n\tif (i == le16_to_cpu(el->l_next_free_rec) && eb_bh) {\n\t\teb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t\t/*\n\t\t * Check the next leaf for any extents.\n\t\t */\n\n\t\tif (le64_to_cpu(eb->h_next_leaf_blk) == 0ULL)\n\t\t\tgoto no_more_extents;\n\n\t\tret = ocfs2_read_extent_block(ci,\n\t\t\t\t\t      le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t      &next_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnext_eb = (struct ocfs2_extent_block *)next_eb_bh->b_data;\n\t\tel = &next_eb->h_list;\n\t\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\t}\n\nno_more_extents:\n\tif (i == le16_to_cpu(el->l_next_free_rec)) {\n\t\t/*\n\t\t * We're at the end of our existing allocation. Just\n\t\t * return the maximum number of clusters we could\n\t\t * possibly allocate.\n\t\t */\n\t\t*num_clusters = UINT_MAX - v_cluster;\n\t} else {\n\t\t*num_clusters = le32_to_cpu(el->l_recs[i].e_cpos) - v_cluster;\n\t}\n\n\tret = 0;\nout:\n\tbrelse(next_eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "next_eb_bh"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[i].e_cpos"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_for_hole_index",
          "args": [
            "el",
            "v_cluster"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_for_hole_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "330-344",
          "snippet": "static int ocfs2_search_for_hole_index(struct ocfs2_extent_list *el,\n\t\t\t\t       u32 v_cluster)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (v_cluster < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_search_for_hole_index(struct ocfs2_extent_list *el,\n\t\t\t\t       u32 v_cluster)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (v_cluster < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "ci",
            "le64_to_cpu(eb->h_next_leaf_blk)",
            "&next_eb_bh"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_next_leaf_blk"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_figure_hole_clusters(struct ocfs2_caching_info *ci,\n\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t       struct buffer_head *eb_bh,\n\t\t\t       u32 v_cluster,\n\t\t\t       u32 *num_clusters)\n{\n\tint ret, i;\n\tstruct buffer_head *next_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb, *next_eb;\n\n\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\n\tif (i == le16_to_cpu(el->l_next_free_rec) && eb_bh) {\n\t\teb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t\t/*\n\t\t * Check the next leaf for any extents.\n\t\t */\n\n\t\tif (le64_to_cpu(eb->h_next_leaf_blk) == 0ULL)\n\t\t\tgoto no_more_extents;\n\n\t\tret = ocfs2_read_extent_block(ci,\n\t\t\t\t\t      le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t      &next_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnext_eb = (struct ocfs2_extent_block *)next_eb_bh->b_data;\n\t\tel = &next_eb->h_list;\n\t\ti = ocfs2_search_for_hole_index(el, v_cluster);\n\t}\n\nno_more_extents:\n\tif (i == le16_to_cpu(el->l_next_free_rec)) {\n\t\t/*\n\t\t * We're at the end of our existing allocation. Just\n\t\t * return the maximum number of clusters we could\n\t\t * possibly allocate.\n\t\t */\n\t\t*num_clusters = UINT_MAX - v_cluster;\n\t} else {\n\t\t*num_clusters = le32_to_cpu(el->l_recs[i].e_cpos) - v_cluster;\n\t}\n\n\tret = 0;\nout:\n\tbrelse(next_eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_search_for_hole_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "330-344",
    "snippet": "static int ocfs2_search_for_hole_index(struct ocfs2_extent_list *el,\n\t\t\t\t       u32 v_cluster)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (v_cluster < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_search_for_hole_index(struct ocfs2_extent_list *el,\n\t\t\t\t       u32 v_cluster)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (v_cluster < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "ocfs2_last_eb_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "288-324",
    "snippet": "static int ocfs2_last_eb_is_empty(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tint ret, next_free;\n\tu64 last_eb_blk = le64_to_cpu(di->i_last_eb_blk);\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_read_extent_block(INODE_CACHE(inode), last_eb_blk, &eb_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\tel = &eb->h_list;\n\n\tif (el->l_tree_depth) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0])))\n\t\tret = 1;\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has non zero tree depth in \"\n\t\t\t    \"leaf block %llu\\n\"",
            "inode->i_ino",
            "(unsigned long long)eb_bh->b_blocknr"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "INODE_CACHE(inode)",
            "last_eb_blk",
            "&eb_bh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_last_eb_blk"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_last_eb_is_empty(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tint ret, next_free;\n\tu64 last_eb_blk = le64_to_cpu(di->i_last_eb_blk);\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_read_extent_block(INODE_CACHE(inode), last_eb_blk, &eb_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\tel = &eb->h_list;\n\n\tif (el->l_tree_depth) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0])))\n\t\tret = 1;\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_extent_map_insert_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "227-286",
    "snippet": "void ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_emi"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_copy_emi_fields",
          "args": [
            "emi",
            "&ins"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_copy_emi_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "171-178",
          "snippet": "static void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&emi->ei_list",
            "&em->em_list"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "em->em_list.prev",
            "structocfs2_extent_map_item",
            "ei_list"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&em->em_list) || em->em_num_items == 0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&em->em_list"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_emi->ei_list",
            "&em->em_list"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new_emi)",
            "GFP_NOFS"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&emi->ei_list",
            "&em->em_list"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_try_to_merge_extent_map",
          "args": [
            "emi",
            "&ins"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_to_merge_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "184-217",
          "snippet": "static int ocfs2_try_to_merge_extent_map(struct ocfs2_extent_map_item *emi,\n\t\t\t\t\t struct ocfs2_extent_map_item *ins)\n{\n\t/*\n\t * Handle contiguousness\n\t */\n\tif (ins->ei_phys == (emi->ei_phys + emi->ei_clusters) &&\n\t    ins->ei_cpos == (emi->ei_cpos + emi->ei_clusters) &&\n\t    ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t} else if ((ins->ei_phys + ins->ei_clusters) == emi->ei_phys &&\n\t\t   (ins->ei_cpos + ins->ei_clusters) == emi->ei_cpos &&\n\t\t   ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_phys = ins->ei_phys;\n\t\temi->ei_cpos = ins->ei_cpos;\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Overlapping extents - this shouldn't happen unless we've\n\t * split an extent to change it's flags. That is exceedingly\n\t * rare, so there's no sense in trying to optimize it yet.\n\t */\n\tif (ocfs2_ei_is_contained(emi, ins) ||\n\t    ocfs2_ei_is_contained(ins, emi)) {\n\t\tocfs2_copy_emi_fields(emi, ins);\n\t\treturn 1;\n\t}\n\n\t/* No merge was possible. */\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_try_to_merge_extent_map(struct ocfs2_extent_map_item *emi,\n\t\t\t\t\t struct ocfs2_extent_map_item *ins)\n{\n\t/*\n\t * Handle contiguousness\n\t */\n\tif (ins->ei_phys == (emi->ei_phys + emi->ei_clusters) &&\n\t    ins->ei_cpos == (emi->ei_cpos + emi->ei_clusters) &&\n\t    ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t} else if ((ins->ei_phys + ins->ei_clusters) == emi->ei_phys &&\n\t\t   (ins->ei_cpos + ins->ei_clusters) == emi->ei_cpos &&\n\t\t   ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_phys = ins->ei_phys;\n\t\temi->ei_cpos = ins->ei_cpos;\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Overlapping extents - this shouldn't happen unless we've\n\t * split an extent to change it's flags. That is exceedingly\n\t * rare, so there's no sense in trying to optimize it yet.\n\t */\n\tif (ocfs2_ei_is_contained(emi, ins) ||\n\t    ocfs2_ei_is_contained(ins, emi)) {\n\t\tocfs2_copy_emi_fields(emi, ins);\n\t\treturn 1;\n\t}\n\n\t/* No merge was possible. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "emi",
            "&em->em_list",
            "ei_list"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "le64_to_cpu(rec->e_blkno)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}"
  },
  {
    "function_name": "ocfs2_try_to_merge_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "184-217",
    "snippet": "static int ocfs2_try_to_merge_extent_map(struct ocfs2_extent_map_item *emi,\n\t\t\t\t\t struct ocfs2_extent_map_item *ins)\n{\n\t/*\n\t * Handle contiguousness\n\t */\n\tif (ins->ei_phys == (emi->ei_phys + emi->ei_clusters) &&\n\t    ins->ei_cpos == (emi->ei_cpos + emi->ei_clusters) &&\n\t    ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t} else if ((ins->ei_phys + ins->ei_clusters) == emi->ei_phys &&\n\t\t   (ins->ei_cpos + ins->ei_clusters) == emi->ei_cpos &&\n\t\t   ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_phys = ins->ei_phys;\n\t\temi->ei_cpos = ins->ei_cpos;\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Overlapping extents - this shouldn't happen unless we've\n\t * split an extent to change it's flags. That is exceedingly\n\t * rare, so there's no sense in trying to optimize it yet.\n\t */\n\tif (ocfs2_ei_is_contained(emi, ins) ||\n\t    ocfs2_ei_is_contained(ins, emi)) {\n\t\tocfs2_copy_emi_fields(emi, ins);\n\t\treturn 1;\n\t}\n\n\t/* No merge was possible. */\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_copy_emi_fields",
          "args": [
            "emi",
            "ins"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_copy_emi_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "171-178",
          "snippet": "static void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_ei_is_contained",
          "args": [
            "ins",
            "emi"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ei_is_contained",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "149-169",
          "snippet": "static int ocfs2_ei_is_contained(struct ocfs2_extent_map_item *emi1,\n\t\t\t\t struct ocfs2_extent_map_item *emi2)\n{\n\tunsigned int range1, range2;\n\n\t/*\n\t * Check if logical start of emi2 is inside emi1\n\t */\n\trange1 = emi1->ei_cpos + emi1->ei_clusters;\n\tif (emi2->ei_cpos >= emi1->ei_cpos && emi2->ei_cpos < range1)\n\t\treturn 1;\n\n\t/*\n\t * Check if logical end of emi2 is inside emi1\n\t */\n\trange2 = emi2->ei_cpos + emi2->ei_clusters;\n\tif (range2 > emi1->ei_cpos && range2 <= range1)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_ei_is_contained(struct ocfs2_extent_map_item *emi1,\n\t\t\t\t struct ocfs2_extent_map_item *emi2)\n{\n\tunsigned int range1, range2;\n\n\t/*\n\t * Check if logical start of emi2 is inside emi1\n\t */\n\trange1 = emi1->ei_cpos + emi1->ei_clusters;\n\tif (emi2->ei_cpos >= emi1->ei_cpos && emi2->ei_cpos < range1)\n\t\treturn 1;\n\n\t/*\n\t * Check if logical end of emi2 is inside emi1\n\t */\n\trange2 = emi2->ei_cpos + emi2->ei_clusters;\n\tif (range2 > emi1->ei_cpos && range2 <= range1)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_try_to_merge_extent_map(struct ocfs2_extent_map_item *emi,\n\t\t\t\t\t struct ocfs2_extent_map_item *ins)\n{\n\t/*\n\t * Handle contiguousness\n\t */\n\tif (ins->ei_phys == (emi->ei_phys + emi->ei_clusters) &&\n\t    ins->ei_cpos == (emi->ei_cpos + emi->ei_clusters) &&\n\t    ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t} else if ((ins->ei_phys + ins->ei_clusters) == emi->ei_phys &&\n\t\t   (ins->ei_cpos + ins->ei_clusters) == emi->ei_cpos &&\n\t\t   ins->ei_flags == emi->ei_flags) {\n\t\temi->ei_phys = ins->ei_phys;\n\t\temi->ei_cpos = ins->ei_cpos;\n\t\temi->ei_clusters += ins->ei_clusters;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Overlapping extents - this shouldn't happen unless we've\n\t * split an extent to change it's flags. That is exceedingly\n\t * rare, so there's no sense in trying to optimize it yet.\n\t */\n\tif (ocfs2_ei_is_contained(emi, ins) ||\n\t    ocfs2_ei_is_contained(ins, emi)) {\n\t\tocfs2_copy_emi_fields(emi, ins);\n\t\treturn 1;\n\t}\n\n\t/* No merge was possible. */\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_copy_emi_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "171-178",
    "snippet": "static void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_copy_emi_fields(struct ocfs2_extent_map_item *dest,\n\t\t\t\t  struct ocfs2_extent_map_item *src)\n{\n\tdest->ei_cpos = src->ei_cpos;\n\tdest->ei_phys = src->ei_phys;\n\tdest->ei_clusters = src->ei_clusters;\n\tdest->ei_flags = src->ei_flags;\n}"
  },
  {
    "function_name": "ocfs2_ei_is_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "149-169",
    "snippet": "static int ocfs2_ei_is_contained(struct ocfs2_extent_map_item *emi1,\n\t\t\t\t struct ocfs2_extent_map_item *emi2)\n{\n\tunsigned int range1, range2;\n\n\t/*\n\t * Check if logical start of emi2 is inside emi1\n\t */\n\trange1 = emi1->ei_cpos + emi1->ei_clusters;\n\tif (emi2->ei_cpos >= emi1->ei_cpos && emi2->ei_cpos < range1)\n\t\treturn 1;\n\n\t/*\n\t * Check if logical end of emi2 is inside emi1\n\t */\n\trange2 = emi2->ei_cpos + emi2->ei_clusters;\n\tif (range2 > emi1->ei_cpos && range2 <= range1)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_ei_is_contained(struct ocfs2_extent_map_item *emi1,\n\t\t\t\t struct ocfs2_extent_map_item *emi2)\n{\n\tunsigned int range1, range2;\n\n\t/*\n\t * Check if logical start of emi2 is inside emi1\n\t */\n\trange1 = emi1->ei_cpos + emi1->ei_clusters;\n\tif (emi2->ei_cpos >= emi1->ei_cpos && emi2->ei_cpos < range1)\n\t\treturn 1;\n\n\t/*\n\t * Check if logical end of emi2 is inside emi1\n\t */\n\trange2 = emi2->ei_cpos + emi2->ei_clusters;\n\tif (range2 > emi1->ei_cpos && range2 <= range1)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_extent_map_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "114-144",
    "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "emi"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&emi->ei_list"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "emi",
            "n",
            "&tmp_list",
            "ei_list"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "em->em_num_items == 0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&emi->ei_list",
            "&tmp_list"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "emi",
            "n",
            "&em->em_list",
            "ei_list"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_extent_map_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "83-109",
    "snippet": "static int ocfs2_extent_map_lookup(struct inode *inode, unsigned int cpos,\n\t\t\t\t   unsigned int *phys, unsigned int *len,\n\t\t\t\t   unsigned int *flags)\n{\n\tunsigned int coff;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map_item *emi;\n\n\tspin_lock(&oi->ip_lock);\n\n\t__ocfs2_extent_map_lookup(&oi->ip_extent_map, cpos, &emi);\n\tif (emi) {\n\t\tcoff = cpos - emi->ei_cpos;\n\t\t*phys = emi->ei_phys + coff;\n\t\tif (len)\n\t\t\t*len = emi->ei_clusters - coff;\n\t\tif (flags)\n\t\t\t*flags = emi->ei_flags;\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\n\tif (emi == NULL)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_extent_map_lookup",
          "args": [
            "&oi->ip_extent_map",
            "cpos",
            "&emi"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_extent_map_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "62-81",
          "snippet": "static void __ocfs2_extent_map_lookup(struct ocfs2_extent_map *em,\n\t\t\t\t      unsigned int cpos,\n\t\t\t\t      struct ocfs2_extent_map_item **ret_emi)\n{\n\tunsigned int range;\n\tstruct ocfs2_extent_map_item *emi;\n\n\t*ret_emi = NULL;\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\n\t\tif (cpos >= emi->ei_cpos && cpos < range) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\n\t\t\t*ret_emi = emi;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void __ocfs2_extent_map_lookup(struct ocfs2_extent_map *em,\n\t\t\t\t      unsigned int cpos,\n\t\t\t\t      struct ocfs2_extent_map_item **ret_emi)\n{\n\tunsigned int range;\n\tstruct ocfs2_extent_map_item *emi;\n\n\t*ret_emi = NULL;\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\n\t\tif (cpos >= emi->ei_cpos && cpos < range) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\n\t\t\t*ret_emi = emi;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extent_map_lookup(struct inode *inode, unsigned int cpos,\n\t\t\t\t   unsigned int *phys, unsigned int *len,\n\t\t\t\t   unsigned int *flags)\n{\n\tunsigned int coff;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map_item *emi;\n\n\tspin_lock(&oi->ip_lock);\n\n\t__ocfs2_extent_map_lookup(&oi->ip_extent_map, cpos, &emi);\n\tif (emi) {\n\t\tcoff = cpos - emi->ei_cpos;\n\t\t*phys = emi->ei_phys + coff;\n\t\tif (len)\n\t\t\t*len = emi->ei_clusters - coff;\n\t\tif (flags)\n\t\t\t*flags = emi->ei_flags;\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\n\tif (emi == NULL)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ocfs2_extent_map_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "62-81",
    "snippet": "static void __ocfs2_extent_map_lookup(struct ocfs2_extent_map *em,\n\t\t\t\t      unsigned int cpos,\n\t\t\t\t      struct ocfs2_extent_map_item **ret_emi)\n{\n\tunsigned int range;\n\tstruct ocfs2_extent_map_item *emi;\n\n\t*ret_emi = NULL;\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\n\t\tif (cpos >= emi->ei_cpos && cpos < range) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\n\t\t\t*ret_emi = emi;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&emi->ei_list",
            "&em->em_list"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "emi",
            "&em->em_list",
            "ei_list"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic void __ocfs2_extent_map_lookup(struct ocfs2_extent_map *em,\n\t\t\t\t      unsigned int cpos,\n\t\t\t\t      struct ocfs2_extent_map_item **ret_emi)\n{\n\tunsigned int range;\n\tstruct ocfs2_extent_map_item *emi;\n\n\t*ret_emi = NULL;\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\n\t\tif (cpos >= emi->ei_cpos && cpos < range) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\n\t\t\t*ret_emi = emi;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ocfs2_extent_map_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
    "lines": "54-60",
    "snippet": "void ocfs2_extent_map_init(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->ip_extent_map.em_num_items = 0;\n\tINIT_LIST_HEAD(&oi->ip_extent_map.em_list);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"symlink.h\"",
      "#include \"super.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&oi->ip_extent_map.em_list"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_init(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->ip_extent_map.em_num_items = 0;\n\tINIT_LIST_HEAD(&oi->ip_extent_map.em_list);\n}"
  }
]