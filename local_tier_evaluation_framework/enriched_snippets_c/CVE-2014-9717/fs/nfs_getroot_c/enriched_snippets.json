[
  {
    "function_name": "nfs_get_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/getroot.c",
    "lines": "71-133",
    "snippet": "struct dentry *nfs_get_root(struct super_block *sb, struct nfs_fh *mntfh,\n\t\t\t    const char *devname)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\tstruct nfs_fsinfo fsinfo;\n\tstruct dentry *ret;\n\tstruct inode *inode;\n\tvoid *name = kstrdup(devname, GFP_KERNEL);\n\tint error;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get the actual root for this mount */\n\tfsinfo.fattr = nfs_alloc_fattr();\n\tif (fsinfo.fattr == NULL) {\n\t\tkfree(name);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terror = server->nfs_client->rpc_ops->getroot(server, mntfh, &fsinfo);\n\tif (error < 0) {\n\t\tdprintk(\"nfs_get_root: getattr error = %d\\n\", -error);\n\t\tret = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tinode = nfs_fhget(sb, mntfh, fsinfo.fattr, NULL);\n\tif (IS_ERR(inode)) {\n\t\tdprintk(\"nfs_get_root: get root inode failed\\n\");\n\t\tret = ERR_CAST(inode);\n\t\tgoto out;\n\t}\n\n\terror = nfs_superblock_set_dummy_root(sb, inode);\n\tif (error != 0) {\n\t\tret = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\t/* root dentries normally start off anonymous and get spliced in later\n\t * if the dentry tree reaches them; however if the dentry already\n\t * exists, we'll pick it up at this point and use it as the root\n\t */\n\tret = d_obtain_root(inode);\n\tif (IS_ERR(ret)) {\n\t\tdprintk(\"nfs_get_root: get root dentry failed\\n\");\n\t\tgoto out;\n\t}\n\n\tsecurity_d_instantiate(ret, inode);\n\tspin_lock(&ret->d_lock);\n\tif (IS_ROOT(ret) && !ret->d_fsdata &&\n\t    !(ret->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tret->d_fsdata = name;\n\t\tname = NULL;\n\t}\n\tspin_unlock(&ret->d_lock);\nout:\n\tkfree(name);\n\tnfs_free_fattr(fsinfo.fattr);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/unistd.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fsinfo.fattr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ret->d_lock"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "ret"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ret->d_lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_d_instantiate",
          "args": [
            "ret",
            "inode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_get_root: get root dentry failed\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ret"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_root",
          "args": [
            "inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1998-2001",
          "snippet": "struct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_superblock_set_dummy_root",
          "args": [
            "sb",
            "inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_superblock_set_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/getroot.c",
          "lines": "43-66",
          "snippet": "static int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *inode)\n{\n\t/* The mntroot acts as the dummy root dentry for this superblock */\n\tif (sb->s_root == NULL) {\n\t\tsb->s_root = d_make_root(inode);\n\t\tif (sb->s_root == NULL)\n\t\t\treturn -ENOMEM;\n\t\tihold(inode);\n\t\t/*\n\t\t * Ensure that this dentry is invisible to d_find_alias().\n\t\t * Otherwise, it may be spliced into the tree by\n\t\t * d_splice_alias if a parent directory from the same\n\t\t * filesystem gets mounted at a later time.\n\t\t * This again causes shrink_dcache_for_umount_subtree() to\n\t\t * Oops, since the test for IS_ROOT() will fail.\n\t\t */\n\t\tspin_lock(&sb->s_root->d_inode->i_lock);\n\t\tspin_lock(&sb->s_root->d_lock);\n\t\thlist_del_init(&sb->s_root->d_u.d_alias);\n\t\tspin_unlock(&sb->s_root->d_lock);\n\t\tspin_unlock(&sb->s_root->d_inode->i_lock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *inode)\n{\n\t/* The mntroot acts as the dummy root dentry for this superblock */\n\tif (sb->s_root == NULL) {\n\t\tsb->s_root = d_make_root(inode);\n\t\tif (sb->s_root == NULL)\n\t\t\treturn -ENOMEM;\n\t\tihold(inode);\n\t\t/*\n\t\t * Ensure that this dentry is invisible to d_find_alias().\n\t\t * Otherwise, it may be spliced into the tree by\n\t\t * d_splice_alias if a parent directory from the same\n\t\t * filesystem gets mounted at a later time.\n\t\t * This again causes shrink_dcache_for_umount_subtree() to\n\t\t * Oops, since the test for IS_ROOT() will fail.\n\t\t */\n\t\tspin_lock(&sb->s_root->d_inode->i_lock);\n\t\tspin_lock(&sb->s_root->d_lock);\n\t\thlist_del_init(&sb->s_root->d_u.d_alias);\n\t\tspin_unlock(&sb->s_root->d_lock);\n\t\tspin_unlock(&sb->s_root->d_inode->i_lock);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_get_root: get root inode failed\\n\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fhget",
          "args": [
            "sb",
            "mntfh",
            "fsinfo.fattr",
            "NULL"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fhget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "343-490",
          "snippet": "struct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfs_get_root: getattr error = %d\\n\"",
            "-error"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->nfs_client->rpc_ops->getroot",
          "args": [
            "server",
            "mntfh",
            "&fsinfo"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "devname",
            "GFP_KERNEL"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "sb"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct dentry *nfs_get_root(struct super_block *sb, struct nfs_fh *mntfh,\n\t\t\t    const char *devname)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\tstruct nfs_fsinfo fsinfo;\n\tstruct dentry *ret;\n\tstruct inode *inode;\n\tvoid *name = kstrdup(devname, GFP_KERNEL);\n\tint error;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get the actual root for this mount */\n\tfsinfo.fattr = nfs_alloc_fattr();\n\tif (fsinfo.fattr == NULL) {\n\t\tkfree(name);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terror = server->nfs_client->rpc_ops->getroot(server, mntfh, &fsinfo);\n\tif (error < 0) {\n\t\tdprintk(\"nfs_get_root: getattr error = %d\\n\", -error);\n\t\tret = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tinode = nfs_fhget(sb, mntfh, fsinfo.fattr, NULL);\n\tif (IS_ERR(inode)) {\n\t\tdprintk(\"nfs_get_root: get root inode failed\\n\");\n\t\tret = ERR_CAST(inode);\n\t\tgoto out;\n\t}\n\n\terror = nfs_superblock_set_dummy_root(sb, inode);\n\tif (error != 0) {\n\t\tret = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\t/* root dentries normally start off anonymous and get spliced in later\n\t * if the dentry tree reaches them; however if the dentry already\n\t * exists, we'll pick it up at this point and use it as the root\n\t */\n\tret = d_obtain_root(inode);\n\tif (IS_ERR(ret)) {\n\t\tdprintk(\"nfs_get_root: get root dentry failed\\n\");\n\t\tgoto out;\n\t}\n\n\tsecurity_d_instantiate(ret, inode);\n\tspin_lock(&ret->d_lock);\n\tif (IS_ROOT(ret) && !ret->d_fsdata &&\n\t    !(ret->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tret->d_fsdata = name;\n\t\tname = NULL;\n\t}\n\tspin_unlock(&ret->d_lock);\nout:\n\tkfree(name);\n\tnfs_free_fattr(fsinfo.fattr);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_superblock_set_dummy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/getroot.c",
    "lines": "43-66",
    "snippet": "static int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *inode)\n{\n\t/* The mntroot acts as the dummy root dentry for this superblock */\n\tif (sb->s_root == NULL) {\n\t\tsb->s_root = d_make_root(inode);\n\t\tif (sb->s_root == NULL)\n\t\t\treturn -ENOMEM;\n\t\tihold(inode);\n\t\t/*\n\t\t * Ensure that this dentry is invisible to d_find_alias().\n\t\t * Otherwise, it may be spliced into the tree by\n\t\t * d_splice_alias if a parent directory from the same\n\t\t * filesystem gets mounted at a later time.\n\t\t * This again causes shrink_dcache_for_umount_subtree() to\n\t\t * Oops, since the test for IS_ROOT() will fail.\n\t\t */\n\t\tspin_lock(&sb->s_root->d_inode->i_lock);\n\t\tspin_lock(&sb->s_root->d_lock);\n\t\thlist_del_init(&sb->s_root->d_u.d_alias);\n\t\tspin_unlock(&sb->s_root->d_lock);\n\t\tspin_unlock(&sb->s_root->d_inode->i_lock);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/unistd.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb->s_root->d_inode->i_lock"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&sb->s_root->d_u.d_alias"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb->s_root->d_lock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *inode)\n{\n\t/* The mntroot acts as the dummy root dentry for this superblock */\n\tif (sb->s_root == NULL) {\n\t\tsb->s_root = d_make_root(inode);\n\t\tif (sb->s_root == NULL)\n\t\t\treturn -ENOMEM;\n\t\tihold(inode);\n\t\t/*\n\t\t * Ensure that this dentry is invisible to d_find_alias().\n\t\t * Otherwise, it may be spliced into the tree by\n\t\t * d_splice_alias if a parent directory from the same\n\t\t * filesystem gets mounted at a later time.\n\t\t * This again causes shrink_dcache_for_umount_subtree() to\n\t\t * Oops, since the test for IS_ROOT() will fail.\n\t\t */\n\t\tspin_lock(&sb->s_root->d_inode->i_lock);\n\t\tspin_lock(&sb->s_root->d_lock);\n\t\thlist_del_init(&sb->s_root->d_u.d_alias);\n\t\tspin_unlock(&sb->s_root->d_lock);\n\t\tspin_unlock(&sb->s_root->d_inode->i_lock);\n\t}\n\treturn 0;\n}"
  }
]