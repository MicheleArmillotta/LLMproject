[
  {
    "function_name": "nfsd4_block_proc_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayout.c",
    "lines": "151-181",
    "snippet": "static __be32\nnfsd4_block_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\tint error;\n\n\tnr_iomaps = nfsd4_block_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "error"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iomaps"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_export_op->commit_blocks",
          "args": [
            "inode",
            "iomaps",
            "nr_iomaps",
            "&iattr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&lcp->lc_mtime",
            "&inode->i_mtime"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_block_decode_layoutupdate",
          "args": [
            "lcp->lc_up_layout",
            "lcp->lc_up_len",
            "&iomaps",
            "1 << inode->i_blkbits"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_decode_layoutupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayoutxdr.c",
          "lines": "91-157",
          "snippet": "int\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * NFS4_BLOCK_EXTENT_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset %lld\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"blocklayoutxdr.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfs4.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\nint\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * NFS4_BLOCK_EXTENT_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length %lld\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset %lld\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <linux/nfsd/debug.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\tint error;\n\n\tnr_iomaps = nfsd4_block_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}"
  },
  {
    "function_name": "nfsd4_block_proc_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayout.c",
    "lines": "47-149",
    "snippet": "static __be32\nnfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\n\t\tstruct nfsd4_layoutget *args)\n{\n\tstruct nfsd4_layout_seg *seg = &args->lg_seg;\n\tstruct super_block *sb = inode->i_sb;\n\tu32 block_size = (1 << inode->i_blkbits);\n\tstruct pnfs_block_extent *bex;\n\tstruct iomap iomap;\n\tu32 device_generation = 0;\n\tint error;\n\n\t/*\n\t * We do not attempt to support I/O smaller than the fs block size,\n\t * or not aligned to it.\n\t */\n\tif (args->lg_minlength < block_size) {\n\t\tdprintk(\"pnfsd: I/O too small\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\tif (seg->offset & (block_size - 1)) {\n\t\tdprintk(\"pnfsd: I/O misaligned\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\t/*\n\t * Some clients barf on non-zero block numbers for NONE or INVALID\n\t * layouts, so make sure to zero the whole structure.\n\t */\n\terror = -ENOMEM;\n\tbex = kzalloc(sizeof(*bex), GFP_KERNEL);\n\tif (!bex)\n\t\tgoto out_error;\n\targs->lg_content = bex;\n\n\terror = sb->s_export_op->map_blocks(inode, seg->offset, seg->length,\n\t\t\t\t\t    &iomap, seg->iomode != IOMODE_READ,\n\t\t\t\t\t    &device_generation);\n\tif (error) {\n\t\tif (error == -ENXIO)\n\t\t\tgoto out_layoutunavailable;\n\t\tgoto out_error;\n\t}\n\n\tif (iomap.length < args->lg_minlength) {\n\t\tdprintk(\"pnfsd: extent smaller than minlength\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (seg->iomode == IOMODE_READ)\n\t\t\tbex->es = PNFS_BLOCK_READ_DATA;\n\t\telse\n\t\t\tbex->es = PNFS_BLOCK_READWRITE_DATA;\n\t\tbex->soff = (iomap.blkno << 9);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tif (seg->iomode & IOMODE_RW) {\n\t\t\t/*\n\t\t\t * Crack monkey special case from section 2.3.1.\n\t\t\t */\n\t\t\tif (args->lg_minlength == 0) {\n\t\t\t\tdprintk(\"pnfsd: no soup for you!\\n\");\n\t\t\t\tgoto out_layoutunavailable;\n\t\t\t}\n\n\t\t\tbex->es = PNFS_BLOCK_INVALID_DATA;\n\t\t\tbex->soff = (iomap.blkno << 9);\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_HOLE:\n\t\tif (seg->iomode == IOMODE_READ) {\n\t\t\tbex->es = PNFS_BLOCK_NONE_DATA;\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_DELALLOC:\n\tdefault:\n\t\tWARN(1, \"pnfsd: filesystem returned %d extent\\n\", iomap.type);\n\t\tgoto out_layoutunavailable;\n\t}\n\n\terror = nfsd4_set_deviceid(&bex->vol_id, fhp, device_generation);\n\tif (error)\n\t\tgoto out_error;\n\tbex->foff = iomap.offset;\n\tbex->len = iomap.length;\n\n\tseg->offset = iomap.offset;\n\tseg->length = iomap.length;\n\n\tdprintk(\"GET: %lld:%lld %d\\n\", bex->foff, bex->len, bex->es);\n\treturn 0;\n\nout_error:\n\tseg->length = 0;\n\treturn nfserrno(error);\nout_layoutunavailable:\n\tseg->length = 0;\n\treturn nfserr_layoutunavailable;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "error"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"GET: %lld:%lld %d\\n\"",
            "bex->foff",
            "bex->len",
            "bex->es"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_set_deviceid",
          "args": [
            "&bex->vol_id",
            "fhp",
            "device_generation"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "101-115",
          "snippet": "int\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nint\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"pnfsd: filesystem returned %d extent\\n\"",
            "iomap.type"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: no soup for you!\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: extent smaller than minlength\\n\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_export_op->map_blocks",
          "args": [
            "inode",
            "seg->offset",
            "seg->length",
            "&iomap",
            "seg->iomode != IOMODE_READ",
            "&device_generation"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bex)",
            "GFP_KERNEL"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: I/O misaligned\\n\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: I/O too small\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <linux/nfsd/debug.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\n\t\tstruct nfsd4_layoutget *args)\n{\n\tstruct nfsd4_layout_seg *seg = &args->lg_seg;\n\tstruct super_block *sb = inode->i_sb;\n\tu32 block_size = (1 << inode->i_blkbits);\n\tstruct pnfs_block_extent *bex;\n\tstruct iomap iomap;\n\tu32 device_generation = 0;\n\tint error;\n\n\t/*\n\t * We do not attempt to support I/O smaller than the fs block size,\n\t * or not aligned to it.\n\t */\n\tif (args->lg_minlength < block_size) {\n\t\tdprintk(\"pnfsd: I/O too small\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\tif (seg->offset & (block_size - 1)) {\n\t\tdprintk(\"pnfsd: I/O misaligned\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\t/*\n\t * Some clients barf on non-zero block numbers for NONE or INVALID\n\t * layouts, so make sure to zero the whole structure.\n\t */\n\terror = -ENOMEM;\n\tbex = kzalloc(sizeof(*bex), GFP_KERNEL);\n\tif (!bex)\n\t\tgoto out_error;\n\targs->lg_content = bex;\n\n\terror = sb->s_export_op->map_blocks(inode, seg->offset, seg->length,\n\t\t\t\t\t    &iomap, seg->iomode != IOMODE_READ,\n\t\t\t\t\t    &device_generation);\n\tif (error) {\n\t\tif (error == -ENXIO)\n\t\t\tgoto out_layoutunavailable;\n\t\tgoto out_error;\n\t}\n\n\tif (iomap.length < args->lg_minlength) {\n\t\tdprintk(\"pnfsd: extent smaller than minlength\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (seg->iomode == IOMODE_READ)\n\t\t\tbex->es = PNFS_BLOCK_READ_DATA;\n\t\telse\n\t\t\tbex->es = PNFS_BLOCK_READWRITE_DATA;\n\t\tbex->soff = (iomap.blkno << 9);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tif (seg->iomode & IOMODE_RW) {\n\t\t\t/*\n\t\t\t * Crack monkey special case from section 2.3.1.\n\t\t\t */\n\t\t\tif (args->lg_minlength == 0) {\n\t\t\t\tdprintk(\"pnfsd: no soup for you!\\n\");\n\t\t\t\tgoto out_layoutunavailable;\n\t\t\t}\n\n\t\t\tbex->es = PNFS_BLOCK_INVALID_DATA;\n\t\t\tbex->soff = (iomap.blkno << 9);\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_HOLE:\n\t\tif (seg->iomode == IOMODE_READ) {\n\t\t\tbex->es = PNFS_BLOCK_NONE_DATA;\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_DELALLOC:\n\tdefault:\n\t\tWARN(1, \"pnfsd: filesystem returned %d extent\\n\", iomap.type);\n\t\tgoto out_layoutunavailable;\n\t}\n\n\terror = nfsd4_set_deviceid(&bex->vol_id, fhp, device_generation);\n\tif (error)\n\t\tgoto out_error;\n\tbex->foff = iomap.offset;\n\tbex->len = iomap.length;\n\n\tseg->offset = iomap.offset;\n\tseg->length = iomap.length;\n\n\tdprintk(\"GET: %lld:%lld %d\\n\", bex->foff, bex->len, bex->es);\n\treturn 0;\n\nout_error:\n\tseg->length = 0;\n\treturn nfserrno(error);\nout_layoutunavailable:\n\tseg->length = 0;\n\treturn nfserr_layoutunavailable;\n}"
  },
  {
    "function_name": "nfsd4_block_proc_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayout.c",
    "lines": "38-45",
    "snippet": "static __be32\nnfsd4_block_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (sb->s_bdev != sb->s_bdev->bd_contains)\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_simple(sb, gdp));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nfsd4_block_get_device_info_simple(sb, gdp)"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_block_get_device_info_simple",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_get_device_info_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayout.c",
          "lines": "16-36",
          "snippet": "static int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <linux/nfsd/debug.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <linux/nfsd/debug.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (sb->s_bdev != sb->s_bdev->bd_contains)\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_simple(sb, gdp));\n}"
  },
  {
    "function_name": "nfsd4_block_get_device_info_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/blocklayout.c",
    "lines": "16-36",
    "snippet": "static int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb->s_export_op->get_uuid",
          "args": [
            "sb",
            "b->simple.sig",
            "&b->simple.sig_len",
            "&b->simple.offset"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume)",
            "GFP_KERNEL"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <linux/nfsd/debug.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}"
  }
]