[
  {
    "function_name": "dlm_recoverd_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "338-341",
    "snippet": "void dlm_recoverd_resume(struct dlm_ls *ls)\n{\n\tmutex_unlock(&ls->ls_recoverd_active);\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_recoverd_active"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_resume(struct dlm_ls *ls)\n{\n\tmutex_unlock(&ls->ls_recoverd_active);\n}"
  },
  {
    "function_name": "dlm_recoverd_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "332-336",
    "snippet": "void dlm_recoverd_suspend(struct dlm_ls *ls)\n{\n\twake_up(&ls->ls_wait_general);\n\tmutex_lock(&ls->ls_recoverd_active);\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_recoverd_active"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ls->ls_wait_general"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_suspend(struct dlm_ls *ls)\n{\n\twake_up(&ls->ls_wait_general);\n\tmutex_lock(&ls->ls_recoverd_active);\n}"
  },
  {
    "function_name": "dlm_recoverd_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "327-330",
    "snippet": "void dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "ls->ls_recoverd_task"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}"
  },
  {
    "function_name": "dlm_recoverd_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "314-325",
    "snippet": "int dlm_recoverd_start(struct dlm_ls *ls)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_recoverd, ls, \"dlm_recoverd\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n                ls->ls_recoverd_task = p;\n\treturn error;\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "dlm_recoverd",
            "ls",
            "\"dlm_recoverd\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recoverd_start(struct dlm_ls *ls)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_recoverd, ls, \"dlm_recoverd\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n                ls->ls_recoverd_task = p;\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_recoverd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "276-312",
    "snippet": "static int dlm_recoverd(void *arg)\n{\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_local(arg);\n\tif (!ls) {\n\t\tlog_print(\"dlm_recoverd: no lockspace %p\", arg);\n\t\treturn -1;\n\t}\n\n\tdown_write(&ls->ls_in_recovery);\n\tset_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\twake_up(&ls->ls_recover_lock_wait);\n\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!test_bit(LSFL_RECOVER_WORK, &ls->ls_flags) &&\n\t\t    !test_bit(LSFL_RECOVER_DOWN, &ls->ls_flags))\n\t\t\tschedule();\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tif (test_and_clear_bit(LSFL_RECOVER_DOWN, &ls->ls_flags)) {\n\t\t\tdown_write(&ls->ls_in_recovery);\n\t\t\tset_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\t\twake_up(&ls->ls_recover_lock_wait);\n\t\t}\n\n\t\tif (test_and_clear_bit(LSFL_RECOVER_WORK, &ls->ls_flags))\n\t\t\tdo_ls_recovery(ls);\n\t}\n\n\tif (test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags))\n\t\tup_write(&ls->ls_in_recovery);\n\n\tdlm_put_lockspace(ls);\n\treturn 0;\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RECOVER_LOCK",
            "&ls->ls_flags"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_ls_recovery",
          "args": [
            "ls"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "do_ls_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "258-274",
          "snippet": "static void do_ls_recovery(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trv = ls->ls_recover_args;\n\tls->ls_recover_args = NULL;\n\tif (rv && ls->ls_recover_seq == rv->seq)\n\t\tclear_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv) {\n\t\tls_recover(ls, rv);\n\t\tkfree(rv->nodes);\n\t\tkfree(rv);\n\t}\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void do_ls_recovery(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trv = ls->ls_recover_args;\n\tls->ls_recover_args = NULL;\n\tif (rv && ls->ls_recover_seq == rv->seq)\n\t\tclear_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv) {\n\t\tls_recover(ls, rv);\n\t\tkfree(rv->nodes);\n\t\tkfree(rv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "LSFL_RECOVER_WORK",
            "&ls->ls_flags"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ls->ls_recover_lock_wait"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_RECOVER_LOCK",
            "&ls->ls_flags"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_recoverd: no lockspace %p\"",
            "arg"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "arg"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int dlm_recoverd(void *arg)\n{\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_local(arg);\n\tif (!ls) {\n\t\tlog_print(\"dlm_recoverd: no lockspace %p\", arg);\n\t\treturn -1;\n\t}\n\n\tdown_write(&ls->ls_in_recovery);\n\tset_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\twake_up(&ls->ls_recover_lock_wait);\n\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!test_bit(LSFL_RECOVER_WORK, &ls->ls_flags) &&\n\t\t    !test_bit(LSFL_RECOVER_DOWN, &ls->ls_flags))\n\t\t\tschedule();\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tif (test_and_clear_bit(LSFL_RECOVER_DOWN, &ls->ls_flags)) {\n\t\t\tdown_write(&ls->ls_in_recovery);\n\t\t\tset_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\t\twake_up(&ls->ls_recover_lock_wait);\n\t\t}\n\n\t\tif (test_and_clear_bit(LSFL_RECOVER_WORK, &ls->ls_flags))\n\t\t\tdo_ls_recovery(ls);\n\t}\n\n\tif (test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags))\n\t\tup_write(&ls->ls_in_recovery);\n\n\tdlm_put_lockspace(ls);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_ls_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "258-274",
    "snippet": "static void do_ls_recovery(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trv = ls->ls_recover_args;\n\tls->ls_recover_args = NULL;\n\tif (rv && ls->ls_recover_seq == rv->seq)\n\t\tclear_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv) {\n\t\tls_recover(ls, rv);\n\t\tkfree(rv->nodes);\n\t\tkfree(rv);\n\t}\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rv"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rv->nodes"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_recover",
          "args": [
            "ls",
            "rv"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ls_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "53-252",
          "snippet": "static int ls_recover(struct dlm_ls *ls, struct dlm_recover *rv)\n{\n\tunsigned long start;\n\tint error, neg = 0;\n\n\tlog_rinfo(ls, \"dlm_recover %llu\", (unsigned long long)rv->seq);\n\n\tmutex_lock(&ls->ls_recoverd_active);\n\n\tdlm_callback_suspend(ls);\n\n\tdlm_clear_toss(ls);\n\n\t/*\n\t * This list of root rsb's will be the basis of most of the recovery\n\t * routines.\n\t */\n\n\tdlm_create_root_list(ls);\n\n\t/*\n\t * Add or remove nodes from the lockspace's ls_nodes list.\n\t */\n\n\terror = dlm_recover_members(ls, rv, &neg);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_dir_nodeid(ls);\n\n\tls->ls_recover_dir_sent_res = 0;\n\tls->ls_recover_dir_sent_msg = 0;\n\tls->ls_recover_locks_in = 0;\n\n\tdlm_set_recover_status(ls, DLM_RS_NODES);\n\n\terror = dlm_recover_members_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tstart = jiffies;\n\n\t/*\n\t * Rebuild our own share of the directory by collecting from all other\n\t * nodes their master rsb names that hash to us.\n\t */\n\n\terror = dlm_recover_directory(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\terror = dlm_recover_directory_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u out %u messages\",\n\t\t  ls->ls_recover_dir_sent_res, ls->ls_recover_dir_sent_msg);\n\n\t/*\n\t * We may have outstanding operations that are waiting for a reply from\n\t * a failed node.  Mark these to be resent after recovery.  Unlock and\n\t * cancel ops can just be completed.\n\t */\n\n\tdlm_recover_waiters_pre(ls);\n\n\terror = dlm_recovery_stopped(ls);\n\tif (error)\n\t\tgoto fail;\n\n\tif (neg || dlm_no_directory(ls)) {\n\t\t/*\n\t\t * Clear lkb's for departed nodes.\n\t\t */\n\n\t\tdlm_recover_purge(ls);\n\n\t\t/*\n\t\t * Get new master nodeid's for rsb's that were mastered on\n\t\t * departed nodes.\n\t\t */\n\n\t\terror = dlm_recover_masters(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_masters error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Send our locks on remastered rsb's to the new masters.\n\t\t */\n\n\t\terror = dlm_recover_locks(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlog_rinfo(ls, \"dlm_recover_locks %u in\",\n\t\t\t  ls->ls_recover_locks_in);\n\n\t\t/*\n\t\t * Finalize state in master rsb's now that all locks can be\n\t\t * checked.  This includes conversion resolution and lvb\n\t\t * settings.\n\t\t */\n\n\t\tdlm_recover_rsbs(ls);\n\t} else {\n\t\t/*\n\t\t * Other lockspace members may be going through the \"neg\" steps\n\t\t * while also adding us to the lockspace, in which case they'll\n\t\t * be doing the recover_locks (RS_LOCKS) barrier.\n\t\t */\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdlm_release_root_list(ls);\n\n\t/*\n\t * Purge directory-related requests that are saved in requestqueue.\n\t * All dir requests from before recovery are invalid now due to the dir\n\t * rebuild and will be resent by the requesting nodes.\n\t */\n\n\tdlm_purge_requestqueue(ls);\n\n\tdlm_set_recover_status(ls, DLM_RS_DONE);\n\n\terror = dlm_recover_done_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_done_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_clear_members_gone(ls);\n\n\tdlm_adjust_timeouts(ls);\n\n\tdlm_callback_resume(ls);\n\n\terror = enable_locking(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"enable_locking error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_process_requestqueue(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_process_requestqueue error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_recover_waiters_post(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_waiters_post error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_grant(ls);\n\n\tlog_rinfo(ls, \"dlm_recover %llu generation %u done: %u ms\",\n\t\t  (unsigned long long)rv->seq, ls->ls_generation,\n\t\t  jiffies_to_msecs(jiffies - start));\n\tmutex_unlock(&ls->ls_recoverd_active);\n\n\tdlm_lsop_recover_done(ls);\n\treturn 0;\n\n fail:\n\tdlm_release_root_list(ls);\n\tlog_rinfo(ls, \"dlm_recover %llu error %d\",\n\t\t  (unsigned long long)rv->seq, error);\n\tmutex_unlock(&ls->ls_recoverd_active);\n\treturn error;\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int ls_recover(struct dlm_ls *ls, struct dlm_recover *rv)\n{\n\tunsigned long start;\n\tint error, neg = 0;\n\n\tlog_rinfo(ls, \"dlm_recover %llu\", (unsigned long long)rv->seq);\n\n\tmutex_lock(&ls->ls_recoverd_active);\n\n\tdlm_callback_suspend(ls);\n\n\tdlm_clear_toss(ls);\n\n\t/*\n\t * This list of root rsb's will be the basis of most of the recovery\n\t * routines.\n\t */\n\n\tdlm_create_root_list(ls);\n\n\t/*\n\t * Add or remove nodes from the lockspace's ls_nodes list.\n\t */\n\n\terror = dlm_recover_members(ls, rv, &neg);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_dir_nodeid(ls);\n\n\tls->ls_recover_dir_sent_res = 0;\n\tls->ls_recover_dir_sent_msg = 0;\n\tls->ls_recover_locks_in = 0;\n\n\tdlm_set_recover_status(ls, DLM_RS_NODES);\n\n\terror = dlm_recover_members_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tstart = jiffies;\n\n\t/*\n\t * Rebuild our own share of the directory by collecting from all other\n\t * nodes their master rsb names that hash to us.\n\t */\n\n\terror = dlm_recover_directory(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\terror = dlm_recover_directory_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u out %u messages\",\n\t\t  ls->ls_recover_dir_sent_res, ls->ls_recover_dir_sent_msg);\n\n\t/*\n\t * We may have outstanding operations that are waiting for a reply from\n\t * a failed node.  Mark these to be resent after recovery.  Unlock and\n\t * cancel ops can just be completed.\n\t */\n\n\tdlm_recover_waiters_pre(ls);\n\n\terror = dlm_recovery_stopped(ls);\n\tif (error)\n\t\tgoto fail;\n\n\tif (neg || dlm_no_directory(ls)) {\n\t\t/*\n\t\t * Clear lkb's for departed nodes.\n\t\t */\n\n\t\tdlm_recover_purge(ls);\n\n\t\t/*\n\t\t * Get new master nodeid's for rsb's that were mastered on\n\t\t * departed nodes.\n\t\t */\n\n\t\terror = dlm_recover_masters(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_masters error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Send our locks on remastered rsb's to the new masters.\n\t\t */\n\n\t\terror = dlm_recover_locks(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlog_rinfo(ls, \"dlm_recover_locks %u in\",\n\t\t\t  ls->ls_recover_locks_in);\n\n\t\t/*\n\t\t * Finalize state in master rsb's now that all locks can be\n\t\t * checked.  This includes conversion resolution and lvb\n\t\t * settings.\n\t\t */\n\n\t\tdlm_recover_rsbs(ls);\n\t} else {\n\t\t/*\n\t\t * Other lockspace members may be going through the \"neg\" steps\n\t\t * while also adding us to the lockspace, in which case they'll\n\t\t * be doing the recover_locks (RS_LOCKS) barrier.\n\t\t */\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdlm_release_root_list(ls);\n\n\t/*\n\t * Purge directory-related requests that are saved in requestqueue.\n\t * All dir requests from before recovery are invalid now due to the dir\n\t * rebuild and will be resent by the requesting nodes.\n\t */\n\n\tdlm_purge_requestqueue(ls);\n\n\tdlm_set_recover_status(ls, DLM_RS_DONE);\n\n\terror = dlm_recover_done_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_done_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_clear_members_gone(ls);\n\n\tdlm_adjust_timeouts(ls);\n\n\tdlm_callback_resume(ls);\n\n\terror = enable_locking(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"enable_locking error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_process_requestqueue(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_process_requestqueue error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_recover_waiters_post(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_waiters_post error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_grant(ls);\n\n\tlog_rinfo(ls, \"dlm_recover %llu generation %u done: %u ms\",\n\t\t  (unsigned long long)rv->seq, ls->ls_generation,\n\t\t  jiffies_to_msecs(jiffies - start));\n\tmutex_unlock(&ls->ls_recoverd_active);\n\n\tdlm_lsop_recover_done(ls);\n\treturn 0;\n\n fail:\n\tdlm_release_root_list(ls);\n\tlog_rinfo(ls, \"dlm_recover %llu error %d\",\n\t\t  (unsigned long long)rv->seq, error);\n\tmutex_unlock(&ls->ls_recoverd_active);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "LSFL_RECOVER_STOP",
            "&ls->ls_flags"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void do_ls_recovery(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trv = ls->ls_recover_args;\n\tls->ls_recover_args = NULL;\n\tif (rv && ls->ls_recover_seq == rv->seq)\n\t\tclear_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv) {\n\t\tls_recover(ls, rv);\n\t\tkfree(rv->nodes);\n\t\tkfree(rv);\n\t}\n}"
  },
  {
    "function_name": "ls_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "53-252",
    "snippet": "static int ls_recover(struct dlm_ls *ls, struct dlm_recover *rv)\n{\n\tunsigned long start;\n\tint error, neg = 0;\n\n\tlog_rinfo(ls, \"dlm_recover %llu\", (unsigned long long)rv->seq);\n\n\tmutex_lock(&ls->ls_recoverd_active);\n\n\tdlm_callback_suspend(ls);\n\n\tdlm_clear_toss(ls);\n\n\t/*\n\t * This list of root rsb's will be the basis of most of the recovery\n\t * routines.\n\t */\n\n\tdlm_create_root_list(ls);\n\n\t/*\n\t * Add or remove nodes from the lockspace's ls_nodes list.\n\t */\n\n\terror = dlm_recover_members(ls, rv, &neg);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_dir_nodeid(ls);\n\n\tls->ls_recover_dir_sent_res = 0;\n\tls->ls_recover_dir_sent_msg = 0;\n\tls->ls_recover_locks_in = 0;\n\n\tdlm_set_recover_status(ls, DLM_RS_NODES);\n\n\terror = dlm_recover_members_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tstart = jiffies;\n\n\t/*\n\t * Rebuild our own share of the directory by collecting from all other\n\t * nodes their master rsb names that hash to us.\n\t */\n\n\terror = dlm_recover_directory(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\terror = dlm_recover_directory_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u out %u messages\",\n\t\t  ls->ls_recover_dir_sent_res, ls->ls_recover_dir_sent_msg);\n\n\t/*\n\t * We may have outstanding operations that are waiting for a reply from\n\t * a failed node.  Mark these to be resent after recovery.  Unlock and\n\t * cancel ops can just be completed.\n\t */\n\n\tdlm_recover_waiters_pre(ls);\n\n\terror = dlm_recovery_stopped(ls);\n\tif (error)\n\t\tgoto fail;\n\n\tif (neg || dlm_no_directory(ls)) {\n\t\t/*\n\t\t * Clear lkb's for departed nodes.\n\t\t */\n\n\t\tdlm_recover_purge(ls);\n\n\t\t/*\n\t\t * Get new master nodeid's for rsb's that were mastered on\n\t\t * departed nodes.\n\t\t */\n\n\t\terror = dlm_recover_masters(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_masters error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Send our locks on remastered rsb's to the new masters.\n\t\t */\n\n\t\terror = dlm_recover_locks(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlog_rinfo(ls, \"dlm_recover_locks %u in\",\n\t\t\t  ls->ls_recover_locks_in);\n\n\t\t/*\n\t\t * Finalize state in master rsb's now that all locks can be\n\t\t * checked.  This includes conversion resolution and lvb\n\t\t * settings.\n\t\t */\n\n\t\tdlm_recover_rsbs(ls);\n\t} else {\n\t\t/*\n\t\t * Other lockspace members may be going through the \"neg\" steps\n\t\t * while also adding us to the lockspace, in which case they'll\n\t\t * be doing the recover_locks (RS_LOCKS) barrier.\n\t\t */\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdlm_release_root_list(ls);\n\n\t/*\n\t * Purge directory-related requests that are saved in requestqueue.\n\t * All dir requests from before recovery are invalid now due to the dir\n\t * rebuild and will be resent by the requesting nodes.\n\t */\n\n\tdlm_purge_requestqueue(ls);\n\n\tdlm_set_recover_status(ls, DLM_RS_DONE);\n\n\terror = dlm_recover_done_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_done_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_clear_members_gone(ls);\n\n\tdlm_adjust_timeouts(ls);\n\n\tdlm_callback_resume(ls);\n\n\terror = enable_locking(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"enable_locking error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_process_requestqueue(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_process_requestqueue error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_recover_waiters_post(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_waiters_post error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_grant(ls);\n\n\tlog_rinfo(ls, \"dlm_recover %llu generation %u done: %u ms\",\n\t\t  (unsigned long long)rv->seq, ls->ls_generation,\n\t\t  jiffies_to_msecs(jiffies - start));\n\tmutex_unlock(&ls->ls_recoverd_active);\n\n\tdlm_lsop_recover_done(ls);\n\treturn 0;\n\n fail:\n\tdlm_release_root_list(ls);\n\tlog_rinfo(ls, \"dlm_recover %llu error %d\",\n\t\t  (unsigned long long)rv->seq, error);\n\tmutex_unlock(&ls->ls_recoverd_active);\n\treturn error;\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_recoverd_active"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover %llu error %d\"",
            "(unsigned long long)rv->seq",
            "error"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_release_root_list",
          "args": [
            "ls"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_root_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "921-931",
          "snippet": "void dlm_release_root_list(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *safe;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry_safe(r, safe, &ls->ls_root_list, res_root_list) {\n\t\tlist_del_init(&r->res_root_list);\n\t\tdlm_put_rsb(r);\n\t}\n\tup_write(&ls->ls_root_sem);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_release_root_list(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *safe;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry_safe(r, safe, &ls->ls_root_list, res_root_list) {\n\t\tlist_del_init(&r->res_root_list);\n\t\tdlm_put_rsb(r);\n\t}\n\tup_write(&ls->ls_root_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lsop_recover_done",
          "args": [
            "ls"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lsop_recover_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "485-515",
          "snippet": "void dlm_lsop_recover_done(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint i, num;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_done)\n\t\treturn;\n\n\tnum = ls->ls_num_nodes;\n\n\tslots = kzalloc(num * sizeof(struct dlm_slot), GFP_KERNEL);\n\tif (!slots)\n\t\treturn;\n\n\ti = 0;\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (i == num) {\n\t\t\tlog_error(ls, \"dlm_lsop_recover_done bad num %d\", num);\n\t\t\tgoto out;\n\t\t}\n\t\tslots[i].nodeid = memb->nodeid;\n\t\tslots[i].slot = memb->slot;\n\t\ti++;\n\t}\n\n\tls->ls_ops->recover_done(ls->ls_ops_arg, slots, num,\n\t\t\t\t ls->ls_slot, ls->ls_generation);\n out:\n\tkfree(slots);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_lsop_recover_done(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint i, num;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_done)\n\t\treturn;\n\n\tnum = ls->ls_num_nodes;\n\n\tslots = kzalloc(num * sizeof(struct dlm_slot), GFP_KERNEL);\n\tif (!slots)\n\t\treturn;\n\n\ti = 0;\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (i == num) {\n\t\t\tlog_error(ls, \"dlm_lsop_recover_done bad num %d\", num);\n\t\t\tgoto out;\n\t\t}\n\t\tslots[i].nodeid = memb->nodeid;\n\t\tslots[i].slot = memb->slot;\n\t\ti++;\n\t}\n\n\tls->ls_ops->recover_done(ls->ls_ops_arg, slots, num,\n\t\t\t\t ls->ls_slot, ls->ls_generation);\n out:\n\tkfree(slots);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_recoverd_active"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover %llu generation %u done: %u ms\"",
            "(unsigned long long)rv->seq",
            "ls->ls_generation",
            "jiffies_to_msecs(jiffies - start)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - start"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_grant",
          "args": [
            "ls"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5510-5542",
          "snippet": "void dlm_recover_grant(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint bucket = 0;\n\tunsigned int count = 0;\n\tunsigned int rsb_count = 0;\n\tunsigned int lkb_count = 0;\n\n\twhile (1) {\n\t\tr = find_grant_rsb(ls, bucket);\n\t\tif (!r) {\n\t\t\tif (bucket == ls->ls_rsbtbl_size - 1)\n\t\t\t\tbreak;\n\t\t\tbucket++;\n\t\t\tcontinue;\n\t\t}\n\t\trsb_count++;\n\t\tcount = 0;\n\t\tlock_rsb(r);\n\t\t/* the RECOVER_GRANT flag is checked in the grant path */\n\t\tgrant_pending_locks(r, &count);\n\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\tlkb_count += count;\n\t\tconfirm_master(r, 0);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tcond_resched();\n\t}\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_grant %u locks on %u resources\",\n\t\t\t  lkb_count, rsb_count);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_recover_grant(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint bucket = 0;\n\tunsigned int count = 0;\n\tunsigned int rsb_count = 0;\n\tunsigned int lkb_count = 0;\n\n\twhile (1) {\n\t\tr = find_grant_rsb(ls, bucket);\n\t\tif (!r) {\n\t\t\tif (bucket == ls->ls_rsbtbl_size - 1)\n\t\t\t\tbreak;\n\t\t\tbucket++;\n\t\t\tcontinue;\n\t\t}\n\t\trsb_count++;\n\t\tcount = 0;\n\t\tlock_rsb(r);\n\t\t/* the RECOVER_GRANT flag is checked in the grant path */\n\t\tgrant_pending_locks(r, &count);\n\t\trsb_clear_flag(r, RSB_RECOVER_GRANT);\n\t\tlkb_count += count;\n\t\tconfirm_master(r, 0);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tcond_resched();\n\t}\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_grant %u locks on %u resources\",\n\t\t\t  lkb_count, rsb_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_waiters_post error %d\"",
            "error"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_waiters_post",
          "args": [
            "ls"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_waiters_post",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5265-5359",
          "snippet": "int dlm_recover_waiters_post(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error = 0, mstype, err, oc, ou;\n\n\twhile (1) {\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"recover_waiters_post aborted\");\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tlkb = find_resend_waiter(ls);\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tmstype = lkb->lkb_wait_type;\n\t\toc = is_overlap_cancel(lkb);\n\t\tou = is_overlap_unlock(lkb);\n\t\terr = 0;\n\n\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d \"\n\t\t\t  \"overlap %d %d\", lkb->lkb_id, lkb->lkb_remid, mstype,\n\t\t\t  r->res_nodeid, lkb->lkb_nodeid, lkb->lkb_wait_nodeid,\n\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\n\t\t/* At this point we assume that we won't get a reply to any\n\t\t   previous op or overlap op on this lock.  First, do a big\n\t\t   remove_from_waiters() for all previous ops. */\n\n\t\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_wait_count = 0;\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\t\tunhold_lkb(lkb); /* for waiters list */\n\n\t\tif (oc || ou) {\n\t\t\t/* do an unlock or cancel instead of resending */\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\tqueue_cast(r, lkb, ou ? -DLM_EUNLOCK :\n\t\t\t\t\t\t\t-DLM_ECANCEL);\n\t\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\tif (oc) {\n\t\t\t\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\t\t\t} else {\n\t\t\t\t\tlkb->lkb_exflags |= DLM_LKF_FORCEUNLOCK;\n\t\t\t\t\t_unlock_lock(r, lkb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\t_request_lock(r, lkb);\n\t\t\t\tif (is_master(r))\n\t\t\t\t\tconfirm_master(r, 0);\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\t_convert_lock(r, lkb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (err) {\n\t\t\tlog_error(ls, \"waiter %x msg %d r_nodeid %d \"\n\t\t\t\t  \"dir_nodeid %d overlap %d %d\",\n\t\t\t\t  lkb->lkb_id, mstype, r->res_nodeid,\n\t\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_recover_waiters_post(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error = 0, mstype, err, oc, ou;\n\n\twhile (1) {\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"recover_waiters_post aborted\");\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tlkb = find_resend_waiter(ls);\n\t\tif (!lkb)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tmstype = lkb->lkb_wait_type;\n\t\toc = is_overlap_cancel(lkb);\n\t\tou = is_overlap_unlock(lkb);\n\t\terr = 0;\n\n\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d \"\n\t\t\t  \"overlap %d %d\", lkb->lkb_id, lkb->lkb_remid, mstype,\n\t\t\t  r->res_nodeid, lkb->lkb_nodeid, lkb->lkb_wait_nodeid,\n\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\n\t\t/* At this point we assume that we won't get a reply to any\n\t\t   previous op or overlap op on this lock.  First, do a big\n\t\t   remove_from_waiters() for all previous ops. */\n\n\t\tlkb->lkb_flags &= ~DLM_IFL_RESEND;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\n\t\tlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\n\t\tlkb->lkb_wait_type = 0;\n\t\tlkb->lkb_wait_count = 0;\n\t\tmutex_lock(&ls->ls_waiters_mutex);\n\t\tlist_del_init(&lkb->lkb_wait_reply);\n\t\tmutex_unlock(&ls->ls_waiters_mutex);\n\t\tunhold_lkb(lkb); /* for waiters list */\n\n\t\tif (oc || ou) {\n\t\t\t/* do an unlock or cancel instead of resending */\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\tqueue_cast(r, lkb, ou ? -DLM_EUNLOCK :\n\t\t\t\t\t\t\t-DLM_ECANCEL);\n\t\t\t\tunhold_lkb(lkb); /* undoes create_lkb() */\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\tif (oc) {\n\t\t\t\t\tqueue_cast(r, lkb, -DLM_ECANCEL);\n\t\t\t\t} else {\n\t\t\t\t\tlkb->lkb_exflags |= DLM_LKF_FORCEUNLOCK;\n\t\t\t\t\t_unlock_lock(r, lkb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (mstype) {\n\t\t\tcase DLM_MSG_LOOKUP:\n\t\t\tcase DLM_MSG_REQUEST:\n\t\t\t\t_request_lock(r, lkb);\n\t\t\t\tif (is_master(r))\n\t\t\t\t\tconfirm_master(r, 0);\n\t\t\t\tbreak;\n\t\t\tcase DLM_MSG_CONVERT:\n\t\t\t\t_convert_lock(r, lkb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (err) {\n\t\t\tlog_error(ls, \"waiter %x msg %d r_nodeid %d \"\n\t\t\t\t  \"dir_nodeid %d overlap %d %d\",\n\t\t\t\t  lkb->lkb_id, mstype, r->res_nodeid,\n\t\t\t\t  dlm_dir_nodeid(r), oc, ou);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_process_requestqueue error %d\"",
            "error"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_process_requestqueue",
          "args": [
            "ls"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_process_requestqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
          "lines": "65-106",
          "snippet": "int dlm_process_requestqueue(struct dlm_ls *ls)\n{\n\tstruct rq_entry *e;\n\tstruct dlm_message *ms;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\n\tfor (;;) {\n\t\tif (list_empty(&ls->ls_requestqueue)) {\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\te = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\n\t\tms = &e->request;\n\n\t\tlog_limit(ls, \"dlm_process_requestqueue msg %d from %d \"\n\t\t\t  \"lkid %x remid %x result %d seq %u\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, ms->m_remid, ms->m_result,\n\t\t\t  e->recover_seq);\n\n\t\tdlm_receive_message_saved(ls, &e->request, e->recover_seq);\n\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"process_requestqueue abort running\");\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"requestqueue.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"member.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nint dlm_process_requestqueue(struct dlm_ls *ls)\n{\n\tstruct rq_entry *e;\n\tstruct dlm_message *ms;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\n\tfor (;;) {\n\t\tif (list_empty(&ls->ls_requestqueue)) {\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\te = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\n\t\tms = &e->request;\n\n\t\tlog_limit(ls, \"dlm_process_requestqueue msg %d from %d \"\n\t\t\t  \"lkid %x remid %x result %d seq %u\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, ms->m_remid, ms->m_result,\n\t\t\t  e->recover_seq);\n\n\t\tdlm_receive_message_saved(ls, &e->request, e->recover_seq);\n\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"process_requestqueue abort running\");\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"enable_locking error %d\"",
            "error"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_locking",
          "args": [
            "ls",
            "rv->seq"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "enable_locking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "33-51",
          "snippet": "static int enable_locking(struct dlm_ls *ls, uint64_t seq)\n{\n\tint error = -EINTR;\n\n\tdown_write(&ls->ls_recv_active);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_recover_seq == seq) {\n\t\tset_bit(LSFL_RUNNING, &ls->ls_flags);\n\t\t/* unblocks processes waiting to enter the dlm */\n\t\tup_write(&ls->ls_in_recovery);\n\t\tclear_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\terror = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tup_write(&ls->ls_recv_active);\n\treturn error;\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int enable_locking(struct dlm_ls *ls, uint64_t seq)\n{\n\tint error = -EINTR;\n\n\tdown_write(&ls->ls_recv_active);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_recover_seq == seq) {\n\t\tset_bit(LSFL_RUNNING, &ls->ls_flags);\n\t\t/* unblocks processes waiting to enter the dlm */\n\t\tup_write(&ls->ls_in_recovery);\n\t\tclear_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\terror = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tup_write(&ls->ls_recv_active);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_callback_resume",
          "args": [
            "ls"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_callback_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "293-313",
          "snippet": "void dlm_callback_resume(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tint count = 0;\n\n\tclear_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (!ls->ls_callback_wq)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_cb_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_cb_delay, lkb_cb_list) {\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\tcount++;\n\t}\n\tmutex_unlock(&ls->ls_cb_mutex);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_callback_resume %d\", count);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_resume(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tint count = 0;\n\n\tclear_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (!ls->ls_callback_wq)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_cb_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_cb_delay, lkb_cb_list) {\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\tcount++;\n\t}\n\tmutex_unlock(&ls->ls_cb_mutex);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_callback_resume %d\", count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_adjust_timeouts",
          "args": [
            "ls"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_adjust_timeouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1924-1944",
          "snippet": "void dlm_adjust_timeouts(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tu64 adj_us = jiffies_to_usecs(jiffies - ls->ls_recover_begin);\n\n\tls->ls_recover_begin = 0;\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list)\n\t\tlkb->lkb_timestamp = ktime_add_us(lkb->lkb_timestamp, adj_us);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_to_us(lkb->lkb_wait_time))\n\t\t\tlkb->lkb_wait_time = ktime_get();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_adjust_timeouts(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tu64 adj_us = jiffies_to_usecs(jiffies - ls->ls_recover_begin);\n\n\tls->ls_recover_begin = 0;\n\tmutex_lock(&ls->ls_timeout_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list)\n\t\tlkb->lkb_timestamp = ktime_add_us(lkb->lkb_timestamp, adj_us);\n\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_to_us(lkb->lkb_wait_time))\n\t\t\tlkb->lkb_wait_time = ktime_get();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_clear_members_gone",
          "args": [
            "ls"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clear_members_gone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "382-385",
          "snippet": "void dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_done_wait error %d\"",
            "error"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_done_wait",
          "args": [
            "ls"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_done_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "220-223",
          "snippet": "int dlm_recover_done_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DONE);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_done_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_recover_status",
          "args": [
            "ls",
            "DLM_RS_DONE"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "86-91",
          "snippet": "void dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_purge_requestqueue",
          "args": [
            "ls"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_purge_requestqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
          "lines": "155-170",
          "snippet": "void dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
          "includes": [
            "#include \"requestqueue.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"member.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_locks_wait error %d\"",
            "error"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_locks_wait",
          "args": [
            "ls"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_locks_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "215-218",
          "snippet": "int dlm_recover_locks_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_LOCKS);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_locks_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_LOCKS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_rsbs",
          "args": [
            "ls"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_rsbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "856-887",
          "snippet": "void dlm_recover_rsbs(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tif (rsb_flag(r, RSB_RECOVER_CONVERT))\n\t\t\t\trecover_conversion(r);\n\n\t\t\t/* recover lvb before granting locks so the updated\n\t\t\t   lvb/VALNOTVALID is presented in the completion */\n\t\t\trecover_lvb(r);\n\n\t\t\tif (rsb_flag(r, RSB_NEW_MASTER2))\n\t\t\t\trecover_grant(r);\n\t\t\tcount++;\n\t\t} else {\n\t\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t\t}\n\t\trsb_clear_flag(r, RSB_RECOVER_CONVERT);\n\t\trsb_clear_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\trsb_clear_flag(r, RSB_NEW_MASTER2);\n\t\tunlock_rsb(r);\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_recover_rsbs %d done\", count);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recover_rsbs(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tif (rsb_flag(r, RSB_RECOVER_CONVERT))\n\t\t\t\trecover_conversion(r);\n\n\t\t\t/* recover lvb before granting locks so the updated\n\t\t\t   lvb/VALNOTVALID is presented in the completion */\n\t\t\trecover_lvb(r);\n\n\t\t\tif (rsb_flag(r, RSB_NEW_MASTER2))\n\t\t\t\trecover_grant(r);\n\t\t\tcount++;\n\t\t} else {\n\t\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t\t}\n\t\trsb_clear_flag(r, RSB_RECOVER_CONVERT);\n\t\trsb_clear_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\trsb_clear_flag(r, RSB_NEW_MASTER2);\n\t\tunlock_rsb(r);\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_recover_rsbs %d done\", count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_locks %u in\"",
            "ls->ls_recover_locks_in"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_locks_wait error %d\"",
            "error"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_locks error %d\"",
            "error"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_locks",
          "args": [
            "ls"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "657-695",
          "snippet": "int dlm_recover_locks(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint error, count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rsb_flag(r, RSB_NEW_MASTER))\n\t\t\tcontinue;\n\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = recover_locks(r);\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcount += r->res_recover_locks_count;\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_locks %d out\", count);\n\n\terror = dlm_wait_function(ls, &recover_list_empty);\n out:\n\tif (error)\n\t\trecover_list_clear(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_locks(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint error, count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rsb_flag(r, RSB_NEW_MASTER))\n\t\t\tcontinue;\n\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = recover_locks(r);\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcount += r->res_recover_locks_count;\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_locks %d out\", count);\n\n\terror = dlm_wait_function(ls, &recover_list_empty);\n out:\n\tif (error)\n\t\trecover_list_clear(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_masters error %d\"",
            "error"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_masters",
          "args": [
            "ls"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_masters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "521-562",
          "snippet": "int dlm_recover_masters(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int total = 0;\n\tunsigned int count = 0;\n\tint nodir = dlm_no_directory(ls);\n\tint error;\n\n\tlog_rinfo(ls, \"dlm_recover_masters\");\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_rsb(r);\n\t\tif (nodir)\n\t\t\terror = recover_master_static(r, &count);\n\t\telse\n\t\t\terror = recover_master(r, &count);\n\t\tunlock_rsb(r);\n\t\tcond_resched();\n\t\ttotal++;\n\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_masters %u of %u\", count, total);\n\n\terror = dlm_wait_function(ls, &recover_idr_empty);\n out:\n\tif (error)\n\t\trecover_idr_clear(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_masters(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int total = 0;\n\tunsigned int count = 0;\n\tint nodir = dlm_no_directory(ls);\n\tint error;\n\n\tlog_rinfo(ls, \"dlm_recover_masters\");\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_rsb(r);\n\t\tif (nodir)\n\t\t\terror = recover_master_static(r, &count);\n\t\telse\n\t\t\terror = recover_master(r, &count);\n\t\tunlock_rsb(r);\n\t\tcond_resched();\n\t\ttotal++;\n\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_masters %u of %u\", count, total);\n\n\terror = dlm_wait_function(ls, &recover_idr_empty);\n out:\n\tif (error)\n\t\trecover_idr_clear(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_purge",
          "args": [
            "ls"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5428-5468",
          "snippet": "void dlm_recover_purge(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_member *memb;\n\tint nodes_count = 0;\n\tint nodeid_gone = 0;\n\tunsigned int lkb_count = 0;\n\n\t/* cache one removed nodeid to optimize the common\n\t   case of a single node removed */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tnodes_count++;\n\t\tnodeid_gone = memb->nodeid;\n\t}\n\n\tif (!nodes_count)\n\t\treturn;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tpurge_dead_list(ls, r, &r->res_grantqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_convertqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_waitqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tcond_resched();\n\t}\n\tup_write(&ls->ls_root_sem);\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_purge %u locks for %u nodes\",\n\t\t\t  lkb_count, nodes_count);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_recover_purge(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_member *memb;\n\tint nodes_count = 0;\n\tint nodeid_gone = 0;\n\tunsigned int lkb_count = 0;\n\n\t/* cache one removed nodeid to optimize the common\n\t   case of a single node removed */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tnodes_count++;\n\t\tnodeid_gone = memb->nodeid;\n\t}\n\n\tif (!nodes_count)\n\t\treturn;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tpurge_dead_list(ls, r, &r->res_grantqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_convertqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t\tpurge_dead_list(ls, r, &r->res_waitqueue,\n\t\t\t\t\tnodeid_gone, &lkb_count);\n\t\t}\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tcond_resched();\n\t}\n\tup_write(&ls->ls_root_sem);\n\n\tif (lkb_count)\n\t\tlog_rinfo(ls, \"dlm_recover_purge %u locks for %u nodes\",\n\t\t\t  lkb_count, nodes_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_waiters_pre",
          "args": [
            "ls"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_waiters_pre",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5116-5227",
          "snippet": "void dlm_recover_waiters_pre(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tstruct dlm_message *ms_stub;\n\tint wait_type, stub_unlock_result, stub_cancel_result;\n\tint dir_nodeid;\n\n\tms_stub = kmalloc(sizeof(struct dlm_message), GFP_KERNEL);\n\tif (!ms_stub) {\n\t\tlog_error(ls, \"dlm_recover_waiters_pre no mem\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_waiters, lkb_wait_reply) {\n\n\t\tdir_nodeid = dlm_dir_nodeid(lkb->lkb_resource);\n\n\t\t/* exclude debug messages about unlocks because there can be so\n\t\t   many and they aren't very interesting */\n\n\t\tif (lkb->lkb_wait_type != DLM_MSG_UNLOCK) {\n\t\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  lkb->lkb_remid,\n\t\t\t\t  lkb->lkb_wait_type,\n\t\t\t\t  lkb->lkb_resource->res_nodeid,\n\t\t\t\t  lkb->lkb_nodeid,\n\t\t\t\t  lkb->lkb_wait_nodeid,\n\t\t\t\t  dir_nodeid);\n\t\t}\n\n\t\t/* all outstanding lookups, regardless of destination  will be\n\t\t   resent after recovery is done */\n\n\t\tif (lkb->lkb_wait_type == DLM_MSG_LOOKUP) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!waiter_needs_recovery(ls, lkb, dir_nodeid))\n\t\t\tcontinue;\n\n\t\twait_type = lkb->lkb_wait_type;\n\t\tstub_unlock_result = -DLM_EUNLOCK;\n\t\tstub_cancel_result = -DLM_ECANCEL;\n\n\t\t/* Main reply may have been received leaving a zero wait_type,\n\t\t   but a reply for the overlapping op may not have been\n\t\t   received.  In that case we need to fake the appropriate\n\t\t   reply for the overlap op. */\n\n\t\tif (!wait_type) {\n\t\t\tif (is_overlap_cancel(lkb)) {\n\t\t\t\twait_type = DLM_MSG_CANCEL;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_cancel_result = 0;\n\t\t\t}\n\t\t\tif (is_overlap_unlock(lkb)) {\n\t\t\t\twait_type = DLM_MSG_UNLOCK;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_unlock_result = -ENOENT;\n\t\t\t}\n\n\t\t\tlog_debug(ls, \"rwpre overlap %x %x %d %d %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_flags, wait_type,\n\t\t\t\t  stub_cancel_result, stub_unlock_result);\n\t\t}\n\n\t\tswitch (wait_type) {\n\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CONVERT:\n\t\t\trecover_convert_waiter(ls, lkb, ms_stub);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_UNLOCK_REPLY;\n\t\t\tms_stub->m_result = stub_unlock_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_unlock_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CANCEL:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_CANCEL_REPLY;\n\t\t\tms_stub->m_result = stub_cancel_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_cancel_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_error(ls, \"invalid lkb wait_type %d %d\",\n\t\t\t\t  lkb->lkb_wait_type, wait_type);\n\t\t}\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(ms_stub);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_recover_waiters_pre(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tstruct dlm_message *ms_stub;\n\tint wait_type, stub_unlock_result, stub_cancel_result;\n\tint dir_nodeid;\n\n\tms_stub = kmalloc(sizeof(struct dlm_message), GFP_KERNEL);\n\tif (!ms_stub) {\n\t\tlog_error(ls, \"dlm_recover_waiters_pre no mem\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_waiters, lkb_wait_reply) {\n\n\t\tdir_nodeid = dlm_dir_nodeid(lkb->lkb_resource);\n\n\t\t/* exclude debug messages about unlocks because there can be so\n\t\t   many and they aren't very interesting */\n\n\t\tif (lkb->lkb_wait_type != DLM_MSG_UNLOCK) {\n\t\t\tlog_debug(ls, \"waiter %x remote %x msg %d r_nodeid %d \"\n\t\t\t\t  \"lkb_nodeid %d wait_nodeid %d dir_nodeid %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  lkb->lkb_remid,\n\t\t\t\t  lkb->lkb_wait_type,\n\t\t\t\t  lkb->lkb_resource->res_nodeid,\n\t\t\t\t  lkb->lkb_nodeid,\n\t\t\t\t  lkb->lkb_wait_nodeid,\n\t\t\t\t  dir_nodeid);\n\t\t}\n\n\t\t/* all outstanding lookups, regardless of destination  will be\n\t\t   resent after recovery is done */\n\n\t\tif (lkb->lkb_wait_type == DLM_MSG_LOOKUP) {\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!waiter_needs_recovery(ls, lkb, dir_nodeid))\n\t\t\tcontinue;\n\n\t\twait_type = lkb->lkb_wait_type;\n\t\tstub_unlock_result = -DLM_EUNLOCK;\n\t\tstub_cancel_result = -DLM_ECANCEL;\n\n\t\t/* Main reply may have been received leaving a zero wait_type,\n\t\t   but a reply for the overlapping op may not have been\n\t\t   received.  In that case we need to fake the appropriate\n\t\t   reply for the overlap op. */\n\n\t\tif (!wait_type) {\n\t\t\tif (is_overlap_cancel(lkb)) {\n\t\t\t\twait_type = DLM_MSG_CANCEL;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_cancel_result = 0;\n\t\t\t}\n\t\t\tif (is_overlap_unlock(lkb)) {\n\t\t\t\twait_type = DLM_MSG_UNLOCK;\n\t\t\t\tif (lkb->lkb_grmode == DLM_LOCK_IV)\n\t\t\t\t\tstub_unlock_result = -ENOENT;\n\t\t\t}\n\n\t\t\tlog_debug(ls, \"rwpre overlap %x %x %d %d %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_flags, wait_type,\n\t\t\t\t  stub_cancel_result, stub_unlock_result);\n\t\t}\n\n\t\tswitch (wait_type) {\n\n\t\tcase DLM_MSG_REQUEST:\n\t\t\tlkb->lkb_flags |= DLM_IFL_RESEND;\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CONVERT:\n\t\t\trecover_convert_waiter(ls, lkb, ms_stub);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_UNLOCK:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_UNLOCK_REPLY;\n\t\t\tms_stub->m_result = stub_unlock_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_unlock_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tcase DLM_MSG_CANCEL:\n\t\t\thold_lkb(lkb);\n\t\t\tmemset(ms_stub, 0, sizeof(struct dlm_message));\n\t\t\tms_stub->m_flags = DLM_IFL_STUB_MS;\n\t\t\tms_stub->m_type = DLM_MSG_CANCEL_REPLY;\n\t\t\tms_stub->m_result = stub_cancel_result;\n\t\t\tms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\n\t\t\t_receive_cancel_reply(lkb, ms_stub);\n\t\t\tdlm_put_lkb(lkb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog_error(ls, \"invalid lkb wait_type %d %d\",\n\t\t\t\t  lkb->lkb_wait_type, wait_type);\n\t\t}\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(ms_stub);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_directory %u out %u messages\"",
            "ls->ls_recover_dir_sent_res",
            "ls->ls_recover_dir_sent_msg"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_directory_wait error %d\"",
            "error"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_directory_wait",
          "args": [
            "ls"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_directory_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "210-213",
          "snippet": "int dlm_recover_directory_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DIR);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_directory_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_directory error %d\"",
            "error"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_directory",
          "args": [
            "ls"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "63-198",
          "snippet": "int dlm_recover_directory(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tchar *b, *last_name = NULL;\n\tint error = -ENOMEM, last_len, nodeid, result;\n\tuint16_t namelen;\n\tunsigned int count = 0, count_match = 0, count_bad = 0, count_add = 0;\n\n\tlog_rinfo(ls, \"dlm_recover_directory\");\n\n\tif (dlm_no_directory(ls))\n\t\tgoto out_status;\n\n\tlast_name = kmalloc(DLM_RESNAME_MAXLEN, GFP_NOFS);\n\tif (!last_name)\n\t\tgoto out;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == dlm_our_nodeid())\n\t\t\tcontinue;\n\n\t\tmemset(last_name, 0, DLM_RESNAME_MAXLEN);\n\t\tlast_len = 0;\n\n\t\tfor (;;) {\n\t\t\tint left;\n\t\t\terror = dlm_recovery_stopped(ls);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\terror = dlm_rcom_names(ls, memb->nodeid,\n\t\t\t\t\t       last_name, last_len);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tcond_resched();\n\n\t\t\t/*\n\t\t\t * pick namelen/name pairs out of received buffer\n\t\t\t */\n\n\t\t\tb = ls->ls_recover_buf->rc_buf;\n\t\t\tleft = ls->ls_recover_buf->rc_header.h_length;\n\t\t\tleft -= sizeof(struct dlm_rcom);\n\n\t\t\tfor (;;) {\n\t\t\t\t__be16 v;\n\n\t\t\t\terror = -EINVAL;\n\t\t\t\tif (left < sizeof(__be16))\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tmemcpy(&v, b, sizeof(__be16));\n\t\t\t\tnamelen = be16_to_cpu(v);\n\t\t\t\tb += sizeof(__be16);\n\t\t\t\tleft -= sizeof(__be16);\n\n\t\t\t\t/* namelen of 0xFFFFF marks end of names for\n\t\t\t\t   this node; namelen of 0 marks end of the\n\t\t\t\t   buffer */\n\n\t\t\t\tif (namelen == 0xFFFF)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (!namelen)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (namelen > left)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tif (namelen > DLM_RESNAME_MAXLEN)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\terror = dlm_master_lookup(ls, memb->nodeid,\n\t\t\t\t\t\t\t  b, namelen,\n\t\t\t\t\t\t\t  DLM_LU_RECOVER_DIR,\n\t\t\t\t\t\t\t  &nodeid, &result);\n\t\t\t\tif (error) {\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d\",\n\t\t\t\t\t\t  error);\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, but the\n\t\t\t\t * master nodeid is different from\n\t\t\t\t * memb->nodeid which says it is the master.\n\t\t\t\t * This should not happen. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid != memb->nodeid) {\n\t\t\t\t\tcount_bad++;\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d \"\n\t\t\t\t\t\t  \"nodeid %d memb %d bad %u\",\n\t\t\t\t\t\t  result, nodeid, memb->nodeid,\n\t\t\t\t\t\t  count_bad);\n\t\t\t\t\tprint_hex_dump_bytes(\"dlm_recover_dir \",\n\t\t\t\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t\t\t\t     b, namelen);\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, and the\n\t\t\t\t * master nodeid matches memb->nodeid. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid == memb->nodeid) {\n\t\t\t\t\tcount_match++;\n\t\t\t\t}\n\n\t\t\t\t/* The name was not found in rsbtbl and was\n\t\t\t\t * added with memb->nodeid as the master. */\n\n\t\t\t\tif (result == DLM_LU_ADD) {\n\t\t\t\t\tcount_add++;\n\t\t\t\t}\n\n\t\t\t\tlast_len = namelen;\n\t\t\t\tmemcpy(last_name, b, namelen);\n\t\t\t\tb += namelen;\n\t\t\t\tleft -= namelen;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t done:\n\t\t;\n\t}\n\n out_status:\n\terror = 0;\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u in %u new\",\n\t\t  count, count_add);\n out_free:\n\tkfree(last_name);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_directory(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tchar *b, *last_name = NULL;\n\tint error = -ENOMEM, last_len, nodeid, result;\n\tuint16_t namelen;\n\tunsigned int count = 0, count_match = 0, count_bad = 0, count_add = 0;\n\n\tlog_rinfo(ls, \"dlm_recover_directory\");\n\n\tif (dlm_no_directory(ls))\n\t\tgoto out_status;\n\n\tlast_name = kmalloc(DLM_RESNAME_MAXLEN, GFP_NOFS);\n\tif (!last_name)\n\t\tgoto out;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == dlm_our_nodeid())\n\t\t\tcontinue;\n\n\t\tmemset(last_name, 0, DLM_RESNAME_MAXLEN);\n\t\tlast_len = 0;\n\n\t\tfor (;;) {\n\t\t\tint left;\n\t\t\terror = dlm_recovery_stopped(ls);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\terror = dlm_rcom_names(ls, memb->nodeid,\n\t\t\t\t\t       last_name, last_len);\n\t\t\tif (error)\n\t\t\t\tgoto out_free;\n\n\t\t\tcond_resched();\n\n\t\t\t/*\n\t\t\t * pick namelen/name pairs out of received buffer\n\t\t\t */\n\n\t\t\tb = ls->ls_recover_buf->rc_buf;\n\t\t\tleft = ls->ls_recover_buf->rc_header.h_length;\n\t\t\tleft -= sizeof(struct dlm_rcom);\n\n\t\t\tfor (;;) {\n\t\t\t\t__be16 v;\n\n\t\t\t\terror = -EINVAL;\n\t\t\t\tif (left < sizeof(__be16))\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tmemcpy(&v, b, sizeof(__be16));\n\t\t\t\tnamelen = be16_to_cpu(v);\n\t\t\t\tb += sizeof(__be16);\n\t\t\t\tleft -= sizeof(__be16);\n\n\t\t\t\t/* namelen of 0xFFFFF marks end of names for\n\t\t\t\t   this node; namelen of 0 marks end of the\n\t\t\t\t   buffer */\n\n\t\t\t\tif (namelen == 0xFFFF)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (!namelen)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (namelen > left)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\tif (namelen > DLM_RESNAME_MAXLEN)\n\t\t\t\t\tgoto out_free;\n\n\t\t\t\terror = dlm_master_lookup(ls, memb->nodeid,\n\t\t\t\t\t\t\t  b, namelen,\n\t\t\t\t\t\t\t  DLM_LU_RECOVER_DIR,\n\t\t\t\t\t\t\t  &nodeid, &result);\n\t\t\t\tif (error) {\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d\",\n\t\t\t\t\t\t  error);\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, but the\n\t\t\t\t * master nodeid is different from\n\t\t\t\t * memb->nodeid which says it is the master.\n\t\t\t\t * This should not happen. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid != memb->nodeid) {\n\t\t\t\t\tcount_bad++;\n\t\t\t\t\tlog_error(ls, \"recover_dir lookup %d \"\n\t\t\t\t\t\t  \"nodeid %d memb %d bad %u\",\n\t\t\t\t\t\t  result, nodeid, memb->nodeid,\n\t\t\t\t\t\t  count_bad);\n\t\t\t\t\tprint_hex_dump_bytes(\"dlm_recover_dir \",\n\t\t\t\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t\t\t\t     b, namelen);\n\t\t\t\t}\n\n\t\t\t\t/* The name was found in rsbtbl, and the\n\t\t\t\t * master nodeid matches memb->nodeid. */\n\n\t\t\t\tif (result == DLM_LU_MATCH &&\n\t\t\t\t    nodeid == memb->nodeid) {\n\t\t\t\t\tcount_match++;\n\t\t\t\t}\n\n\t\t\t\t/* The name was not found in rsbtbl and was\n\t\t\t\t * added with memb->nodeid as the master. */\n\n\t\t\t\tif (result == DLM_LU_ADD) {\n\t\t\t\t\tcount_add++;\n\t\t\t\t}\n\n\t\t\t\tlast_len = namelen;\n\t\t\t\tmemcpy(last_name, b, namelen);\n\t\t\t\tb += namelen;\n\t\t\t\tleft -= namelen;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t done:\n\t\t;\n\t}\n\n out_status:\n\terror = 0;\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u in %u new\",\n\t\t  count, count_add);\n out_free:\n\tkfree(last_name);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_members_wait error %d\"",
            "error"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_members_wait",
          "args": [
            "ls"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_members_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "167-208",
          "snippet": "int dlm_recover_members_wait(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint num_slots, slots_size;\n\tint error, rv;\n\tuint32_t gen;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tmemb->slot = -1;\n\t\tmemb->generation = 0;\n\t}\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, DLM_RS_NODES, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/* slots array is sparse, slots_size may be > num_slots */\n\n\t\trv = dlm_slots_assign(ls, &num_slots, &slots_size, &slots, &gen);\n\t\tif (!rv) {\n\t\t\tspin_lock(&ls->ls_recover_lock);\n\t\t\t_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t\tls->ls_num_slots = num_slots;\n\t\t\tls->ls_slots_size = slots_size;\n\t\t\tls->ls_slots = slots;\n\t\t\tls->ls_generation = gen;\n\t\t\tspin_unlock(&ls->ls_recover_lock);\n\t\t} else {\n\t\t\tdlm_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t}\n\t} else {\n\t\terror = wait_status_low(ls, DLM_RS_NODES_ALL, DLM_RSF_NEED_SLOTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdlm_slots_copy_in(ls);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_members_wait(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint num_slots, slots_size;\n\tint error, rv;\n\tuint32_t gen;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tmemb->slot = -1;\n\t\tmemb->generation = 0;\n\t}\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, DLM_RS_NODES, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/* slots array is sparse, slots_size may be > num_slots */\n\n\t\trv = dlm_slots_assign(ls, &num_slots, &slots_size, &slots, &gen);\n\t\tif (!rv) {\n\t\t\tspin_lock(&ls->ls_recover_lock);\n\t\t\t_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t\tls->ls_num_slots = num_slots;\n\t\t\tls->ls_slots_size = slots_size;\n\t\t\tls->ls_slots = slots;\n\t\t\tls->ls_generation = gen;\n\t\t\tspin_unlock(&ls->ls_recover_lock);\n\t\t} else {\n\t\t\tdlm_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t}\n\t} else {\n\t\terror = wait_status_low(ls, DLM_RS_NODES_ALL, DLM_RSF_NEED_SLOTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdlm_slots_copy_in(ls);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_dir_nodeid",
          "args": [
            "ls"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "52-61",
          "snippet": "void dlm_recover_dir_nodeid(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tr->res_dir_nodeid = dlm_hash2nodeid(ls, r->res_hash);\n\t}\n\tup_read(&ls->ls_root_sem);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recover_dir_nodeid(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tr->res_dir_nodeid = dlm_hash2nodeid(ls, r->res_hash);\n\t}\n\tup_read(&ls->ls_root_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_members error %d\"",
            "error"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_members",
          "args": [
            "ls",
            "rv",
            "&neg"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_members",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "529-593",
          "snippet": "int dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\n{\n\tstruct dlm_member *memb, *safe;\n\tstruct dlm_config_node *node;\n\tint i, error, neg = 0, low = -1;\n\n\t/* previously removed members that we've not finished removing need to\n\t   count as a negative change so the \"neg\" recovery steps will happen */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tlog_rinfo(ls, \"prev removed member %d\", memb->nodeid);\n\t\tneg++;\n\t}\n\n\t/* move departed members from ls_nodes to ls_nodes_gone */\n\n\tlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\n\t\tnode = find_config_node(rv, memb->nodeid);\n\t\tif (node && !node->new)\n\t\t\tcontinue;\n\n\t\tif (!node) {\n\t\t\tlog_rinfo(ls, \"remove member %d\", memb->nodeid);\n\t\t} else {\n\t\t\t/* removed and re-added */\n\t\t\tlog_rinfo(ls, \"remove member %d comm_seq %u %u\",\n\t\t\t\t  memb->nodeid, memb->comm_seq, node->comm_seq);\n\t\t}\n\n\t\tneg++;\n\t\tlist_move(&memb->list, &ls->ls_nodes_gone);\n\t\tls->ls_num_nodes--;\n\t\tdlm_lsop_recover_slot(ls, memb);\n\t}\n\n\t/* add new members to ls_nodes */\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tnode = &rv->nodes[i];\n\t\tif (dlm_is_member(ls, node->nodeid))\n\t\t\tcontinue;\n\t\tdlm_add_member(ls, node);\n\t\tlog_rinfo(ls, \"add member %d\", node->nodeid);\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (low == -1 || memb->nodeid < low)\n\t\t\tlow = memb->nodeid;\n\t}\n\tls->ls_low_nodeid = low;\n\n\tmake_member_array(ls);\n\t*neg_out = neg;\n\n\terror = ping_members(ls);\n\tif (!error || error == -EPROTO) {\n\t\t/* new_lockspace() may be waiting to know if the config\n\t\t   is good or bad */\n\t\tls->ls_members_result = error;\n\t\tcomplete(&ls->ls_members_done);\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_members %d nodes\", ls->ls_num_nodes);\n\treturn error;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\n{\n\tstruct dlm_member *memb, *safe;\n\tstruct dlm_config_node *node;\n\tint i, error, neg = 0, low = -1;\n\n\t/* previously removed members that we've not finished removing need to\n\t   count as a negative change so the \"neg\" recovery steps will happen */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tlog_rinfo(ls, \"prev removed member %d\", memb->nodeid);\n\t\tneg++;\n\t}\n\n\t/* move departed members from ls_nodes to ls_nodes_gone */\n\n\tlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\n\t\tnode = find_config_node(rv, memb->nodeid);\n\t\tif (node && !node->new)\n\t\t\tcontinue;\n\n\t\tif (!node) {\n\t\t\tlog_rinfo(ls, \"remove member %d\", memb->nodeid);\n\t\t} else {\n\t\t\t/* removed and re-added */\n\t\t\tlog_rinfo(ls, \"remove member %d comm_seq %u %u\",\n\t\t\t\t  memb->nodeid, memb->comm_seq, node->comm_seq);\n\t\t}\n\n\t\tneg++;\n\t\tlist_move(&memb->list, &ls->ls_nodes_gone);\n\t\tls->ls_num_nodes--;\n\t\tdlm_lsop_recover_slot(ls, memb);\n\t}\n\n\t/* add new members to ls_nodes */\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tnode = &rv->nodes[i];\n\t\tif (dlm_is_member(ls, node->nodeid))\n\t\t\tcontinue;\n\t\tdlm_add_member(ls, node);\n\t\tlog_rinfo(ls, \"add member %d\", node->nodeid);\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (low == -1 || memb->nodeid < low)\n\t\t\tlow = memb->nodeid;\n\t}\n\tls->ls_low_nodeid = low;\n\n\tmake_member_array(ls);\n\t*neg_out = neg;\n\n\terror = ping_members(ls);\n\tif (!error || error == -EPROTO) {\n\t\t/* new_lockspace() may be waiting to know if the config\n\t\t   is good or bad */\n\t\tls->ls_members_result = error;\n\t\tcomplete(&ls->ls_members_done);\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_members %d nodes\", ls->ls_num_nodes);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_create_root_list",
          "args": [
            "ls"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_create_root_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "891-919",
          "snippet": "int dlm_create_root_list(struct dlm_ls *ls)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i, error = 0;\n\n\tdown_write(&ls->ls_root_sem);\n\tif (!list_empty(&ls->ls_root_list)) {\n\t\tlog_error(ls, \"root list not empty\");\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tlist_add(&r->res_root_list, &ls->ls_root_list);\n\t\t\tdlm_hold_rsb(r);\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&ls->ls_rsbtbl[i].toss))\n\t\t\tlog_error(ls, \"dlm_create_root_list toss not empty\");\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n out:\n\tup_write(&ls->ls_root_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_create_root_list(struct dlm_ls *ls)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i, error = 0;\n\n\tdown_write(&ls->ls_root_sem);\n\tif (!list_empty(&ls->ls_root_list)) {\n\t\tlog_error(ls, \"root list not empty\");\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tlist_add(&r->res_root_list, &ls->ls_root_list);\n\t\t\tdlm_hold_rsb(r);\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&ls->ls_rsbtbl[i].toss))\n\t\t\tlog_error(ls, \"dlm_create_root_list toss not empty\");\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n out:\n\tup_write(&ls->ls_root_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_clear_toss",
          "args": [
            "ls"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clear_toss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "933-954",
          "snippet": "void dlm_clear_toss(struct dlm_ls *ls)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].toss); n; n = next) {\n\t\t\tnext = rb_next(n);\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(r);\n\t\t\tcount++;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_clear_toss %u done\", count);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_toss(struct dlm_ls *ls)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].toss); n; n = next) {\n\t\t\tnext = rb_next(n);\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(r);\n\t\t\tcount++;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_clear_toss %u done\", count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_callback_suspend",
          "args": [
            "ls"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_callback_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "285-291",
          "snippet": "void dlm_callback_suspend(struct dlm_ls *ls)\n{\n\tset_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (ls->ls_callback_wq)\n\t\tflush_workqueue(ls->ls_callback_wq);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_suspend(struct dlm_ls *ls)\n{\n\tset_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (ls->ls_callback_wq)\n\t\tflush_workqueue(ls->ls_callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_recoverd_active"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover %llu\"",
            "(unsigned long long)rv->seq"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int ls_recover(struct dlm_ls *ls, struct dlm_recover *rv)\n{\n\tunsigned long start;\n\tint error, neg = 0;\n\n\tlog_rinfo(ls, \"dlm_recover %llu\", (unsigned long long)rv->seq);\n\n\tmutex_lock(&ls->ls_recoverd_active);\n\n\tdlm_callback_suspend(ls);\n\n\tdlm_clear_toss(ls);\n\n\t/*\n\t * This list of root rsb's will be the basis of most of the recovery\n\t * routines.\n\t */\n\n\tdlm_create_root_list(ls);\n\n\t/*\n\t * Add or remove nodes from the lockspace's ls_nodes list.\n\t */\n\n\terror = dlm_recover_members(ls, rv, &neg);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_dir_nodeid(ls);\n\n\tls->ls_recover_dir_sent_res = 0;\n\tls->ls_recover_dir_sent_msg = 0;\n\tls->ls_recover_locks_in = 0;\n\n\tdlm_set_recover_status(ls, DLM_RS_NODES);\n\n\terror = dlm_recover_members_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_members_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tstart = jiffies;\n\n\t/*\n\t * Rebuild our own share of the directory by collecting from all other\n\t * nodes their master rsb names that hash to us.\n\t */\n\n\terror = dlm_recover_directory(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_set_recover_status(ls, DLM_RS_DIR);\n\n\terror = dlm_recover_directory_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_directory_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_directory %u out %u messages\",\n\t\t  ls->ls_recover_dir_sent_res, ls->ls_recover_dir_sent_msg);\n\n\t/*\n\t * We may have outstanding operations that are waiting for a reply from\n\t * a failed node.  Mark these to be resent after recovery.  Unlock and\n\t * cancel ops can just be completed.\n\t */\n\n\tdlm_recover_waiters_pre(ls);\n\n\terror = dlm_recovery_stopped(ls);\n\tif (error)\n\t\tgoto fail;\n\n\tif (neg || dlm_no_directory(ls)) {\n\t\t/*\n\t\t * Clear lkb's for departed nodes.\n\t\t */\n\n\t\tdlm_recover_purge(ls);\n\n\t\t/*\n\t\t * Get new master nodeid's for rsb's that were mastered on\n\t\t * departed nodes.\n\t\t */\n\n\t\terror = dlm_recover_masters(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_masters error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Send our locks on remastered rsb's to the new masters.\n\t\t */\n\n\t\terror = dlm_recover_locks(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlog_rinfo(ls, \"dlm_recover_locks %u in\",\n\t\t\t  ls->ls_recover_locks_in);\n\n\t\t/*\n\t\t * Finalize state in master rsb's now that all locks can be\n\t\t * checked.  This includes conversion resolution and lvb\n\t\t * settings.\n\t\t */\n\n\t\tdlm_recover_rsbs(ls);\n\t} else {\n\t\t/*\n\t\t * Other lockspace members may be going through the \"neg\" steps\n\t\t * while also adding us to the lockspace, in which case they'll\n\t\t * be doing the recover_locks (RS_LOCKS) barrier.\n\t\t */\n\t\tdlm_set_recover_status(ls, DLM_RS_LOCKS);\n\n\t\terror = dlm_recover_locks_wait(ls);\n\t\tif (error) {\n\t\t\tlog_rinfo(ls, \"dlm_recover_locks_wait error %d\", error);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tdlm_release_root_list(ls);\n\n\t/*\n\t * Purge directory-related requests that are saved in requestqueue.\n\t * All dir requests from before recovery are invalid now due to the dir\n\t * rebuild and will be resent by the requesting nodes.\n\t */\n\n\tdlm_purge_requestqueue(ls);\n\n\tdlm_set_recover_status(ls, DLM_RS_DONE);\n\n\terror = dlm_recover_done_wait(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_done_wait error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_clear_members_gone(ls);\n\n\tdlm_adjust_timeouts(ls);\n\n\tdlm_callback_resume(ls);\n\n\terror = enable_locking(ls, rv->seq);\n\tif (error) {\n\t\tlog_rinfo(ls, \"enable_locking error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_process_requestqueue(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_process_requestqueue error %d\", error);\n\t\tgoto fail;\n\t}\n\n\terror = dlm_recover_waiters_post(ls);\n\tif (error) {\n\t\tlog_rinfo(ls, \"dlm_recover_waiters_post error %d\", error);\n\t\tgoto fail;\n\t}\n\n\tdlm_recover_grant(ls);\n\n\tlog_rinfo(ls, \"dlm_recover %llu generation %u done: %u ms\",\n\t\t  (unsigned long long)rv->seq, ls->ls_generation,\n\t\t  jiffies_to_msecs(jiffies - start));\n\tmutex_unlock(&ls->ls_recoverd_active);\n\n\tdlm_lsop_recover_done(ls);\n\treturn 0;\n\n fail:\n\tdlm_release_root_list(ls);\n\tlog_rinfo(ls, \"dlm_recover %llu error %d\",\n\t\t  (unsigned long long)rv->seq, error);\n\tmutex_unlock(&ls->ls_recoverd_active);\n\treturn error;\n}"
  },
  {
    "function_name": "enable_locking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
    "lines": "33-51",
    "snippet": "static int enable_locking(struct dlm_ls *ls, uint64_t seq)\n{\n\tint error = -EINTR;\n\n\tdown_write(&ls->ls_recv_active);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_recover_seq == seq) {\n\t\tset_bit(LSFL_RUNNING, &ls->ls_flags);\n\t\t/* unblocks processes waiting to enter the dlm */\n\t\tup_write(&ls->ls_in_recovery);\n\t\tclear_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\terror = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tup_write(&ls->ls_recv_active);\n\treturn error;\n}",
    "includes": [
      "#include \"recoverd.h\"",
      "#include \"requestqueue.h\"",
      "#include \"lock.h\"",
      "#include \"lowcomms.h\"",
      "#include \"recover.h\"",
      "#include \"ast.h\"",
      "#include \"dir.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "LSFL_RECOVER_LOCK",
            "&ls->ls_flags"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_RUNNING",
            "&ls->ls_flags"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int enable_locking(struct dlm_ls *ls, uint64_t seq)\n{\n\tint error = -EINTR;\n\n\tdown_write(&ls->ls_recv_active);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_recover_seq == seq) {\n\t\tset_bit(LSFL_RUNNING, &ls->ls_flags);\n\t\t/* unblocks processes waiting to enter the dlm */\n\t\tup_write(&ls->ls_in_recovery);\n\t\tclear_bit(LSFL_RECOVER_LOCK, &ls->ls_flags);\n\t\terror = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tup_write(&ls->ls_recv_active);\n\treturn error;\n}"
  }
]