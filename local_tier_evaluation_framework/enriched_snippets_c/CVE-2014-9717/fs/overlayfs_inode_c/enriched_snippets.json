[
  {
    "function_name": "ovl_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "395-436",
    "snippet": "struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};",
      "static const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"illegal file type: %i\\n\"",
            "mode"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};\nstatic const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};\n\nstruct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ovl_dentry_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "339-370",
    "snippet": "static int ovl_dentry_open(struct dentry *dentry, struct file *file,\n\t\t    const struct cred *cred)\n{\n\tint err;\n\tstruct path realpath;\n\tenum ovl_path_type type;\n\tbool want_write = false;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\tif (ovl_open_need_copy_up(file->f_flags, type, realpath.dentry)) {\n\t\twant_write = true;\n\t\terr = ovl_want_write(dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\terr = ovl_copy_up_last(dentry, NULL, true);\n\t\telse\n\t\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tovl_path_upper(dentry, &realpath);\n\t}\n\n\terr = vfs_open(&realpath, file, cred);\nout_drop_write:\n\tif (want_write)\n\t\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "dentry"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_open",
          "args": [
            "&realpath",
            "file",
            "cred"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "858-869",
          "snippet": "int vfs_open(const struct path *path, struct file *filp,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->dentry_open)\n\t\treturn inode->i_op->dentry_open(path->dentry, filp, cred);\n\telse {\n\t\tfilp->f_path = *path;\n\t\treturn do_dentry_open(filp, NULL, cred);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_open(const struct path *path, struct file *filp,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->dentry_open)\n\t\treturn inode->i_op->dentry_open(path->dentry, filp, cred);\n\telse {\n\t\tfilp->f_path = *path;\n\t\treturn do_dentry_open(filp, NULL, cred);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "dentry"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up_last",
          "args": [
            "dentry",
            "NULL",
            "true"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "15-41",
          "snippet": "static int ovl_copy_up_last(struct dentry *dentry, struct iattr *attr,\n\t\t\t    bool no_data)\n{\n\tint err;\n\tstruct dentry *parent;\n\tstruct kstat stat;\n\tstruct path lowerpath;\n\n\tparent = dget_parent(dentry);\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tovl_path_lower(dentry, &lowerpath);\n\terr = vfs_getattr(&lowerpath, &stat);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tif (no_data)\n\t\tstat.size = 0;\n\n\terr = ovl_copy_up_one(parent, dentry, &lowerpath, &stat, attr);\n\nout_dput_parent:\n\tdput(parent);\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_copy_up_last(struct dentry *dentry, struct iattr *attr,\n\t\t\t    bool no_data)\n{\n\tint err;\n\tstruct dentry *parent;\n\tstruct kstat stat;\n\tstruct path lowerpath;\n\n\tparent = dget_parent(dentry);\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tovl_path_lower(dentry, &lowerpath);\n\terr = vfs_getattr(&lowerpath, &stat);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tif (no_data)\n\t\tstat.size = 0;\n\n\terr = ovl_copy_up_one(parent, dentry, &lowerpath, &stat, attr);\n\nout_dput_parent:\n\tdput(parent);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "dentry"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_open_need_copy_up",
          "args": [
            "file->f_flags",
            "type",
            "realpath.dentry"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_open_need_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "324-337",
          "snippet": "static bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,\n\t\t\t\t  struct dentry *realdentry)\n{\n\tif (OVL_TYPE_UPPER(type))\n\t\treturn false;\n\n\tif (special_file(realdentry->d_inode->i_mode))\n\t\treturn false;\n\n\tif (!(OPEN_FMODE(flags) & FMODE_WRITE) && !(flags & O_TRUNC))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,\n\t\t\t\t  struct dentry *realdentry)\n{\n\tif (OVL_TYPE_UPPER(type))\n\t\treturn false;\n\n\tif (special_file(realdentry->d_inode->i_mode))\n\t\treturn false;\n\n\tif (!(OPEN_FMODE(flags) & FMODE_WRITE) && !(flags & O_TRUNC))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dentry_open(struct dentry *dentry, struct file *file,\n\t\t    const struct cred *cred)\n{\n\tint err;\n\tstruct path realpath;\n\tenum ovl_path_type type;\n\tbool want_write = false;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\tif (ovl_open_need_copy_up(file->f_flags, type, realpath.dentry)) {\n\t\twant_write = true;\n\t\terr = ovl_want_write(dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\terr = ovl_copy_up_last(dentry, NULL, true);\n\t\telse\n\t\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tovl_path_upper(dentry, &realpath);\n\t}\n\n\terr = vfs_open(&realpath, file, cred);\nout_drop_write:\n\tif (want_write)\n\t\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_open_need_copy_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "324-337",
    "snippet": "static bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,\n\t\t\t\t  struct dentry *realdentry)\n{\n\tif (OVL_TYPE_UPPER(type))\n\t\treturn false;\n\n\tif (special_file(realdentry->d_inode->i_mode))\n\t\treturn false;\n\n\tif (!(OPEN_FMODE(flags) & FMODE_WRITE) && !(flags & O_TRUNC))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "flags"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "realdentry->d_inode->i_mode"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "type"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,\n\t\t\t\t  struct dentry *realdentry)\n{\n\tif (OVL_TYPE_UPPER(type))\n\t\treturn false;\n\n\tif (special_file(realdentry->d_inode->i_mode))\n\t\treturn false;\n\n\tif (!(OPEN_FMODE(flags) & FMODE_WRITE) && !(flags & O_TRUNC))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "ovl_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "291-322",
    "snippet": "int ovl_removexattr(struct dentry *dentry, const char *name)\n{\n\tint err;\n\tstruct path realpath;\n\tenum ovl_path_type type = ovl_path_real(dentry, &realpath);\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = -ENODATA;\n\tif (ovl_need_xattr_filter(dentry, type) && ovl_is_private_xattr(name))\n\t\tgoto out_drop_write;\n\n\tif (!OVL_TYPE_UPPER(type)) {\n\t\terr = vfs_getxattr(realpath.dentry, name, NULL, 0);\n\t\tif (err < 0)\n\t\t\tgoto out_drop_write;\n\n\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tovl_path_upper(dentry, &realpath);\n\t}\n\n\terr = vfs_removexattr(realpath.dentry, name);\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "dentry"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_removexattr",
          "args": [
            "realpath.dentry",
            "name"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "286-314",
          "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode->i_op->removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn error;\n\t}\n\n\terror = inode->i_op->removexattr(dentry, name);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "dentry"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "realpath.dentry",
            "name",
            "NULL",
            "0"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "type"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_is_private_xattr",
          "args": [
            "name"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_private_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "206-209",
          "snippet": "static bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_need_xattr_filter",
          "args": [
            "dentry",
            "type"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_need_xattr_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "238-245",
          "snippet": "static bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "dentry"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_removexattr(struct dentry *dentry, const char *name)\n{\n\tint err;\n\tstruct path realpath;\n\tenum ovl_path_type type = ovl_path_real(dentry, &realpath);\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = -ENODATA;\n\tif (ovl_need_xattr_filter(dentry, type) && ovl_is_private_xattr(name))\n\t\tgoto out_drop_write;\n\n\tif (!OVL_TYPE_UPPER(type)) {\n\t\terr = vfs_getxattr(realpath.dentry, name, NULL, 0);\n\t\tif (err < 0)\n\t\t\tgoto out_drop_write;\n\n\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tovl_path_upper(dentry, &realpath);\n\t}\n\n\terr = vfs_removexattr(realpath.dentry, name);\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "259-289",
    "snippet": "ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct path realpath;\n\tenum ovl_path_type type = ovl_path_real(dentry, &realpath);\n\tssize_t res;\n\tint off;\n\n\tres = vfs_listxattr(realpath.dentry, list, size);\n\tif (res <= 0 || size == 0)\n\t\treturn res;\n\n\tif (!ovl_need_xattr_filter(dentry, type))\n\t\treturn res;\n\n\t/* filter out private xattrs */\n\tfor (off = 0; off < res;) {\n\t\tchar *s = list + off;\n\t\tsize_t slen = strlen(s) + 1;\n\n\t\tBUG_ON(off + slen > res);\n\n\t\tif (ovl_is_private_xattr(s)) {\n\t\t\tres -= slen;\n\t\t\tmemmove(s, s + slen, res - off);\n\t\t} else {\n\t\t\toff += slen;\n\t\t}\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "s",
            "s + slen",
            "res - off"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_is_private_xattr",
          "args": [
            "s"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_private_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "206-209",
          "snippet": "static bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "off + slen > res"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_need_xattr_filter",
          "args": [
            "dentry",
            "type"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_need_xattr_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "238-245",
          "snippet": "static bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_listxattr",
          "args": [
            "realpath.dentry",
            "list",
            "size"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "266-283",
          "snippet": "ssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct path realpath;\n\tenum ovl_path_type type = ovl_path_real(dentry, &realpath);\n\tssize_t res;\n\tint off;\n\n\tres = vfs_listxattr(realpath.dentry, list, size);\n\tif (res <= 0 || size == 0)\n\t\treturn res;\n\n\tif (!ovl_need_xattr_filter(dentry, type))\n\t\treturn res;\n\n\t/* filter out private xattrs */\n\tfor (off = 0; off < res;) {\n\t\tchar *s = list + off;\n\t\tsize_t slen = strlen(s) + 1;\n\n\t\tBUG_ON(off + slen > res);\n\n\t\tif (ovl_is_private_xattr(s)) {\n\t\t\tres -= slen;\n\t\t\tmemmove(s, s + slen, res - off);\n\t\t} else {\n\t\t\toff += slen;\n\t\t}\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "ovl_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "247-257",
    "snippet": "ssize_t ovl_getxattr(struct dentry *dentry, const char *name,\n\t\t     void *value, size_t size)\n{\n\tstruct path realpath;\n\tenum ovl_path_type type = ovl_path_real(dentry, &realpath);\n\n\tif (ovl_need_xattr_filter(dentry, type) && ovl_is_private_xattr(name))\n\t\treturn -ENODATA;\n\n\treturn vfs_getxattr(realpath.dentry, name, value, size);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "realpath.dentry",
            "name",
            "value",
            "size"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_is_private_xattr",
          "args": [
            "name"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_private_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "206-209",
          "snippet": "static bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_need_xattr_filter",
          "args": [
            "dentry",
            "type"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_need_xattr_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "238-245",
          "snippet": "static bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t ovl_getxattr(struct dentry *dentry, const char *name,\n\t\t     void *value, size_t size)\n{\n\tstruct path realpath;\n\tenum ovl_path_type type = ovl_path_real(dentry, &realpath);\n\n\tif (ovl_need_xattr_filter(dentry, type) && ovl_is_private_xattr(name))\n\t\treturn -ENODATA;\n\n\treturn vfs_getxattr(realpath.dentry, name, value, size);\n}"
  },
  {
    "function_name": "ovl_need_xattr_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "238-245",
    "snippet": "static bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dentry->d_inode->i_mode"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_need_xattr_filter(struct dentry *dentry,\n\t\t\t\t  enum ovl_path_type type)\n{\n\tif ((type & (__OVL_PATH_PURE | __OVL_PATH_UPPER)) == __OVL_PATH_UPPER)\n\t\treturn S_ISDIR(dentry->d_inode->i_mode);\n\telse\n\t\treturn false;\n}"
  },
  {
    "function_name": "ovl_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "211-236",
    "snippet": "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (ovl_is_private_xattr(name))\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(dentry);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tupperdentry = ovl_dentry_upper(dentry);\n\terr = vfs_setxattr(upperdentry, name, value, size, flags);\n\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "dentry"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "upperdentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "dentry"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_is_private_xattr",
          "args": [
            "name"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_private_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "206-209",
          "snippet": "static bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "dentry"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (ovl_is_private_xattr(name))\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(dentry);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\tupperdentry = ovl_dentry_upper(dentry);\n\terr = vfs_setxattr(upperdentry, name, value, size, flags);\n\nout_drop_write:\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_is_private_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "206-209",
    "snippet": "static bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "OVL_XATTR_PRE_NAME",
            "OVL_XATTR_PRE_LEN"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_private_xattr(const char *name)\n{\n\treturn strncmp(name, OVL_XATTR_PRE_NAME, OVL_XATTR_PRE_LEN) == 0;\n}"
  },
  {
    "function_name": "ovl_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "189-203",
    "snippet": "static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)\n{\n\tstruct path realpath;\n\tstruct inode *realinode;\n\n\tovl_path_real(dentry, &realpath);\n\trealinode = realpath.dentry->d_inode;\n\n\tif (!realinode->i_op->readlink)\n\t\treturn -EINVAL;\n\n\ttouch_atime(&realpath);\n\n\treturn realinode->i_op->readlink(realpath.dentry, buf, bufsiz);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realinode->i_op->readlink",
          "args": [
            "realpath.dentry",
            "buf",
            "bufsiz"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_atime",
          "args": [
            "&realpath"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "touch_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1587-1631",
          "snippet": "void touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)\n{\n\tstruct path realpath;\n\tstruct inode *realinode;\n\n\tovl_path_real(dentry, &realpath);\n\trealinode = realpath.dentry->d_inode;\n\n\tif (!realinode->i_op->readlink)\n\t\treturn -EINVAL;\n\n\ttouch_atime(&realpath);\n\n\treturn realinode->i_op->readlink(realpath.dentry, buf, bufsiz);\n}"
  },
  {
    "function_name": "ovl_put_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "176-187",
    "snippet": "static void ovl_put_link(struct dentry *dentry, struct nameidata *nd, void *c)\n{\n\tstruct inode *realinode;\n\tstruct ovl_link_data *data = c;\n\n\tif (!data)\n\t\treturn;\n\n\trealinode = data->realdentry->d_inode;\n\trealinode->i_op->put_link(data->realdentry, nd, data->cookie);\n\tkfree(data);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realinode->i_op->put_link",
          "args": [
            "data->realdentry",
            "nd",
            "data->cookie"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "put_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "729-735",
          "snippet": "static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_put_link(struct dentry *dentry, struct nameidata *nd, void *c)\n{\n\tstruct inode *realinode;\n\tstruct ovl_link_data *data = c;\n\n\tif (!data)\n\t\treturn;\n\n\trealinode = data->realdentry->d_inode;\n\trealinode->i_op->put_link(data->realdentry, nd, data->cookie);\n\tkfree(data);\n}"
  },
  {
    "function_name": "ovl_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "143-174",
    "snippet": "static void *ovl_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tvoid *ret;\n\tstruct dentry *realdentry;\n\tstruct inode *realinode;\n\n\trealdentry = ovl_dentry_real(dentry);\n\trealinode = realdentry->d_inode;\n\n\tif (WARN_ON(!realinode->i_op->follow_link))\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = realinode->i_op->follow_link(realdentry, nd);\n\tif (IS_ERR(ret))\n\t\treturn ret;\n\n\tif (realinode->i_op->put_link) {\n\t\tstruct ovl_link_data *data;\n\n\t\tdata = kmalloc(sizeof(struct ovl_link_data), GFP_KERNEL);\n\t\tif (!data) {\n\t\t\trealinode->i_op->put_link(realdentry, nd, ret);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tdata->realdentry = realdentry;\n\t\tdata->cookie = ret;\n\n\t\treturn data;\n\t} else {\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realinode->i_op->put_link",
          "args": [
            "realdentry",
            "nd",
            "ret"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "put_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "729-735",
          "snippet": "static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ovl_link_data)",
            "GFP_KERNEL"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ret"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realinode->i_op->follow_link",
          "args": [
            "realdentry",
            "nd"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!realinode->i_op->follow_link"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_real",
          "args": [
            "dentry"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "131-141",
          "snippet": "struct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (!realdentry)\n\t\trealdentry = __ovl_dentry_lower(oe);\n\n\treturn realdentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (!realdentry)\n\t\trealdentry = __ovl_dentry_lower(oe);\n\n\treturn realdentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void *ovl_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tvoid *ret;\n\tstruct dentry *realdentry;\n\tstruct inode *realinode;\n\n\trealdentry = ovl_dentry_real(dentry);\n\trealinode = realdentry->d_inode;\n\n\tif (WARN_ON(!realinode->i_op->follow_link))\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = realinode->i_op->follow_link(realdentry, nd);\n\tif (IS_ERR(ret))\n\t\treturn ret;\n\n\tif (realinode->i_op->put_link) {\n\t\tstruct ovl_link_data *data;\n\n\t\tdata = kmalloc(sizeof(struct ovl_link_data), GFP_KERNEL);\n\t\tif (!data) {\n\t\t\trealinode->i_op->put_link(realdentry, nd, ret);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tdata->realdentry = realdentry;\n\t\tdata->cookie = ret;\n\n\t\treturn data;\n\t} else {\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "ovl_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "74-135",
    "snippet": "int ovl_permission(struct inode *inode, int mask)\n{\n\tstruct ovl_entry *oe;\n\tstruct dentry *alias = NULL;\n\tstruct inode *realinode;\n\tstruct dentry *realdentry;\n\tbool is_upper;\n\tint err;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\toe = inode->i_private;\n\t} else if (mask & MAY_NOT_BLOCK) {\n\t\treturn -ECHILD;\n\t} else {\n\t\t/*\n\t\t * For non-directories find an alias and get the info\n\t\t * from there.\n\t\t */\n\t\talias = d_find_any_alias(inode);\n\t\tif (WARN_ON(!alias))\n\t\t\treturn -ENOENT;\n\n\t\toe = alias->d_fsdata;\n\t}\n\n\trealdentry = ovl_entry_real(oe, &is_upper);\n\n\t/* Careful in RCU walk mode */\n\trealinode = ACCESS_ONCE(realdentry->d_inode);\n\tif (!realinode) {\n\t\tWARN_ON(!(mask & MAY_NOT_BLOCK));\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tif (mask & MAY_WRITE) {\n\t\tumode_t mode = realinode->i_mode;\n\n\t\t/*\n\t\t * Writes will always be redirected to upper layer, so\n\t\t * ignore lower layer being read-only.\n\t\t *\n\t\t * If the overlay itself is read-only then proceed\n\t\t * with the permission check, don't return EROFS.\n\t\t * This will only happen if this is the lower layer of\n\t\t * another overlayfs.\n\t\t *\n\t\t * If upper fs becomes read-only after the overlay was\n\t\t * constructed return EROFS to prevent modification of\n\t\t * upper layer.\n\t\t */\n\t\terr = -EROFS;\n\t\tif (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&\n\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\tgoto out_dput;\n\t}\n\n\terr = __inode_permission(realinode, mask);\nout_dput:\n\tdput(alias);\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "alias"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inode_permission",
          "args": [
            "realinode",
            "mask"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "403-424",
          "snippet": "int __inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint __inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "realinode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "inode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(mask & MAY_NOT_BLOCK)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "realdentry->d_inode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_entry_real",
          "args": [
            "oe",
            "&is_upper"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_entry_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "143-155",
          "snippet": "struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)\n{\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (realdentry) {\n\t\t*is_upper = true;\n\t} else {\n\t\trealdentry = __ovl_dentry_lower(oe);\n\t\t*is_upper = false;\n\t}\n\treturn realdentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)\n{\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (realdentry) {\n\t\t*is_upper = true;\n\t} else {\n\t\trealdentry = __ovl_dentry_lower(oe);\n\t\t*is_upper = false;\n\t}\n\treturn realdentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!alias"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1892-1900",
          "snippet": "struct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_permission(struct inode *inode, int mask)\n{\n\tstruct ovl_entry *oe;\n\tstruct dentry *alias = NULL;\n\tstruct inode *realinode;\n\tstruct dentry *realdentry;\n\tbool is_upper;\n\tint err;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\toe = inode->i_private;\n\t} else if (mask & MAY_NOT_BLOCK) {\n\t\treturn -ECHILD;\n\t} else {\n\t\t/*\n\t\t * For non-directories find an alias and get the info\n\t\t * from there.\n\t\t */\n\t\talias = d_find_any_alias(inode);\n\t\tif (WARN_ON(!alias))\n\t\t\treturn -ENOENT;\n\n\t\toe = alias->d_fsdata;\n\t}\n\n\trealdentry = ovl_entry_real(oe, &is_upper);\n\n\t/* Careful in RCU walk mode */\n\trealinode = ACCESS_ONCE(realdentry->d_inode);\n\tif (!realinode) {\n\t\tWARN_ON(!(mask & MAY_NOT_BLOCK));\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tif (mask & MAY_WRITE) {\n\t\tumode_t mode = realinode->i_mode;\n\n\t\t/*\n\t\t * Writes will always be redirected to upper layer, so\n\t\t * ignore lower layer being read-only.\n\t\t *\n\t\t * If the overlay itself is read-only then proceed\n\t\t * with the permission check, don't return EROFS.\n\t\t * This will only happen if this is the lower layer of\n\t\t * another overlayfs.\n\t\t *\n\t\t * If upper fs becomes read-only after the overlay was\n\t\t * constructed return EROFS to prevent modification of\n\t\t * upper layer.\n\t\t */\n\t\terr = -EROFS;\n\t\tif (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&\n\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\tgoto out_dput;\n\t}\n\n\terr = __inode_permission(realinode, mask);\nout_dput:\n\tdput(alias);\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "65-72",
    "snippet": "static int ovl_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t struct kstat *stat)\n{\n\tstruct path realpath;\n\n\tovl_path_real(dentry, &realpath);\n\treturn vfs_getattr(&realpath, stat);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&realpath",
            "stat"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "dentry",
            "&realpath"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t struct kstat *stat)\n{\n\tstruct path realpath;\n\n\tovl_path_real(dentry, &realpath);\n\treturn vfs_getattr(&realpath, stat);\n}"
  },
  {
    "function_name": "ovl_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "43-63",
    "snippet": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_drop_write",
          "args": [
            "dentry"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "184-188",
          "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up_last",
          "args": [
            "dentry",
            "attr",
            "false"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "15-41",
          "snippet": "static int ovl_copy_up_last(struct dentry *dentry, struct iattr *attr,\n\t\t\t    bool no_data)\n{\n\tint err;\n\tstruct dentry *parent;\n\tstruct kstat stat;\n\tstruct path lowerpath;\n\n\tparent = dget_parent(dentry);\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tovl_path_lower(dentry, &lowerpath);\n\terr = vfs_getattr(&lowerpath, &stat);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tif (no_data)\n\t\tstat.size = 0;\n\n\terr = ovl_copy_up_one(parent, dentry, &lowerpath, &stat, attr);\n\nout_dput_parent:\n\tdput(parent);\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_copy_up_last(struct dentry *dentry, struct iattr *attr,\n\t\t\t    bool no_data)\n{\n\tint err;\n\tstruct dentry *parent;\n\tstruct kstat stat;\n\tstruct path lowerpath;\n\n\tparent = dget_parent(dentry);\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tovl_path_lower(dentry, &lowerpath);\n\terr = vfs_getattr(&lowerpath, &stat);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tif (no_data)\n\t\tstat.size = 0;\n\n\terr = ovl_copy_up_one(parent, dentry, &lowerpath, &stat, attr);\n\nout_dput_parent:\n\tdput(parent);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&upperdentry->d_inode->i_mutex"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "upperdentry",
            "attr",
            "NULL"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&upperdentry->d_inode->i_mutex"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_want_write",
          "args": [
            "dentry"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "178-182",
          "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_copy_up_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
    "lines": "15-41",
    "snippet": "static int ovl_copy_up_last(struct dentry *dentry, struct iattr *attr,\n\t\t\t    bool no_data)\n{\n\tint err;\n\tstruct dentry *parent;\n\tstruct kstat stat;\n\tstruct path lowerpath;\n\n\tparent = dget_parent(dentry);\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tovl_path_lower(dentry, &lowerpath);\n\terr = vfs_getattr(&lowerpath, &stat);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tif (no_data)\n\t\tstat.size = 0;\n\n\terr = ovl_copy_up_one(parent, dentry, &lowerpath, &stat, attr);\n\nout_dput_parent:\n\tdput(parent);\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up_one",
          "args": [
            "parent",
            "dentry",
            "&lowerpath",
            "&stat",
            "attr"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "288-373",
          "snippet": "int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&lowerpath",
            "&stat"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_lower",
          "args": [
            "dentry",
            "&lowerpath"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "171-176",
          "snippet": "void ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up",
          "args": [
            "parent"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "375-413",
          "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_copy_up_last(struct dentry *dentry, struct iattr *attr,\n\t\t\t    bool no_data)\n{\n\tint err;\n\tstruct dentry *parent;\n\tstruct kstat stat;\n\tstruct path lowerpath;\n\n\tparent = dget_parent(dentry);\n\terr = ovl_copy_up(parent);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tovl_path_lower(dentry, &lowerpath);\n\terr = vfs_getattr(&lowerpath, &stat);\n\tif (err)\n\t\tgoto out_dput_parent;\n\n\tif (no_data)\n\t\tstat.size = 0;\n\n\terr = ovl_copy_up_one(parent, dentry, &lowerpath, &stat, attr);\n\nout_dput_parent:\n\tdput(parent);\n\treturn err;\n}"
  }
]