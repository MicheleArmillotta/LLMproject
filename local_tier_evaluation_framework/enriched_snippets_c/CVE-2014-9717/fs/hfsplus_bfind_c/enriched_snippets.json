[
  {
    "function_name": "hfs_brec_goto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "232-295",
    "snippet": "int hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "bnode",
            "fd->key",
            "off",
            "keylen"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_keylen",
          "args": [
            "bnode",
            "fd->record"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "31-60",
          "snippet": "u16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t   (node->tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\tretval = node->tree->max_key_len + 2;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node,\n\t\t\tnode->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (recoff > node->tree->node_size - 2) {\n\t\t\tpr_err(\"recoff %d too large\\n\", recoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\tpr_err(\"keylen %d too large\\n\",\n\t\t\t\tretval);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t   (node->tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\tretval = node->tree->max_key_len + 2;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node,\n\t\t\tnode->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (recoff > node->tree->node_size - 2) {\n\t\t\tpr_err(\"recoff %d too large\\n\", recoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\tpr_err(\"keylen %d too large\\n\",\n\t\t\t\tretval);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_lenoff",
          "args": [
            "bnode",
            "fd->record",
            "&off"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_lenoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "19-28",
          "snippet": "u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bnode"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bnode"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "idx"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "bnode"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bnode"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bnode"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}"
  },
  {
    "function_name": "hfs_brec_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "219-230",
    "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd->bnode",
            "rec",
            "fd->entryoffset",
            "fd->entrylength"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_brec_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "165-217",
    "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "bnode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\"",
            "height",
            "bnode->height",
            "bnode->type",
            "nidx",
            "parent"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "data"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "bnode",
            "&data",
            "fd->entryoffset",
            "4"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfs_brec_find",
          "args": [
            "bnode",
            "fd",
            "do_key_compare"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "113-161",
          "snippet": "int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bnode"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bnode"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "nidx"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
  },
  {
    "function_name": "__hfs_brec_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "113-161",
    "snippet": "int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "bnode",
            "fd->key",
            "off",
            "keylen"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_keylen",
          "args": [
            "bnode",
            "e"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "31-60",
          "snippet": "u16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t   (node->tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\tretval = node->tree->max_key_len + 2;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node,\n\t\t\tnode->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (recoff > node->tree->node_size - 2) {\n\t\t\tpr_err(\"recoff %d too large\\n\", recoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\tpr_err(\"keylen %d too large\\n\",\n\t\t\t\tretval);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t   (node->tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\tretval = node->tree->max_key_len + 2;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node,\n\t\t\tnode->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (recoff > node->tree->node_size - 2) {\n\t\t\tpr_err(\"recoff %d too large\\n\", recoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\tpr_err(\"keylen %d too large\\n\",\n\t\t\t\tretval);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_lenoff",
          "args": [
            "bnode",
            "e",
            "&off"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_lenoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "19-28",
          "snippet": "u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rec_found",
          "args": [
            "bnode",
            "fd",
            "&b",
            "&e",
            "&rec"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}"
  },
  {
    "function_name": "hfs_find_rec_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "91-110",
    "snippet": "int hfs_find_rec_by_key(struct hfs_bnode *bnode,\n\t\t\t\tstruct hfs_find_data *fd,\n\t\t\t\tint *begin,\n\t\t\t\tint *end,\n\t\t\t\tint *cur_rec)\n{\n\tint cmpval;\n\n\tcmpval = bnode->tree->keycmp(fd->key, fd->search_key);\n\tif (!cmpval) {\n\t\t(*end) = (*cur_rec);\n\t\treturn 1;\n\t}\n\tif (cmpval < 0)\n\t\t(*begin) = (*cur_rec) + 1;\n\telse\n\t\t*(end) = (*cur_rec) - 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bnode->tree->keycmp",
          "args": [
            "fd->key",
            "fd->search_key"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_rec_by_key(struct hfs_bnode *bnode,\n\t\t\t\tstruct hfs_find_data *fd,\n\t\t\t\tint *begin,\n\t\t\t\tint *end,\n\t\t\t\tint *cur_rec)\n{\n\tint cmpval;\n\n\tcmpval = bnode->tree->keycmp(fd->key, fd->search_key);\n\tif (!cmpval) {\n\t\t(*end) = (*cur_rec);\n\t\treturn 1;\n\t}\n\tif (cmpval < 0)\n\t\t(*begin) = (*cur_rec) + 1;\n\telse\n\t\t*(end) = (*cur_rec) - 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_find_1st_rec_by_cnid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "53-89",
    "snippet": "int hfs_find_1st_rec_by_cnid(struct hfs_bnode *bnode,\n\t\t\t\tstruct hfs_find_data *fd,\n\t\t\t\tint *begin,\n\t\t\t\tint *end,\n\t\t\t\tint *cur_rec)\n{\n\t__be32 cur_cnid;\n\t__be32 search_cnid;\n\n\tif (bnode->tree->cnid == HFSPLUS_EXT_CNID) {\n\t\tcur_cnid = fd->key->ext.cnid;\n\t\tsearch_cnid = fd->search_key->ext.cnid;\n\t} else if (bnode->tree->cnid == HFSPLUS_CAT_CNID) {\n\t\tcur_cnid = fd->key->cat.parent;\n\t\tsearch_cnid = fd->search_key->cat.parent;\n\t} else if (bnode->tree->cnid == HFSPLUS_ATTR_CNID) {\n\t\tcur_cnid = fd->key->attr.cnid;\n\t\tsearch_cnid = fd->search_key->attr.cnid;\n\t} else {\n\t\tcur_cnid = 0;\t/* used-uninitialized warning */\n\t\tsearch_cnid = 0;\n\t\tBUG();\n\t}\n\n\tif (cur_cnid == search_cnid) {\n\t\t(*end) = (*cur_rec);\n\t\tif ((*begin) == (*end))\n\t\t\treturn 1;\n\t} else {\n\t\tif (be32_to_cpu(cur_cnid) < be32_to_cpu(search_cnid))\n\t\t\t(*begin) = (*cur_rec) + 1;\n\t\telse\n\t\t\t(*end) = (*cur_rec) - 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "search_cnid"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "cur_cnid"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_1st_rec_by_cnid(struct hfs_bnode *bnode,\n\t\t\t\tstruct hfs_find_data *fd,\n\t\t\t\tint *begin,\n\t\t\t\tint *end,\n\t\t\t\tint *cur_rec)\n{\n\t__be32 cur_cnid;\n\t__be32 search_cnid;\n\n\tif (bnode->tree->cnid == HFSPLUS_EXT_CNID) {\n\t\tcur_cnid = fd->key->ext.cnid;\n\t\tsearch_cnid = fd->search_key->ext.cnid;\n\t} else if (bnode->tree->cnid == HFSPLUS_CAT_CNID) {\n\t\tcur_cnid = fd->key->cat.parent;\n\t\tsearch_cnid = fd->search_key->cat.parent;\n\t} else if (bnode->tree->cnid == HFSPLUS_ATTR_CNID) {\n\t\tcur_cnid = fd->key->attr.cnid;\n\t\tsearch_cnid = fd->search_key->attr.cnid;\n\t} else {\n\t\tcur_cnid = 0;\t/* used-uninitialized warning */\n\t\tsearch_cnid = 0;\n\t\tBUG();\n\t}\n\n\tif (cur_cnid == search_cnid) {\n\t\t(*end) = (*cur_rec);\n\t\tif ((*begin) == (*end))\n\t\t\treturn 1;\n\t} else {\n\t\tif (be32_to_cpu(cur_cnid) < be32_to_cpu(search_cnid))\n\t\t\t(*begin) = (*cur_rec) + 1;\n\t\telse\n\t\t\t(*end) = (*cur_rec) - 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_find_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "43-51",
    "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fd->tree->tree_lock"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_REFS",
            "\"find_exit: %d (%p)\\n\"",
            "fd->tree->cnid",
            "__builtin_return_address(0)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fd->search_key"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "fd->bnode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
  },
  {
    "function_name": "hfs_find_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
    "lines": "14-41",
    "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&tree->tree_lock",
            "ATTR_BTREE_MUTEX"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&tree->tree_lock",
            "EXTENTS_BTREE_MUTEX"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&tree->tree_lock",
            "CATALOG_BTREE_MUTEX"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_REFS",
            "\"find_init: %d (%p)\\n\"",
            "tree->cnid",
            "__builtin_return_address(0)"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "tree->max_key_len * 2 + 4",
            "GFP_KERNEL"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
  }
]