[
  {
    "function_name": "cachefiles_uncache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "955-967",
    "snippet": "void cachefiles_uncache_page(struct fscache_object *_object, struct page *page)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"%p,{%lu}\", object, page->index);\n\n\tspin_unlock(&object->fscache.cookie->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->fscache.cookie->lock"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,{%lu}\"",
            "object",
            "page->index"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nvoid cachefiles_uncache_page(struct fscache_object *_object, struct page *page)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"%p,{%lu}\", object, page->index);\n\n\tspin_unlock(&object->fscache.cookie->lock);\n}"
  },
  {
    "function_name": "cachefiles_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "879-949",
    "snippet": "int cachefiles_write_page(struct fscache_storage *op, struct page *page)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct file *file;\n\tstruct path path;\n\tloff_t pos, eof;\n\tsize_t len;\n\tvoid *data;\n\tint ret;\n\n\tASSERT(op != NULL);\n\tASSERT(page != NULL);\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\n\t_enter(\"%p,%p{%lx},,,\", object, page, page->index);\n\n\tif (!object->backer) {\n\t\t_leave(\" = -ENOBUFS\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERT(d_is_reg(object->backer));\n\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t/* write the page to the backing filesystem and let it store it in its\n\t * own time */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = object->backer;\n\tfile = dentry_open(&path, O_RDWR | O_LARGEFILE, cache->cache_cred);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t} else {\n\t\tpos = (loff_t) page->index << PAGE_SHIFT;\n\n\t\t/* we mustn't write more data than we have, so we have\n\t\t * to beware of a partial page at EOF */\n\t\teof = object->fscache.store_limit_l;\n\t\tlen = PAGE_SIZE;\n\t\tif (eof & ~PAGE_MASK) {\n\t\t\tASSERTCMP(pos, <, eof);\n\t\t\tif (eof - pos < PAGE_SIZE) {\n\t\t\t\t_debug(\"cut short %llx to %llx\",\n\t\t\t\t       pos, eof);\n\t\t\t\tlen = eof - pos;\n\t\t\t\tASSERTCMP(pos + len, ==, eof);\n\t\t\t}\n\t\t}\n\n\t\tdata = kmap(page);\n\t\tret = __kernel_write(file, data, len, &pos);\n\t\tkunmap(page);\n\t\tif (ret != len)\n\t\t\tret = -EIO;\n\t\tfput(file);\n\t}\n\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error_obj(\n\t\t\t\tobject, \"Write page to backing file failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Write page to backing file failed\""
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_write",
          "args": [
            "file",
            "data",
            "len",
            "&pos"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "545-572",
          "snippet": "ssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "pos + len",
            "==,eof"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"cut short %llx to %llx\"",
            "pos",
            "eof"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "pos",
            "<,eof"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&path",
            "O_RDWR | O_LARGEFILE",
            "cache->cache_cred"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "d_is_reg(object->backer)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "object->backer"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS\""
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p{%lx},,,\"",
            "object",
            "page",
            "page->index"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "page != NULL"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "op != NULL"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nint cachefiles_write_page(struct fscache_storage *op, struct page *page)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct file *file;\n\tstruct path path;\n\tloff_t pos, eof;\n\tsize_t len;\n\tvoid *data;\n\tint ret;\n\n\tASSERT(op != NULL);\n\tASSERT(page != NULL);\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\n\t_enter(\"%p,%p{%lx},,,\", object, page, page->index);\n\n\tif (!object->backer) {\n\t\t_leave(\" = -ENOBUFS\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERT(d_is_reg(object->backer));\n\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t/* write the page to the backing filesystem and let it store it in its\n\t * own time */\n\tpath.mnt = cache->mnt;\n\tpath.dentry = object->backer;\n\tfile = dentry_open(&path, O_RDWR | O_LARGEFILE, cache->cache_cred);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t} else {\n\t\tpos = (loff_t) page->index << PAGE_SHIFT;\n\n\t\t/* we mustn't write more data than we have, so we have\n\t\t * to beware of a partial page at EOF */\n\t\teof = object->fscache.store_limit_l;\n\t\tlen = PAGE_SIZE;\n\t\tif (eof & ~PAGE_MASK) {\n\t\t\tASSERTCMP(pos, <, eof);\n\t\t\tif (eof - pos < PAGE_SIZE) {\n\t\t\t\t_debug(\"cut short %llx to %llx\",\n\t\t\t\t       pos, eof);\n\t\t\t\tlen = eof - pos;\n\t\t\t\tASSERTCMP(pos + len, ==, eof);\n\t\t\t}\n\t\t}\n\n\t\tdata = kmap(page);\n\t\tret = __kernel_write(file, data, len, &pos);\n\t\tkunmap(page);\n\t\tif (ret != len)\n\t\t\tret = -EIO;\n\t\tfput(file);\n\t}\n\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error_obj(\n\t\t\t\tobject, \"Write page to backing file failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_allocate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "833-870",
    "snippet": "int cachefiles_allocate_pages(struct fscache_retrieval *op,\n\t\t\t      struct list_head *pages,\n\t\t\t      unsigned *nr_pages,\n\t\t\t      gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct pagevec pagevec;\n\tstruct page *page;\n\tint ret;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"%p,,,%d,\", object, *nr_pages);\n\n\tret = cachefiles_has_space(cache, 0, *nr_pages);\n\tif (ret == 0) {\n\t\tpagevec_init(&pagevec, 0);\n\n\t\tlist_for_each_entry(page, pages, lru) {\n\t\t\tif (pagevec_add(&pagevec, page) == 0)\n\t\t\t\tfscache_mark_pages_cached(op, &pagevec);\n\t\t}\n\n\t\tif (pagevec_count(&pagevec) > 0)\n\t\t\tfscache_mark_pages_cached(op, &pagevec);\n\t\tret = -ENODATA;\n\t} else {\n\t\tret = -ENOBUFS;\n\t}\n\n\tfscache_retrieval_complete(op, *nr_pages);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "*nr_pages"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_pages_cached",
          "args": [
            "op",
            "&pagevec"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_pages_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1145-1154",
          "snippet": "void fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pagevec"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "&pagevec",
            "page"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "pages",
            "lru"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pagevec",
            "0"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "0",
            "*nr_pages"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,,,%d,\"",
            "object",
            "*nr_pages"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nint cachefiles_allocate_pages(struct fscache_retrieval *op,\n\t\t\t      struct list_head *pages,\n\t\t\t      unsigned *nr_pages,\n\t\t\t      gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct pagevec pagevec;\n\tstruct page *page;\n\tint ret;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"%p,,,%d,\", object, *nr_pages);\n\n\tret = cachefiles_has_space(cache, 0, *nr_pages);\n\tif (ret == 0) {\n\t\tpagevec_init(&pagevec, 0);\n\n\t\tlist_for_each_entry(page, pages, lru) {\n\t\t\tif (pagevec_add(&pagevec, page) == 0)\n\t\t\t\tfscache_mark_pages_cached(op, &pagevec);\n\t\t}\n\n\t\tif (pagevec_count(&pagevec) > 0)\n\t\t\tfscache_mark_pages_cached(op, &pagevec);\n\t\tret = -ENODATA;\n\t} else {\n\t\tret = -ENOBUFS;\n\t}\n\n\tfscache_retrieval_complete(op, *nr_pages);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_allocate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "796-820",
    "snippet": "int cachefiles_allocate_page(struct fscache_retrieval *op,\n\t\t\t     struct page *page,\n\t\t\t     gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tint ret;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"%p,{%lx},\", object, page->index);\n\n\tret = cachefiles_has_space(cache, 0, 1);\n\tif (ret == 0)\n\t\tfscache_mark_page_cached(op, page);\n\telse\n\t\tret = -ENOBUFS;\n\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_page_cached",
          "args": [
            "op",
            "page"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_page_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1113-1134",
          "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "0",
            "1"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,{%lx},\"",
            "object",
            "page->index"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nint cachefiles_allocate_page(struct fscache_retrieval *op,\n\t\t\t     struct page *page,\n\t\t\t     gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tint ret;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"%p,{%lx},\", object, page->index);\n\n\tret = cachefiles_has_space(cache, 0, 1);\n\tif (ret == 0)\n\t\tfscache_mark_page_cached(op, page);\n\telse\n\t\tret = -ENOBUFS;\n\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_read_or_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "678-783",
    "snippet": "int cachefiles_read_or_alloc_pages(struct fscache_retrieval *op,\n\t\t\t\t   struct list_head *pages,\n\t\t\t\t   unsigned *nr_pages,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct list_head backpages;\n\tstruct pagevec pagevec;\n\tstruct inode *inode;\n\tstruct page *page, *_n;\n\tunsigned shift, nrbackpages;\n\tint ret, ret2, space;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"{OBJ%x,%d},,%d,,\",\n\t       object->fscache.debug_id, atomic_read(&op->op.usage),\n\t       *nr_pages);\n\n\tif (!object->backer)\n\t\tgoto all_enobufs;\n\n\tspace = 1;\n\tif (cachefiles_has_space(cache, 0, *nr_pages) < 0)\n\t\tspace = 0;\n\n\tinode = object->backer->d_inode;\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT(inode->i_mapping->a_ops->bmap);\n\tASSERT(inode->i_mapping->a_ops->readpages);\n\n\t/* calculate the shift required to use bmap */\n\tif (inode->i_sb->s_blocksize > PAGE_SIZE)\n\t\tgoto all_enobufs;\n\n\tshift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;\n\n\tpagevec_init(&pagevec, 0);\n\n\top->op.flags &= FSCACHE_OP_KEEP_FLAGS;\n\top->op.flags |= FSCACHE_OP_ASYNC;\n\top->op.processor = cachefiles_read_copier;\n\n\tINIT_LIST_HEAD(&backpages);\n\tnrbackpages = 0;\n\n\tret = space ? -ENODATA : -ENOBUFS;\n\tlist_for_each_entry_safe(page, _n, pages, lru) {\n\t\tsector_t block0, block;\n\n\t\t/* we assume the absence or presence of the first block is a\n\t\t * good enough indication for the page as a whole\n\t\t * - TODO: don't use bmap() for this as it is _not_ actually\n\t\t *   good enough for this as it doesn't indicate errors, but\n\t\t *   it's all we've got for the moment\n\t\t */\n\t\tblock0 = page->index;\n\t\tblock0 <<= shift;\n\n\t\tblock = inode->i_mapping->a_ops->bmap(inode->i_mapping,\n\t\t\t\t\t\t      block0);\n\t\t_debug(\"%llx -> %llx\",\n\t\t       (unsigned long long) block0,\n\t\t       (unsigned long long) block);\n\n\t\tif (block) {\n\t\t\t/* we have data - add it to the list to give to the\n\t\t\t * backing fs */\n\t\t\tlist_move(&page->lru, &backpages);\n\t\t\t(*nr_pages)--;\n\t\t\tnrbackpages++;\n\t\t} else if (space && pagevec_add(&pagevec, page) == 0) {\n\t\t\tfscache_mark_pages_cached(op, &pagevec);\n\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\tret = -ENODATA;\n\t\t} else {\n\t\t\tfscache_retrieval_complete(op, 1);\n\t\t}\n\t}\n\n\tif (pagevec_count(&pagevec) > 0)\n\t\tfscache_mark_pages_cached(op, &pagevec);\n\n\tif (list_empty(pages))\n\t\tret = 0;\n\n\t/* submit the apparently valid pages to the backing fs to be read from\n\t * disk */\n\tif (nrbackpages > 0) {\n\t\tret2 = cachefiles_read_backing_file(object, op, &backpages);\n\t\tif (ret2 == -ENOMEM || ret2 == -EINTR)\n\t\t\tret = ret2;\n\t}\n\n\t_leave(\" = %d [nr=%u%s]\",\n\t       ret, *nr_pages, list_empty(pages) ? \" empty\" : \"\");\n\treturn ret;\n\nall_enobufs:\n\tfscache_retrieval_complete(op, *nr_pages);\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "*nr_pages"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [nr=%u%s]\"",
            "ret",
            "*nr_pages",
            "list_empty(pages) ? \" empty\" : \"\""
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_dx_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "679-690",
          "snippet": "static int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nstatic int ocfs2_read_dx_leaves(struct inode *dir, u64 start, int num,\n\t\t\t\tstruct buffer_head **dx_leaf_bhs)\n{\n\tint ret;\n\n\tret = ocfs2_read_blocks(INODE_CACHE(dir), start, num, dx_leaf_bhs, 0,\n\t\t\t\tocfs2_validate_dx_leaf);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_read_backing_file",
          "args": [
            "object",
            "op",
            "&backpages"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_read_backing_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
          "lines": "466-672",
          "snippet": "static int cachefiles_read_backing_file(struct cachefiles_object *object,\n\t\t\t\t\tstruct fscache_retrieval *op,\n\t\t\t\t\tstruct list_head *list)\n{\n\tstruct cachefiles_one_read *monitor = NULL;\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *newpage = NULL, *netpage, *_n, *backpage = NULL;\n\tint ret = 0;\n\n\t_enter(\"\");\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\n\t\t_debug(\"read back %p{%lu,%d}\",\n\t\t       netpage, netpage->index, page_count(netpage));\n\n\t\tif (!monitor) {\n\t\t\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\t\t\tif (!monitor)\n\t\t\t\tgoto nomem;\n\n\t\t\tmonitor->op = fscache_get_retrieval(op);\n\t\t\tinit_waitqueue_func_entry(&monitor->monitor,\n\t\t\t\t\t\t  cachefiles_read_waiter);\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\t\tif (backpage)\n\t\t\t\tgoto backing_page_already_present;\n\n\t\t\tif (!newpage) {\n\t\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t\t     __GFP_COLD);\n\t\t\t\tif (!newpage)\n\t\t\t\t\tgoto nomem;\n\t\t\t}\n\n\t\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t\t    netpage->index,\n\t\t\t\t\t\t    cachefiles_gfp);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto installed_new_backing_page;\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* we've installed a new backing page, so now we need\n\t\t * to start it reading */\n\tinstalled_new_backing_page:\n\t\t_debug(\"- new %p\", newpage);\n\n\t\tbackpage = newpage;\n\t\tnewpage = NULL;\n\n\treread_backing_page:\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto read_error;\n\n\t\t/* add the netfs page to the pagecache and LRU, and set the\n\t\t * monitor to transfer the data across */\n\tmonitor_backing_page:\n\t\t_debug(\"- monitor add\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* install a monitor */\n\t\tpage_cache_get(netpage);\n\t\tmonitor->netfs_page = netpage;\n\n\t\tpage_cache_get(backpage);\n\t\tmonitor->back_page = backpage;\n\t\tmonitor->monitor.private = backpage;\n\t\tadd_page_wait_queue(backpage, &monitor->monitor);\n\t\tmonitor = NULL;\n\n\t\t/* but the page may have been read before the monitor was\n\t\t * installed, so the monitor may miss the event - so we have to\n\t\t * ensure that we do get one in such a case */\n\t\tif (trylock_page(backpage)) {\n\t\t\t_debug(\"2unlock %p {%lx}\", backpage, backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t}\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tcontinue;\n\n\t\t/* if the backing page is already present, it can be in one of\n\t\t * three states: read in progress, read failed or read okay */\n\tbacking_page_already_present:\n\t\t_debug(\"- present %p\", backpage);\n\n\t\tif (PageError(backpage))\n\t\t\tgoto io_error;\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate;\n\n\t\t_debug(\"- not ready %p{%lx}\", backpage, backpage->flags);\n\n\t\tif (!trylock_page(backpage))\n\t\t\tgoto monitor_backing_page;\n\n\t\tif (PageError(backpage)) {\n\t\t\t_debug(\"error %lx\", backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t\tgoto io_error;\n\t\t}\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate_unlock;\n\n\t\t/* we've locked a page that's neither up to date nor erroneous,\n\t\t * so we need to attempt to read it again */\n\t\tgoto reread_backing_page;\n\n\t\t/* the backing page is already up to date, attach the netfs\n\t\t * page to the pagecache and LRU and copy the data across */\n\tbacking_page_already_uptodate_unlock:\n\t\t_debug(\"uptodate %lx\", backpage->flags);\n\t\tunlock_page(backpage);\n\tbacking_page_already_uptodate:\n\t\t_debug(\"- uptodate\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tcopy_highpage(netpage, backpage);\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tfscache_mark_page_cached(op, netpage);\n\n\t\t/* the netpage is unlocked and marked up to date here */\n\t\tfscache_end_io(op, netpage, 0);\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tfscache_retrieval_complete(op, 1);\n\t\tcontinue;\n\t}\n\n\tnetpage = NULL;\n\n\t_debug(\"out\");\n\nout:\n\t/* tidy up */\n\tif (newpage)\n\t\tpage_cache_release(newpage);\n\tif (netpage)\n\t\tpage_cache_release(netpage);\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(op);\n\t\tkfree(monitor);\n\t}\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\t\tpage_cache_release(netpage);\n\t\tfscache_retrieval_complete(op, 1);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnomem:\n\t_debug(\"nomem\");\n\tret = -ENOMEM;\n\tgoto record_page_complete;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM)\n\t\tgoto record_page_complete;\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tret = -ENOBUFS;\nrecord_page_complete:\n\tfscache_retrieval_complete(op, 1);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_backing_file(struct cachefiles_object *object,\n\t\t\t\t\tstruct fscache_retrieval *op,\n\t\t\t\t\tstruct list_head *list)\n{\n\tstruct cachefiles_one_read *monitor = NULL;\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *newpage = NULL, *netpage, *_n, *backpage = NULL;\n\tint ret = 0;\n\n\t_enter(\"\");\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\n\t\t_debug(\"read back %p{%lu,%d}\",\n\t\t       netpage, netpage->index, page_count(netpage));\n\n\t\tif (!monitor) {\n\t\t\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\t\t\tif (!monitor)\n\t\t\t\tgoto nomem;\n\n\t\t\tmonitor->op = fscache_get_retrieval(op);\n\t\t\tinit_waitqueue_func_entry(&monitor->monitor,\n\t\t\t\t\t\t  cachefiles_read_waiter);\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\t\tif (backpage)\n\t\t\t\tgoto backing_page_already_present;\n\n\t\t\tif (!newpage) {\n\t\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t\t     __GFP_COLD);\n\t\t\t\tif (!newpage)\n\t\t\t\t\tgoto nomem;\n\t\t\t}\n\n\t\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t\t    netpage->index,\n\t\t\t\t\t\t    cachefiles_gfp);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto installed_new_backing_page;\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* we've installed a new backing page, so now we need\n\t\t * to start it reading */\n\tinstalled_new_backing_page:\n\t\t_debug(\"- new %p\", newpage);\n\n\t\tbackpage = newpage;\n\t\tnewpage = NULL;\n\n\treread_backing_page:\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto read_error;\n\n\t\t/* add the netfs page to the pagecache and LRU, and set the\n\t\t * monitor to transfer the data across */\n\tmonitor_backing_page:\n\t\t_debug(\"- monitor add\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* install a monitor */\n\t\tpage_cache_get(netpage);\n\t\tmonitor->netfs_page = netpage;\n\n\t\tpage_cache_get(backpage);\n\t\tmonitor->back_page = backpage;\n\t\tmonitor->monitor.private = backpage;\n\t\tadd_page_wait_queue(backpage, &monitor->monitor);\n\t\tmonitor = NULL;\n\n\t\t/* but the page may have been read before the monitor was\n\t\t * installed, so the monitor may miss the event - so we have to\n\t\t * ensure that we do get one in such a case */\n\t\tif (trylock_page(backpage)) {\n\t\t\t_debug(\"2unlock %p {%lx}\", backpage, backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t}\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tcontinue;\n\n\t\t/* if the backing page is already present, it can be in one of\n\t\t * three states: read in progress, read failed or read okay */\n\tbacking_page_already_present:\n\t\t_debug(\"- present %p\", backpage);\n\n\t\tif (PageError(backpage))\n\t\t\tgoto io_error;\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate;\n\n\t\t_debug(\"- not ready %p{%lx}\", backpage, backpage->flags);\n\n\t\tif (!trylock_page(backpage))\n\t\t\tgoto monitor_backing_page;\n\n\t\tif (PageError(backpage)) {\n\t\t\t_debug(\"error %lx\", backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t\tgoto io_error;\n\t\t}\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate_unlock;\n\n\t\t/* we've locked a page that's neither up to date nor erroneous,\n\t\t * so we need to attempt to read it again */\n\t\tgoto reread_backing_page;\n\n\t\t/* the backing page is already up to date, attach the netfs\n\t\t * page to the pagecache and LRU and copy the data across */\n\tbacking_page_already_uptodate_unlock:\n\t\t_debug(\"uptodate %lx\", backpage->flags);\n\t\tunlock_page(backpage);\n\tbacking_page_already_uptodate:\n\t\t_debug(\"- uptodate\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tcopy_highpage(netpage, backpage);\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tfscache_mark_page_cached(op, netpage);\n\n\t\t/* the netpage is unlocked and marked up to date here */\n\t\tfscache_end_io(op, netpage, 0);\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tfscache_retrieval_complete(op, 1);\n\t\tcontinue;\n\t}\n\n\tnetpage = NULL;\n\n\t_debug(\"out\");\n\nout:\n\t/* tidy up */\n\tif (newpage)\n\t\tpage_cache_release(newpage);\n\tif (netpage)\n\t\tpage_cache_release(netpage);\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(op);\n\t\tkfree(monitor);\n\t}\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\t\tpage_cache_release(netpage);\n\t\tfscache_retrieval_complete(op, 1);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnomem:\n\t_debug(\"nomem\");\n\tret = -ENOMEM;\n\tgoto record_page_complete;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM)\n\t\tgoto record_page_complete;\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tret = -ENOBUFS;\nrecord_page_complete:\n\tfscache_retrieval_complete(op, 1);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_mark_pages_cached",
          "args": [
            "op",
            "&pagevec"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_pages_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1145-1154",
          "snippet": "void fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pagevec"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "&pagevec",
            "page"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&backpages"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"%llx -> %llx\"",
            "(unsigned long long) block0",
            "(unsigned long long) block"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode->i_mapping->a_ops->bmap",
          "args": [
            "inode->i_mapping",
            "block0"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1502-1508",
          "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "_n",
            "pages",
            "lru"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&backpages"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pagevec",
            "0"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inode->i_mapping->a_ops->readpages"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inode->i_mapping->a_ops->bmap"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISREG(inode->i_mode)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "0",
            "*nr_pages"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%d},,%d,,\"",
            "object->fscache.debug_id",
            "atomic_read(&op->op.usage)",
            "*nr_pages"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->op.usage"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nint cachefiles_read_or_alloc_pages(struct fscache_retrieval *op,\n\t\t\t\t   struct list_head *pages,\n\t\t\t\t   unsigned *nr_pages,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct list_head backpages;\n\tstruct pagevec pagevec;\n\tstruct inode *inode;\n\tstruct page *page, *_n;\n\tunsigned shift, nrbackpages;\n\tint ret, ret2, space;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"{OBJ%x,%d},,%d,,\",\n\t       object->fscache.debug_id, atomic_read(&op->op.usage),\n\t       *nr_pages);\n\n\tif (!object->backer)\n\t\tgoto all_enobufs;\n\n\tspace = 1;\n\tif (cachefiles_has_space(cache, 0, *nr_pages) < 0)\n\t\tspace = 0;\n\n\tinode = object->backer->d_inode;\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT(inode->i_mapping->a_ops->bmap);\n\tASSERT(inode->i_mapping->a_ops->readpages);\n\n\t/* calculate the shift required to use bmap */\n\tif (inode->i_sb->s_blocksize > PAGE_SIZE)\n\t\tgoto all_enobufs;\n\n\tshift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;\n\n\tpagevec_init(&pagevec, 0);\n\n\top->op.flags &= FSCACHE_OP_KEEP_FLAGS;\n\top->op.flags |= FSCACHE_OP_ASYNC;\n\top->op.processor = cachefiles_read_copier;\n\n\tINIT_LIST_HEAD(&backpages);\n\tnrbackpages = 0;\n\n\tret = space ? -ENODATA : -ENOBUFS;\n\tlist_for_each_entry_safe(page, _n, pages, lru) {\n\t\tsector_t block0, block;\n\n\t\t/* we assume the absence or presence of the first block is a\n\t\t * good enough indication for the page as a whole\n\t\t * - TODO: don't use bmap() for this as it is _not_ actually\n\t\t *   good enough for this as it doesn't indicate errors, but\n\t\t *   it's all we've got for the moment\n\t\t */\n\t\tblock0 = page->index;\n\t\tblock0 <<= shift;\n\n\t\tblock = inode->i_mapping->a_ops->bmap(inode->i_mapping,\n\t\t\t\t\t\t      block0);\n\t\t_debug(\"%llx -> %llx\",\n\t\t       (unsigned long long) block0,\n\t\t       (unsigned long long) block);\n\n\t\tif (block) {\n\t\t\t/* we have data - add it to the list to give to the\n\t\t\t * backing fs */\n\t\t\tlist_move(&page->lru, &backpages);\n\t\t\t(*nr_pages)--;\n\t\t\tnrbackpages++;\n\t\t} else if (space && pagevec_add(&pagevec, page) == 0) {\n\t\t\tfscache_mark_pages_cached(op, &pagevec);\n\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\tret = -ENODATA;\n\t\t} else {\n\t\t\tfscache_retrieval_complete(op, 1);\n\t\t}\n\t}\n\n\tif (pagevec_count(&pagevec) > 0)\n\t\tfscache_mark_pages_cached(op, &pagevec);\n\n\tif (list_empty(pages))\n\t\tret = 0;\n\n\t/* submit the apparently valid pages to the backing fs to be read from\n\t * disk */\n\tif (nrbackpages > 0) {\n\t\tret2 = cachefiles_read_backing_file(object, op, &backpages);\n\t\tif (ret2 == -ENOMEM || ret2 == -EINTR)\n\t\t\tret = ret2;\n\t}\n\n\t_leave(\" = %d [nr=%u%s]\",\n\t       ret, *nr_pages, list_empty(pages) ? \" empty\" : \"\");\n\treturn ret;\n\nall_enobufs:\n\tfscache_retrieval_complete(op, *nr_pages);\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "cachefiles_read_backing_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "466-672",
    "snippet": "static int cachefiles_read_backing_file(struct cachefiles_object *object,\n\t\t\t\t\tstruct fscache_retrieval *op,\n\t\t\t\t\tstruct list_head *list)\n{\n\tstruct cachefiles_one_read *monitor = NULL;\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *newpage = NULL, *netpage, *_n, *backpage = NULL;\n\tint ret = 0;\n\n\t_enter(\"\");\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\n\t\t_debug(\"read back %p{%lu,%d}\",\n\t\t       netpage, netpage->index, page_count(netpage));\n\n\t\tif (!monitor) {\n\t\t\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\t\t\tif (!monitor)\n\t\t\t\tgoto nomem;\n\n\t\t\tmonitor->op = fscache_get_retrieval(op);\n\t\t\tinit_waitqueue_func_entry(&monitor->monitor,\n\t\t\t\t\t\t  cachefiles_read_waiter);\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\t\tif (backpage)\n\t\t\t\tgoto backing_page_already_present;\n\n\t\t\tif (!newpage) {\n\t\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t\t     __GFP_COLD);\n\t\t\t\tif (!newpage)\n\t\t\t\t\tgoto nomem;\n\t\t\t}\n\n\t\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t\t    netpage->index,\n\t\t\t\t\t\t    cachefiles_gfp);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto installed_new_backing_page;\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* we've installed a new backing page, so now we need\n\t\t * to start it reading */\n\tinstalled_new_backing_page:\n\t\t_debug(\"- new %p\", newpage);\n\n\t\tbackpage = newpage;\n\t\tnewpage = NULL;\n\n\treread_backing_page:\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto read_error;\n\n\t\t/* add the netfs page to the pagecache and LRU, and set the\n\t\t * monitor to transfer the data across */\n\tmonitor_backing_page:\n\t\t_debug(\"- monitor add\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* install a monitor */\n\t\tpage_cache_get(netpage);\n\t\tmonitor->netfs_page = netpage;\n\n\t\tpage_cache_get(backpage);\n\t\tmonitor->back_page = backpage;\n\t\tmonitor->monitor.private = backpage;\n\t\tadd_page_wait_queue(backpage, &monitor->monitor);\n\t\tmonitor = NULL;\n\n\t\t/* but the page may have been read before the monitor was\n\t\t * installed, so the monitor may miss the event - so we have to\n\t\t * ensure that we do get one in such a case */\n\t\tif (trylock_page(backpage)) {\n\t\t\t_debug(\"2unlock %p {%lx}\", backpage, backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t}\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tcontinue;\n\n\t\t/* if the backing page is already present, it can be in one of\n\t\t * three states: read in progress, read failed or read okay */\n\tbacking_page_already_present:\n\t\t_debug(\"- present %p\", backpage);\n\n\t\tif (PageError(backpage))\n\t\t\tgoto io_error;\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate;\n\n\t\t_debug(\"- not ready %p{%lx}\", backpage, backpage->flags);\n\n\t\tif (!trylock_page(backpage))\n\t\t\tgoto monitor_backing_page;\n\n\t\tif (PageError(backpage)) {\n\t\t\t_debug(\"error %lx\", backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t\tgoto io_error;\n\t\t}\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate_unlock;\n\n\t\t/* we've locked a page that's neither up to date nor erroneous,\n\t\t * so we need to attempt to read it again */\n\t\tgoto reread_backing_page;\n\n\t\t/* the backing page is already up to date, attach the netfs\n\t\t * page to the pagecache and LRU and copy the data across */\n\tbacking_page_already_uptodate_unlock:\n\t\t_debug(\"uptodate %lx\", backpage->flags);\n\t\tunlock_page(backpage);\n\tbacking_page_already_uptodate:\n\t\t_debug(\"- uptodate\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tcopy_highpage(netpage, backpage);\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tfscache_mark_page_cached(op, netpage);\n\n\t\t/* the netpage is unlocked and marked up to date here */\n\t\tfscache_end_io(op, netpage, 0);\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tfscache_retrieval_complete(op, 1);\n\t\tcontinue;\n\t}\n\n\tnetpage = NULL;\n\n\t_debug(\"out\");\n\nout:\n\t/* tidy up */\n\tif (newpage)\n\t\tpage_cache_release(newpage);\n\tif (netpage)\n\t\tpage_cache_release(netpage);\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(op);\n\t\tkfree(monitor);\n\t}\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\t\tpage_cache_release(netpage);\n\t\tfscache_retrieval_complete(op, 1);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnomem:\n\t_debug(\"nomem\");\n\tret = -ENOMEM;\n\tgoto record_page_complete;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM)\n\t\tgoto record_page_complete;\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tret = -ENOBUFS;\nrecord_page_complete:\n\tfscache_retrieval_complete(op, 1);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Page read error on backing file\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"read error %d\"",
            "ret"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"nomem\""
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "netpage"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&netpage->lru"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "netpage",
            "_n",
            "list",
            "lru"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "monitor"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "op"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "backpage"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "netpage"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "newpage"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "netpage"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_end_io",
          "args": [
            "op",
            "netpage",
            "0"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_page_cached",
          "args": [
            "op",
            "netpage"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_page_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1113-1134",
          "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "backpage"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "netpage",
            "backpage"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "netpage"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "netpage",
            "op->mapping",
            "netpage->index",
            "cachefiles_gfp"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "backpage"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "backpage"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "backpage"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "backpage"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"- not ready %p{%lx}\"",
            "backpage",
            "backpage->flags"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "backpage"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "backpage"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "netpage"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "backpage"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "backpage"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_wait_queue",
          "args": [
            "backpage",
            "&monitor->monitor"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "backpage"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "netpage"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "netpage"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "netpage",
            "op->mapping",
            "netpage->index",
            "cachefiles_gfp"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmapping->a_ops->readpage",
          "args": [
            "NULL",
            "backpage"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "newpage",
            "bmapping",
            "netpage->index",
            "cachefiles_gfp"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "cachefiles_gfp |\n\t\t\t\t\t\t\t     __GFP_COLD"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "bmapping",
            "netpage->index"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&monitor->monitor",
            "cachefiles_read_waiter"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_get_retrieval",
          "args": [
            "op"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*monitor)",
            "cachefiles_gfp"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "netpage"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "netpage",
            "_n",
            "list",
            "lru"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_backing_file(struct cachefiles_object *object,\n\t\t\t\t\tstruct fscache_retrieval *op,\n\t\t\t\t\tstruct list_head *list)\n{\n\tstruct cachefiles_one_read *monitor = NULL;\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *newpage = NULL, *netpage, *_n, *backpage = NULL;\n\tint ret = 0;\n\n\t_enter(\"\");\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\n\t\t_debug(\"read back %p{%lu,%d}\",\n\t\t       netpage, netpage->index, page_count(netpage));\n\n\t\tif (!monitor) {\n\t\t\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\t\t\tif (!monitor)\n\t\t\t\tgoto nomem;\n\n\t\t\tmonitor->op = fscache_get_retrieval(op);\n\t\t\tinit_waitqueue_func_entry(&monitor->monitor,\n\t\t\t\t\t\t  cachefiles_read_waiter);\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\t\tif (backpage)\n\t\t\t\tgoto backing_page_already_present;\n\n\t\t\tif (!newpage) {\n\t\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t\t     __GFP_COLD);\n\t\t\t\tif (!newpage)\n\t\t\t\t\tgoto nomem;\n\t\t\t}\n\n\t\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t\t    netpage->index,\n\t\t\t\t\t\t    cachefiles_gfp);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto installed_new_backing_page;\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* we've installed a new backing page, so now we need\n\t\t * to start it reading */\n\tinstalled_new_backing_page:\n\t\t_debug(\"- new %p\", newpage);\n\n\t\tbackpage = newpage;\n\t\tnewpage = NULL;\n\n\treread_backing_page:\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto read_error;\n\n\t\t/* add the netfs page to the pagecache and LRU, and set the\n\t\t * monitor to transfer the data across */\n\tmonitor_backing_page:\n\t\t_debug(\"- monitor add\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\t/* install a monitor */\n\t\tpage_cache_get(netpage);\n\t\tmonitor->netfs_page = netpage;\n\n\t\tpage_cache_get(backpage);\n\t\tmonitor->back_page = backpage;\n\t\tmonitor->monitor.private = backpage;\n\t\tadd_page_wait_queue(backpage, &monitor->monitor);\n\t\tmonitor = NULL;\n\n\t\t/* but the page may have been read before the monitor was\n\t\t * installed, so the monitor may miss the event - so we have to\n\t\t * ensure that we do get one in such a case */\n\t\tif (trylock_page(backpage)) {\n\t\t\t_debug(\"2unlock %p {%lx}\", backpage, backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t}\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tcontinue;\n\n\t\t/* if the backing page is already present, it can be in one of\n\t\t * three states: read in progress, read failed or read okay */\n\tbacking_page_already_present:\n\t\t_debug(\"- present %p\", backpage);\n\n\t\tif (PageError(backpage))\n\t\t\tgoto io_error;\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate;\n\n\t\t_debug(\"- not ready %p{%lx}\", backpage, backpage->flags);\n\n\t\tif (!trylock_page(backpage))\n\t\t\tgoto monitor_backing_page;\n\n\t\tif (PageError(backpage)) {\n\t\t\t_debug(\"error %lx\", backpage->flags);\n\t\t\tunlock_page(backpage);\n\t\t\tgoto io_error;\n\t\t}\n\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto backing_page_already_uptodate_unlock;\n\n\t\t/* we've locked a page that's neither up to date nor erroneous,\n\t\t * so we need to attempt to read it again */\n\t\tgoto reread_backing_page;\n\n\t\t/* the backing page is already up to date, attach the netfs\n\t\t * page to the pagecache and LRU and copy the data across */\n\tbacking_page_already_uptodate_unlock:\n\t\t_debug(\"uptodate %lx\", backpage->flags);\n\t\tunlock_page(backpage);\n\tbacking_page_already_uptodate:\n\t\t_debug(\"- uptodate\");\n\n\t\tret = add_to_page_cache_lru(netpage, op->mapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EEXIST) {\n\t\t\t\tpage_cache_release(netpage);\n\t\t\t\tfscache_retrieval_complete(op, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tcopy_highpage(netpage, backpage);\n\n\t\tpage_cache_release(backpage);\n\t\tbackpage = NULL;\n\n\t\tfscache_mark_page_cached(op, netpage);\n\n\t\t/* the netpage is unlocked and marked up to date here */\n\t\tfscache_end_io(op, netpage, 0);\n\t\tpage_cache_release(netpage);\n\t\tnetpage = NULL;\n\t\tfscache_retrieval_complete(op, 1);\n\t\tcontinue;\n\t}\n\n\tnetpage = NULL;\n\n\t_debug(\"out\");\n\nout:\n\t/* tidy up */\n\tif (newpage)\n\t\tpage_cache_release(newpage);\n\tif (netpage)\n\t\tpage_cache_release(netpage);\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(op);\n\t\tkfree(monitor);\n\t}\n\n\tlist_for_each_entry_safe(netpage, _n, list, lru) {\n\t\tlist_del(&netpage->lru);\n\t\tpage_cache_release(netpage);\n\t\tfscache_retrieval_complete(op, 1);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnomem:\n\t_debug(\"nomem\");\n\tret = -ENOMEM;\n\tgoto record_page_complete;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM)\n\t\tgoto record_page_complete;\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tret = -ENOBUFS;\nrecord_page_complete:\n\tfscache_retrieval_complete(op, 1);\n\tgoto out;\n}"
  },
  {
    "function_name": "cachefiles_read_or_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "390-460",
    "snippet": "int cachefiles_read_or_alloc_page(struct fscache_retrieval *op,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct inode *inode;\n\tsector_t block0, block;\n\tunsigned shift;\n\tint ret;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"{%p},{%lx},,,\", object, page->index);\n\n\tif (!object->backer)\n\t\tgoto enobufs;\n\n\tinode = object->backer->d_inode;\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT(inode->i_mapping->a_ops->bmap);\n\tASSERT(inode->i_mapping->a_ops->readpages);\n\n\t/* calculate the shift required to use bmap */\n\tif (inode->i_sb->s_blocksize > PAGE_SIZE)\n\t\tgoto enobufs;\n\n\tshift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;\n\n\top->op.flags &= FSCACHE_OP_KEEP_FLAGS;\n\top->op.flags |= FSCACHE_OP_ASYNC;\n\top->op.processor = cachefiles_read_copier;\n\n\t/* we assume the absence or presence of the first block is a good\n\t * enough indication for the page as a whole\n\t * - TODO: don't use bmap() for this as it is _not_ actually good\n\t *   enough for this as it doesn't indicate errors, but it's all we've\n\t *   got for the moment\n\t */\n\tblock0 = page->index;\n\tblock0 <<= shift;\n\n\tblock = inode->i_mapping->a_ops->bmap(inode->i_mapping, block0);\n\t_debug(\"%llx -> %llx\",\n\t       (unsigned long long) block0,\n\t       (unsigned long long) block);\n\n\tif (block) {\n\t\t/* submit the apparently valid page to the backing fs to be\n\t\t * read from disk */\n\t\tret = cachefiles_read_backing_file_one(object, op, page);\n\t} else if (cachefiles_has_space(cache, 0, 1) == 0) {\n\t\t/* there's space in the cache we can use */\n\t\tfscache_mark_page_cached(op, page);\n\t\tfscache_retrieval_complete(op, 1);\n\t\tret = -ENODATA;\n\t} else {\n\t\tgoto enobufs;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nenobufs:\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS\""
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_page_cached",
          "args": [
            "op",
            "page"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_page_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1113-1134",
          "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "0",
            "1"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_read_backing_file_one",
          "args": [
            "object",
            "op",
            "page"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_read_backing_file_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
          "lines": "226-374",
          "snippet": "static int cachefiles_read_backing_file_one(struct cachefiles_object *object,\n\t\t\t\t\t    struct fscache_retrieval *op,\n\t\t\t\t\t    struct page *netpage)\n{\n\tstruct cachefiles_one_read *monitor;\n\tstruct address_space *bmapping;\n\tstruct page *newpage, *backpage;\n\tint ret;\n\n\t_enter(\"\");\n\n\t_debug(\"read back %p{%lu,%d}\",\n\t       netpage, netpage->index, page_count(netpage));\n\n\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\tif (!monitor)\n\t\tgoto nomem;\n\n\tmonitor->netfs_page = netpage;\n\tmonitor->op = fscache_get_retrieval(op);\n\n\tinit_waitqueue_func_entry(&monitor->monitor, cachefiles_read_waiter);\n\n\t/* attempt to get hold of the backing page */\n\tbmapping = object->backer->d_inode->i_mapping;\n\tnewpage = NULL;\n\n\tfor (;;) {\n\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\tif (backpage)\n\t\t\tgoto backing_page_already_present;\n\n\t\tif (!newpage) {\n\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t     __GFP_COLD);\n\t\t\tif (!newpage)\n\t\t\t\tgoto nomem_monitor;\n\t\t}\n\n\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret == 0)\n\t\t\tgoto installed_new_backing_page;\n\t\tif (ret != -EEXIST)\n\t\t\tgoto nomem_page;\n\t}\n\n\t/* we've installed a new backing page, so now we need to start\n\t * it reading */\ninstalled_new_backing_page:\n\t_debug(\"- new %p\", newpage);\n\n\tbackpage = newpage;\n\tnewpage = NULL;\n\nread_backing_page:\n\tret = bmapping->a_ops->readpage(NULL, backpage);\n\tif (ret < 0)\n\t\tgoto read_error;\n\n\t/* set the monitor to transfer the data across */\nmonitor_backing_page:\n\t_debug(\"- monitor add\");\n\n\t/* install the monitor */\n\tpage_cache_get(monitor->netfs_page);\n\tpage_cache_get(backpage);\n\tmonitor->back_page = backpage;\n\tmonitor->monitor.private = backpage;\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\tmonitor = NULL;\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\tgoto success;\n\n\t/* if the backing page is already present, it can be in one of\n\t * three states: read in progress, read failed or read okay */\nbacking_page_already_present:\n\t_debug(\"- present\");\n\n\tif (newpage) {\n\t\tpage_cache_release(newpage);\n\t\tnewpage = NULL;\n\t}\n\n\tif (PageError(backpage))\n\t\tgoto io_error;\n\n\tif (PageUptodate(backpage))\n\t\tgoto backing_page_already_uptodate;\n\n\tif (!trylock_page(backpage))\n\t\tgoto monitor_backing_page;\n\t_debug(\"read %p {%lx}\", backpage, backpage->flags);\n\tgoto read_backing_page;\n\n\t/* the backing page is already up to date, attach the netfs\n\t * page to the pagecache and LRU and copy the data across */\nbacking_page_already_uptodate:\n\t_debug(\"- uptodate\");\n\n\tfscache_mark_page_cached(op, netpage);\n\n\tcopy_highpage(netpage, backpage);\n\tfscache_end_io(op, netpage, 0);\n\tfscache_retrieval_complete(op, 1);\n\nsuccess:\n\t_debug(\"success\");\n\tret = 0;\n\nout:\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(monitor->op);\n\t\tkfree(monitor);\n\t}\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM) {\n\t\tfscache_retrieval_complete(op, 1);\n\t\tgoto out;\n\t}\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tfscache_retrieval_complete(op, 1);\n\tret = -ENOBUFS;\n\tgoto out;\n\nnomem_page:\n\tpage_cache_release(newpage);\nnomem_monitor:\n\tfscache_put_retrieval(monitor->op);\n\tkfree(monitor);\nnomem:\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_backing_file_one(struct cachefiles_object *object,\n\t\t\t\t\t    struct fscache_retrieval *op,\n\t\t\t\t\t    struct page *netpage)\n{\n\tstruct cachefiles_one_read *monitor;\n\tstruct address_space *bmapping;\n\tstruct page *newpage, *backpage;\n\tint ret;\n\n\t_enter(\"\");\n\n\t_debug(\"read back %p{%lu,%d}\",\n\t       netpage, netpage->index, page_count(netpage));\n\n\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\tif (!monitor)\n\t\tgoto nomem;\n\n\tmonitor->netfs_page = netpage;\n\tmonitor->op = fscache_get_retrieval(op);\n\n\tinit_waitqueue_func_entry(&monitor->monitor, cachefiles_read_waiter);\n\n\t/* attempt to get hold of the backing page */\n\tbmapping = object->backer->d_inode->i_mapping;\n\tnewpage = NULL;\n\n\tfor (;;) {\n\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\tif (backpage)\n\t\t\tgoto backing_page_already_present;\n\n\t\tif (!newpage) {\n\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t     __GFP_COLD);\n\t\t\tif (!newpage)\n\t\t\t\tgoto nomem_monitor;\n\t\t}\n\n\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret == 0)\n\t\t\tgoto installed_new_backing_page;\n\t\tif (ret != -EEXIST)\n\t\t\tgoto nomem_page;\n\t}\n\n\t/* we've installed a new backing page, so now we need to start\n\t * it reading */\ninstalled_new_backing_page:\n\t_debug(\"- new %p\", newpage);\n\n\tbackpage = newpage;\n\tnewpage = NULL;\n\nread_backing_page:\n\tret = bmapping->a_ops->readpage(NULL, backpage);\n\tif (ret < 0)\n\t\tgoto read_error;\n\n\t/* set the monitor to transfer the data across */\nmonitor_backing_page:\n\t_debug(\"- monitor add\");\n\n\t/* install the monitor */\n\tpage_cache_get(monitor->netfs_page);\n\tpage_cache_get(backpage);\n\tmonitor->back_page = backpage;\n\tmonitor->monitor.private = backpage;\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\tmonitor = NULL;\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\tgoto success;\n\n\t/* if the backing page is already present, it can be in one of\n\t * three states: read in progress, read failed or read okay */\nbacking_page_already_present:\n\t_debug(\"- present\");\n\n\tif (newpage) {\n\t\tpage_cache_release(newpage);\n\t\tnewpage = NULL;\n\t}\n\n\tif (PageError(backpage))\n\t\tgoto io_error;\n\n\tif (PageUptodate(backpage))\n\t\tgoto backing_page_already_uptodate;\n\n\tif (!trylock_page(backpage))\n\t\tgoto monitor_backing_page;\n\t_debug(\"read %p {%lx}\", backpage, backpage->flags);\n\tgoto read_backing_page;\n\n\t/* the backing page is already up to date, attach the netfs\n\t * page to the pagecache and LRU and copy the data across */\nbacking_page_already_uptodate:\n\t_debug(\"- uptodate\");\n\n\tfscache_mark_page_cached(op, netpage);\n\n\tcopy_highpage(netpage, backpage);\n\tfscache_end_io(op, netpage, 0);\n\tfscache_retrieval_complete(op, 1);\n\nsuccess:\n\t_debug(\"success\");\n\tret = 0;\n\nout:\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(monitor->op);\n\t\tkfree(monitor);\n\t}\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM) {\n\t\tfscache_retrieval_complete(op, 1);\n\t\tgoto out;\n\t}\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tfscache_retrieval_complete(op, 1);\n\tret = -ENOBUFS;\n\tgoto out;\n\nnomem_page:\n\tpage_cache_release(newpage);\nnomem_monitor:\n\tfscache_put_retrieval(monitor->op);\n\tkfree(monitor);\nnomem:\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"%llx -> %llx\"",
            "(unsigned long long) block0",
            "(unsigned long long) block"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode->i_mapping->a_ops->bmap",
          "args": [
            "inode->i_mapping",
            "block0"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1502-1508",
          "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inode->i_mapping->a_ops->readpages"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inode->i_mapping->a_ops->bmap"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISREG(inode->i_mode)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%p},{%lx},,,\"",
            "object",
            "page->index"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nint cachefiles_read_or_alloc_page(struct fscache_retrieval *op,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct inode *inode;\n\tsector_t block0, block;\n\tunsigned shift;\n\tint ret;\n\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\t_enter(\"{%p},{%lx},,,\", object, page->index);\n\n\tif (!object->backer)\n\t\tgoto enobufs;\n\n\tinode = object->backer->d_inode;\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT(inode->i_mapping->a_ops->bmap);\n\tASSERT(inode->i_mapping->a_ops->readpages);\n\n\t/* calculate the shift required to use bmap */\n\tif (inode->i_sb->s_blocksize > PAGE_SIZE)\n\t\tgoto enobufs;\n\n\tshift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;\n\n\top->op.flags &= FSCACHE_OP_KEEP_FLAGS;\n\top->op.flags |= FSCACHE_OP_ASYNC;\n\top->op.processor = cachefiles_read_copier;\n\n\t/* we assume the absence or presence of the first block is a good\n\t * enough indication for the page as a whole\n\t * - TODO: don't use bmap() for this as it is _not_ actually good\n\t *   enough for this as it doesn't indicate errors, but it's all we've\n\t *   got for the moment\n\t */\n\tblock0 = page->index;\n\tblock0 <<= shift;\n\n\tblock = inode->i_mapping->a_ops->bmap(inode->i_mapping, block0);\n\t_debug(\"%llx -> %llx\",\n\t       (unsigned long long) block0,\n\t       (unsigned long long) block);\n\n\tif (block) {\n\t\t/* submit the apparently valid page to the backing fs to be\n\t\t * read from disk */\n\t\tret = cachefiles_read_backing_file_one(object, op, page);\n\t} else if (cachefiles_has_space(cache, 0, 1) == 0) {\n\t\t/* there's space in the cache we can use */\n\t\tfscache_mark_page_cached(op, page);\n\t\tfscache_retrieval_complete(op, 1);\n\t\tret = -ENODATA;\n\t} else {\n\t\tgoto enobufs;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nenobufs:\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "cachefiles_read_backing_file_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "226-374",
    "snippet": "static int cachefiles_read_backing_file_one(struct cachefiles_object *object,\n\t\t\t\t\t    struct fscache_retrieval *op,\n\t\t\t\t\t    struct page *netpage)\n{\n\tstruct cachefiles_one_read *monitor;\n\tstruct address_space *bmapping;\n\tstruct page *newpage, *backpage;\n\tint ret;\n\n\t_enter(\"\");\n\n\t_debug(\"read back %p{%lu,%d}\",\n\t       netpage, netpage->index, page_count(netpage));\n\n\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\tif (!monitor)\n\t\tgoto nomem;\n\n\tmonitor->netfs_page = netpage;\n\tmonitor->op = fscache_get_retrieval(op);\n\n\tinit_waitqueue_func_entry(&monitor->monitor, cachefiles_read_waiter);\n\n\t/* attempt to get hold of the backing page */\n\tbmapping = object->backer->d_inode->i_mapping;\n\tnewpage = NULL;\n\n\tfor (;;) {\n\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\tif (backpage)\n\t\t\tgoto backing_page_already_present;\n\n\t\tif (!newpage) {\n\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t     __GFP_COLD);\n\t\t\tif (!newpage)\n\t\t\t\tgoto nomem_monitor;\n\t\t}\n\n\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret == 0)\n\t\t\tgoto installed_new_backing_page;\n\t\tif (ret != -EEXIST)\n\t\t\tgoto nomem_page;\n\t}\n\n\t/* we've installed a new backing page, so now we need to start\n\t * it reading */\ninstalled_new_backing_page:\n\t_debug(\"- new %p\", newpage);\n\n\tbackpage = newpage;\n\tnewpage = NULL;\n\nread_backing_page:\n\tret = bmapping->a_ops->readpage(NULL, backpage);\n\tif (ret < 0)\n\t\tgoto read_error;\n\n\t/* set the monitor to transfer the data across */\nmonitor_backing_page:\n\t_debug(\"- monitor add\");\n\n\t/* install the monitor */\n\tpage_cache_get(monitor->netfs_page);\n\tpage_cache_get(backpage);\n\tmonitor->back_page = backpage;\n\tmonitor->monitor.private = backpage;\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\tmonitor = NULL;\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\tgoto success;\n\n\t/* if the backing page is already present, it can be in one of\n\t * three states: read in progress, read failed or read okay */\nbacking_page_already_present:\n\t_debug(\"- present\");\n\n\tif (newpage) {\n\t\tpage_cache_release(newpage);\n\t\tnewpage = NULL;\n\t}\n\n\tif (PageError(backpage))\n\t\tgoto io_error;\n\n\tif (PageUptodate(backpage))\n\t\tgoto backing_page_already_uptodate;\n\n\tif (!trylock_page(backpage))\n\t\tgoto monitor_backing_page;\n\t_debug(\"read %p {%lx}\", backpage, backpage->flags);\n\tgoto read_backing_page;\n\n\t/* the backing page is already up to date, attach the netfs\n\t * page to the pagecache and LRU and copy the data across */\nbacking_page_already_uptodate:\n\t_debug(\"- uptodate\");\n\n\tfscache_mark_page_cached(op, netpage);\n\n\tcopy_highpage(netpage, backpage);\n\tfscache_end_io(op, netpage, 0);\n\tfscache_retrieval_complete(op, 1);\n\nsuccess:\n\t_debug(\"success\");\n\tret = 0;\n\nout:\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(monitor->op);\n\t\tkfree(monitor);\n\t}\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM) {\n\t\tfscache_retrieval_complete(op, 1);\n\t\tgoto out;\n\t}\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tfscache_retrieval_complete(op, 1);\n\tret = -ENOBUFS;\n\tgoto out;\n\nnomem_page:\n\tpage_cache_release(newpage);\nnomem_monitor:\n\tfscache_put_retrieval(monitor->op);\n\tkfree(monitor);\nnomem:\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "monitor"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "monitor->op"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "newpage"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Page read error on backing file\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"read error %d\"",
            "ret"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "monitor"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "monitor->op"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "backpage"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"success\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_end_io",
          "args": [
            "op",
            "netpage",
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "netpage",
            "backpage"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_page_cached",
          "args": [
            "op",
            "netpage"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_page_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1113-1134",
          "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"read %p {%lx}\"",
            "backpage",
            "backpage->flags"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "backpage"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "backpage"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "backpage"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "newpage"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "backpage"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "backpage"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_wait_queue",
          "args": [
            "backpage",
            "&monitor->monitor"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "backpage"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "monitor->netfs_page"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmapping->a_ops->readpage",
          "args": [
            "NULL",
            "backpage"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "newpage",
            "bmapping",
            "netpage->index",
            "cachefiles_gfp"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "cachefiles_gfp |\n\t\t\t\t\t\t     __GFP_COLD"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "bmapping",
            "netpage->index"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&monitor->monitor",
            "cachefiles_read_waiter"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_get_retrieval",
          "args": [
            "op"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*monitor)",
            "cachefiles_gfp"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "netpage"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_backing_file_one(struct cachefiles_object *object,\n\t\t\t\t\t    struct fscache_retrieval *op,\n\t\t\t\t\t    struct page *netpage)\n{\n\tstruct cachefiles_one_read *monitor;\n\tstruct address_space *bmapping;\n\tstruct page *newpage, *backpage;\n\tint ret;\n\n\t_enter(\"\");\n\n\t_debug(\"read back %p{%lu,%d}\",\n\t       netpage, netpage->index, page_count(netpage));\n\n\tmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\n\tif (!monitor)\n\t\tgoto nomem;\n\n\tmonitor->netfs_page = netpage;\n\tmonitor->op = fscache_get_retrieval(op);\n\n\tinit_waitqueue_func_entry(&monitor->monitor, cachefiles_read_waiter);\n\n\t/* attempt to get hold of the backing page */\n\tbmapping = object->backer->d_inode->i_mapping;\n\tnewpage = NULL;\n\n\tfor (;;) {\n\t\tbackpage = find_get_page(bmapping, netpage->index);\n\t\tif (backpage)\n\t\t\tgoto backing_page_already_present;\n\n\t\tif (!newpage) {\n\t\t\tnewpage = __page_cache_alloc(cachefiles_gfp |\n\t\t\t\t\t\t     __GFP_COLD);\n\t\t\tif (!newpage)\n\t\t\t\tgoto nomem_monitor;\n\t\t}\n\n\t\tret = add_to_page_cache_lru(newpage, bmapping,\n\t\t\t\t\t    netpage->index, cachefiles_gfp);\n\t\tif (ret == 0)\n\t\t\tgoto installed_new_backing_page;\n\t\tif (ret != -EEXIST)\n\t\t\tgoto nomem_page;\n\t}\n\n\t/* we've installed a new backing page, so now we need to start\n\t * it reading */\ninstalled_new_backing_page:\n\t_debug(\"- new %p\", newpage);\n\n\tbackpage = newpage;\n\tnewpage = NULL;\n\nread_backing_page:\n\tret = bmapping->a_ops->readpage(NULL, backpage);\n\tif (ret < 0)\n\t\tgoto read_error;\n\n\t/* set the monitor to transfer the data across */\nmonitor_backing_page:\n\t_debug(\"- monitor add\");\n\n\t/* install the monitor */\n\tpage_cache_get(monitor->netfs_page);\n\tpage_cache_get(backpage);\n\tmonitor->back_page = backpage;\n\tmonitor->monitor.private = backpage;\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\tmonitor = NULL;\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\tgoto success;\n\n\t/* if the backing page is already present, it can be in one of\n\t * three states: read in progress, read failed or read okay */\nbacking_page_already_present:\n\t_debug(\"- present\");\n\n\tif (newpage) {\n\t\tpage_cache_release(newpage);\n\t\tnewpage = NULL;\n\t}\n\n\tif (PageError(backpage))\n\t\tgoto io_error;\n\n\tif (PageUptodate(backpage))\n\t\tgoto backing_page_already_uptodate;\n\n\tif (!trylock_page(backpage))\n\t\tgoto monitor_backing_page;\n\t_debug(\"read %p {%lx}\", backpage, backpage->flags);\n\tgoto read_backing_page;\n\n\t/* the backing page is already up to date, attach the netfs\n\t * page to the pagecache and LRU and copy the data across */\nbacking_page_already_uptodate:\n\t_debug(\"- uptodate\");\n\n\tfscache_mark_page_cached(op, netpage);\n\n\tcopy_highpage(netpage, backpage);\n\tfscache_end_io(op, netpage, 0);\n\tfscache_retrieval_complete(op, 1);\n\nsuccess:\n\t_debug(\"success\");\n\tret = 0;\n\nout:\n\tif (backpage)\n\t\tpage_cache_release(backpage);\n\tif (monitor) {\n\t\tfscache_put_retrieval(monitor->op);\n\t\tkfree(monitor);\n\t}\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nread_error:\n\t_debug(\"read error %d\", ret);\n\tif (ret == -ENOMEM) {\n\t\tfscache_retrieval_complete(op, 1);\n\t\tgoto out;\n\t}\nio_error:\n\tcachefiles_io_error_obj(object, \"Page read error on backing file\");\n\tfscache_retrieval_complete(op, 1);\n\tret = -ENOBUFS;\n\tgoto out;\n\nnomem_page:\n\tpage_cache_release(newpage);\nnomem_monitor:\n\tfscache_put_retrieval(monitor->op);\n\tkfree(monitor);\nnomem:\n\tfscache_retrieval_complete(op, 1);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "cachefiles_read_copier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "149-220",
    "snippet": "static void cachefiles_read_copier(struct fscache_operation *_op)\n{\n\tstruct cachefiles_one_read *monitor;\n\tstruct cachefiles_object *object;\n\tstruct fscache_retrieval *op;\n\tint error, max;\n\n\top = container_of(_op, struct fscache_retrieval, op);\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\n\t_enter(\"{ino=%lu}\", object->backer->d_inode->i_ino);\n\n\tmax = 8;\n\tspin_lock_irq(&object->work_lock);\n\n\twhile (!list_empty(&op->to_do)) {\n\t\tmonitor = list_entry(op->to_do.next,\n\t\t\t\t     struct cachefiles_one_read, op_link);\n\t\tlist_del(&monitor->op_link);\n\n\t\tspin_unlock_irq(&object->work_lock);\n\n\t\t_debug(\"- copy {%lu}\", monitor->back_page->index);\n\n\trecheck:\n\t\tif (test_bit(FSCACHE_COOKIE_INVALIDATING,\n\t\t\t     &object->fscache.cookie->flags)) {\n\t\t\terror = -ESTALE;\n\t\t} else if (PageUptodate(monitor->back_page)) {\n\t\t\tcopy_highpage(monitor->netfs_page, monitor->back_page);\n\t\t\tfscache_mark_page_cached(monitor->op,\n\t\t\t\t\t\t monitor->netfs_page);\n\t\t\terror = 0;\n\t\t} else if (!PageError(monitor->back_page)) {\n\t\t\t/* the page has probably been truncated */\n\t\t\terror = cachefiles_read_reissue(object, monitor);\n\t\t\tif (error == -EINPROGRESS)\n\t\t\t\tgoto next;\n\t\t\tgoto recheck;\n\t\t} else {\n\t\t\tcachefiles_io_error_obj(\n\t\t\t\tobject,\n\t\t\t\t\"Readpage failed on backing file %lx\",\n\t\t\t\t(unsigned long) monitor->back_page->flags);\n\t\t\terror = -EIO;\n\t\t}\n\n\t\tpage_cache_release(monitor->back_page);\n\n\t\tfscache_end_io(op, monitor->netfs_page, error);\n\t\tpage_cache_release(monitor->netfs_page);\n\t\tfscache_retrieval_complete(op, 1);\n\t\tfscache_put_retrieval(op);\n\t\tkfree(monitor);\n\n\tnext:\n\t\t/* let the thread pool have some air occasionally */\n\t\tmax--;\n\t\tif (max < 0 || need_resched()) {\n\t\t\tif (!list_empty(&op->to_do))\n\t\t\t\tfscache_enqueue_retrieval(op);\n\t\t\t_leave(\" [maxed out]\");\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irq(&object->work_lock);\n\t}\n\n\tspin_unlock_irq(&object->work_lock);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&object->work_lock"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&object->work_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_enqueue_retrieval",
          "args": [
            "op"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->to_do"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "monitor"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "op"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_retrieval_complete",
          "args": [
            "op",
            "1"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "monitor->netfs_page"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_end_io",
          "args": [
            "op",
            "monitor->netfs_page",
            "error"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "monitor->back_page"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Readpage failed on backing file %lx\"",
            "(unsigned long) monitor->back_page->flags"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_read_reissue",
          "args": [
            "object",
            "monitor"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_read_reissue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
          "lines": "74-143",
          "snippet": "static int cachefiles_read_reissue(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_one_read *monitor)\n{\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *backpage = monitor->back_page, *backpage2;\n\tint ret;\n\n\t_enter(\"{ino=%lx},{%lx,%lx}\",\n\t       object->backer->d_inode->i_ino,\n\t       backpage->index, backpage->flags);\n\n\t/* skip if the page was truncated away completely */\n\tif (backpage->mapping != bmapping) {\n\t\t_leave(\" = -ENODATA [mapping]\");\n\t\treturn -ENODATA;\n\t}\n\n\tbackpage2 = find_get_page(bmapping, backpage->index);\n\tif (!backpage2) {\n\t\t_leave(\" = -ENODATA [gone]\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (backpage != backpage2) {\n\t\tput_page(backpage2);\n\t\t_leave(\" = -ENODATA [different]\");\n\t\treturn -ENODATA;\n\t}\n\n\t/* the page is still there and we already have a ref on it, so we don't\n\t * need a second */\n\tput_page(backpage2);\n\n\tINIT_LIST_HEAD(&monitor->op_link);\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\n\tif (trylock_page(backpage)) {\n\t\tret = -EIO;\n\t\tif (PageError(backpage))\n\t\t\tgoto unlock_discard;\n\t\tret = 0;\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto unlock_discard;\n\n\t\t_debug(\"reissue read\");\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_discard;\n\t}\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\n\t/* it'll reappear on the todo list */\n\t_leave(\" = -EINPROGRESS\");\n\treturn -EINPROGRESS;\n\nunlock_discard:\n\tunlock_page(backpage);\n\tspin_lock_irq(&object->work_lock);\n\tlist_del(&monitor->op_link);\n\tspin_unlock_irq(&object->work_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_reissue(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_one_read *monitor)\n{\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *backpage = monitor->back_page, *backpage2;\n\tint ret;\n\n\t_enter(\"{ino=%lx},{%lx,%lx}\",\n\t       object->backer->d_inode->i_ino,\n\t       backpage->index, backpage->flags);\n\n\t/* skip if the page was truncated away completely */\n\tif (backpage->mapping != bmapping) {\n\t\t_leave(\" = -ENODATA [mapping]\");\n\t\treturn -ENODATA;\n\t}\n\n\tbackpage2 = find_get_page(bmapping, backpage->index);\n\tif (!backpage2) {\n\t\t_leave(\" = -ENODATA [gone]\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (backpage != backpage2) {\n\t\tput_page(backpage2);\n\t\t_leave(\" = -ENODATA [different]\");\n\t\treturn -ENODATA;\n\t}\n\n\t/* the page is still there and we already have a ref on it, so we don't\n\t * need a second */\n\tput_page(backpage2);\n\n\tINIT_LIST_HEAD(&monitor->op_link);\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\n\tif (trylock_page(backpage)) {\n\t\tret = -EIO;\n\t\tif (PageError(backpage))\n\t\t\tgoto unlock_discard;\n\t\tret = 0;\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto unlock_discard;\n\n\t\t_debug(\"reissue read\");\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_discard;\n\t}\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\n\t/* it'll reappear on the todo list */\n\t_leave(\" = -EINPROGRESS\");\n\treturn -EINPROGRESS;\n\nunlock_discard:\n\tunlock_page(backpage);\n\tspin_lock_irq(&object->work_lock);\n\tlist_del(&monitor->op_link);\n\tspin_unlock_irq(&object->work_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "monitor->back_page"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_page_cached",
          "args": [
            "monitor->op",
            "monitor->netfs_page"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_page_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1113-1134",
          "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "monitor->netfs_page",
            "monitor->back_page"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "monitor->back_page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_INVALIDATING",
            "&object->fscache.cookie->flags"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"- copy {%lu}\"",
            "monitor->back_page->index"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&object->work_lock"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&monitor->op_link"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "op->to_do.next",
            "structcachefiles_one_read",
            "op_link"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&object->work_lock"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{ino=%lu}\"",
            "object->backer->d_inode->i_ino"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_op",
            "structfscache_retrieval",
            "op"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic void cachefiles_read_copier(struct fscache_operation *_op)\n{\n\tstruct cachefiles_one_read *monitor;\n\tstruct cachefiles_object *object;\n\tstruct fscache_retrieval *op;\n\tint error, max;\n\n\top = container_of(_op, struct fscache_retrieval, op);\n\tobject = container_of(op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\n\t_enter(\"{ino=%lu}\", object->backer->d_inode->i_ino);\n\n\tmax = 8;\n\tspin_lock_irq(&object->work_lock);\n\n\twhile (!list_empty(&op->to_do)) {\n\t\tmonitor = list_entry(op->to_do.next,\n\t\t\t\t     struct cachefiles_one_read, op_link);\n\t\tlist_del(&monitor->op_link);\n\n\t\tspin_unlock_irq(&object->work_lock);\n\n\t\t_debug(\"- copy {%lu}\", monitor->back_page->index);\n\n\trecheck:\n\t\tif (test_bit(FSCACHE_COOKIE_INVALIDATING,\n\t\t\t     &object->fscache.cookie->flags)) {\n\t\t\terror = -ESTALE;\n\t\t} else if (PageUptodate(monitor->back_page)) {\n\t\t\tcopy_highpage(monitor->netfs_page, monitor->back_page);\n\t\t\tfscache_mark_page_cached(monitor->op,\n\t\t\t\t\t\t monitor->netfs_page);\n\t\t\terror = 0;\n\t\t} else if (!PageError(monitor->back_page)) {\n\t\t\t/* the page has probably been truncated */\n\t\t\terror = cachefiles_read_reissue(object, monitor);\n\t\t\tif (error == -EINPROGRESS)\n\t\t\t\tgoto next;\n\t\t\tgoto recheck;\n\t\t} else {\n\t\t\tcachefiles_io_error_obj(\n\t\t\t\tobject,\n\t\t\t\t\"Readpage failed on backing file %lx\",\n\t\t\t\t(unsigned long) monitor->back_page->flags);\n\t\t\terror = -EIO;\n\t\t}\n\n\t\tpage_cache_release(monitor->back_page);\n\n\t\tfscache_end_io(op, monitor->netfs_page, error);\n\t\tpage_cache_release(monitor->netfs_page);\n\t\tfscache_retrieval_complete(op, 1);\n\t\tfscache_put_retrieval(op);\n\t\tkfree(monitor);\n\n\tnext:\n\t\t/* let the thread pool have some air occasionally */\n\t\tmax--;\n\t\tif (max < 0 || need_resched()) {\n\t\t\tif (!list_empty(&op->to_do))\n\t\t\t\tfscache_enqueue_retrieval(op);\n\t\t\t_leave(\" [maxed out]\");\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irq(&object->work_lock);\n\t}\n\n\tspin_unlock_irq(&object->work_lock);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "cachefiles_read_reissue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "74-143",
    "snippet": "static int cachefiles_read_reissue(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_one_read *monitor)\n{\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *backpage = monitor->back_page, *backpage2;\n\tint ret;\n\n\t_enter(\"{ino=%lx},{%lx,%lx}\",\n\t       object->backer->d_inode->i_ino,\n\t       backpage->index, backpage->flags);\n\n\t/* skip if the page was truncated away completely */\n\tif (backpage->mapping != bmapping) {\n\t\t_leave(\" = -ENODATA [mapping]\");\n\t\treturn -ENODATA;\n\t}\n\n\tbackpage2 = find_get_page(bmapping, backpage->index);\n\tif (!backpage2) {\n\t\t_leave(\" = -ENODATA [gone]\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (backpage != backpage2) {\n\t\tput_page(backpage2);\n\t\t_leave(\" = -ENODATA [different]\");\n\t\treturn -ENODATA;\n\t}\n\n\t/* the page is still there and we already have a ref on it, so we don't\n\t * need a second */\n\tput_page(backpage2);\n\n\tINIT_LIST_HEAD(&monitor->op_link);\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\n\tif (trylock_page(backpage)) {\n\t\tret = -EIO;\n\t\tif (PageError(backpage))\n\t\t\tgoto unlock_discard;\n\t\tret = 0;\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto unlock_discard;\n\n\t\t_debug(\"reissue read\");\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_discard;\n\t}\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\n\t/* it'll reappear on the todo list */\n\t_leave(\" = -EINPROGRESS\");\n\treturn -EINPROGRESS;\n\nunlock_discard:\n\tunlock_page(backpage);\n\tspin_lock_irq(&object->work_lock);\n\tlist_del(&monitor->op_link);\n\tspin_unlock_irq(&object->work_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&object->work_lock"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&monitor->op_link"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&object->work_lock"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "backpage"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -EINPROGRESS\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"jumpstart %p {%lx}\"",
            "backpage",
            "backpage->flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "backpage"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmapping->a_ops->readpage",
          "args": [
            "NULL",
            "backpage"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"reissue read\""
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "backpage"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "backpage"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "backpage"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_wait_queue",
          "args": [
            "backpage",
            "&monitor->monitor"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&monitor->op_link"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "backpage2"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "bmapping",
            "backpage->index"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{ino=%lx},{%lx,%lx}\"",
            "object->backer->d_inode->i_ino",
            "backpage->index",
            "backpage->flags"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_reissue(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_one_read *monitor)\n{\n\tstruct address_space *bmapping = object->backer->d_inode->i_mapping;\n\tstruct page *backpage = monitor->back_page, *backpage2;\n\tint ret;\n\n\t_enter(\"{ino=%lx},{%lx,%lx}\",\n\t       object->backer->d_inode->i_ino,\n\t       backpage->index, backpage->flags);\n\n\t/* skip if the page was truncated away completely */\n\tif (backpage->mapping != bmapping) {\n\t\t_leave(\" = -ENODATA [mapping]\");\n\t\treturn -ENODATA;\n\t}\n\n\tbackpage2 = find_get_page(bmapping, backpage->index);\n\tif (!backpage2) {\n\t\t_leave(\" = -ENODATA [gone]\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (backpage != backpage2) {\n\t\tput_page(backpage2);\n\t\t_leave(\" = -ENODATA [different]\");\n\t\treturn -ENODATA;\n\t}\n\n\t/* the page is still there and we already have a ref on it, so we don't\n\t * need a second */\n\tput_page(backpage2);\n\n\tINIT_LIST_HEAD(&monitor->op_link);\n\tadd_page_wait_queue(backpage, &monitor->monitor);\n\n\tif (trylock_page(backpage)) {\n\t\tret = -EIO;\n\t\tif (PageError(backpage))\n\t\t\tgoto unlock_discard;\n\t\tret = 0;\n\t\tif (PageUptodate(backpage))\n\t\t\tgoto unlock_discard;\n\n\t\t_debug(\"reissue read\");\n\t\tret = bmapping->a_ops->readpage(NULL, backpage);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_discard;\n\t}\n\n\t/* but the page may have been read before the monitor was installed, so\n\t * the monitor may miss the event - so we have to ensure that we do get\n\t * one in such a case */\n\tif (trylock_page(backpage)) {\n\t\t_debug(\"jumpstart %p {%lx}\", backpage, backpage->flags);\n\t\tunlock_page(backpage);\n\t}\n\n\t/* it'll reappear on the todo list */\n\t_leave(\" = -EINPROGRESS\");\n\treturn -EINPROGRESS;\n\nunlock_discard:\n\tunlock_page(backpage);\n\tspin_lock_irq(&object->work_lock);\n\tlist_del(&monitor->op_link);\n\tspin_unlock_irq(&object->work_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_read_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/rdwr.c",
    "lines": "24-65",
    "snippet": "static int cachefiles_read_waiter(wait_queue_t *wait, unsigned mode,\n\t\t\t\t  int sync, void *_key)\n{\n\tstruct cachefiles_one_read *monitor =\n\t\tcontainer_of(wait, struct cachefiles_one_read, monitor);\n\tstruct cachefiles_object *object;\n\tstruct wait_bit_key *key = _key;\n\tstruct page *page = wait->private;\n\n\tASSERT(key);\n\n\t_enter(\"{%lu},%u,%d,{%p,%u}\",\n\t       monitor->netfs_page->index, mode, sync,\n\t       key->flags, key->bit_nr);\n\n\tif (key->flags != &page->flags ||\n\t    key->bit_nr != PG_locked)\n\t\treturn 0;\n\n\t_debug(\"--- monitor %p %lx ---\", page, page->flags);\n\n\tif (!PageUptodate(page) && !PageError(page)) {\n\t\t/* unlocked, not uptodate and not erronous? */\n\t\t_debug(\"page probably truncated\");\n\t}\n\n\t/* remove from the waitqueue */\n\tlist_del(&wait->task_list);\n\n\t/* move onto the action list and queue for FS-Cache thread pool */\n\tASSERT(monitor->op);\n\n\tobject = container_of(monitor->op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\n\tspin_lock(&object->work_lock);\n\tlist_add_tail(&monitor->op_link, &monitor->op->to_do);\n\tspin_unlock(&object->work_lock);\n\n\tfscache_enqueue_retrieval(monitor->op);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swap.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_enqueue_retrieval",
          "args": [
            "monitor->op"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->work_lock"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&monitor->op_link",
            "&monitor->op->to_do"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->work_lock"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "monitor->op->op.object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "monitor->op"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&wait->task_list"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"page probably truncated\""
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"--- monitor %p %lx ---\"",
            "page",
            "page->flags"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu},%u,%d,{%p,%u}\"",
            "monitor->netfs_page->index",
            "mode",
            "sync",
            "key->flags",
            "key->bit_nr"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "key"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structcachefiles_one_read",
            "monitor"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n\nstatic int cachefiles_read_waiter(wait_queue_t *wait, unsigned mode,\n\t\t\t\t  int sync, void *_key)\n{\n\tstruct cachefiles_one_read *monitor =\n\t\tcontainer_of(wait, struct cachefiles_one_read, monitor);\n\tstruct cachefiles_object *object;\n\tstruct wait_bit_key *key = _key;\n\tstruct page *page = wait->private;\n\n\tASSERT(key);\n\n\t_enter(\"{%lu},%u,%d,{%p,%u}\",\n\t       monitor->netfs_page->index, mode, sync,\n\t       key->flags, key->bit_nr);\n\n\tif (key->flags != &page->flags ||\n\t    key->bit_nr != PG_locked)\n\t\treturn 0;\n\n\t_debug(\"--- monitor %p %lx ---\", page, page->flags);\n\n\tif (!PageUptodate(page) && !PageError(page)) {\n\t\t/* unlocked, not uptodate and not erronous? */\n\t\t_debug(\"page probably truncated\");\n\t}\n\n\t/* remove from the waitqueue */\n\tlist_del(&wait->task_list);\n\n\t/* move onto the action list and queue for FS-Cache thread pool */\n\tASSERT(monitor->op);\n\n\tobject = container_of(monitor->op->op.object,\n\t\t\t      struct cachefiles_object, fscache);\n\n\tspin_lock(&object->work_lock);\n\tlist_add_tail(&monitor->op_link, &monitor->op->to_do);\n\tspin_unlock(&object->work_lock);\n\n\tfscache_enqueue_retrieval(monitor->op);\n\treturn 0;\n}"
  }
]