[
  {
    "function_name": "ocfs2_test_inode_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2864-2917",
    "snippet": "int ocfs2_test_inode_bit(struct ocfs2_super *osb, u64 blkno, int *res)\n{\n\tint status;\n\tu64 group_blkno = 0;\n\tu16 suballoc_bit = 0, suballoc_slot = 0;\n\tstruct inode *inode_alloc_inode;\n\tstruct buffer_head *alloc_bh = NULL;\n\n\ttrace_ocfs2_test_inode_bit((unsigned long long)blkno);\n\n\tstatus = ocfs2_get_suballoc_slot_bit(osb, blkno, &suballoc_slot,\n\t\t\t\t\t     &group_blkno, &suballoc_bit);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"get alloc slot and bit failed %d\\n\", status);\n\t\tgoto bail;\n\t}\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    suballoc_slot);\n\tif (!inode_alloc_inode) {\n\t\t/* the error code could be inaccurate, but we are not able to\n\t\t * get the correct one. */\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"unable to get alloc inode in slot %u\\n\",\n\t\t     (u32)suballoc_slot);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &alloc_bh, 0);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\t\tiput(inode_alloc_inode);\n\t\tmlog(ML_ERROR, \"lock on alloc inode on slot %u failed %d\\n\",\n\t\t     (u32)suballoc_slot, status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_test_suballoc_bit(osb, inode_alloc_inode, alloc_bh,\n\t\t\t\t\t group_blkno, blkno, suballoc_bit, res);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"test suballoc bit failed %d\\n\", status);\n\n\tocfs2_inode_unlock(inode_alloc_inode, 0);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\tiput(inode_alloc_inode);\n\tbrelse(alloc_bh);\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "alloc_bh"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode_alloc_inode"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode_alloc_inode->i_mutex"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode_alloc_inode",
            "0"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"test suballoc bit failed %d\\n\"",
            "status"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_suballoc_bit",
          "args": [
            "osb",
            "inode_alloc_inode",
            "alloc_bh",
            "group_blkno",
            "blkno",
            "suballoc_bit",
            "res"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_suballoc_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2806-2849",
          "snippet": "static int ocfs2_test_suballoc_bit(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *suballoc,\n\t\t\t\t   struct buffer_head *alloc_bh,\n\t\t\t\t   u64 group_blkno, u64 blkno,\n\t\t\t\t   u16 bit, int *res)\n{\n\tstruct ocfs2_dinode *alloc_di;\n\tstruct ocfs2_group_desc *group;\n\tstruct buffer_head *group_bh = NULL;\n\tu64 bg_blkno;\n\tint status;\n\n\ttrace_ocfs2_test_suballoc_bit((unsigned long long)blkno,\n\t\t\t\t      (unsigned int)bit);\n\n\talloc_di = (struct ocfs2_dinode *)alloc_bh->b_data;\n\tif ((bit + 1) > ocfs2_bits_per_group(&alloc_di->id2.i_chain)) {\n\t\tmlog(ML_ERROR, \"suballoc bit %u out of range of %u\\n\",\n\t\t     (unsigned int)bit,\n\t\t     ocfs2_bits_per_group(&alloc_di->id2.i_chain));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tbg_blkno = group_blkno ? group_blkno :\n\t\t   ocfs2_which_suballoc_group(blkno, bit);\n\tstatus = ocfs2_read_group_descriptor(suballoc, alloc_di, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read group %llu failed %d\\n\",\n\t\t     (unsigned long long)bg_blkno, status);\n\t\tgoto bail;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\t*res = ocfs2_test_bit(bit, (unsigned long *)group->bg_bitmap);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_test_suballoc_bit(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *suballoc,\n\t\t\t\t   struct buffer_head *alloc_bh,\n\t\t\t\t   u64 group_blkno, u64 blkno,\n\t\t\t\t   u16 bit, int *res)\n{\n\tstruct ocfs2_dinode *alloc_di;\n\tstruct ocfs2_group_desc *group;\n\tstruct buffer_head *group_bh = NULL;\n\tu64 bg_blkno;\n\tint status;\n\n\ttrace_ocfs2_test_suballoc_bit((unsigned long long)blkno,\n\t\t\t\t      (unsigned int)bit);\n\n\talloc_di = (struct ocfs2_dinode *)alloc_bh->b_data;\n\tif ((bit + 1) > ocfs2_bits_per_group(&alloc_di->id2.i_chain)) {\n\t\tmlog(ML_ERROR, \"suballoc bit %u out of range of %u\\n\",\n\t\t     (unsigned int)bit,\n\t\t     ocfs2_bits_per_group(&alloc_di->id2.i_chain));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tbg_blkno = group_blkno ? group_blkno :\n\t\t   ocfs2_which_suballoc_group(blkno, bit);\n\tstatus = ocfs2_read_group_descriptor(suballoc, alloc_di, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read group %llu failed %d\\n\",\n\t\t     (unsigned long long)bg_blkno, status);\n\t\tgoto bail;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\t*res = ocfs2_test_bit(bit, (unsigned long *)group->bg_bitmap);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lock on alloc inode on slot %u failed %d\\n\"",
            "(u32)suballoc_slot",
            "status"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode_alloc_inode->i_mutex"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode_alloc_inode",
            "&alloc_bh",
            "0"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode_alloc_inode->i_mutex"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "INODE_ALLOC_SYSTEM_INODE",
            "suballoc_slot"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_suballoc_slot_bit",
          "args": [
            "osb",
            "blkno",
            "&suballoc_slot",
            "&group_blkno",
            "&suballoc_bit"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_suballoc_slot_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2749-2797",
          "snippet": "static int ocfs2_get_suballoc_slot_bit(struct ocfs2_super *osb, u64 blkno,\n\t\t\t\t       u16 *suballoc_slot, u64 *group_blkno,\n\t\t\t\t       u16 *suballoc_bit)\n{\n\tint status;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct ocfs2_dinode *inode_fe;\n\n\ttrace_ocfs2_get_suballoc_slot_bit((unsigned long long)blkno);\n\n\t/* dirty read disk */\n\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &inode_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read block %llu failed %d\\n\",\n\t\t     (unsigned long long)blkno, status);\n\t\tgoto bail;\n\t}\n\n\tinode_fe = (struct ocfs2_dinode *) inode_bh->b_data;\n\tif (!OCFS2_IS_VALID_DINODE(inode_fe)) {\n\t\tmlog(ML_ERROR, \"invalid inode %llu requested\\n\",\n\t\t     (unsigned long long)blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (le16_to_cpu(inode_fe->i_suballoc_slot) != (u16)OCFS2_INVALID_SLOT &&\n\t    (u32)le16_to_cpu(inode_fe->i_suballoc_slot) > osb->max_slots - 1) {\n\t\tmlog(ML_ERROR, \"inode %llu has invalid suballoc slot %u\\n\",\n\t\t     (unsigned long long)blkno,\n\t\t     (u32)le16_to_cpu(inode_fe->i_suballoc_slot));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (suballoc_slot)\n\t\t*suballoc_slot = le16_to_cpu(inode_fe->i_suballoc_slot);\n\tif (suballoc_bit)\n\t\t*suballoc_bit = le16_to_cpu(inode_fe->i_suballoc_bit);\n\tif (group_blkno)\n\t\t*group_blkno = le64_to_cpu(inode_fe->i_suballoc_loc);\n\nbail:\n\tbrelse(inode_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_suballoc_slot_bit(struct ocfs2_super *osb, u64 blkno,\n\t\t\t\t       u16 *suballoc_slot, u64 *group_blkno,\n\t\t\t\t       u16 *suballoc_bit)\n{\n\tint status;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct ocfs2_dinode *inode_fe;\n\n\ttrace_ocfs2_get_suballoc_slot_bit((unsigned long long)blkno);\n\n\t/* dirty read disk */\n\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &inode_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read block %llu failed %d\\n\",\n\t\t     (unsigned long long)blkno, status);\n\t\tgoto bail;\n\t}\n\n\tinode_fe = (struct ocfs2_dinode *) inode_bh->b_data;\n\tif (!OCFS2_IS_VALID_DINODE(inode_fe)) {\n\t\tmlog(ML_ERROR, \"invalid inode %llu requested\\n\",\n\t\t     (unsigned long long)blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (le16_to_cpu(inode_fe->i_suballoc_slot) != (u16)OCFS2_INVALID_SLOT &&\n\t    (u32)le16_to_cpu(inode_fe->i_suballoc_slot) > osb->max_slots - 1) {\n\t\tmlog(ML_ERROR, \"inode %llu has invalid suballoc slot %u\\n\",\n\t\t     (unsigned long long)blkno,\n\t\t     (u32)le16_to_cpu(inode_fe->i_suballoc_slot));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (suballoc_slot)\n\t\t*suballoc_slot = le16_to_cpu(inode_fe->i_suballoc_slot);\n\tif (suballoc_bit)\n\t\t*suballoc_bit = le16_to_cpu(inode_fe->i_suballoc_bit);\n\tif (group_blkno)\n\t\t*group_blkno = le64_to_cpu(inode_fe->i_suballoc_loc);\n\nbail:\n\tbrelse(inode_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_test_inode_bit",
          "args": [
            "(unsigned long long)blkno"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nint ocfs2_test_inode_bit(struct ocfs2_super *osb, u64 blkno, int *res)\n{\n\tint status;\n\tu64 group_blkno = 0;\n\tu16 suballoc_bit = 0, suballoc_slot = 0;\n\tstruct inode *inode_alloc_inode;\n\tstruct buffer_head *alloc_bh = NULL;\n\n\ttrace_ocfs2_test_inode_bit((unsigned long long)blkno);\n\n\tstatus = ocfs2_get_suballoc_slot_bit(osb, blkno, &suballoc_slot,\n\t\t\t\t\t     &group_blkno, &suballoc_bit);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"get alloc slot and bit failed %d\\n\", status);\n\t\tgoto bail;\n\t}\n\n\tinode_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb, INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    suballoc_slot);\n\tif (!inode_alloc_inode) {\n\t\t/* the error code could be inaccurate, but we are not able to\n\t\t * get the correct one. */\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"unable to get alloc inode in slot %u\\n\",\n\t\t     (u32)suballoc_slot);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode_alloc_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(inode_alloc_inode, &alloc_bh, 0);\n\tif (status < 0) {\n\t\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\t\tiput(inode_alloc_inode);\n\t\tmlog(ML_ERROR, \"lock on alloc inode on slot %u failed %d\\n\",\n\t\t     (u32)suballoc_slot, status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_test_suballoc_bit(osb, inode_alloc_inode, alloc_bh,\n\t\t\t\t\t group_blkno, blkno, suballoc_bit, res);\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"test suballoc bit failed %d\\n\", status);\n\n\tocfs2_inode_unlock(inode_alloc_inode, 0);\n\tmutex_unlock(&inode_alloc_inode->i_mutex);\n\n\tiput(inode_alloc_inode);\n\tbrelse(alloc_bh);\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_test_suballoc_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2806-2849",
    "snippet": "static int ocfs2_test_suballoc_bit(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *suballoc,\n\t\t\t\t   struct buffer_head *alloc_bh,\n\t\t\t\t   u64 group_blkno, u64 blkno,\n\t\t\t\t   u16 bit, int *res)\n{\n\tstruct ocfs2_dinode *alloc_di;\n\tstruct ocfs2_group_desc *group;\n\tstruct buffer_head *group_bh = NULL;\n\tu64 bg_blkno;\n\tint status;\n\n\ttrace_ocfs2_test_suballoc_bit((unsigned long long)blkno,\n\t\t\t\t      (unsigned int)bit);\n\n\talloc_di = (struct ocfs2_dinode *)alloc_bh->b_data;\n\tif ((bit + 1) > ocfs2_bits_per_group(&alloc_di->id2.i_chain)) {\n\t\tmlog(ML_ERROR, \"suballoc bit %u out of range of %u\\n\",\n\t\t     (unsigned int)bit,\n\t\t     ocfs2_bits_per_group(&alloc_di->id2.i_chain));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tbg_blkno = group_blkno ? group_blkno :\n\t\t   ocfs2_which_suballoc_group(blkno, bit);\n\tstatus = ocfs2_read_group_descriptor(suballoc, alloc_di, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read group %llu failed %d\\n\",\n\t\t     (unsigned long long)bg_blkno, status);\n\t\tgoto bail;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\t*res = ocfs2_test_bit(bit, (unsigned long *)group->bg_bitmap);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "group_bh"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "bit",
            "(unsigned long *)group->bg_bitmap"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"read group %llu failed %d\\n\"",
            "(unsigned long long)bg_blkno",
            "status"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "suballoc",
            "alloc_di",
            "bg_blkno",
            "&group_bh"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "blkno",
            "bit"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bits_per_group",
          "args": [
            "&alloc_di->id2.i_chain"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bits_per_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "164-167",
          "snippet": "static u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_test_suballoc_bit",
          "args": [
            "(unsigned long long)blkno",
            "(unsigned int)bit"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_test_suballoc_bit(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *suballoc,\n\t\t\t\t   struct buffer_head *alloc_bh,\n\t\t\t\t   u64 group_blkno, u64 blkno,\n\t\t\t\t   u16 bit, int *res)\n{\n\tstruct ocfs2_dinode *alloc_di;\n\tstruct ocfs2_group_desc *group;\n\tstruct buffer_head *group_bh = NULL;\n\tu64 bg_blkno;\n\tint status;\n\n\ttrace_ocfs2_test_suballoc_bit((unsigned long long)blkno,\n\t\t\t\t      (unsigned int)bit);\n\n\talloc_di = (struct ocfs2_dinode *)alloc_bh->b_data;\n\tif ((bit + 1) > ocfs2_bits_per_group(&alloc_di->id2.i_chain)) {\n\t\tmlog(ML_ERROR, \"suballoc bit %u out of range of %u\\n\",\n\t\t     (unsigned int)bit,\n\t\t     ocfs2_bits_per_group(&alloc_di->id2.i_chain));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tbg_blkno = group_blkno ? group_blkno :\n\t\t   ocfs2_which_suballoc_group(blkno, bit);\n\tstatus = ocfs2_read_group_descriptor(suballoc, alloc_di, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read group %llu failed %d\\n\",\n\t\t     (unsigned long long)bg_blkno, status);\n\t\tgoto bail;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\t*res = ocfs2_test_bit(bit, (unsigned long *)group->bg_bitmap);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_suballoc_slot_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2749-2797",
    "snippet": "static int ocfs2_get_suballoc_slot_bit(struct ocfs2_super *osb, u64 blkno,\n\t\t\t\t       u16 *suballoc_slot, u64 *group_blkno,\n\t\t\t\t       u16 *suballoc_bit)\n{\n\tint status;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct ocfs2_dinode *inode_fe;\n\n\ttrace_ocfs2_get_suballoc_slot_bit((unsigned long long)blkno);\n\n\t/* dirty read disk */\n\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &inode_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read block %llu failed %d\\n\",\n\t\t     (unsigned long long)blkno, status);\n\t\tgoto bail;\n\t}\n\n\tinode_fe = (struct ocfs2_dinode *) inode_bh->b_data;\n\tif (!OCFS2_IS_VALID_DINODE(inode_fe)) {\n\t\tmlog(ML_ERROR, \"invalid inode %llu requested\\n\",\n\t\t     (unsigned long long)blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (le16_to_cpu(inode_fe->i_suballoc_slot) != (u16)OCFS2_INVALID_SLOT &&\n\t    (u32)le16_to_cpu(inode_fe->i_suballoc_slot) > osb->max_slots - 1) {\n\t\tmlog(ML_ERROR, \"inode %llu has invalid suballoc slot %u\\n\",\n\t\t     (unsigned long long)blkno,\n\t\t     (u32)le16_to_cpu(inode_fe->i_suballoc_slot));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (suballoc_slot)\n\t\t*suballoc_slot = le16_to_cpu(inode_fe->i_suballoc_slot);\n\tif (suballoc_bit)\n\t\t*suballoc_bit = le16_to_cpu(inode_fe->i_suballoc_bit);\n\tif (group_blkno)\n\t\t*group_blkno = le64_to_cpu(inode_fe->i_suballoc_loc);\n\nbail:\n\tbrelse(inode_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "inode_bh"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "inode_fe->i_suballoc_loc"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "inode_fe->i_suballoc_bit"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"inode %llu has invalid suballoc slot %u\\n\"",
            "(unsigned long long)blkno",
            "(u32)le16_to_cpu(inode_fe->i_suballoc_slot)"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"invalid inode %llu requested\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "inode_fe"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "blkno",
            "1",
            "&inode_bh"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_get_suballoc_slot_bit",
          "args": [
            "(unsigned long long)blkno"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_suballoc_slot_bit(struct ocfs2_super *osb, u64 blkno,\n\t\t\t\t       u16 *suballoc_slot, u64 *group_blkno,\n\t\t\t\t       u16 *suballoc_bit)\n{\n\tint status;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct ocfs2_dinode *inode_fe;\n\n\ttrace_ocfs2_get_suballoc_slot_bit((unsigned long long)blkno);\n\n\t/* dirty read disk */\n\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &inode_bh);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"read block %llu failed %d\\n\",\n\t\t     (unsigned long long)blkno, status);\n\t\tgoto bail;\n\t}\n\n\tinode_fe = (struct ocfs2_dinode *) inode_bh->b_data;\n\tif (!OCFS2_IS_VALID_DINODE(inode_fe)) {\n\t\tmlog(ML_ERROR, \"invalid inode %llu requested\\n\",\n\t\t     (unsigned long long)blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (le16_to_cpu(inode_fe->i_suballoc_slot) != (u16)OCFS2_INVALID_SLOT &&\n\t    (u32)le16_to_cpu(inode_fe->i_suballoc_slot) > osb->max_slots - 1) {\n\t\tmlog(ML_ERROR, \"inode %llu has invalid suballoc slot %u\\n\",\n\t\t     (unsigned long long)blkno,\n\t\t     (u32)le16_to_cpu(inode_fe->i_suballoc_slot));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (suballoc_slot)\n\t\t*suballoc_slot = le16_to_cpu(inode_fe->i_suballoc_slot);\n\tif (suballoc_bit)\n\t\t*suballoc_bit = le16_to_cpu(inode_fe->i_suballoc_bit);\n\tif (group_blkno)\n\t\t*group_blkno = le64_to_cpu(inode_fe->i_suballoc_loc);\n\nbail:\n\tbrelse(inode_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_lock_allocators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2674-2743",
    "snippet": "int ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*meta_ac"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "clusters_to_add",
            "data_ac"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata",
          "args": [
            "osb",
            "et->et_root_el",
            "meta_ac"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1051-1058",
          "snippet": "int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_extent_list *root_el,\n\t\t\t       struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\tocfs2_extend_meta_needed(root_el),\n\t\t\t\t\tac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_extent_list *root_el,\n\t\t\t       struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\tocfs2_extend_meta_needed(root_el),\n\t\t\t\t\tac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "osb",
            "et"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "clusters_to_add != 0 && data_ac == NULL"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_debug_suballoc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2634-2662",
    "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\"",
            "i",
            "(unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->id1.bitmap1.i_total"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_debug_bg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2617-2632",
    "snippet": "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg)\n{\n\tprintk(\"Block Group:\\n\");\n\tprintk(\"bg_signature:       %s\\n\", bg->bg_signature);\n\tprintk(\"bg_size:            %u\\n\", bg->bg_size);\n\tprintk(\"bg_bits:            %u\\n\", bg->bg_bits);\n\tprintk(\"bg_free_bits_count: %u\\n\", bg->bg_free_bits_count);\n\tprintk(\"bg_chain:           %u\\n\", bg->bg_chain);\n\tprintk(\"bg_generation:      %u\\n\", le32_to_cpu(bg->bg_generation));\n\tprintk(\"bg_next_group:      %llu\\n\",\n\t       (unsigned long long)bg->bg_next_group);\n\tprintk(\"bg_parent_dinode:   %llu\\n\",\n\t       (unsigned long long)bg->bg_parent_dinode);\n\tprintk(\"bg_blkno:           %llu\\n\",\n\t       (unsigned long long)bg->bg_blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"bg_blkno:           %llu\\n\"",
            "(unsigned long long)bg->bg_blkno"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bg->bg_generation"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg)\n{\n\tprintk(\"Block Group:\\n\");\n\tprintk(\"bg_signature:       %s\\n\", bg->bg_signature);\n\tprintk(\"bg_size:            %u\\n\", bg->bg_size);\n\tprintk(\"bg_bits:            %u\\n\", bg->bg_bits);\n\tprintk(\"bg_free_bits_count: %u\\n\", bg->bg_free_bits_count);\n\tprintk(\"bg_chain:           %u\\n\", bg->bg_chain);\n\tprintk(\"bg_generation:      %u\\n\", le32_to_cpu(bg->bg_generation));\n\tprintk(\"bg_next_group:      %llu\\n\",\n\t       (unsigned long long)bg->bg_next_group);\n\tprintk(\"bg_parent_dinode:   %llu\\n\",\n\t       (unsigned long long)bg->bg_parent_dinode);\n\tprintk(\"bg_blkno:           %llu\\n\",\n\t       (unsigned long long)bg->bg_blkno);\n}"
  },
  {
    "function_name": "ocfs2_release_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2606-2615",
    "snippet": "int ocfs2_release_clusters(handle_t *handle,\n\t\t\t   struct inode *bitmap_inode,\n\t\t\t   struct buffer_head *bitmap_bh,\n\t\t\t   u64 start_blk,\n\t\t\t   unsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_clear_bit);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ocfs2_free_clusters",
          "args": [
            "handle",
            "bitmap_inode",
            "bitmap_bh",
            "start_blk",
            "num_clusters",
            "_ocfs2_clear_bit"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2545-2589",
          "snippet": "static int _ocfs2_free_clusters(handle_t *handle,\n\t\t\t\tstruct inode *bitmap_inode,\n\t\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\t\tu64 start_blk,\n\t\t\t\tunsigned int num_clusters,\n\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\tunsigned long *bitmap))\n{\n\tint status;\n\tu16 bg_start_bit;\n\tu64 bg_blkno;\n\tstruct ocfs2_dinode *fe;\n\n\t/* You can't ever have a contiguous set of clusters\n\t * bigger than a block group bitmap so we never have to worry\n\t * about looping on them.\n\t * This is expensive. We can safely remove once this stuff has\n\t * gotten tested really well. */\n\tBUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));\n\n\tfe = (struct ocfs2_dinode *) bitmap_bh->b_data;\n\n\tocfs2_block_to_cluster_group(bitmap_inode, start_blk, &bg_blkno,\n\t\t\t\t     &bg_start_bit);\n\n\ttrace_ocfs2_free_clusters((unsigned long long)bg_blkno,\n\t\t\t(unsigned long long)start_blk,\n\t\t\tbg_start_bit, num_clusters);\n\n\tstatus = _ocfs2_free_suballoc_bits(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t\t   bg_start_bit, bg_blkno,\n\t\t\t\t\t   num_clusters, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),\n\t\t\t\t\t num_clusters);\n\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic int _ocfs2_free_clusters(handle_t *handle,\n\t\t\t\tstruct inode *bitmap_inode,\n\t\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\t\tu64 start_blk,\n\t\t\t\tunsigned int num_clusters,\n\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\tunsigned long *bitmap))\n{\n\tint status;\n\tu16 bg_start_bit;\n\tu64 bg_blkno;\n\tstruct ocfs2_dinode *fe;\n\n\t/* You can't ever have a contiguous set of clusters\n\t * bigger than a block group bitmap so we never have to worry\n\t * about looping on them.\n\t * This is expensive. We can safely remove once this stuff has\n\t * gotten tested really well. */\n\tBUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));\n\n\tfe = (struct ocfs2_dinode *) bitmap_bh->b_data;\n\n\tocfs2_block_to_cluster_group(bitmap_inode, start_blk, &bg_blkno,\n\t\t\t\t     &bg_start_bit);\n\n\ttrace_ocfs2_free_clusters((unsigned long long)bg_blkno,\n\t\t\t(unsigned long long)start_blk,\n\t\t\tbg_start_bit, num_clusters);\n\n\tstatus = _ocfs2_free_suballoc_bits(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t\t   bg_start_bit, bg_blkno,\n\t\t\t\t\t   num_clusters, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),\n\t\t\t\t\t num_clusters);\n\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_release_clusters(handle_t *handle,\n\t\t\t   struct inode *bitmap_inode,\n\t\t\t   struct buffer_head *bitmap_bh,\n\t\t\t   u64 start_blk,\n\t\t\t   unsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_clear_bit);\n}"
  },
  {
    "function_name": "ocfs2_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2591-2600",
    "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ocfs2_free_clusters",
          "args": [
            "handle",
            "bitmap_inode",
            "bitmap_bh",
            "start_blk",
            "num_clusters",
            "_ocfs2_set_bit"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2545-2589",
          "snippet": "static int _ocfs2_free_clusters(handle_t *handle,\n\t\t\t\tstruct inode *bitmap_inode,\n\t\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\t\tu64 start_blk,\n\t\t\t\tunsigned int num_clusters,\n\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\tunsigned long *bitmap))\n{\n\tint status;\n\tu16 bg_start_bit;\n\tu64 bg_blkno;\n\tstruct ocfs2_dinode *fe;\n\n\t/* You can't ever have a contiguous set of clusters\n\t * bigger than a block group bitmap so we never have to worry\n\t * about looping on them.\n\t * This is expensive. We can safely remove once this stuff has\n\t * gotten tested really well. */\n\tBUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));\n\n\tfe = (struct ocfs2_dinode *) bitmap_bh->b_data;\n\n\tocfs2_block_to_cluster_group(bitmap_inode, start_blk, &bg_blkno,\n\t\t\t\t     &bg_start_bit);\n\n\ttrace_ocfs2_free_clusters((unsigned long long)bg_blkno,\n\t\t\t(unsigned long long)start_blk,\n\t\t\tbg_start_bit, num_clusters);\n\n\tstatus = _ocfs2_free_suballoc_bits(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t\t   bg_start_bit, bg_blkno,\n\t\t\t\t\t   num_clusters, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),\n\t\t\t\t\t num_clusters);\n\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic int _ocfs2_free_clusters(handle_t *handle,\n\t\t\t\tstruct inode *bitmap_inode,\n\t\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\t\tu64 start_blk,\n\t\t\t\tunsigned int num_clusters,\n\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\tunsigned long *bitmap))\n{\n\tint status;\n\tu16 bg_start_bit;\n\tu64 bg_blkno;\n\tstruct ocfs2_dinode *fe;\n\n\t/* You can't ever have a contiguous set of clusters\n\t * bigger than a block group bitmap so we never have to worry\n\t * about looping on them.\n\t * This is expensive. We can safely remove once this stuff has\n\t * gotten tested really well. */\n\tBUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));\n\n\tfe = (struct ocfs2_dinode *) bitmap_bh->b_data;\n\n\tocfs2_block_to_cluster_group(bitmap_inode, start_blk, &bg_blkno,\n\t\t\t\t     &bg_start_bit);\n\n\ttrace_ocfs2_free_clusters((unsigned long long)bg_blkno,\n\t\t\t(unsigned long long)start_blk,\n\t\t\tbg_start_bit, num_clusters);\n\n\tstatus = _ocfs2_free_suballoc_bits(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t\t   bg_start_bit, bg_blkno,\n\t\t\t\t\t   num_clusters, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),\n\t\t\t\t\t num_clusters);\n\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
  },
  {
    "function_name": "_ocfs2_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2545-2589",
    "snippet": "static int _ocfs2_free_clusters(handle_t *handle,\n\t\t\t\tstruct inode *bitmap_inode,\n\t\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\t\tu64 start_blk,\n\t\t\t\tunsigned int num_clusters,\n\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\tunsigned long *bitmap))\n{\n\tint status;\n\tu16 bg_start_bit;\n\tu64 bg_blkno;\n\tstruct ocfs2_dinode *fe;\n\n\t/* You can't ever have a contiguous set of clusters\n\t * bigger than a block group bitmap so we never have to worry\n\t * about looping on them.\n\t * This is expensive. We can safely remove once this stuff has\n\t * gotten tested really well. */\n\tBUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));\n\n\tfe = (struct ocfs2_dinode *) bitmap_bh->b_data;\n\n\tocfs2_block_to_cluster_group(bitmap_inode, start_blk, &bg_blkno,\n\t\t\t\t     &bg_start_bit);\n\n\ttrace_ocfs2_free_clusters((unsigned long long)bg_blkno,\n\t\t\t(unsigned long long)start_blk,\n\t\t\tbg_start_bit, num_clusters);\n\n\tstatus = _ocfs2_free_suballoc_bits(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t\t   bg_start_bit, bg_blkno,\n\t\t\t\t\t   num_clusters, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),\n\t\t\t\t\t num_clusters);\n\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_seen_free_bits",
          "args": [
            "OCFS2_SB(bitmap_inode->i_sb)",
            "num_clusters"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_seen_free_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "228-239",
          "snippet": "void ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "bitmap_inode->i_sb"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "bitmap_inode",
            "bitmap_bh",
            "bg_start_bit",
            "bg_blkno",
            "num_clusters",
            "undo_fn"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2451-2517",
          "snippet": "static int _ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t\t     unsigned int start_bit,\n\t\t\t\t     u64 bg_blkno,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     void (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t     unsigned long *bitmap))\n{\n\tint status = 0;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group;\n\n\t/* The alloc_bh comes from ocfs2_free_dinode() or\n\t * ocfs2_free_clusters().  The callers have all locked the\n\t * allocator and gotten alloc_bh from the lock call.  This\n\t * validates the dinode buffer.  Any corruption that has happened\n\t * is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\tBUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));\n\n\ttrace_ocfs2_free_suballoc_bits(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\t(unsigned long long)bg_blkno,\n\t\tstart_bit, count);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON((count + start_bit) > le16_to_cpu(group->bg_bits));\n\n\tstatus = ocfs2_block_group_clear_bits(handle, alloc_inode,\n\t\t\t\t\t      group, group_bh,\n\t\t\t\t\t      start_bit, count, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t alloc_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle32_add_cpu(&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free,\n\t\t     count);\n\ttmp_used = le32_to_cpu(fe->id1.bitmap1.i_used);\n\tfe->id1.bitmap1.i_used = cpu_to_le32(tmp_used - count);\n\tocfs2_journal_dirty(handle, alloc_bh);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic int _ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t\t     unsigned int start_bit,\n\t\t\t\t     u64 bg_blkno,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     void (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t     unsigned long *bitmap))\n{\n\tint status = 0;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group;\n\n\t/* The alloc_bh comes from ocfs2_free_dinode() or\n\t * ocfs2_free_clusters().  The callers have all locked the\n\t * allocator and gotten alloc_bh from the lock call.  This\n\t * validates the dinode buffer.  Any corruption that has happened\n\t * is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\tBUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));\n\n\ttrace_ocfs2_free_suballoc_bits(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\t(unsigned long long)bg_blkno,\n\t\tstart_bit, count);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON((count + start_bit) > le16_to_cpu(group->bg_bits));\n\n\tstatus = ocfs2_block_group_clear_bits(handle, alloc_inode,\n\t\t\t\t\t      group, group_bh,\n\t\t\t\t\t      start_bit, count, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t alloc_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle32_add_cpu(&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free,\n\t\t     count);\n\ttmp_used = le32_to_cpu(fe->id1.bitmap1.i_used);\n\tfe->id1.bitmap1.i_used = cpu_to_le32(tmp_used - count);\n\tocfs2_journal_dirty(handle, alloc_bh);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_free_clusters",
          "args": [
            "(unsigned long long)bg_blkno",
            "(unsigned long long)start_blk",
            "bg_start_bit",
            "num_clusters"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_to_cluster_group",
          "args": [
            "bitmap_inode",
            "start_blk",
            "&bg_blkno",
            "&bg_start_bit"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_to_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2276-2294",
          "snippet": "static inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 data_cluster = ocfs2_blocks_to_clusters(osb->sb, data_blkno);\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\t*bg_blkno = ocfs2_which_cluster_group(inode,\n\t\t\t\t\t      data_cluster);\n\n\tif (*bg_blkno == osb->first_cluster_group_blkno)\n\t\t*bg_bit_off = (u16) data_cluster;\n\telse\n\t\t*bg_bit_off = (u16) ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t     data_blkno - *bg_blkno);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);",
            "static inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);\nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);\n\nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 data_cluster = ocfs2_blocks_to_clusters(osb->sb, data_blkno);\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\t*bg_blkno = ocfs2_which_cluster_group(inode,\n\t\t\t\t\t      data_cluster);\n\n\tif (*bg_blkno == osb->first_cluster_group_blkno)\n\t\t*bg_bit_off = (u16) data_cluster;\n\telse\n\t\t*bg_bit_off = (u16) ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t     data_blkno - *bg_blkno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk))"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "bitmap_inode->i_sb",
            "ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "bitmap_inode->i_sb",
            "start_blk"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic int _ocfs2_free_clusters(handle_t *handle,\n\t\t\t\tstruct inode *bitmap_inode,\n\t\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\t\tu64 start_blk,\n\t\t\t\tunsigned int num_clusters,\n\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\tunsigned long *bitmap))\n{\n\tint status;\n\tu16 bg_start_bit;\n\tu64 bg_blkno;\n\tstruct ocfs2_dinode *fe;\n\n\t/* You can't ever have a contiguous set of clusters\n\t * bigger than a block group bitmap so we never have to worry\n\t * about looping on them.\n\t * This is expensive. We can safely remove once this stuff has\n\t * gotten tested really well. */\n\tBUG_ON(start_blk != ocfs2_clusters_to_blocks(bitmap_inode->i_sb, ocfs2_blocks_to_clusters(bitmap_inode->i_sb, start_blk)));\n\n\tfe = (struct ocfs2_dinode *) bitmap_bh->b_data;\n\n\tocfs2_block_to_cluster_group(bitmap_inode, start_blk, &bg_blkno,\n\t\t\t\t     &bg_start_bit);\n\n\ttrace_ocfs2_free_clusters((unsigned long long)bg_blkno,\n\t\t\t(unsigned long long)start_blk,\n\t\t\tbg_start_bit, num_clusters);\n\n\tstatus = _ocfs2_free_suballoc_bits(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t\t   bg_start_bit, bg_blkno,\n\t\t\t\t\t   num_clusters, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tocfs2_local_alloc_seen_free_bits(OCFS2_SB(bitmap_inode->i_sb),\n\t\t\t\t\t num_clusters);\n\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_free_dinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2530-2543",
    "snippet": "int ocfs2_free_dinode(handle_t *handle,\n\t\t      struct inode *inode_alloc_inode,\n\t\t      struct buffer_head *inode_alloc_bh,\n\t\t      struct ocfs2_dinode *di)\n{\n\tu64 blk = le64_to_cpu(di->i_blkno);\n\tu16 bit = le16_to_cpu(di->i_suballoc_bit);\n\tu64 bg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\tif (di->i_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(di->i_suballoc_loc);\n\treturn ocfs2_free_suballoc_bits(handle, inode_alloc_inode,\n\t\t\t\t\tinode_alloc_bh, bit, bg_blkno, 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "inode_alloc_inode",
            "inode_alloc_bh",
            "bit",
            "bg_blkno",
            "1"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2519-2528",
          "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_suballoc_loc"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "blk",
            "bit"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_suballoc_bit"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_dinode(handle_t *handle,\n\t\t      struct inode *inode_alloc_inode,\n\t\t      struct buffer_head *inode_alloc_bh,\n\t\t      struct ocfs2_dinode *di)\n{\n\tu64 blk = le64_to_cpu(di->i_blkno);\n\tu16 bit = le16_to_cpu(di->i_suballoc_bit);\n\tu64 bg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\tif (di->i_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(di->i_suballoc_loc);\n\treturn ocfs2_free_suballoc_bits(handle, inode_alloc_inode,\n\t\t\t\t\tinode_alloc_bh, bit, bg_blkno, 1);\n}"
  },
  {
    "function_name": "ocfs2_free_suballoc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2519-2528",
    "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "alloc_inode",
            "alloc_bh",
            "start_bit",
            "bg_blkno",
            "count",
            "NULL"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2451-2517",
          "snippet": "static int _ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t\t     unsigned int start_bit,\n\t\t\t\t     u64 bg_blkno,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     void (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t     unsigned long *bitmap))\n{\n\tint status = 0;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group;\n\n\t/* The alloc_bh comes from ocfs2_free_dinode() or\n\t * ocfs2_free_clusters().  The callers have all locked the\n\t * allocator and gotten alloc_bh from the lock call.  This\n\t * validates the dinode buffer.  Any corruption that has happened\n\t * is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\tBUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));\n\n\ttrace_ocfs2_free_suballoc_bits(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\t(unsigned long long)bg_blkno,\n\t\tstart_bit, count);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON((count + start_bit) > le16_to_cpu(group->bg_bits));\n\n\tstatus = ocfs2_block_group_clear_bits(handle, alloc_inode,\n\t\t\t\t\t      group, group_bh,\n\t\t\t\t\t      start_bit, count, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t alloc_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle32_add_cpu(&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free,\n\t\t     count);\n\ttmp_used = le32_to_cpu(fe->id1.bitmap1.i_used);\n\tfe->id1.bitmap1.i_used = cpu_to_le32(tmp_used - count);\n\tocfs2_journal_dirty(handle, alloc_bh);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic int _ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t\t     unsigned int start_bit,\n\t\t\t\t     u64 bg_blkno,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     void (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t     unsigned long *bitmap))\n{\n\tint status = 0;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group;\n\n\t/* The alloc_bh comes from ocfs2_free_dinode() or\n\t * ocfs2_free_clusters().  The callers have all locked the\n\t * allocator and gotten alloc_bh from the lock call.  This\n\t * validates the dinode buffer.  Any corruption that has happened\n\t * is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\tBUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));\n\n\ttrace_ocfs2_free_suballoc_bits(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\t(unsigned long long)bg_blkno,\n\t\tstart_bit, count);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON((count + start_bit) > le16_to_cpu(group->bg_bits));\n\n\tstatus = ocfs2_block_group_clear_bits(handle, alloc_inode,\n\t\t\t\t\t      group, group_bh,\n\t\t\t\t\t      start_bit, count, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t alloc_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle32_add_cpu(&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free,\n\t\t     count);\n\ttmp_used = le32_to_cpu(fe->id1.bitmap1.i_used);\n\tfe->id1.bitmap1.i_used = cpu_to_le32(tmp_used - count);\n\tocfs2_journal_dirty(handle, alloc_bh);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
  },
  {
    "function_name": "_ocfs2_free_suballoc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2451-2517",
    "snippet": "static int _ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t\t     unsigned int start_bit,\n\t\t\t\t     u64 bg_blkno,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     void (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t     unsigned long *bitmap))\n{\n\tint status = 0;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group;\n\n\t/* The alloc_bh comes from ocfs2_free_dinode() or\n\t * ocfs2_free_clusters().  The callers have all locked the\n\t * allocator and gotten alloc_bh from the lock call.  This\n\t * validates the dinode buffer.  Any corruption that has happened\n\t * is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\tBUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));\n\n\ttrace_ocfs2_free_suballoc_bits(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\t(unsigned long long)bg_blkno,\n\t\tstart_bit, count);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON((count + start_bit) > le16_to_cpu(group->bg_bits));\n\n\tstatus = ocfs2_block_group_clear_bits(handle, alloc_inode,\n\t\t\t\t\t      group, group_bh,\n\t\t\t\t\t      start_bit, count, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t alloc_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle32_add_cpu(&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free,\n\t\t     count);\n\ttmp_used = le32_to_cpu(fe->id1.bitmap1.i_used);\n\tfe->id1.bitmap1.i_used = cpu_to_le32(tmp_used - count);\n\tocfs2_journal_dirty(handle, alloc_bh);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "group_bh"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "alloc_bh"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp_used - count"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->id1.bitmap1.i_used"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free",
            "count"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "group->bg_chain"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "alloc_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_clear_bits",
          "args": [
            "handle",
            "alloc_inode",
            "group",
            "group_bh",
            "start_bit",
            "count",
            "undo_fn"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2385-2446",
          "snippet": "static int ocfs2_block_group_clear_bits(handle_t *handle,\n\t\t\t\t\tstruct inode *alloc_inode,\n\t\t\t\t\tstruct ocfs2_group_desc *bg,\n\t\t\t\t\tstruct buffer_head *group_bh,\n\t\t\t\t\tunsigned int bit_off,\n\t\t\t\t\tunsigned int num_bits,\n\t\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t\tunsigned long *bmap))\n{\n\tint status;\n\tunsigned int tmp;\n\tstruct ocfs2_group_desc *undo_bg = NULL;\n\n\t/* The caller got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\ttrace_ocfs2_block_group_clear_bits(bit_off, num_bits);\n\n\tBUG_ON(undo_fn && !ocfs2_is_cluster_bitmap(alloc_inode));\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t undo_fn ?\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_UNDO :\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (undo_fn) {\n\t\tjbd_lock_bh_state(group_bh);\n\t\tundo_bg = (struct ocfs2_group_desc *)\n\t\t\t\t\tbh2jh(group_bh)->b_committed_data;\n\t\tBUG_ON(!undo_bg);\n\t}\n\n\ttmp = num_bits;\n\twhile(tmp--) {\n\t\tocfs2_clear_bit((bit_off + tmp),\n\t\t\t\t(unsigned long *) bg->bg_bitmap);\n\t\tif (undo_fn)\n\t\t\tundo_fn(bit_off + tmp,\n\t\t\t\t(unsigned long *) undo_bg->bg_bitmap);\n\t}\n\tle16_add_cpu(&bg->bg_free_bits_count, num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\n\tif (undo_fn)\n\t\tjbd_unlock_bh_state(group_bh);\n\n\tocfs2_journal_dirty(handle, group_bh);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nstatic int ocfs2_block_group_clear_bits(handle_t *handle,\n\t\t\t\t\tstruct inode *alloc_inode,\n\t\t\t\t\tstruct ocfs2_group_desc *bg,\n\t\t\t\t\tstruct buffer_head *group_bh,\n\t\t\t\t\tunsigned int bit_off,\n\t\t\t\t\tunsigned int num_bits,\n\t\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t\tunsigned long *bmap))\n{\n\tint status;\n\tunsigned int tmp;\n\tstruct ocfs2_group_desc *undo_bg = NULL;\n\n\t/* The caller got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\ttrace_ocfs2_block_group_clear_bits(bit_off, num_bits);\n\n\tBUG_ON(undo_fn && !ocfs2_is_cluster_bitmap(alloc_inode));\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t undo_fn ?\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_UNDO :\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (undo_fn) {\n\t\tjbd_lock_bh_state(group_bh);\n\t\tundo_bg = (struct ocfs2_group_desc *)\n\t\t\t\t\tbh2jh(group_bh)->b_committed_data;\n\t\tBUG_ON(!undo_bg);\n\t}\n\n\ttmp = num_bits;\n\twhile(tmp--) {\n\t\tocfs2_clear_bit((bit_off + tmp),\n\t\t\t\t(unsigned long *) bg->bg_bitmap);\n\t\tif (undo_fn)\n\t\t\tundo_fn(bit_off + tmp,\n\t\t\t\t(unsigned long *) undo_bg->bg_bitmap);\n\t}\n\tle16_add_cpu(&bg->bg_free_bits_count, num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\n\tif (undo_fn)\n\t\tjbd_unlock_bh_state(group_bh);\n\n\tocfs2_journal_dirty(handle, group_bh);\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(count + start_bit) > le16_to_cpu(group->bg_bits)"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "alloc_inode",
            "fe",
            "bg_blkno",
            "&group_bh"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_free_suballoc_bits",
          "args": [
            "(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno",
            "(unsigned long long)bg_blkno",
            "start_bit",
            "count"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "alloc_inode"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(count + start_bit) > ocfs2_bits_per_group(cl)"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_bits_per_group",
          "args": [
            "cl"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bits_per_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "164-167",
          "snippet": "static u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(fe)"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "fe"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic int _ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t\t     unsigned int start_bit,\n\t\t\t\t     u64 bg_blkno,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     void (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t     unsigned long *bitmap))\n{\n\tint status = 0;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group;\n\n\t/* The alloc_bh comes from ocfs2_free_dinode() or\n\t * ocfs2_free_clusters().  The callers have all locked the\n\t * allocator and gotten alloc_bh from the lock call.  This\n\t * validates the dinode buffer.  Any corruption that has happened\n\t * is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\tBUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));\n\n\ttrace_ocfs2_free_suballoc_bits(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\t(unsigned long long)bg_blkno,\n\t\tstart_bit, count);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe, bg_blkno,\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tgroup = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON((count + start_bit) > le16_to_cpu(group->bg_bits));\n\n\tstatus = ocfs2_block_group_clear_bits(handle, alloc_inode,\n\t\t\t\t\t      group, group_bh,\n\t\t\t\t\t      start_bit, count, undo_fn);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t alloc_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle32_add_cpu(&cl->cl_recs[le16_to_cpu(group->bg_chain)].c_free,\n\t\t     count);\n\ttmp_used = le32_to_cpu(fe->id1.bitmap1.i_used);\n\tfe->id1.bitmap1.i_used = cpu_to_le32(tmp_used - count);\n\tocfs2_journal_dirty(handle, alloc_bh);\n\nbail:\n\tbrelse(group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_group_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2385-2446",
    "snippet": "static int ocfs2_block_group_clear_bits(handle_t *handle,\n\t\t\t\t\tstruct inode *alloc_inode,\n\t\t\t\t\tstruct ocfs2_group_desc *bg,\n\t\t\t\t\tstruct buffer_head *group_bh,\n\t\t\t\t\tunsigned int bit_off,\n\t\t\t\t\tunsigned int num_bits,\n\t\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t\tunsigned long *bmap))\n{\n\tint status;\n\tunsigned int tmp;\n\tstruct ocfs2_group_desc *undo_bg = NULL;\n\n\t/* The caller got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\ttrace_ocfs2_block_group_clear_bits(bit_off, num_bits);\n\n\tBUG_ON(undo_fn && !ocfs2_is_cluster_bitmap(alloc_inode));\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t undo_fn ?\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_UNDO :\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (undo_fn) {\n\t\tjbd_lock_bh_state(group_bh);\n\t\tundo_bg = (struct ocfs2_group_desc *)\n\t\t\t\t\tbh2jh(group_bh)->b_committed_data;\n\t\tBUG_ON(!undo_bg);\n\t}\n\n\ttmp = num_bits;\n\twhile(tmp--) {\n\t\tocfs2_clear_bit((bit_off + tmp),\n\t\t\t\t(unsigned long *) bg->bg_bitmap);\n\t\tif (undo_fn)\n\t\t\tundo_fn(bit_off + tmp,\n\t\t\t\t(unsigned long *) undo_bg->bg_bitmap);\n\t}\n\tle16_add_cpu(&bg->bg_free_bits_count, num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\n\tif (undo_fn)\n\t\tjbd_unlock_bh_state(group_bh);\n\n\tocfs2_journal_dirty(handle, group_bh);\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "group_bh"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "group_bh"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "alloc_inode->i_sb",
            "\"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\"",
            "(unsigned long long)le64_to_cpu(bg->bg_blkno)",
            "le16_to_cpu(bg->bg_bits)",
            "le16_to_cpu(bg->bg_free_bits_count)",
            "num_bits"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_free_bits_count"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "bg->bg_blkno"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&bg->bg_free_bits_count",
            "num_bits"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "undo_fn",
          "args": [
            "bit_off + tmp",
            "(unsigned long *) undo_bg->bg_bitmap"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_bit",
          "args": [
            "(bit_off + tmp)",
            "(unsigned long *) bg->bg_bitmap"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!undo_bg"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "group_bh"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "group_bh"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "group_bh",
            "undo_fn ?\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_UNDO :\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "undo_fn && !ocfs2_is_cluster_bitmap(alloc_inode)"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "alloc_inode"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_block_group_clear_bits",
          "args": [
            "bit_off",
            "num_bits"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_GROUP_DESC(bg)"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_GROUP_DESC",
          "args": [
            "bg"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nstatic int ocfs2_block_group_clear_bits(handle_t *handle,\n\t\t\t\t\tstruct inode *alloc_inode,\n\t\t\t\t\tstruct ocfs2_group_desc *bg,\n\t\t\t\t\tstruct buffer_head *group_bh,\n\t\t\t\t\tunsigned int bit_off,\n\t\t\t\t\tunsigned int num_bits,\n\t\t\t\t\tvoid (*undo_fn)(unsigned int bit,\n\t\t\t\t\t\t\tunsigned long *bmap))\n{\n\tint status;\n\tunsigned int tmp;\n\tstruct ocfs2_group_desc *undo_bg = NULL;\n\n\t/* The caller got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\ttrace_ocfs2_block_group_clear_bits(bit_off, num_bits);\n\n\tBUG_ON(undo_fn && !ocfs2_is_cluster_bitmap(alloc_inode));\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t undo_fn ?\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_UNDO :\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (undo_fn) {\n\t\tjbd_lock_bh_state(group_bh);\n\t\tundo_bg = (struct ocfs2_group_desc *)\n\t\t\t\t\tbh2jh(group_bh)->b_committed_data;\n\t\tBUG_ON(!undo_bg);\n\t}\n\n\ttmp = num_bits;\n\twhile(tmp--) {\n\t\tocfs2_clear_bit((bit_off + tmp),\n\t\t\t\t(unsigned long *) bg->bg_bitmap);\n\t\tif (undo_fn)\n\t\t\tundo_fn(bit_off + tmp,\n\t\t\t\t(unsigned long *) undo_bg->bg_bitmap);\n\t}\n\tle16_add_cpu(&bg->bg_free_bits_count, num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\n\tif (undo_fn)\n\t\tjbd_unlock_bh_state(group_bh);\n\n\tocfs2_journal_dirty(handle, group_bh);\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_claim_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2373-2383",
    "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "ac",
            "min_clusters",
            "bits_wanted",
            "cluster_start",
            "num_clusters"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
  },
  {
    "function_name": "__ocfs2_claim_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2302-2371",
    "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&osb->alloc_stats.bitmap_data"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_desc_bitmap_to_cluster_off",
          "args": [
            "ac->ac_inode",
            "res.sr_bg_blkno",
            "res.sr_bit_offset"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_desc_bitmap_to_cluster_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2243-2256",
          "snippet": "static inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 cluster = 0;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tif (bg_blkno != osb->first_cluster_group_blkno)\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, bg_blkno);\n\tcluster += (u32) bg_bit_off;\n\treturn cluster;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);",
            "static inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);\nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);\n\nstatic inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 cluster = 0;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tif (bg_blkno != osb->first_cluster_group_blkno)\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, bg_blkno);\n\tcluster += (u32) bg_bit_off;\n\treturn cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res.sr_blkno"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_suballoc_bits",
          "args": [
            "ac",
            "handle",
            "bits_wanted",
            "min_clusters",
            "&res"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1883-1991",
          "snippet": "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\"",
            "min_clusters",
            "osb->bitmap_cpg"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&osb->alloc_stats.local_data"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_local_alloc_bits",
          "args": [
            "osb",
            "handle",
            "ac",
            "bits_wanted",
            "cluster_start",
            "num_clusters"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_local_alloc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "728-782",
          "snippet": "int ocfs2_claim_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u32 bits_wanted,\n\t\t\t\t u32 *bit_off,\n\t\t\t\t u32 *num_bits)\n{\n\tint status, start;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tstart = ocfs2_local_alloc_find_clear_bits(osb, alloc, &bits_wanted,\n\t\t\t\t\t\t  ac->ac_resv);\n\tif (start == -1) {\n\t\t/* TODO: Shouldn't we just BUG here? */\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbitmap = la->la_bitmap;\n\t*bit_off = le32_to_cpu(la->la_bm_off) + start;\n\t*num_bits = bits_wanted;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_resmap_claimed_bits(&osb->osb_la_resmap, ac->ac_resv, start,\n\t\t\t\t  bits_wanted);\n\n\twhile(bits_wanted--)\n\t\tocfs2_set_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, *num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_claim_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u32 bits_wanted,\n\t\t\t\t u32 *bit_off,\n\t\t\t\t u32 *num_bits)\n{\n\tint status, start;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tstart = ocfs2_local_alloc_find_clear_bits(osb, alloc, &bits_wanted,\n\t\t\t\t\t\t  ac->ac_resv);\n\tif (start == -1) {\n\t\t/* TODO: Shouldn't we just BUG here? */\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbitmap = la->la_bitmap;\n\t*bit_off = le32_to_cpu(la->la_bm_off) + start;\n\t*num_bits = bits_wanted;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_resmap_claimed_bits(&osb->osb_la_resmap, ac->ac_resv, start,\n\t\t\t\t  bits_wanted);\n\n\twhile(bits_wanted--)\n\t\tocfs2_set_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, *num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "min_clusters > 1"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_given >= ac->ac_bits_wanted"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ac->ac_inode->i_sb"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_to_cluster_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2276-2294",
    "snippet": "static inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 data_cluster = ocfs2_blocks_to_clusters(osb->sb, data_blkno);\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\t*bg_blkno = ocfs2_which_cluster_group(inode,\n\t\t\t\t\t      data_cluster);\n\n\tif (*bg_blkno == osb->first_cluster_group_blkno)\n\t\t*bg_bit_off = (u16) data_cluster;\n\telse\n\t\t*bg_bit_off = (u16) ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t     data_blkno - *bg_blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);",
      "static inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "osb->sb",
            "data_blkno - *bg_blkno"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_cluster_group",
          "args": [
            "inode",
            "data_cluster"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2260-2272",
          "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_cluster_bitmap(inode)"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "inode"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);\nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);\n\nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 data_cluster = ocfs2_blocks_to_clusters(osb->sb, data_blkno);\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\t*bg_blkno = ocfs2_which_cluster_group(inode,\n\t\t\t\t\t      data_cluster);\n\n\tif (*bg_blkno == osb->first_cluster_group_blkno)\n\t\t*bg_bit_off = (u16) data_cluster;\n\telse\n\t\t*bg_bit_off = (u16) ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t     data_blkno - *bg_blkno);\n}"
  },
  {
    "function_name": "ocfs2_which_cluster_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2260-2272",
    "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "group_no * osb->bitmap_cpg"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_cluster_bitmap(inode)"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "inode"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
  },
  {
    "function_name": "ocfs2_desc_bitmap_to_cluster_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2243-2256",
    "snippet": "static inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 cluster = 0;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tif (bg_blkno != osb->first_cluster_group_blkno)\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, bg_blkno);\n\tcluster += (u32) bg_bit_off;\n\treturn cluster;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);",
      "static inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "bg_blkno"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_cluster_bitmap(inode)"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "inode"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off);\nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off);\n\nstatic inline u32 ocfs2_desc_bitmap_to_cluster_off(struct inode *inode,\n\t\t\t\t\t\t   u64 bg_blkno,\n\t\t\t\t\t\t   u16 bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 cluster = 0;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tif (bg_blkno != osb->first_cluster_group_blkno)\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, bg_blkno);\n\tcluster += (u32) bg_bit_off;\n\treturn cluster;\n}"
  },
  {
    "function_name": "ocfs2_claim_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2198-2239",
    "snippet": "int ocfs2_claim_new_inode(handle_t *handle,\n\t\t\t  struct inode *dir,\n\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t  u64 *suballoc_loc,\n\t\t\t  u16 *suballoc_bit,\n\t\t\t  u64 *fe_blkno)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   1,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res.sr_bits != 1);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit = res.sr_bit_offset;\n\t*fe_blkno = res.sr_blkno;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_save_inode_ac_group",
          "args": [
            "dir",
            "ac"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_save_inode_ac_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2059-2064",
          "snippet": "static inline void ocfs2_save_inode_ac_group(struct inode *dir,\n\t\t\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\tOCFS2_I(dir)->ip_last_used_group = ac->ac_last_group;\n\tOCFS2_I(dir)->ip_last_used_slot = ac->ac_alloc_slot;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic inline void ocfs2_save_inode_ac_group(struct inode *dir,\n\t\t\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\tOCFS2_I(dir)->ip_last_used_group = ac->ac_last_group;\n\tOCFS2_I(dir)->ip_last_used_slot = ac->ac_alloc_slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res.sr_bits != 1"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ac->ac_inode->i_sb"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_suballoc_bits",
          "args": [
            "ac",
            "handle",
            "1",
            "1",
            "&res"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1883-1991",
          "snippet": "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_inode_ac_group",
          "args": [
            "dir",
            "parent_fe_bh",
            "ac"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_inode_ac_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2031-2057",
          "snippet": "static void ocfs2_init_inode_ac_group(struct inode *dir,\n\t\t\t\t      struct buffer_head *parent_di_bh,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_di_bh->b_data;\n\t/*\n\t * Try to allocate inodes from some specific group.\n\t *\n\t * If the parent dir has recorded the last group used in allocation,\n\t * cool, use it. Otherwise if we try to allocate new inode from the\n\t * same slot the parent dir belongs to, use the same chunk.\n\t *\n\t * We are very careful here to avoid the mistake of setting\n\t * ac_last_group to a group descriptor from a different (unlocked) slot.\n\t */\n\tif (OCFS2_I(dir)->ip_last_used_group &&\n\t    OCFS2_I(dir)->ip_last_used_slot == ac->ac_alloc_slot)\n\t\tac->ac_last_group = OCFS2_I(dir)->ip_last_used_group;\n\telse if (le16_to_cpu(di->i_suballoc_slot) == ac->ac_alloc_slot) {\n\t\tif (di->i_suballoc_loc)\n\t\t\tac->ac_last_group = le64_to_cpu(di->i_suballoc_loc);\n\t\telse\n\t\t\tac->ac_last_group = ocfs2_which_suballoc_group(\n\t\t\t\t\tle64_to_cpu(di->i_blkno),\n\t\t\t\t\tle16_to_cpu(di->i_suballoc_bit));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic void ocfs2_init_inode_ac_group(struct inode *dir,\n\t\t\t\t      struct buffer_head *parent_di_bh,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_di_bh->b_data;\n\t/*\n\t * Try to allocate inodes from some specific group.\n\t *\n\t * If the parent dir has recorded the last group used in allocation,\n\t * cool, use it. Otherwise if we try to allocate new inode from the\n\t * same slot the parent dir belongs to, use the same chunk.\n\t *\n\t * We are very careful here to avoid the mistake of setting\n\t * ac_last_group to a group descriptor from a different (unlocked) slot.\n\t */\n\tif (OCFS2_I(dir)->ip_last_used_group &&\n\t    OCFS2_I(dir)->ip_last_used_slot == ac->ac_alloc_slot)\n\t\tac->ac_last_group = OCFS2_I(dir)->ip_last_used_group;\n\telse if (le16_to_cpu(di->i_suballoc_slot) == ac->ac_alloc_slot) {\n\t\tif (di->i_suballoc_loc)\n\t\t\tac->ac_last_group = le64_to_cpu(di->i_suballoc_loc);\n\t\telse\n\t\t\tac->ac_last_group = ocfs2_which_suballoc_group(\n\t\t\t\t\tle64_to_cpu(di->i_blkno),\n\t\t\t\t\tle16_to_cpu(di->i_suballoc_bit));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_which != OCFS2_AC_USE_INODE"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_wanted != 1"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_given != 0"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ac"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_new_inode(handle_t *handle,\n\t\t\t  struct inode *dir,\n\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t  u64 *suballoc_loc,\n\t\t\t  u16 *suballoc_bit,\n\t\t\t  u64 *fe_blkno)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   1,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res.sr_bits != 1);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit = res.sr_bit_offset;\n\t*fe_blkno = res.sr_blkno;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_claim_new_inode_at_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2127-2196",
    "snippet": "int ocfs2_claim_new_inode_at_loc(handle_t *handle,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u64 *suballoc_loc,\n\t\t\t\t u16 *suballoc_bit,\n\t\t\t\t u64 di_blkno)\n{\n\tint ret;\n\tu16 chain;\n\tstruct ocfs2_suballoc_result *res = ac->ac_find_loc_priv;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/*\n\t * Since di_blkno is being passed back in, we check for any\n\t * inconsistencies which may have happened between\n\t * calls. These are code bugs as di_blkno is not expected to\n\t * change once returned from ocfs2_find_new_inode_loc()\n\t */\n\tBUG_ON(res->sr_blkno != di_blkno);\n\n\tret = ocfs2_read_group_descriptor(ac->ac_inode, di,\n\t\t\t\t\t  res->sr_bg_stable_blkno, &bg_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tchain = le16_to_cpu(bg->bg_chain);\n\n\tret = ocfs2_alloc_dinode_update_counts(ac->ac_inode, handle,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits,\n\t\t\t\t\t       chain);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t ac->ac_inode,\n\t\t\t\t\t bg,\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t res->sr_bit_offset,\n\t\t\t\t\t res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(ac->ac_inode,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_claim_new_inode_at_loc((unsigned long long)di_blkno,\n\t\t\t\t\t   res->sr_bits);\n\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res->sr_bits != 1);\n\n\t*suballoc_loc = res->sr_bg_blkno;\n\t*suballoc_bit = res->sr_bit_offset;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\nout:\n\tbrelse(bg_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bg_bh"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_save_inode_ac_group",
          "args": [
            "dir",
            "ac"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_save_inode_ac_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2059-2064",
          "snippet": "static inline void ocfs2_save_inode_ac_group(struct inode *dir,\n\t\t\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\tOCFS2_I(dir)->ip_last_used_group = ac->ac_last_group;\n\tOCFS2_I(dir)->ip_last_used_slot = ac->ac_alloc_slot;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic inline void ocfs2_save_inode_ac_group(struct inode *dir,\n\t\t\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\tOCFS2_I(dir)->ip_last_used_group = ac->ac_last_group;\n\tOCFS2_I(dir)->ip_last_used_slot = ac->ac_alloc_slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->sr_bits != 1"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ac->ac_inode->i_sb"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_claim_new_inode_at_loc",
          "args": [
            "(unsigned long long)di_blkno",
            "res->sr_bits"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rollback_alloc_dinode_counts",
          "args": [
            "ac->ac_inode",
            "ac->ac_bh",
            "res->sr_bits",
            "chain"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rollback_alloc_dinode_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1611-1624",
          "snippet": "void ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nvoid ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_set_bits",
          "args": [
            "handle",
            "ac->ac_inode",
            "bg",
            "bg_bh",
            "res->sr_bit_offset",
            "res->sr_bits"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1341-1387",
          "snippet": "int ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nint ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_dinode_update_counts",
          "args": [
            "ac->ac_inode",
            "handle",
            "ac->ac_bh",
            "res->sr_bits",
            "chain"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_dinode_update_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1584-1609",
          "snippet": "int ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nint ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_chain"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "ac->ac_inode",
            "di",
            "res->sr_bg_stable_blkno",
            "&bg_bh"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->sr_blkno != di_blkno"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_new_inode_at_loc(handle_t *handle,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u64 *suballoc_loc,\n\t\t\t\t u16 *suballoc_bit,\n\t\t\t\t u64 di_blkno)\n{\n\tint ret;\n\tu16 chain;\n\tstruct ocfs2_suballoc_result *res = ac->ac_find_loc_priv;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/*\n\t * Since di_blkno is being passed back in, we check for any\n\t * inconsistencies which may have happened between\n\t * calls. These are code bugs as di_blkno is not expected to\n\t * change once returned from ocfs2_find_new_inode_loc()\n\t */\n\tBUG_ON(res->sr_blkno != di_blkno);\n\n\tret = ocfs2_read_group_descriptor(ac->ac_inode, di,\n\t\t\t\t\t  res->sr_bg_stable_blkno, &bg_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tchain = le16_to_cpu(bg->bg_chain);\n\n\tret = ocfs2_alloc_dinode_update_counts(ac->ac_inode, handle,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits,\n\t\t\t\t\t       chain);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t ac->ac_inode,\n\t\t\t\t\t bg,\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t res->sr_bit_offset,\n\t\t\t\t\t res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(ac->ac_inode,\n\t\t\t\t\t       ac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_claim_new_inode_at_loc((unsigned long long)di_blkno,\n\t\t\t\t\t   res->sr_bits);\n\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\tBUG_ON(res->sr_bits != 1);\n\n\t*suballoc_loc = res->sr_bg_blkno;\n\t*suballoc_bit = res->sr_bit_offset;\n\tac->ac_bits_given++;\n\tocfs2_save_inode_ac_group(dir, ac);\n\nout:\n\tbrelse(bg_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_new_inode_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2066-2125",
    "snippet": "int ocfs2_find_new_inode_loc(struct inode *dir,\n\t\t\t     struct buffer_head *parent_fe_bh,\n\t\t\t     struct ocfs2_alloc_context *ac,\n\t\t\t     u64 *fe_blkno)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_suballoc_result *res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tres = kzalloc(sizeof(*res), GFP_NOFS);\n\tif (res == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\t/*\n\t * The handle started here is for chain relink. Alternatively,\n\t * we could just disable relink for these calls.\n\t */\n\thandle = ocfs2_start_trans(OCFS2_SB(dir->i_sb), OCFS2_SUBALLOC_ALLOC);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This will instruct ocfs2_claim_suballoc_bits and\n\t * ocfs2_search_one_group to search but save actual allocation\n\t * for later.\n\t */\n\tac->ac_find_loc_only = 1;\n\n\tret = ocfs2_claim_suballoc_bits(ac, handle, 1, 1, res);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac->ac_find_loc_priv = res;\n\t*fe_blkno = res->sr_blkno;\n\tocfs2_update_inode_fsync_trans(handle, dir, 0);\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(dir->i_sb), handle);\n\n\tif (ret)\n\t\tkfree(res);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(dir->i_sb)",
            "handle"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "dir",
            "0"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_suballoc_bits",
          "args": [
            "ac",
            "handle",
            "1",
            "1",
            "res"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1883-1991",
          "snippet": "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(dir->i_sb)",
            "OCFS2_SUBALLOC_ALLOC"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_inode_ac_group",
          "args": [
            "dir",
            "parent_fe_bh",
            "ac"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_inode_ac_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2031-2057",
          "snippet": "static void ocfs2_init_inode_ac_group(struct inode *dir,\n\t\t\t\t      struct buffer_head *parent_di_bh,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_di_bh->b_data;\n\t/*\n\t * Try to allocate inodes from some specific group.\n\t *\n\t * If the parent dir has recorded the last group used in allocation,\n\t * cool, use it. Otherwise if we try to allocate new inode from the\n\t * same slot the parent dir belongs to, use the same chunk.\n\t *\n\t * We are very careful here to avoid the mistake of setting\n\t * ac_last_group to a group descriptor from a different (unlocked) slot.\n\t */\n\tif (OCFS2_I(dir)->ip_last_used_group &&\n\t    OCFS2_I(dir)->ip_last_used_slot == ac->ac_alloc_slot)\n\t\tac->ac_last_group = OCFS2_I(dir)->ip_last_used_group;\n\telse if (le16_to_cpu(di->i_suballoc_slot) == ac->ac_alloc_slot) {\n\t\tif (di->i_suballoc_loc)\n\t\t\tac->ac_last_group = le64_to_cpu(di->i_suballoc_loc);\n\t\telse\n\t\t\tac->ac_last_group = ocfs2_which_suballoc_group(\n\t\t\t\t\tle64_to_cpu(di->i_blkno),\n\t\t\t\t\tle16_to_cpu(di->i_suballoc_bit));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic void ocfs2_init_inode_ac_group(struct inode *dir,\n\t\t\t\t      struct buffer_head *parent_di_bh,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_di_bh->b_data;\n\t/*\n\t * Try to allocate inodes from some specific group.\n\t *\n\t * If the parent dir has recorded the last group used in allocation,\n\t * cool, use it. Otherwise if we try to allocate new inode from the\n\t * same slot the parent dir belongs to, use the same chunk.\n\t *\n\t * We are very careful here to avoid the mistake of setting\n\t * ac_last_group to a group descriptor from a different (unlocked) slot.\n\t */\n\tif (OCFS2_I(dir)->ip_last_used_group &&\n\t    OCFS2_I(dir)->ip_last_used_slot == ac->ac_alloc_slot)\n\t\tac->ac_last_group = OCFS2_I(dir)->ip_last_used_group;\n\telse if (le16_to_cpu(di->i_suballoc_slot) == ac->ac_alloc_slot) {\n\t\tif (di->i_suballoc_loc)\n\t\t\tac->ac_last_group = le64_to_cpu(di->i_suballoc_loc);\n\t\telse\n\t\t\tac->ac_last_group = ocfs2_which_suballoc_group(\n\t\t\t\t\tle64_to_cpu(di->i_blkno),\n\t\t\t\t\tle16_to_cpu(di->i_suballoc_bit));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*res)",
            "GFP_NOFS"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_which != OCFS2_AC_USE_INODE"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_wanted != 1"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_given != 0"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ac"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_find_new_inode_loc(struct inode *dir,\n\t\t\t     struct buffer_head *parent_fe_bh,\n\t\t\t     struct ocfs2_alloc_context *ac,\n\t\t\t     u64 *fe_blkno)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_suballoc_result *res;\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_given != 0);\n\tBUG_ON(ac->ac_bits_wanted != 1);\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_INODE);\n\n\tres = kzalloc(sizeof(*res), GFP_NOFS);\n\tif (res == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_inode_ac_group(dir, parent_fe_bh, ac);\n\n\t/*\n\t * The handle started here is for chain relink. Alternatively,\n\t * we could just disable relink for these calls.\n\t */\n\thandle = ocfs2_start_trans(OCFS2_SB(dir->i_sb), OCFS2_SUBALLOC_ALLOC);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This will instruct ocfs2_claim_suballoc_bits and\n\t * ocfs2_search_one_group to search but save actual allocation\n\t * for later.\n\t */\n\tac->ac_find_loc_only = 1;\n\n\tret = ocfs2_claim_suballoc_bits(ac, handle, 1, 1, res);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac->ac_find_loc_priv = res;\n\t*fe_blkno = res->sr_blkno;\n\tocfs2_update_inode_fsync_trans(handle, dir, 0);\nout:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(dir->i_sb), handle);\n\n\tif (ret)\n\t\tkfree(res);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_save_inode_ac_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2059-2064",
    "snippet": "static inline void ocfs2_save_inode_ac_group(struct inode *dir,\n\t\t\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\tOCFS2_I(dir)->ip_last_used_group = ac->ac_last_group;\n\tOCFS2_I(dir)->ip_last_used_slot = ac->ac_alloc_slot;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic inline void ocfs2_save_inode_ac_group(struct inode *dir,\n\t\t\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\tOCFS2_I(dir)->ip_last_used_group = ac->ac_last_group;\n\tOCFS2_I(dir)->ip_last_used_slot = ac->ac_alloc_slot;\n}"
  },
  {
    "function_name": "ocfs2_init_inode_ac_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "2031-2057",
    "snippet": "static void ocfs2_init_inode_ac_group(struct inode *dir,\n\t\t\t\t      struct buffer_head *parent_di_bh,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_di_bh->b_data;\n\t/*\n\t * Try to allocate inodes from some specific group.\n\t *\n\t * If the parent dir has recorded the last group used in allocation,\n\t * cool, use it. Otherwise if we try to allocate new inode from the\n\t * same slot the parent dir belongs to, use the same chunk.\n\t *\n\t * We are very careful here to avoid the mistake of setting\n\t * ac_last_group to a group descriptor from a different (unlocked) slot.\n\t */\n\tif (OCFS2_I(dir)->ip_last_used_group &&\n\t    OCFS2_I(dir)->ip_last_used_slot == ac->ac_alloc_slot)\n\t\tac->ac_last_group = OCFS2_I(dir)->ip_last_used_group;\n\telse if (le16_to_cpu(di->i_suballoc_slot) == ac->ac_alloc_slot) {\n\t\tif (di->i_suballoc_loc)\n\t\t\tac->ac_last_group = le64_to_cpu(di->i_suballoc_loc);\n\t\telse\n\t\t\tac->ac_last_group = ocfs2_which_suballoc_group(\n\t\t\t\t\tle64_to_cpu(di->i_blkno),\n\t\t\t\t\tle16_to_cpu(di->i_suballoc_bit));\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "le64_to_cpu(di->i_blkno)",
            "le16_to_cpu(di->i_suballoc_bit)"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_suballoc_bit"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_blkno"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dir"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic void ocfs2_init_inode_ac_group(struct inode *dir,\n\t\t\t\t      struct buffer_head *parent_di_bh,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_di_bh->b_data;\n\t/*\n\t * Try to allocate inodes from some specific group.\n\t *\n\t * If the parent dir has recorded the last group used in allocation,\n\t * cool, use it. Otherwise if we try to allocate new inode from the\n\t * same slot the parent dir belongs to, use the same chunk.\n\t *\n\t * We are very careful here to avoid the mistake of setting\n\t * ac_last_group to a group descriptor from a different (unlocked) slot.\n\t */\n\tif (OCFS2_I(dir)->ip_last_used_group &&\n\t    OCFS2_I(dir)->ip_last_used_slot == ac->ac_alloc_slot)\n\t\tac->ac_last_group = OCFS2_I(dir)->ip_last_used_group;\n\telse if (le16_to_cpu(di->i_suballoc_slot) == ac->ac_alloc_slot) {\n\t\tif (di->i_suballoc_loc)\n\t\t\tac->ac_last_group = le64_to_cpu(di->i_suballoc_loc);\n\t\telse\n\t\t\tac->ac_last_group = ocfs2_which_suballoc_group(\n\t\t\t\t\tle64_to_cpu(di->i_blkno),\n\t\t\t\t\tle16_to_cpu(di->i_suballoc_bit));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_claim_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1993-2029",
    "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ac->ac_inode->i_sb"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_suballoc_bits",
          "args": [
            "ac",
            "handle",
            "bits_wanted",
            "1",
            "&res"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1883-1991",
          "snippet": "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_which != OCFS2_AC_USE_META"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted)"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ac"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_claim_suballoc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1883-1991",
    "snippet": "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_group_from_res",
          "args": [
            "res"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_from_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "71-80",
          "snippet": "static u64 ocfs2_group_from_res(struct ocfs2_suballoc_result *res)\n{\n\tif (res->sr_blkno == 0)\n\t\treturn 0;\n\n\tif (res->sr_bg_blkno)\n\t\treturn res->sr_bg_blkno;\n\n\treturn ocfs2_which_suballoc_group(res->sr_blkno, res->sr_bit_offset);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic u64 ocfs2_group_from_res(struct ocfs2_suballoc_result *res)\n{\n\tif (res->sr_blkno == 0)\n\t\treturn 0;\n\n\tif (res->sr_bg_blkno)\n\t\treturn res->sr_bg_blkno;\n\n\treturn ocfs2_which_suballoc_group(res->sr_blkno, res->sr_bit_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_chain",
          "args": [
            "ac",
            "handle",
            "bits_wanted",
            "min_bits",
            "res",
            "&bits_left"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1742-1880",
          "snippet": "static int ocfs2_search_chain(struct ocfs2_alloc_context *ac,\n\t\t\t      handle_t *handle,\n\t\t\t      u32 bits_wanted,\n\t\t\t      u32 min_bits,\n\t\t\t      struct ocfs2_suballoc_result *res,\n\t\t\t      u16 *bits_left)\n{\n\tint status;\n\tu16 chain;\n\tu64 next_group;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct buffer_head *prev_group_bh = NULL;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\tstruct ocfs2_group_desc *bg;\n\n\tchain = ac->ac_chain;\n\ttrace_ocfs2_search_chain_begin(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\tbits_wanted, chain);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t     le64_to_cpu(cl->cl_recs[chain].c_blkno),\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tstatus = -ENOSPC;\n\t/* for now, the chain search is a bit simplistic. We just use\n\t * the 1st group with any empty bits. */\n\twhile ((status = ac->ac_group_search(alloc_inode, group_bh,\n\t\t\t\t\t     bits_wanted, min_bits,\n\t\t\t\t\t     ac->ac_max_block,\n\t\t\t\t\t     res)) == -ENOSPC) {\n\t\tif (!bg->bg_next_group)\n\t\t\tbreak;\n\n\t\tbrelse(prev_group_bh);\n\t\tprev_group_bh = NULL;\n\n\t\tnext_group = le64_to_cpu(bg->bg_next_group);\n\t\tprev_group_bh = group_bh;\n\t\tgroup_bh = NULL;\n\t\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t\t     next_group, &group_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_succ(\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno), res->sr_bits);\n\n\tres->sr_bg_blkno = le64_to_cpu(bg->bg_blkno);\n\n\tBUG_ON(res->sr_bits == 0);\n\tif (!status)\n\t\tocfs2_bg_discontig_fix_result(ac, bg, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\t/*\n\t * Keep track of previous block descriptor read. When\n\t * we find a target, if we have read more than X\n\t * number of descriptors, and the target is reasonably\n\t * empty, relink him to top of his chain.\n\t *\n\t * We've read 0 extra blocks and only send one more to\n\t * the transaction, yet the next guy to search has a\n\t * much easier time.\n\t *\n\t * Do this *after* figuring out how many bits we're taking out\n\t * of our target group.\n\t */\n\tif (!ac->ac_disable_chain_relink &&\n\t    (prev_group_bh) &&\n\t    (ocfs2_block_group_reasonably_empty(bg, res->sr_bits))) {\n\t\tstatus = ocfs2_relink_block_group(handle, alloc_inode,\n\t\t\t\t\t\t  ac->ac_bh, group_bh,\n\t\t\t\t\t\t  prev_group_bh, chain);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tstatus = ocfs2_alloc_dinode_update_counts(alloc_inode, handle,\n\t\t\t\t\t\t  ac->ac_bh, res->sr_bits,\n\t\t\t\t\t\t  chain);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t    alloc_inode,\n\t\t\t\t\t    bg,\n\t\t\t\t\t    group_bh,\n\t\t\t\t\t    res->sr_bit_offset,\n\t\t\t\t\t    res->sr_bits);\n\tif (status < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode,\n\t\t\t\t\tac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_end(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\tres->sr_bits);\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(bg->bg_free_bits_count);\nbail:\n\tbrelse(group_bh);\n\tbrelse(prev_group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_search_chain(struct ocfs2_alloc_context *ac,\n\t\t\t      handle_t *handle,\n\t\t\t      u32 bits_wanted,\n\t\t\t      u32 min_bits,\n\t\t\t      struct ocfs2_suballoc_result *res,\n\t\t\t      u16 *bits_left)\n{\n\tint status;\n\tu16 chain;\n\tu64 next_group;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct buffer_head *prev_group_bh = NULL;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\tstruct ocfs2_group_desc *bg;\n\n\tchain = ac->ac_chain;\n\ttrace_ocfs2_search_chain_begin(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\tbits_wanted, chain);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t     le64_to_cpu(cl->cl_recs[chain].c_blkno),\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tstatus = -ENOSPC;\n\t/* for now, the chain search is a bit simplistic. We just use\n\t * the 1st group with any empty bits. */\n\twhile ((status = ac->ac_group_search(alloc_inode, group_bh,\n\t\t\t\t\t     bits_wanted, min_bits,\n\t\t\t\t\t     ac->ac_max_block,\n\t\t\t\t\t     res)) == -ENOSPC) {\n\t\tif (!bg->bg_next_group)\n\t\t\tbreak;\n\n\t\tbrelse(prev_group_bh);\n\t\tprev_group_bh = NULL;\n\n\t\tnext_group = le64_to_cpu(bg->bg_next_group);\n\t\tprev_group_bh = group_bh;\n\t\tgroup_bh = NULL;\n\t\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t\t     next_group, &group_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_succ(\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno), res->sr_bits);\n\n\tres->sr_bg_blkno = le64_to_cpu(bg->bg_blkno);\n\n\tBUG_ON(res->sr_bits == 0);\n\tif (!status)\n\t\tocfs2_bg_discontig_fix_result(ac, bg, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\t/*\n\t * Keep track of previous block descriptor read. When\n\t * we find a target, if we have read more than X\n\t * number of descriptors, and the target is reasonably\n\t * empty, relink him to top of his chain.\n\t *\n\t * We've read 0 extra blocks and only send one more to\n\t * the transaction, yet the next guy to search has a\n\t * much easier time.\n\t *\n\t * Do this *after* figuring out how many bits we're taking out\n\t * of our target group.\n\t */\n\tif (!ac->ac_disable_chain_relink &&\n\t    (prev_group_bh) &&\n\t    (ocfs2_block_group_reasonably_empty(bg, res->sr_bits))) {\n\t\tstatus = ocfs2_relink_block_group(handle, alloc_inode,\n\t\t\t\t\t\t  ac->ac_bh, group_bh,\n\t\t\t\t\t\t  prev_group_bh, chain);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tstatus = ocfs2_alloc_dinode_update_counts(alloc_inode, handle,\n\t\t\t\t\t\t  ac->ac_bh, res->sr_bits,\n\t\t\t\t\t\t  chain);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t    alloc_inode,\n\t\t\t\t\t    bg,\n\t\t\t\t\t    group_bh,\n\t\t\t\t\t    res->sr_bit_offset,\n\t\t\t\t\t    res->sr_bits);\n\tif (status < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode,\n\t\t\t\t\tac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_end(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\tres->sr_bits);\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(bg->bg_free_bits_count);\nbail:\n\tbrelse(group_bh);\n\tbrelse(prev_group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_next_free_rec"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_claim_suballoc_bits",
          "args": [
            "victim"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_victim_chain",
          "args": [
            "cl"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_victim_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1390-1406",
          "snippet": "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tBUG_ON(!cl->cl_next_free_rec);\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tif (le32_to_cpu(cl->cl_recs[curr].c_free) >\n\t\t    le32_to_cpu(cl->cl_recs[best].c_free))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\n\tBUG_ON(best >= le16_to_cpu(cl->cl_next_free_rec));\n\treturn best;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tBUG_ON(!cl->cl_next_free_rec);\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tif (le32_to_cpu(cl->cl_recs[curr].c_free) >\n\t\t    le32_to_cpu(cl->cl_recs[best].c_free))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\n\tBUG_ON(best >= le16_to_cpu(cl->cl_next_free_rec));\n\treturn best;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_one_group",
          "args": [
            "ac",
            "handle",
            "bits_wanted",
            "min_bits",
            "res",
            "&bits_left"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_one_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1675-1740",
          "snippet": "static int ocfs2_search_one_group(struct ocfs2_alloc_context *ac,\n\t\t\t\t  handle_t *handle,\n\t\t\t\t  u32 bits_wanted,\n\t\t\t\t  u32 min_bits,\n\t\t\t\t  struct ocfs2_suballoc_result *res,\n\t\t\t\t  u16 *bits_left)\n{\n\tint ret;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\n\tret = ocfs2_read_group_descriptor(alloc_inode, di,\n\t\t\t\t\t  res->sr_bg_blkno, &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tgd = (struct ocfs2_group_desc *) group_bh->b_data;\n\tret = ac->ac_group_search(alloc_inode, group_bh, bits_wanted, min_bits,\n\t\t\t\t  ac->ac_max_block, res);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ret)\n\t\tocfs2_bg_discontig_fix_result(ac, gd, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tret = ocfs2_alloc_dinode_update_counts(alloc_inode, handle, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, alloc_inode, gd, group_bh,\n\t\t\t\t\t res->sr_bit_offset, res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(gd->bg_free_bits_count);\n\nout:\n\tbrelse(group_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_search_one_group(struct ocfs2_alloc_context *ac,\n\t\t\t\t  handle_t *handle,\n\t\t\t\t  u32 bits_wanted,\n\t\t\t\t  u32 min_bits,\n\t\t\t\t  struct ocfs2_suballoc_result *res,\n\t\t\t\t  u16 *bits_left)\n{\n\tint ret;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\n\tret = ocfs2_read_group_descriptor(alloc_inode, di,\n\t\t\t\t\t  res->sr_bg_blkno, &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tgd = (struct ocfs2_group_desc *) group_bh->b_data;\n\tret = ac->ac_group_search(alloc_inode, group_bh, bits_wanted, min_bits,\n\t\t\t\t  ac->ac_max_block, res);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ret)\n\t\tocfs2_bg_discontig_fix_result(ac, gd, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tret = ocfs2_alloc_dinode_update_counts(alloc_inode, handle, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, alloc_inode, gd, group_bh,\n\t\t\t\t\t res->sr_bit_offset, res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(gd->bg_free_bits_count);\n\nout:\n\tbrelse(group_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ac->ac_inode->i_sb",
            "\"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\"",
            "(unsigned long long)le64_to_cpu(fe->i_blkno)",
            "le32_to_cpu(fe->id1.bitmap1.i_used)",
            "le32_to_cpu(fe->id1.bitmap1.i_total)"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->id1.bitmap1.i_total"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_blkno"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(fe)"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "fe"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ac->ac_bh"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given)"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_bits_given >= ac->ac_bits_wanted"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tint status;\n\tu16 victim, i;\n\tu16 bits_left = 0;\n\tu64 hint = ac->ac_last_group;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_dinode *fe;\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\tBUG_ON(bits_wanted > (ac->ac_bits_wanted - ac->ac_bits_given));\n\tBUG_ON(!ac->ac_bh);\n\n\tfe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\n\t/* The bh was validated by the inode read during\n\t * ocfs2_reserve_suballoc_bits().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le32_to_cpu(fe->id1.bitmap1.i_used) >=\n\t    le32_to_cpu(fe->id1.bitmap1.i_total)) {\n\t\tocfs2_error(ac->ac_inode->i_sb,\n\t\t\t    \"Chain allocator dinode %llu has %u used \"\n\t\t\t    \"bits but only %u total.\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_used),\n\t\t\t    le32_to_cpu(fe->id1.bitmap1.i_total));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tres->sr_bg_blkno = hint;\n\tif (res->sr_bg_blkno) {\n\t\t/* Attempt to short-circuit the usual search mechanism\n\t\t * by jumping straight to the most recently used\n\t\t * allocation group. This helps us maintain some\n\t\t * contiguousness across allocations. */\n\t\tstatus = ocfs2_search_one_group(ac, handle, bits_wanted,\n\t\t\t\t\t\tmin_bits, res, &bits_left);\n\t\tif (!status)\n\t\t\tgoto set_hint;\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tcl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\n\tvictim = ocfs2_find_victim_chain(cl);\n\tac->ac_chain = victim;\n\n\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t    res, &bits_left);\n\tif (!status) {\n\t\thint = ocfs2_group_from_res(res);\n\t\tgoto set_hint;\n\t}\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_claim_suballoc_bits(victim);\n\n\t/* If we didn't pick a good victim, then just default to\n\t * searching each chain in order. Don't allow chain relinking\n\t * because we only calculate enough journal credits for one\n\t * relink per alloc. */\n\tac->ac_disable_chain_relink = 1;\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i ++) {\n\t\tif (i == victim)\n\t\t\tcontinue;\n\t\tif (!cl->cl_recs[i].c_free)\n\t\t\tcontinue;\n\n\t\tac->ac_chain = i;\n\t\tstatus = ocfs2_search_chain(ac, handle, bits_wanted, min_bits,\n\t\t\t\t\t    res, &bits_left);\n\t\tif (!status) {\n\t\t\thint = ocfs2_group_from_res(res);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0 && status != -ENOSPC) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nset_hint:\n\tif (status != -ENOSPC) {\n\t\t/* If the next search of this group is not likely to\n\t\t * yield a suitable extent, then we reset the last\n\t\t * group hint so as to not waste a disk read */\n\t\tif (bits_left < min_bits)\n\t\t\tac->ac_last_group = 0;\n\t\telse\n\t\t\tac->ac_last_group = hint;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_search_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1742-1880",
    "snippet": "static int ocfs2_search_chain(struct ocfs2_alloc_context *ac,\n\t\t\t      handle_t *handle,\n\t\t\t      u32 bits_wanted,\n\t\t\t      u32 min_bits,\n\t\t\t      struct ocfs2_suballoc_result *res,\n\t\t\t      u16 *bits_left)\n{\n\tint status;\n\tu16 chain;\n\tu64 next_group;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct buffer_head *prev_group_bh = NULL;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\tstruct ocfs2_group_desc *bg;\n\n\tchain = ac->ac_chain;\n\ttrace_ocfs2_search_chain_begin(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\tbits_wanted, chain);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t     le64_to_cpu(cl->cl_recs[chain].c_blkno),\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tstatus = -ENOSPC;\n\t/* for now, the chain search is a bit simplistic. We just use\n\t * the 1st group with any empty bits. */\n\twhile ((status = ac->ac_group_search(alloc_inode, group_bh,\n\t\t\t\t\t     bits_wanted, min_bits,\n\t\t\t\t\t     ac->ac_max_block,\n\t\t\t\t\t     res)) == -ENOSPC) {\n\t\tif (!bg->bg_next_group)\n\t\t\tbreak;\n\n\t\tbrelse(prev_group_bh);\n\t\tprev_group_bh = NULL;\n\n\t\tnext_group = le64_to_cpu(bg->bg_next_group);\n\t\tprev_group_bh = group_bh;\n\t\tgroup_bh = NULL;\n\t\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t\t     next_group, &group_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_succ(\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno), res->sr_bits);\n\n\tres->sr_bg_blkno = le64_to_cpu(bg->bg_blkno);\n\n\tBUG_ON(res->sr_bits == 0);\n\tif (!status)\n\t\tocfs2_bg_discontig_fix_result(ac, bg, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\t/*\n\t * Keep track of previous block descriptor read. When\n\t * we find a target, if we have read more than X\n\t * number of descriptors, and the target is reasonably\n\t * empty, relink him to top of his chain.\n\t *\n\t * We've read 0 extra blocks and only send one more to\n\t * the transaction, yet the next guy to search has a\n\t * much easier time.\n\t *\n\t * Do this *after* figuring out how many bits we're taking out\n\t * of our target group.\n\t */\n\tif (!ac->ac_disable_chain_relink &&\n\t    (prev_group_bh) &&\n\t    (ocfs2_block_group_reasonably_empty(bg, res->sr_bits))) {\n\t\tstatus = ocfs2_relink_block_group(handle, alloc_inode,\n\t\t\t\t\t\t  ac->ac_bh, group_bh,\n\t\t\t\t\t\t  prev_group_bh, chain);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tstatus = ocfs2_alloc_dinode_update_counts(alloc_inode, handle,\n\t\t\t\t\t\t  ac->ac_bh, res->sr_bits,\n\t\t\t\t\t\t  chain);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t    alloc_inode,\n\t\t\t\t\t    bg,\n\t\t\t\t\t    group_bh,\n\t\t\t\t\t    res->sr_bit_offset,\n\t\t\t\t\t    res->sr_bits);\n\tif (status < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode,\n\t\t\t\t\tac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_end(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\tres->sr_bits);\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(bg->bg_free_bits_count);\nbail:\n\tbrelse(group_bh);\n\tbrelse(prev_group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "prev_group_bh"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_free_bits_count"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_search_chain_end",
          "args": [
            "(unsigned long long)le64_to_cpu(fe->i_blkno)",
            "res->sr_bits"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_blkno"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rollback_alloc_dinode_counts",
          "args": [
            "alloc_inode",
            "ac->ac_bh",
            "res->sr_bits",
            "chain"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rollback_alloc_dinode_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1611-1624",
          "snippet": "void ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nvoid ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_set_bits",
          "args": [
            "handle",
            "alloc_inode",
            "bg",
            "group_bh",
            "res->sr_bit_offset",
            "res->sr_bits"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1341-1387",
          "snippet": "int ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nint ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_dinode_update_counts",
          "args": [
            "alloc_inode",
            "handle",
            "ac->ac_bh",
            "res->sr_bits",
            "chain"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_dinode_update_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1584-1609",
          "snippet": "int ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nint ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_relink_block_group",
          "args": [
            "handle",
            "alloc_inode",
            "ac->ac_bh",
            "group_bh",
            "prev_group_bh",
            "chain"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_relink_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1408-1471",
          "snippet": "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain)\n{\n\tint status;\n\t/* there is a really tiny chance the journal calls could fail,\n\t * but we wouldn't want inconsistent blocks in *any* case. */\n\tu64 bg_ptr, prev_bg_ptr;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct ocfs2_group_desc *prev_bg = (struct ocfs2_group_desc *) prev_bg_bh->b_data;\n\n\t/* The caller got these descriptors from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(prev_bg));\n\n\ttrace_ocfs2_relink_block_group(\n\t\t(unsigned long long)le64_to_cpu(fe->i_blkno), chain,\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t(unsigned long long)le64_to_cpu(prev_bg->bg_blkno));\n\n\tbg_ptr = le64_to_cpu(bg->bg_next_group);\n\tprev_bg_ptr = le64_to_cpu(prev_bg->bg_next_group);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t prev_bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out;\n\n\tprev_bg->bg_next_group = bg->bg_next_group;\n\tocfs2_journal_dirty(handle, prev_bg_bh);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_prev_bg;\n\n\tbg->bg_next_group = fe->id2.i_chain.cl_recs[chain].c_blkno;\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t fe_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_bg;\n\n\tfe->id2.i_chain.cl_recs[chain].c_blkno = bg->bg_blkno;\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n\nout_rollback_bg:\n\tbg->bg_next_group = cpu_to_le64(bg_ptr);\nout_rollback_prev_bg:\n\tprev_bg->bg_next_group = cpu_to_le64(prev_bg_ptr);\n\tgoto out;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain)\n{\n\tint status;\n\t/* there is a really tiny chance the journal calls could fail,\n\t * but we wouldn't want inconsistent blocks in *any* case. */\n\tu64 bg_ptr, prev_bg_ptr;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct ocfs2_group_desc *prev_bg = (struct ocfs2_group_desc *) prev_bg_bh->b_data;\n\n\t/* The caller got these descriptors from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(prev_bg));\n\n\ttrace_ocfs2_relink_block_group(\n\t\t(unsigned long long)le64_to_cpu(fe->i_blkno), chain,\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t(unsigned long long)le64_to_cpu(prev_bg->bg_blkno));\n\n\tbg_ptr = le64_to_cpu(bg->bg_next_group);\n\tprev_bg_ptr = le64_to_cpu(prev_bg->bg_next_group);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t prev_bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out;\n\n\tprev_bg->bg_next_group = bg->bg_next_group;\n\tocfs2_journal_dirty(handle, prev_bg_bh);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_prev_bg;\n\n\tbg->bg_next_group = fe->id2.i_chain.cl_recs[chain].c_blkno;\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t fe_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_bg;\n\n\tfe->id2.i_chain.cl_recs[chain].c_blkno = bg->bg_blkno;\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n\nout_rollback_bg:\n\tbg->bg_next_group = cpu_to_le64(bg_ptr);\nout_rollback_prev_bg:\n\tprev_bg->bg_next_group = cpu_to_le64(prev_bg_ptr);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_reasonably_empty",
          "args": [
            "bg",
            "res->sr_bits"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_reasonably_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1473-1477",
          "snippet": "static inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted)\n{\n\treturn le16_to_cpu(bg->bg_free_bits_count) > wanted;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted);\n\nstatic inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted)\n{\n\treturn le16_to_cpu(bg->bg_free_bits_count) > wanted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bg_discontig_fix_result",
          "args": [
            "ac",
            "bg",
            "res"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bg_discontig_fix_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1645-1673",
          "snippet": "static void ocfs2_bg_discontig_fix_result(struct ocfs2_alloc_context *ac,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_suballoc_result *res)\n{\n\tint i;\n\tu64 bg_blkno = res->sr_bg_blkno;  /* Save off */\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &di->id2.i_chain;\n\n\tif (ocfs2_is_cluster_bitmap(ac->ac_inode)) {\n\t\tres->sr_blkno = 0;\n\t\treturn;\n\t}\n\n\tres->sr_blkno = res->sr_bg_blkno + res->sr_bit_offset;\n\tres->sr_bg_blkno = 0;  /* Clear it for contig block groups */\n\tif (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||\n\t    !bg->bg_list.l_next_free_rec)\n\t\treturn;\n\n\tfor (i = 0; i < le16_to_cpu(bg->bg_list.l_next_free_rec); i++) {\n\t\trec = &bg->bg_list.l_recs[i];\n\t\tif (ocfs2_bg_discontig_fix_by_rec(res, rec, cl)) {\n\t\t\tres->sr_bg_blkno = bg_blkno;  /* Restore */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic void ocfs2_bg_discontig_fix_result(struct ocfs2_alloc_context *ac,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_suballoc_result *res)\n{\n\tint i;\n\tu64 bg_blkno = res->sr_bg_blkno;  /* Save off */\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &di->id2.i_chain;\n\n\tif (ocfs2_is_cluster_bitmap(ac->ac_inode)) {\n\t\tres->sr_blkno = 0;\n\t\treturn;\n\t}\n\n\tres->sr_blkno = res->sr_bg_blkno + res->sr_bit_offset;\n\tres->sr_bg_blkno = 0;  /* Clear it for contig block groups */\n\tif (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||\n\t    !bg->bg_list.l_next_free_rec)\n\t\treturn;\n\n\tfor (i = 0; i < le16_to_cpu(bg->bg_list.l_next_free_rec); i++) {\n\t\trec = &bg->bg_list.l_recs[i];\n\t\tif (ocfs2_bg_discontig_fix_by_rec(res, rec, cl)) {\n\t\t\tres->sr_bg_blkno = bg_blkno;  /* Restore */\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->sr_bits == 0"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_search_chain_succ",
          "args": [
            "(unsigned long long)le64_to_cpu(bg->bg_blkno)",
            "res->sr_bits"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "alloc_inode",
            "fe",
            "next_group",
            "&group_bh"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac->ac_group_search",
          "args": [
            "alloc_inode",
            "group_bh",
            "bits_wanted",
            "min_bits",
            "ac->ac_max_block",
            "res"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_search_chain_begin",
          "args": [
            "(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno",
            "bits_wanted",
            "chain"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "alloc_inode"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_search_chain(struct ocfs2_alloc_context *ac,\n\t\t\t      handle_t *handle,\n\t\t\t      u32 bits_wanted,\n\t\t\t      u32 min_bits,\n\t\t\t      struct ocfs2_suballoc_result *res,\n\t\t\t      u16 *bits_left)\n{\n\tint status;\n\tu16 chain;\n\tu64 next_group;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct buffer_head *prev_group_bh = NULL;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &fe->id2.i_chain;\n\tstruct ocfs2_group_desc *bg;\n\n\tchain = ac->ac_chain;\n\ttrace_ocfs2_search_chain_begin(\n\t\t(unsigned long long)OCFS2_I(alloc_inode)->ip_blkno,\n\t\tbits_wanted, chain);\n\n\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t     le64_to_cpu(cl->cl_recs[chain].c_blkno),\n\t\t\t\t\t     &group_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tstatus = -ENOSPC;\n\t/* for now, the chain search is a bit simplistic. We just use\n\t * the 1st group with any empty bits. */\n\twhile ((status = ac->ac_group_search(alloc_inode, group_bh,\n\t\t\t\t\t     bits_wanted, min_bits,\n\t\t\t\t\t     ac->ac_max_block,\n\t\t\t\t\t     res)) == -ENOSPC) {\n\t\tif (!bg->bg_next_group)\n\t\t\tbreak;\n\n\t\tbrelse(prev_group_bh);\n\t\tprev_group_bh = NULL;\n\n\t\tnext_group = le64_to_cpu(bg->bg_next_group);\n\t\tprev_group_bh = group_bh;\n\t\tgroup_bh = NULL;\n\t\tstatus = ocfs2_read_group_descriptor(alloc_inode, fe,\n\t\t\t\t\t\t     next_group, &group_bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tbg = (struct ocfs2_group_desc *) group_bh->b_data;\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_succ(\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno), res->sr_bits);\n\n\tres->sr_bg_blkno = le64_to_cpu(bg->bg_blkno);\n\n\tBUG_ON(res->sr_bits == 0);\n\tif (!status)\n\t\tocfs2_bg_discontig_fix_result(ac, bg, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\t/*\n\t * Keep track of previous block descriptor read. When\n\t * we find a target, if we have read more than X\n\t * number of descriptors, and the target is reasonably\n\t * empty, relink him to top of his chain.\n\t *\n\t * We've read 0 extra blocks and only send one more to\n\t * the transaction, yet the next guy to search has a\n\t * much easier time.\n\t *\n\t * Do this *after* figuring out how many bits we're taking out\n\t * of our target group.\n\t */\n\tif (!ac->ac_disable_chain_relink &&\n\t    (prev_group_bh) &&\n\t    (ocfs2_block_group_reasonably_empty(bg, res->sr_bits))) {\n\t\tstatus = ocfs2_relink_block_group(handle, alloc_inode,\n\t\t\t\t\t\t  ac->ac_bh, group_bh,\n\t\t\t\t\t\t  prev_group_bh, chain);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tstatus = ocfs2_alloc_dinode_update_counts(alloc_inode, handle,\n\t\t\t\t\t\t  ac->ac_bh, res->sr_bits,\n\t\t\t\t\t\t  chain);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_set_bits(handle,\n\t\t\t\t\t    alloc_inode,\n\t\t\t\t\t    bg,\n\t\t\t\t\t    group_bh,\n\t\t\t\t\t    res->sr_bit_offset,\n\t\t\t\t\t    res->sr_bits);\n\tif (status < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode,\n\t\t\t\t\tac->ac_bh, res->sr_bits, chain);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_search_chain_end(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_blkno),\n\t\t\tres->sr_bits);\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(bg->bg_free_bits_count);\nbail:\n\tbrelse(group_bh);\n\tbrelse(prev_group_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_search_one_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1675-1740",
    "snippet": "static int ocfs2_search_one_group(struct ocfs2_alloc_context *ac,\n\t\t\t\t  handle_t *handle,\n\t\t\t\t  u32 bits_wanted,\n\t\t\t\t  u32 min_bits,\n\t\t\t\t  struct ocfs2_suballoc_result *res,\n\t\t\t\t  u16 *bits_left)\n{\n\tint ret;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\n\tret = ocfs2_read_group_descriptor(alloc_inode, di,\n\t\t\t\t\t  res->sr_bg_blkno, &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tgd = (struct ocfs2_group_desc *) group_bh->b_data;\n\tret = ac->ac_group_search(alloc_inode, group_bh, bits_wanted, min_bits,\n\t\t\t\t  ac->ac_max_block, res);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ret)\n\t\tocfs2_bg_discontig_fix_result(ac, gd, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tret = ocfs2_alloc_dinode_update_counts(alloc_inode, handle, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, alloc_inode, gd, group_bh,\n\t\t\t\t\t res->sr_bit_offset, res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(gd->bg_free_bits_count);\n\nout:\n\tbrelse(group_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "group_bh"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_free_bits_count"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rollback_alloc_dinode_counts",
          "args": [
            "alloc_inode",
            "ac->ac_bh",
            "res->sr_bits",
            "le16_to_cpu(gd->bg_chain)"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rollback_alloc_dinode_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1611-1624",
          "snippet": "void ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nvoid ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_set_bits",
          "args": [
            "handle",
            "alloc_inode",
            "gd",
            "group_bh",
            "res->sr_bit_offset",
            "res->sr_bits"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1341-1387",
          "snippet": "int ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nint ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_dinode_update_counts",
          "args": [
            "alloc_inode",
            "handle",
            "ac->ac_bh",
            "res->sr_bits",
            "le16_to_cpu(gd->bg_chain)"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_dinode_update_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1584-1609",
          "snippet": "int ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nint ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bg_discontig_fix_result",
          "args": [
            "ac",
            "gd",
            "res"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bg_discontig_fix_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1645-1673",
          "snippet": "static void ocfs2_bg_discontig_fix_result(struct ocfs2_alloc_context *ac,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_suballoc_result *res)\n{\n\tint i;\n\tu64 bg_blkno = res->sr_bg_blkno;  /* Save off */\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &di->id2.i_chain;\n\n\tif (ocfs2_is_cluster_bitmap(ac->ac_inode)) {\n\t\tres->sr_blkno = 0;\n\t\treturn;\n\t}\n\n\tres->sr_blkno = res->sr_bg_blkno + res->sr_bit_offset;\n\tres->sr_bg_blkno = 0;  /* Clear it for contig block groups */\n\tif (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||\n\t    !bg->bg_list.l_next_free_rec)\n\t\treturn;\n\n\tfor (i = 0; i < le16_to_cpu(bg->bg_list.l_next_free_rec); i++) {\n\t\trec = &bg->bg_list.l_recs[i];\n\t\tif (ocfs2_bg_discontig_fix_by_rec(res, rec, cl)) {\n\t\t\tres->sr_bg_blkno = bg_blkno;  /* Restore */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic void ocfs2_bg_discontig_fix_result(struct ocfs2_alloc_context *ac,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_suballoc_result *res)\n{\n\tint i;\n\tu64 bg_blkno = res->sr_bg_blkno;  /* Save off */\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &di->id2.i_chain;\n\n\tif (ocfs2_is_cluster_bitmap(ac->ac_inode)) {\n\t\tres->sr_blkno = 0;\n\t\treturn;\n\t}\n\n\tres->sr_blkno = res->sr_bg_blkno + res->sr_bit_offset;\n\tres->sr_bg_blkno = 0;  /* Clear it for contig block groups */\n\tif (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||\n\t    !bg->bg_list.l_next_free_rec)\n\t\treturn;\n\n\tfor (i = 0; i < le16_to_cpu(bg->bg_list.l_next_free_rec); i++) {\n\t\trec = &bg->bg_list.l_recs[i];\n\t\tif (ocfs2_bg_discontig_fix_by_rec(res, rec, cl)) {\n\t\t\tres->sr_bg_blkno = bg_blkno;  /* Restore */\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ac->ac_group_search",
          "args": [
            "alloc_inode",
            "group_bh",
            "bits_wanted",
            "min_bits",
            "ac->ac_max_block",
            "res"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "alloc_inode",
            "di",
            "res->sr_bg_blkno",
            "&group_bh"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_search_one_group(struct ocfs2_alloc_context *ac,\n\t\t\t\t  handle_t *handle,\n\t\t\t\t  u32 bits_wanted,\n\t\t\t\t  u32 min_bits,\n\t\t\t\t  struct ocfs2_suballoc_result *res,\n\t\t\t\t  u16 *bits_left)\n{\n\tint ret;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct inode *alloc_inode = ac->ac_inode;\n\n\tret = ocfs2_read_group_descriptor(alloc_inode, di,\n\t\t\t\t\t  res->sr_bg_blkno, &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tgd = (struct ocfs2_group_desc *) group_bh->b_data;\n\tret = ac->ac_group_search(alloc_inode, group_bh, bits_wanted, min_bits,\n\t\t\t\t  ac->ac_max_block, res);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!ret)\n\t\tocfs2_bg_discontig_fix_result(ac, gd, res);\n\n\t/*\n\t * sr_bg_blkno might have been changed by\n\t * ocfs2_bg_discontig_fix_result\n\t */\n\tres->sr_bg_stable_blkno = group_bh->b_blocknr;\n\n\tif (ac->ac_find_loc_only)\n\t\tgoto out_loc_only;\n\n\tret = ocfs2_alloc_dinode_update_counts(alloc_inode, handle, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, alloc_inode, gd, group_bh,\n\t\t\t\t\t res->sr_bit_offset, res->sr_bits);\n\tif (ret < 0) {\n\t\tocfs2_rollback_alloc_dinode_counts(alloc_inode, ac->ac_bh,\n\t\t\t\t\t       res->sr_bits,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\nout_loc_only:\n\t*bits_left = le16_to_cpu(gd->bg_free_bits_count);\n\nout:\n\tbrelse(group_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_bg_discontig_fix_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1645-1673",
    "snippet": "static void ocfs2_bg_discontig_fix_result(struct ocfs2_alloc_context *ac,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_suballoc_result *res)\n{\n\tint i;\n\tu64 bg_blkno = res->sr_bg_blkno;  /* Save off */\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &di->id2.i_chain;\n\n\tif (ocfs2_is_cluster_bitmap(ac->ac_inode)) {\n\t\tres->sr_blkno = 0;\n\t\treturn;\n\t}\n\n\tres->sr_blkno = res->sr_bg_blkno + res->sr_bit_offset;\n\tres->sr_bg_blkno = 0;  /* Clear it for contig block groups */\n\tif (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||\n\t    !bg->bg_list.l_next_free_rec)\n\t\treturn;\n\n\tfor (i = 0; i < le16_to_cpu(bg->bg_list.l_next_free_rec); i++) {\n\t\trec = &bg->bg_list.l_recs[i];\n\t\tif (ocfs2_bg_discontig_fix_by_rec(res, rec, cl)) {\n\t\t\tres->sr_bg_blkno = bg_blkno;  /* Restore */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_bg_discontig_fix_by_rec",
          "args": [
            "res",
            "rec",
            "cl"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bg_discontig_fix_by_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1626-1643",
          "snippet": "static int ocfs2_bg_discontig_fix_by_rec(struct ocfs2_suballoc_result *res,\n\t\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t\t struct ocfs2_chain_list *cl)\n{\n\tunsigned int bpc = le16_to_cpu(cl->cl_bpc);\n\tunsigned int bitoff = le32_to_cpu(rec->e_cpos) * bpc;\n\tunsigned int bitcount = le16_to_cpu(rec->e_leaf_clusters) * bpc;\n\n\tif (res->sr_bit_offset < bitoff)\n\t\treturn 0;\n\tif (res->sr_bit_offset >= (bitoff + bitcount))\n\t\treturn 0;\n\tres->sr_blkno = le64_to_cpu(rec->e_blkno) +\n\t\t(res->sr_bit_offset - bitoff);\n\tif ((res->sr_bit_offset + res->sr_bits) > (bitoff + bitcount))\n\t\tres->sr_bits = (bitoff + bitcount) - res->sr_bit_offset;\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_bg_discontig_fix_by_rec(struct ocfs2_suballoc_result *res,\n\t\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t\t struct ocfs2_chain_list *cl)\n{\n\tunsigned int bpc = le16_to_cpu(cl->cl_bpc);\n\tunsigned int bitoff = le32_to_cpu(rec->e_cpos) * bpc;\n\tunsigned int bitcount = le16_to_cpu(rec->e_leaf_clusters) * bpc;\n\n\tif (res->sr_bit_offset < bitoff)\n\t\treturn 0;\n\tif (res->sr_bit_offset >= (bitoff + bitcount))\n\t\treturn 0;\n\tres->sr_blkno = le64_to_cpu(rec->e_blkno) +\n\t\t(res->sr_bit_offset - bitoff);\n\tif ((res->sr_bit_offset + res->sr_bits) > (bitoff + bitcount))\n\t\tres->sr_bits = (bitoff + bitcount) - res->sr_bit_offset;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_list.l_next_free_rec"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_discontig_bg",
          "args": [
            "OCFS2_SB(ac->ac_inode->i_sb)"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_discontig_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "539-544",
          "snippet": "static inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ac->ac_inode->i_sb"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "ac->ac_inode"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic void ocfs2_bg_discontig_fix_result(struct ocfs2_alloc_context *ac,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_suballoc_result *res)\n{\n\tint i;\n\tu64 bg_blkno = res->sr_bg_blkno;  /* Save off */\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)ac->ac_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &di->id2.i_chain;\n\n\tif (ocfs2_is_cluster_bitmap(ac->ac_inode)) {\n\t\tres->sr_blkno = 0;\n\t\treturn;\n\t}\n\n\tres->sr_blkno = res->sr_bg_blkno + res->sr_bit_offset;\n\tres->sr_bg_blkno = 0;  /* Clear it for contig block groups */\n\tif (!ocfs2_supports_discontig_bg(OCFS2_SB(ac->ac_inode->i_sb)) ||\n\t    !bg->bg_list.l_next_free_rec)\n\t\treturn;\n\n\tfor (i = 0; i < le16_to_cpu(bg->bg_list.l_next_free_rec); i++) {\n\t\trec = &bg->bg_list.l_recs[i];\n\t\tif (ocfs2_bg_discontig_fix_by_rec(res, rec, cl)) {\n\t\t\tres->sr_bg_blkno = bg_blkno;  /* Restore */\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ocfs2_bg_discontig_fix_by_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1626-1643",
    "snippet": "static int ocfs2_bg_discontig_fix_by_rec(struct ocfs2_suballoc_result *res,\n\t\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t\t struct ocfs2_chain_list *cl)\n{\n\tunsigned int bpc = le16_to_cpu(cl->cl_bpc);\n\tunsigned int bitoff = le32_to_cpu(rec->e_cpos) * bpc;\n\tunsigned int bitcount = le16_to_cpu(rec->e_leaf_clusters) * bpc;\n\n\tif (res->sr_bit_offset < bitoff)\n\t\treturn 0;\n\tif (res->sr_bit_offset >= (bitoff + bitcount))\n\t\treturn 0;\n\tres->sr_blkno = le64_to_cpu(rec->e_blkno) +\n\t\t(res->sr_bit_offset - bitoff);\n\tif ((res->sr_bit_offset + res->sr_bits) > (bitoff + bitcount))\n\t\tres->sr_bits = (bitoff + bitcount) - res->sr_bit_offset;\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_bg_discontig_fix_by_rec(struct ocfs2_suballoc_result *res,\n\t\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t\t struct ocfs2_chain_list *cl)\n{\n\tunsigned int bpc = le16_to_cpu(cl->cl_bpc);\n\tunsigned int bitoff = le32_to_cpu(rec->e_cpos) * bpc;\n\tunsigned int bitcount = le16_to_cpu(rec->e_leaf_clusters) * bpc;\n\n\tif (res->sr_bit_offset < bitoff)\n\t\treturn 0;\n\tif (res->sr_bit_offset >= (bitoff + bitcount))\n\t\treturn 0;\n\tres->sr_blkno = le64_to_cpu(rec->e_blkno) +\n\t\t(res->sr_bit_offset - bitoff);\n\tif ((res->sr_bit_offset + res->sr_bits) > (bitoff + bitcount))\n\t\tres->sr_bits = (bitoff + bitcount) - res->sr_bit_offset;\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_rollback_alloc_dinode_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1611-1624",
    "snippet": "void ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cl->cl_recs[chain].c_free",
            "num_bits"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tmp_used - num_bits"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id1.bitmap1.i_used"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nvoid ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}"
  },
  {
    "function_name": "ocfs2_alloc_dinode_update_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1584-1609",
    "snippet": "int ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cl->cl_recs[chain].c_free",
            "-num_bits"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_bits + tmp_used"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id1.bitmap1.i_used"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nint ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_block_group_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1552-1582",
    "snippet": "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res)\n{\n\tint ret = -ENOSPC;\n\tu64 blkoff;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON(min_bits != 1);\n\tBUG_ON(ocfs2_is_cluster_bitmap(inode));\n\n\tif (bg->bg_free_bits_count) {\n\t\tret = ocfs2_block_group_find_clear_bits(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tgroup_bh, bits_wanted,\n\t\t\t\t\t\t\tle16_to_cpu(bg->bg_bits),\n\t\t\t\t\t\t\tres);\n\t\tif (!ret && max_block) {\n\t\t\tblkoff = le64_to_cpu(bg->bg_blkno) +\n\t\t\t\tres->sr_bit_offset + res->sr_bits;\n\t\t\ttrace_ocfs2_block_group_search_max_block(\n\t\t\t\t(unsigned long long)blkoff,\n\t\t\t\t(unsigned long long)max_block);\n\t\t\tif (blkoff > max_block)\n\t\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_block_group_search_max_block",
          "args": [
            "(unsigned long long)blkoff",
            "(unsigned long long)max_block"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "bg->bg_blkno"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_find_clear_bits",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "group_bh",
            "bits_wanted",
            "le16_to_cpu(bg->bg_bits)",
            "res"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_find_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1281-1339",
          "snippet": "static int ocfs2_block_group_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct buffer_head *bg_bh,\n\t\t\t\t\t     unsigned int bits_wanted,\n\t\t\t\t\t     unsigned int total_bits,\n\t\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tvoid *bitmap;\n\tu16 best_offset, best_size;\n\tint offset, start, found, status = 0;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\t/* Callers got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\tfound = start = best_offset = best_size = 0;\n\tbitmap = bg->bg_bitmap;\n\n\twhile((offset = ocfs2_find_next_zero_bit(bitmap, total_bits, start)) != -1) {\n\t\tif (offset == total_bits)\n\t\t\tbreak;\n\n\t\tif (!ocfs2_test_bg_bit_allocatable(bg_bh, offset)) {\n\t\t\t/* We found a zero, but we can't use it as it\n\t\t\t * hasn't been put to disk yet! */\n\t\t\tfound = 0;\n\t\t\tstart = offset + 1;\n\t\t} else if (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_size) {\n\t\t\tbest_size = found;\n\t\t\tbest_offset = start - found;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (found == bits_wanted) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_size) {\n\t\tres->sr_bit_offset = best_offset;\n\t\tres->sr_bits = best_size;\n\t} else {\n\t\tstatus = -ENOSPC;\n\t\t/* No error log here -- see the comment above\n\t\t * ocfs2_test_bg_bit_allocatable */\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_block_group_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct buffer_head *bg_bh,\n\t\t\t\t\t     unsigned int bits_wanted,\n\t\t\t\t\t     unsigned int total_bits,\n\t\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tvoid *bitmap;\n\tu16 best_offset, best_size;\n\tint offset, start, found, status = 0;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\t/* Callers got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\tfound = start = best_offset = best_size = 0;\n\tbitmap = bg->bg_bitmap;\n\n\twhile((offset = ocfs2_find_next_zero_bit(bitmap, total_bits, start)) != -1) {\n\t\tif (offset == total_bits)\n\t\t\tbreak;\n\n\t\tif (!ocfs2_test_bg_bit_allocatable(bg_bh, offset)) {\n\t\t\t/* We found a zero, but we can't use it as it\n\t\t\t * hasn't been put to disk yet! */\n\t\t\tfound = 0;\n\t\t\tstart = offset + 1;\n\t\t} else if (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_size) {\n\t\t\tbest_size = found;\n\t\t\tbest_offset = start - found;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (found == bits_wanted) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_size) {\n\t\tres->sr_bit_offset = best_offset;\n\t\tres->sr_bits = best_size;\n\t} else {\n\t\tstatus = -ENOSPC;\n\t\t/* No error log here -- see the comment above\n\t\t * ocfs2_test_bg_bit_allocatable */\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_bits"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_is_cluster_bitmap(inode)"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "inode"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "min_bits != 1"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res)\n{\n\tint ret = -ENOSPC;\n\tu64 blkoff;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) group_bh->b_data;\n\n\tBUG_ON(min_bits != 1);\n\tBUG_ON(ocfs2_is_cluster_bitmap(inode));\n\n\tif (bg->bg_free_bits_count) {\n\t\tret = ocfs2_block_group_find_clear_bits(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tgroup_bh, bits_wanted,\n\t\t\t\t\t\t\tle16_to_cpu(bg->bg_bits),\n\t\t\t\t\t\t\tres);\n\t\tif (!ret && max_block) {\n\t\t\tblkoff = le64_to_cpu(bg->bg_blkno) +\n\t\t\t\tres->sr_bit_offset + res->sr_bits;\n\t\t\ttrace_ocfs2_block_group_search_max_block(\n\t\t\t\t(unsigned long long)blkoff,\n\t\t\t\t(unsigned long long)max_block);\n\t\t\tif (blkoff > max_block)\n\t\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cluster_group_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1481-1550",
    "snippet": "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res)\n{\n\tint search = -ENOSPC;\n\tint ret;\n\tu64 blkoff;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *) group_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int max_bits, gd_cluster_off;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tif (gd->bg_free_bits_count) {\n\t\tmax_bits = le16_to_cpu(gd->bg_bits);\n\n\t\t/* Tail groups in cluster bitmaps which aren't cpg\n\t\t * aligned are prone to partial extension by a failed\n\t\t * fs resize. If the file system resize never got to\n\t\t * update the dinode cluster count, then we don't want\n\t\t * to trust any clusters past it, regardless of what\n\t\t * the group descriptor says. */\n\t\tgd_cluster_off = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t  le64_to_cpu(gd->bg_blkno));\n\t\tif ((gd_cluster_off + max_bits) >\n\t\t    OCFS2_I(inode)->ip_clusters) {\n\t\t\tmax_bits = OCFS2_I(inode)->ip_clusters - gd_cluster_off;\n\t\t\ttrace_ocfs2_cluster_group_search_wrong_max_bits(\n\t\t\t\t(unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t\tle16_to_cpu(gd->bg_bits),\n\t\t\t\tOCFS2_I(inode)->ip_clusters, max_bits);\n\t\t}\n\n\t\tret = ocfs2_block_group_find_clear_bits(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tgroup_bh, bits_wanted,\n\t\t\t\t\t\t\tmax_bits, res);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (max_block) {\n\t\t\tblkoff = ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t  gd_cluster_off +\n\t\t\t\t\t\t\t  res->sr_bit_offset +\n\t\t\t\t\t\t\t  res->sr_bits);\n\t\t\ttrace_ocfs2_cluster_group_search_max_block(\n\t\t\t\t(unsigned long long)blkoff,\n\t\t\t\t(unsigned long long)max_block);\n\t\t\tif (blkoff > max_block)\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* ocfs2_block_group_find_clear_bits() might\n\t\t * return success, but we still want to return\n\t\t * -ENOSPC unless it found the minimum number\n\t\t * of bits. */\n\t\tif (min_bits <= res->sr_bits)\n\t\t\tsearch = 0; /* success */\n\t\telse if (res->sr_bits) {\n\t\t\t/*\n\t\t\t * Don't show bits which we'll be returning\n\t\t\t * for allocation to the local alloc bitmap.\n\t\t\t */\n\t\t\tocfs2_local_alloc_seen_free_bits(osb, res->sr_bits);\n\t\t}\n\t}\n\n\treturn search;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_seen_free_bits",
          "args": [
            "osb",
            "res->sr_bits"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_seen_free_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "228-239",
          "snippet": "void ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cluster_group_search_max_block",
          "args": [
            "(unsigned long long)blkoff",
            "(unsigned long long)max_block"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "gd_cluster_off +\n\t\t\t\t\t\t\t  res->sr_bit_offset +\n\t\t\t\t\t\t\t  res->sr_bits"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_find_clear_bits",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "group_bh",
            "bits_wanted",
            "max_bits",
            "res"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_find_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1281-1339",
          "snippet": "static int ocfs2_block_group_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct buffer_head *bg_bh,\n\t\t\t\t\t     unsigned int bits_wanted,\n\t\t\t\t\t     unsigned int total_bits,\n\t\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tvoid *bitmap;\n\tu16 best_offset, best_size;\n\tint offset, start, found, status = 0;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\t/* Callers got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\tfound = start = best_offset = best_size = 0;\n\tbitmap = bg->bg_bitmap;\n\n\twhile((offset = ocfs2_find_next_zero_bit(bitmap, total_bits, start)) != -1) {\n\t\tif (offset == total_bits)\n\t\t\tbreak;\n\n\t\tif (!ocfs2_test_bg_bit_allocatable(bg_bh, offset)) {\n\t\t\t/* We found a zero, but we can't use it as it\n\t\t\t * hasn't been put to disk yet! */\n\t\t\tfound = 0;\n\t\t\tstart = offset + 1;\n\t\t} else if (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_size) {\n\t\t\tbest_size = found;\n\t\t\tbest_offset = start - found;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (found == bits_wanted) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_size) {\n\t\tres->sr_bit_offset = best_offset;\n\t\tres->sr_bits = best_size;\n\t} else {\n\t\tstatus = -ENOSPC;\n\t\t/* No error log here -- see the comment above\n\t\t * ocfs2_test_bg_bit_allocatable */\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_block_group_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct buffer_head *bg_bh,\n\t\t\t\t\t     unsigned int bits_wanted,\n\t\t\t\t\t     unsigned int total_bits,\n\t\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tvoid *bitmap;\n\tu16 best_offset, best_size;\n\tint offset, start, found, status = 0;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\t/* Callers got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\tfound = start = best_offset = best_size = 0;\n\tbitmap = bg->bg_bitmap;\n\n\twhile((offset = ocfs2_find_next_zero_bit(bitmap, total_bits, start)) != -1) {\n\t\tif (offset == total_bits)\n\t\t\tbreak;\n\n\t\tif (!ocfs2_test_bg_bit_allocatable(bg_bh, offset)) {\n\t\t\t/* We found a zero, but we can't use it as it\n\t\t\t * hasn't been put to disk yet! */\n\t\t\tfound = 0;\n\t\t\tstart = offset + 1;\n\t\t} else if (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_size) {\n\t\t\tbest_size = found;\n\t\t\tbest_offset = start - found;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (found == bits_wanted) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_size) {\n\t\tres->sr_bit_offset = best_offset;\n\t\tres->sr_bits = best_size;\n\t} else {\n\t\tstatus = -ENOSPC;\n\t\t/* No error log here -- see the comment above\n\t\t * ocfs2_test_bg_bit_allocatable */\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cluster_group_search_wrong_max_bits",
          "args": [
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)",
            "le16_to_cpu(gd->bg_bits)",
            "OCFS2_I(inode)->ip_clusters",
            "max_bits"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_bits"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "le64_to_cpu(gd->bg_blkno)"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_cluster_bitmap(inode)"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "inode"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res)\n{\n\tint search = -ENOSPC;\n\tint ret;\n\tu64 blkoff;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *) group_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int max_bits, gd_cluster_off;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tif (gd->bg_free_bits_count) {\n\t\tmax_bits = le16_to_cpu(gd->bg_bits);\n\n\t\t/* Tail groups in cluster bitmaps which aren't cpg\n\t\t * aligned are prone to partial extension by a failed\n\t\t * fs resize. If the file system resize never got to\n\t\t * update the dinode cluster count, then we don't want\n\t\t * to trust any clusters past it, regardless of what\n\t\t * the group descriptor says. */\n\t\tgd_cluster_off = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t  le64_to_cpu(gd->bg_blkno));\n\t\tif ((gd_cluster_off + max_bits) >\n\t\t    OCFS2_I(inode)->ip_clusters) {\n\t\t\tmax_bits = OCFS2_I(inode)->ip_clusters - gd_cluster_off;\n\t\t\ttrace_ocfs2_cluster_group_search_wrong_max_bits(\n\t\t\t\t(unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t\tle16_to_cpu(gd->bg_bits),\n\t\t\t\tOCFS2_I(inode)->ip_clusters, max_bits);\n\t\t}\n\n\t\tret = ocfs2_block_group_find_clear_bits(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tgroup_bh, bits_wanted,\n\t\t\t\t\t\t\tmax_bits, res);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (max_block) {\n\t\t\tblkoff = ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t  gd_cluster_off +\n\t\t\t\t\t\t\t  res->sr_bit_offset +\n\t\t\t\t\t\t\t  res->sr_bits);\n\t\t\ttrace_ocfs2_cluster_group_search_max_block(\n\t\t\t\t(unsigned long long)blkoff,\n\t\t\t\t(unsigned long long)max_block);\n\t\t\tif (blkoff > max_block)\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* ocfs2_block_group_find_clear_bits() might\n\t\t * return success, but we still want to return\n\t\t * -ENOSPC unless it found the minimum number\n\t\t * of bits. */\n\t\tif (min_bits <= res->sr_bits)\n\t\t\tsearch = 0; /* success */\n\t\telse if (res->sr_bits) {\n\t\t\t/*\n\t\t\t * Don't show bits which we'll be returning\n\t\t\t * for allocation to the local alloc bitmap.\n\t\t\t */\n\t\t\tocfs2_local_alloc_seen_free_bits(osb, res->sr_bits);\n\t\t}\n\t}\n\n\treturn search;\n}"
  },
  {
    "function_name": "ocfs2_block_group_reasonably_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1473-1477",
    "snippet": "static inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted)\n{\n\treturn le16_to_cpu(bg->bg_free_bits_count) > wanted;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_free_bits_count"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted);\n\nstatic inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,\n\t\t\t\t\t\t     u32 wanted)\n{\n\treturn le16_to_cpu(bg->bg_free_bits_count) > wanted;\n}"
  },
  {
    "function_name": "ocfs2_relink_block_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1408-1471",
    "snippet": "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain)\n{\n\tint status;\n\t/* there is a really tiny chance the journal calls could fail,\n\t * but we wouldn't want inconsistent blocks in *any* case. */\n\tu64 bg_ptr, prev_bg_ptr;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct ocfs2_group_desc *prev_bg = (struct ocfs2_group_desc *) prev_bg_bh->b_data;\n\n\t/* The caller got these descriptors from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(prev_bg));\n\n\ttrace_ocfs2_relink_block_group(\n\t\t(unsigned long long)le64_to_cpu(fe->i_blkno), chain,\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t(unsigned long long)le64_to_cpu(prev_bg->bg_blkno));\n\n\tbg_ptr = le64_to_cpu(bg->bg_next_group);\n\tprev_bg_ptr = le64_to_cpu(prev_bg->bg_next_group);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t prev_bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out;\n\n\tprev_bg->bg_next_group = bg->bg_next_group;\n\tocfs2_journal_dirty(handle, prev_bg_bh);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_prev_bg;\n\n\tbg->bg_next_group = fe->id2.i_chain.cl_recs[chain].c_blkno;\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t fe_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_bg;\n\n\tfe->id2.i_chain.cl_recs[chain].c_blkno = bg->bg_blkno;\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n\nout_rollback_bg:\n\tbg->bg_next_group = cpu_to_le64(bg_ptr);\nout_rollback_prev_bg:\n\tprev_bg->bg_next_group = cpu_to_le64(prev_bg_ptr);\n\tgoto out;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "prev_bg_ptr"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bg_ptr"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "fe_bh"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "bg_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "prev_bg->bg_next_group"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_relink_block_group",
          "args": [
            "(unsigned long long)le64_to_cpu(fe->i_blkno)",
            "chain",
            "(unsigned long long)le64_to_cpu(bg->bg_blkno)",
            "(unsigned long long)le64_to_cpu(prev_bg->bg_blkno)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_GROUP_DESC(prev_bg)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_GROUP_DESC",
          "args": [
            "prev_bg"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_GROUP_DESC(bg)"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_GROUP_DESC",
          "args": [
            "bg"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain)\n{\n\tint status;\n\t/* there is a really tiny chance the journal calls could fail,\n\t * but we wouldn't want inconsistent blocks in *any* case. */\n\tu64 bg_ptr, prev_bg_ptr;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) fe_bh->b_data;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct ocfs2_group_desc *prev_bg = (struct ocfs2_group_desc *) prev_bg_bh->b_data;\n\n\t/* The caller got these descriptors from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(prev_bg));\n\n\ttrace_ocfs2_relink_block_group(\n\t\t(unsigned long long)le64_to_cpu(fe->i_blkno), chain,\n\t\t(unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t(unsigned long long)le64_to_cpu(prev_bg->bg_blkno));\n\n\tbg_ptr = le64_to_cpu(bg->bg_next_group);\n\tprev_bg_ptr = le64_to_cpu(prev_bg->bg_next_group);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t prev_bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out;\n\n\tprev_bg->bg_next_group = bg->bg_next_group;\n\tocfs2_journal_dirty(handle, prev_bg_bh);\n\n\tstatus = ocfs2_journal_access_gd(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_prev_bg;\n\n\tbg->bg_next_group = fe->id2.i_chain.cl_recs[chain].c_blkno;\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t fe_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0)\n\t\tgoto out_rollback_bg;\n\n\tfe->id2.i_chain.cl_recs[chain].c_blkno = bg->bg_blkno;\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout:\n\tif (status < 0)\n\t\tmlog_errno(status);\n\treturn status;\n\nout_rollback_bg:\n\tbg->bg_next_group = cpu_to_le64(bg_ptr);\nout_rollback_prev_bg:\n\tprev_bg->bg_next_group = cpu_to_le64(prev_bg_ptr);\n\tgoto out;\n}"
  },
  {
    "function_name": "ocfs2_find_victim_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1390-1406",
    "snippet": "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tBUG_ON(!cl->cl_next_free_rec);\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tif (le32_to_cpu(cl->cl_recs[curr].c_free) >\n\t\t    le32_to_cpu(cl->cl_recs[best].c_free))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\n\tBUG_ON(best >= le16_to_cpu(cl->cl_next_free_rec));\n\treturn best;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "best >= le16_to_cpu(cl->cl_next_free_rec)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_next_free_rec"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cl->cl_recs[best].c_free"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cl->cl_next_free_rec"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tBUG_ON(!cl->cl_next_free_rec);\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tif (le32_to_cpu(cl->cl_recs[curr].c_free) >\n\t\t    le32_to_cpu(cl->cl_recs[best].c_free))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\n\tBUG_ON(best >= le16_to_cpu(cl->cl_next_free_rec));\n\treturn best;\n}"
  },
  {
    "function_name": "ocfs2_block_group_set_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1341-1387",
    "snippet": "int ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "group_bh"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_bit",
          "args": [
            "bit_off++",
            "bitmap"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "alloc_inode->i_sb",
            "\"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\"",
            "(unsigned long long)le64_to_cpu(bg->bg_blkno)",
            "le16_to_cpu(bg->bg_bits)",
            "le16_to_cpu(bg->bg_free_bits_count)",
            "num_bits"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_free_bits_count"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "bg->bg_blkno"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&bg->bg_free_bits_count",
            "-num_bits"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "group_bh",
            "journal_type"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "alloc_inode"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_block_group_set_bits",
          "args": [
            "bit_off",
            "num_bits"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(bg->bg_free_bits_count) < num_bits"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_GROUP_DESC(bg)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_GROUP_DESC",
          "args": [
            "bg"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nint ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_group_find_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1281-1339",
    "snippet": "static int ocfs2_block_group_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct buffer_head *bg_bh,\n\t\t\t\t\t     unsigned int bits_wanted,\n\t\t\t\t\t     unsigned int total_bits,\n\t\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tvoid *bitmap;\n\tu16 best_offset, best_size;\n\tint offset, start, found, status = 0;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\t/* Callers got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\tfound = start = best_offset = best_size = 0;\n\tbitmap = bg->bg_bitmap;\n\n\twhile((offset = ocfs2_find_next_zero_bit(bitmap, total_bits, start)) != -1) {\n\t\tif (offset == total_bits)\n\t\t\tbreak;\n\n\t\tif (!ocfs2_test_bg_bit_allocatable(bg_bh, offset)) {\n\t\t\t/* We found a zero, but we can't use it as it\n\t\t\t * hasn't been put to disk yet! */\n\t\t\tfound = 0;\n\t\t\tstart = offset + 1;\n\t\t} else if (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_size) {\n\t\t\tbest_size = found;\n\t\t\tbest_offset = start - found;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (found == bits_wanted) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_size) {\n\t\tres->sr_bit_offset = best_offset;\n\t\tres->sr_bits = best_size;\n\t} else {\n\t\tstatus = -ENOSPC;\n\t\t/* No error log here -- see the comment above\n\t\t * ocfs2_test_bg_bit_allocatable */\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_test_bg_bit_allocatable",
          "args": [
            "bg_bh",
            "offset"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bg_bit_allocatable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1258-1279",
          "snippet": "static int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr)\n{\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tint ret;\n\n\tif (ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap))\n\t\treturn 0;\n\n\tif (!buffer_jbd(bg_bh))\n\t\treturn 1;\n\n\tjbd_lock_bh_state(bg_bh);\n\tbg = (struct ocfs2_group_desc *) bh2jh(bg_bh)->b_committed_data;\n\tif (bg)\n\t\tret = !ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap);\n\telse\n\t\tret = 1;\n\tjbd_unlock_bh_state(bg_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr);\n\nstatic int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr)\n{\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tint ret;\n\n\tif (ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap))\n\t\treturn 0;\n\n\tif (!buffer_jbd(bg_bh))\n\t\treturn 1;\n\n\tjbd_lock_bh_state(bg_bh);\n\tbg = (struct ocfs2_group_desc *) bh2jh(bg_bh)->b_committed_data;\n\tif (bg)\n\t\tret = !ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap);\n\telse\n\t\tret = 1;\n\tjbd_unlock_bh_state(bg_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit",
          "args": [
            "bitmap",
            "total_bits",
            "start"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_GROUP_DESC(bg)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_GROUP_DESC",
          "args": [
            "bg"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic int ocfs2_block_group_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct buffer_head *bg_bh,\n\t\t\t\t\t     unsigned int bits_wanted,\n\t\t\t\t\t     unsigned int total_bits,\n\t\t\t\t\t     struct ocfs2_suballoc_result *res)\n{\n\tvoid *bitmap;\n\tu16 best_offset, best_size;\n\tint offset, start, found, status = 0;\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\t/* Callers got this descriptor from\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\n\tfound = start = best_offset = best_size = 0;\n\tbitmap = bg->bg_bitmap;\n\n\twhile((offset = ocfs2_find_next_zero_bit(bitmap, total_bits, start)) != -1) {\n\t\tif (offset == total_bits)\n\t\t\tbreak;\n\n\t\tif (!ocfs2_test_bg_bit_allocatable(bg_bh, offset)) {\n\t\t\t/* We found a zero, but we can't use it as it\n\t\t\t * hasn't been put to disk yet! */\n\t\t\tfound = 0;\n\t\t\tstart = offset + 1;\n\t\t} else if (offset == start) {\n\t\t\t/* we found a zero */\n\t\t\tfound++;\n\t\t\t/* move start to the next bit to test */\n\t\t\tstart++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tfound = 1;\n\t\t\tstart = offset + 1;\n\t\t}\n\t\tif (found > best_size) {\n\t\t\tbest_size = found;\n\t\t\tbest_offset = start - found;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (found == bits_wanted) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best_size) {\n\t\tres->sr_bit_offset = best_offset;\n\t\tres->sr_bits = best_size;\n\t} else {\n\t\tstatus = -ENOSPC;\n\t\t/* No error log here -- see the comment above\n\t\t * ocfs2_test_bg_bit_allocatable */\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_test_bg_bit_allocatable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1258-1279",
    "snippet": "static int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr)\n{\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tint ret;\n\n\tif (ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap))\n\t\treturn 0;\n\n\tif (!buffer_jbd(bg_bh))\n\t\treturn 1;\n\n\tjbd_lock_bh_state(bg_bh);\n\tbg = (struct ocfs2_group_desc *) bh2jh(bg_bh)->b_committed_data;\n\tif (bg)\n\t\tret = !ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap);\n\telse\n\t\tret = 1;\n\tjbd_unlock_bh_state(bg_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bg_bh"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "nr",
            "(unsigned long *)bg->bg_bitmap"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bg_bh"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bg_bh"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bg_bh"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr);\n\nstatic int ocfs2_test_bg_bit_allocatable(struct buffer_head *bg_bh,\n\t\t\t\t\t int nr)\n{\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tint ret;\n\n\tif (ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap))\n\t\treturn 0;\n\n\tif (!buffer_jbd(bg_bh))\n\t\treturn 1;\n\n\tjbd_lock_bh_state(bg_bh);\n\tbg = (struct ocfs2_group_desc *) bh2jh(bg_bh)->b_committed_data;\n\tif (bg)\n\t\tret = !ocfs2_test_bit(nr, (unsigned long *)bg->bg_bitmap);\n\telse\n\t\tret = 1;\n\tjbd_unlock_bh_state(bg_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reserve_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1228-1234",
    "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ALLOC_NEW_GROUP\t\t\t0x1"
    ],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters_with_limit",
          "args": [
            "osb",
            "bits_wanted",
            "0",
            "ALLOC_NEW_GROUP",
            "ac"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters_with_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1178-1226",
          "snippet": "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = bits_wanted;\n\t(*ac)->ac_max_block = max_block;\n\n\tstatus = -ENOSPC;\n\tif (!(flags & ALLOC_GROUPS_FROM_GLOBAL) &&\n\t    ocfs2_alloc_should_use_local(osb, bits_wanted)) {\n\t\tstatus = ocfs2_reserve_local_alloc_bits(osb,\n\t\t\t\t\t\t\tbits_wanted,\n\t\t\t\t\t\t\t*ac);\n\t\tif ((status < 0) && (status != -ENOSPC)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (status == -ENOSPC) {\n\t\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2"
          ],
          "globals_used": [
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = bits_wanted;\n\t(*ac)->ac_max_block = max_block;\n\n\tstatus = -ENOSPC;\n\tif (!(flags & ALLOC_GROUPS_FROM_GLOBAL) &&\n\t    ocfs2_alloc_should_use_local(osb, bits_wanted)) {\n\t\tstatus = ocfs2_reserve_local_alloc_bits(osb,\n\t\t\t\t\t\t\tbits_wanted,\n\t\t\t\t\t\t\t*ac);\n\t\tif ((status < 0) && (status != -ENOSPC)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (status == -ENOSPC) {\n\t\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
  },
  {
    "function_name": "ocfs2_reserve_clusters_with_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1178-1226",
    "snippet": "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = bits_wanted;\n\t(*ac)->ac_max_block = max_block;\n\n\tstatus = -ENOSPC;\n\tif (!(flags & ALLOC_GROUPS_FROM_GLOBAL) &&\n\t    ocfs2_alloc_should_use_local(osb, bits_wanted)) {\n\t\tstatus = ocfs2_reserve_local_alloc_bits(osb,\n\t\t\t\t\t\t\tbits_wanted,\n\t\t\t\t\t\t\t*ac);\n\t\tif ((status < 0) && (status != -ENOSPC)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (status == -ENOSPC) {\n\t\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2"
    ],
    "globals_used": [
      "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*ac"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_cluster_bitmap_bits",
          "args": [
            "osb",
            "*ac"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_cluster_bitmap_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1154-1173",
          "snippet": "int ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\n\tac->ac_which = OCFS2_AC_USE_MAIN;\n\tac->ac_group_search = ocfs2_cluster_group_search;\n\n\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t     GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t     OCFS2_INVALID_SLOT, NULL,\n\t\t\t\t\t     ALLOC_NEW_GROUP);\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\n\tac->ac_which = OCFS2_AC_USE_MAIN;\n\tac->ac_group_search = ocfs2_cluster_group_search;\n\n\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t     GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t     OCFS2_INVALID_SLOT, NULL,\n\t\t\t\t\t     ALLOC_NEW_GROUP);\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_local_alloc_bits",
          "args": [
            "osb",
            "bits_wanted",
            "*ac"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_local_alloc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "627-726",
          "snippet": "int ocfs2_reserve_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t   u32 bits_wanted,\n\t\t\t\t   struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\tstruct ocfs2_dinode *alloc;\n\tstruct inode *local_alloc_inode;\n\tunsigned int free_bits;\n\n\tBUG_ON(!ac);\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&local_alloc_inode->i_mutex);\n\n\t/*\n\t * We must double check state and allocator bits because\n\t * another process may have changed them while holding i_mutex.\n\t */\n\tspin_lock(&osb->osb_lock);\n\tif (!ocfs2_la_state_enabled(osb) ||\n\t    (bits_wanted > osb->local_alloc_bits)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) !=\n\t    ocfs2_local_alloc_count_bits(alloc)) {\n\t\tocfs2_error(osb->sb, \"local alloc inode %llu says it has \"\n\t\t\t    \"%u free bits, but a count shows %u\",\n\t\t\t    (unsigned long long)le64_to_cpu(alloc->i_blkno),\n\t\t\t    le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t\t    ocfs2_local_alloc_count_bits(alloc));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n#endif\n\n\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\tif (bits_wanted > free_bits) {\n\t\t/* uhoh, window change time. */\n\t\tstatus =\n\t\t\tocfs2_local_alloc_slide_window(osb, local_alloc_inode);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/*\n\t\t * Under certain conditions, the window slide code\n\t\t * might have reduced the number of bits available or\n\t\t * disabled the the local alloc entirely. Re-check\n\t\t * here and return -ENOSPC if necessary.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tif (!ocfs2_la_state_enabled(osb))\n\t\t\tgoto bail;\n\n\t\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\t\tif (bits_wanted > free_bits)\n\t\t\tgoto bail;\n\t}\n\n\tac->ac_inode = local_alloc_inode;\n\t/* We should never use localalloc from another slot */\n\tac->ac_alloc_slot = osb->slot_num;\n\tac->ac_which = OCFS2_AC_USE_LOCAL;\n\tget_bh(osb->local_alloc_bh);\n\tac->ac_bh = osb->local_alloc_bh;\n\tstatus = 0;\nbail:\n\tif (status < 0 && local_alloc_inode) {\n\t\tmutex_unlock(&local_alloc_inode->i_mutex);\n\t\tiput(local_alloc_inode);\n\t}\n\n\ttrace_ocfs2_reserve_local_alloc_bits(\n\t\t(unsigned long long)ac->ac_max_block,\n\t\tbits_wanted, osb->slot_num, status);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_reserve_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t   u32 bits_wanted,\n\t\t\t\t   struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\tstruct ocfs2_dinode *alloc;\n\tstruct inode *local_alloc_inode;\n\tunsigned int free_bits;\n\n\tBUG_ON(!ac);\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&local_alloc_inode->i_mutex);\n\n\t/*\n\t * We must double check state and allocator bits because\n\t * another process may have changed them while holding i_mutex.\n\t */\n\tspin_lock(&osb->osb_lock);\n\tif (!ocfs2_la_state_enabled(osb) ||\n\t    (bits_wanted > osb->local_alloc_bits)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) !=\n\t    ocfs2_local_alloc_count_bits(alloc)) {\n\t\tocfs2_error(osb->sb, \"local alloc inode %llu says it has \"\n\t\t\t    \"%u free bits, but a count shows %u\",\n\t\t\t    (unsigned long long)le64_to_cpu(alloc->i_blkno),\n\t\t\t    le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t\t    ocfs2_local_alloc_count_bits(alloc));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n#endif\n\n\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\tif (bits_wanted > free_bits) {\n\t\t/* uhoh, window change time. */\n\t\tstatus =\n\t\t\tocfs2_local_alloc_slide_window(osb, local_alloc_inode);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/*\n\t\t * Under certain conditions, the window slide code\n\t\t * might have reduced the number of bits available or\n\t\t * disabled the the local alloc entirely. Re-check\n\t\t * here and return -ENOSPC if necessary.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tif (!ocfs2_la_state_enabled(osb))\n\t\t\tgoto bail;\n\n\t\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\t\tif (bits_wanted > free_bits)\n\t\t\tgoto bail;\n\t}\n\n\tac->ac_inode = local_alloc_inode;\n\t/* We should never use localalloc from another slot */\n\tac->ac_alloc_slot = osb->slot_num;\n\tac->ac_which = OCFS2_AC_USE_LOCAL;\n\tget_bh(osb->local_alloc_bh);\n\tac->ac_bh = osb->local_alloc_bh;\n\tstatus = 0;\nbail:\n\tif (status < 0 && local_alloc_inode) {\n\t\tmutex_unlock(&local_alloc_inode->i_mutex);\n\t\tiput(local_alloc_inode);\n\t}\n\n\ttrace_ocfs2_reserve_local_alloc_bits(\n\t\t(unsigned long long)ac->ac_max_block,\n\t\tbits_wanted, osb->slot_num, status);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_should_use_local",
          "args": [
            "osb",
            "bits_wanted"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_should_use_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "258-282",
          "snippet": "int ocfs2_alloc_should_use_local(struct ocfs2_super *osb, u64 bits)\n{\n\tint ret = 0;\n\tint la_bits;\n\n\tspin_lock(&osb->osb_lock);\n\tla_bits = osb->local_alloc_bits;\n\n\tif (!ocfs2_la_state_enabled(osb))\n\t\tgoto bail;\n\n\t/* la_bits should be at least twice the size (in clusters) of\n\t * a new block group. We want to be sure block group\n\t * allocations go through the local alloc, so allow an\n\t * allocation to take up to half the bitmap. */\n\tif (bits > (la_bits / 2))\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\ttrace_ocfs2_alloc_should_use_local(\n\t     (unsigned long long)bits, osb->local_alloc_state, la_bits, ret);\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_alloc_should_use_local(struct ocfs2_super *osb, u64 bits)\n{\n\tint ret = 0;\n\tint la_bits;\n\n\tspin_lock(&osb->osb_lock);\n\tla_bits = osb->local_alloc_bits;\n\n\tif (!ocfs2_la_state_enabled(osb))\n\t\tgoto bail;\n\n\t/* la_bits should be at least twice the size (in clusters) of\n\t * a new block group. We want to be sure block group\n\t * allocations go through the local alloc, so allow an\n\t * allocation to take up to half the bitmap. */\n\tif (bits > (la_bits / 2))\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\ttrace_ocfs2_alloc_should_use_local(\n\t     (unsigned long long)bits, osb->local_alloc_state, la_bits, ret);\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_alloc_context)",
            "GFP_KERNEL"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = bits_wanted;\n\t(*ac)->ac_max_block = max_block;\n\n\tstatus = -ENOSPC;\n\tif (!(flags & ALLOC_GROUPS_FROM_GLOBAL) &&\n\t    ocfs2_alloc_should_use_local(osb, bits_wanted)) {\n\t\tstatus = ocfs2_reserve_local_alloc_bits(osb,\n\t\t\t\t\t\t\tbits_wanted,\n\t\t\t\t\t\t\t*ac);\n\t\tif ((status < 0) && (status != -ENOSPC)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (status == -ENOSPC) {\n\t\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_reserve_cluster_bitmap_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1154-1173",
    "snippet": "int ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\n\tac->ac_which = OCFS2_AC_USE_MAIN;\n\tac->ac_group_search = ocfs2_cluster_group_search;\n\n\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t     GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t     OCFS2_INVALID_SLOT, NULL,\n\t\t\t\t\t     ALLOC_NEW_GROUP);\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ALLOC_NEW_GROUP\t\t\t0x1"
    ],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_suballoc_bits",
          "args": [
            "osb",
            "ac",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT",
            "NULL",
            "ALLOC_NEW_GROUP"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "796-886",
          "snippet": "static int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\n\tac->ac_which = OCFS2_AC_USE_MAIN;\n\tac->ac_group_search = ocfs2_cluster_group_search;\n\n\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t     GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t     OCFS2_INVALID_SLOT, NULL,\n\t\t\t\t\t     ALLOC_NEW_GROUP);\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_reserve_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1060-1150",
    "snippet": "int ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_MAX_TO_STEAL\t\t1024",
      "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
      "#define ALLOC_NEW_GROUP\t\t\t0x1"
    ],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*ac"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&osb->s_num_inodes_stolen"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_steal_inode",
          "args": [
            "osb",
            "*ac"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_steal_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "977-981",
          "snippet": "static int ocfs2_steal_inode(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, INODE_ALLOC_SYSTEM_INODE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_inode(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, INODE_ALLOC_SYSTEM_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_ac_resource",
          "args": [
            "*ac"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_ac_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "136-156",
          "snippet": "void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_inode_steal_slot",
          "args": [
            "osb"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_inode_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "888-894",
          "snippet": "static void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_inode_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_inode_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reserve_new_inode_new_group",
          "args": [
            "(unsigned long long)alloc_group"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_suballoc_bits",
          "args": [
            "osb",
            "*ac",
            "INODE_ALLOC_SYSTEM_INODE",
            "(u32)osb->slot_num",
            "&alloc_group",
            "ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "796-886",
          "snippet": "static int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->s_num_inodes_stolen",
            "0"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->s_num_inodes_stolen"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_alloc_context)",
            "GFP_KERNEL"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_inode_steal_slot",
          "args": [
            "osb"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_inode_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "934-937",
          "snippet": "static int ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, INODE_ALLOC_SYSTEM_INODE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, INODE_ALLOC_SYSTEM_INODE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_inode(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_inode_steal_slot(osb);\n\tu64 alloc_group;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = 1;\n\t(*ac)->ac_which = OCFS2_AC_USE_INODE;\n\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\t/*\n\t * stat(2) can't handle i_ino > 32bits, so we tell the\n\t * lower levels not to allocate us a block group past that\n\t * limit.  The 'inode64' mount option avoids this behavior.\n\t */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))\n\t\t(*ac)->ac_max_block = (u32)~0U;\n\n\t/*\n\t * slot is set when we successfully steal inode from other nodes.\n\t * It is reset in 3 places:\n\t * 1. when we flush the truncate log\n\t * 2. when we complete local alloc recovery.\n\t * 3. when we successfully allocate from our own slot.\n\t * After it is set, we will go on stealing inodes until we find the\n\t * need to check our slots to see whether there is some space for us.\n\t */\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t    atomic_read(&osb->s_num_inodes_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto inode_steal;\n\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n\talloc_group = osb->osb_inode_alloc_group;\n\tstatus = ocfs2_reserve_suballoc_bits(osb, *ac,\n\t\t\t\t\t     INODE_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num,\n\t\t\t\t\t     &alloc_group,\n\t\t\t\t\t     ALLOC_NEW_GROUP |\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL);\n\tif (status >= 0) {\n\t\tstatus = 0;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->osb_inode_alloc_group = alloc_group;\n\t\tspin_unlock(&osb->osb_lock);\n\t\ttrace_ocfs2_reserve_new_inode_new_group(\n\t\t\t(unsigned long long)alloc_group);\n\n\t\t/*\n\t\t * Some inodes must be freed by us, so try to allocate\n\t\t * from our own next time.\n\t\t */\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_inode_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\ninode_steal:\n\tstatus = ocfs2_steal_inode(osb, *ac);\n\tatomic_inc(&osb->s_num_inodes_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_reserve_new_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "1051-1058",
    "snippet": "int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_extent_list *root_el,\n\t\t\t       struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\tocfs2_extend_meta_needed(root_el),\n\t\t\t\t\tac);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "ocfs2_extend_meta_needed(root_el)",
            "ac"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "root_el"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_extent_list *root_el,\n\t\t\t       struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_new_metadata_blocks(osb,\n\t\t\t\t\tocfs2_extend_meta_needed(root_el),\n\t\t\t\t\tac);\n}"
  },
  {
    "function_name": "ocfs2_reserve_new_metadata_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "989-1049",
    "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_MAX_TO_STEAL\t\t1024",
      "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
      "#define ALLOC_NEW_GROUP\t\t\t0x1"
    ],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*ac"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&osb->s_num_meta_stolen"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_steal_meta",
          "args": [
            "osb",
            "*ac"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_steal_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "983-987",
          "snippet": "static int ocfs2_steal_meta(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, EXTENT_ALLOC_SYSTEM_INODE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_meta(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, EXTENT_ALLOC_SYSTEM_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_ac_resource",
          "args": [
            "*ac"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_ac_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "136-156",
          "snippet": "void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_meta_steal_slot",
          "args": [
            "osb"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_meta_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "896-902",
          "snippet": "static void ocfs2_init_meta_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_meta_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_init_meta_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_meta_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_suballoc_bits",
          "args": [
            "osb",
            "(*ac)",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "(u32)osb->slot_num",
            "NULL",
            "ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "796-886",
          "snippet": "static int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->s_num_meta_stolen",
            "0"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->s_num_meta_stolen"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_alloc_context)",
            "GFP_KERNEL"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_meta_steal_slot",
          "args": [
            "osb"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_meta_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "939-942",
          "snippet": "static int ocfs2_get_meta_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, EXTENT_ALLOC_SYSTEM_INODE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_meta_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, EXTENT_ALLOC_SYSTEM_INODE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_steal_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "983-987",
    "snippet": "static int ocfs2_steal_meta(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, EXTENT_ALLOC_SYSTEM_INODE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_steal_resource",
          "args": [
            "osb",
            "ac",
            "EXTENT_ALLOC_SYSTEM_INODE"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_steal_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "944-975",
          "snippet": "static int ocfs2_steal_resource(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tint type)\n{\n\tint i, status = -ENOSPC;\n\tint slot = __ocfs2_get_steal_slot(osb, type);\n\n\t/* Start to steal resource from the first slot after ours. */\n\tif (slot == OCFS2_INVALID_SLOT)\n\t\tslot = osb->slot_num + 1;\n\n\tfor (i = 0; i < osb->max_slots; i++, slot++) {\n\t\tif (slot == osb->max_slots)\n\t\t\tslot = 0;\n\n\t\tif (slot == osb->slot_num)\n\t\t\tcontinue;\n\n\t\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t\t     type,\n\t\t\t\t\t\t     (u32)slot, NULL,\n\t\t\t\t\t\t     NOT_ALLOC_NEW_GROUP);\n\t\tif (status >= 0) {\n\t\t\t__ocfs2_set_steal_slot(osb, slot, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_free_ac_resource(ac);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NOT_ALLOC_NEW_GROUP\t\t0"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define NOT_ALLOC_NEW_GROUP\t\t0\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_resource(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tint type)\n{\n\tint i, status = -ENOSPC;\n\tint slot = __ocfs2_get_steal_slot(osb, type);\n\n\t/* Start to steal resource from the first slot after ours. */\n\tif (slot == OCFS2_INVALID_SLOT)\n\t\tslot = osb->slot_num + 1;\n\n\tfor (i = 0; i < osb->max_slots; i++, slot++) {\n\t\tif (slot == osb->max_slots)\n\t\t\tslot = 0;\n\n\t\tif (slot == osb->slot_num)\n\t\t\tcontinue;\n\n\t\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t\t     type,\n\t\t\t\t\t\t     (u32)slot, NULL,\n\t\t\t\t\t\t     NOT_ALLOC_NEW_GROUP);\n\t\tif (status >= 0) {\n\t\t\t__ocfs2_set_steal_slot(osb, slot, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_free_ac_resource(ac);\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_meta(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, EXTENT_ALLOC_SYSTEM_INODE);\n}"
  },
  {
    "function_name": "ocfs2_steal_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "977-981",
    "snippet": "static int ocfs2_steal_inode(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, INODE_ALLOC_SYSTEM_INODE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_steal_resource",
          "args": [
            "osb",
            "ac",
            "INODE_ALLOC_SYSTEM_INODE"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_steal_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "944-975",
          "snippet": "static int ocfs2_steal_resource(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tint type)\n{\n\tint i, status = -ENOSPC;\n\tint slot = __ocfs2_get_steal_slot(osb, type);\n\n\t/* Start to steal resource from the first slot after ours. */\n\tif (slot == OCFS2_INVALID_SLOT)\n\t\tslot = osb->slot_num + 1;\n\n\tfor (i = 0; i < osb->max_slots; i++, slot++) {\n\t\tif (slot == osb->max_slots)\n\t\t\tslot = 0;\n\n\t\tif (slot == osb->slot_num)\n\t\t\tcontinue;\n\n\t\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t\t     type,\n\t\t\t\t\t\t     (u32)slot, NULL,\n\t\t\t\t\t\t     NOT_ALLOC_NEW_GROUP);\n\t\tif (status >= 0) {\n\t\t\t__ocfs2_set_steal_slot(osb, slot, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_free_ac_resource(ac);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NOT_ALLOC_NEW_GROUP\t\t0"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define NOT_ALLOC_NEW_GROUP\t\t0\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_resource(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tint type)\n{\n\tint i, status = -ENOSPC;\n\tint slot = __ocfs2_get_steal_slot(osb, type);\n\n\t/* Start to steal resource from the first slot after ours. */\n\tif (slot == OCFS2_INVALID_SLOT)\n\t\tslot = osb->slot_num + 1;\n\n\tfor (i = 0; i < osb->max_slots; i++, slot++) {\n\t\tif (slot == osb->max_slots)\n\t\t\tslot = 0;\n\n\t\tif (slot == osb->slot_num)\n\t\t\tcontinue;\n\n\t\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t\t     type,\n\t\t\t\t\t\t     (u32)slot, NULL,\n\t\t\t\t\t\t     NOT_ALLOC_NEW_GROUP);\n\t\tif (status >= 0) {\n\t\t\t__ocfs2_set_steal_slot(osb, slot, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_free_ac_resource(ac);\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_inode(struct ocfs2_super *osb,\n\t\t\t     struct ocfs2_alloc_context *ac)\n{\n\treturn ocfs2_steal_resource(osb, ac, INODE_ALLOC_SYSTEM_INODE);\n}"
  },
  {
    "function_name": "ocfs2_steal_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "944-975",
    "snippet": "static int ocfs2_steal_resource(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tint type)\n{\n\tint i, status = -ENOSPC;\n\tint slot = __ocfs2_get_steal_slot(osb, type);\n\n\t/* Start to steal resource from the first slot after ours. */\n\tif (slot == OCFS2_INVALID_SLOT)\n\t\tslot = osb->slot_num + 1;\n\n\tfor (i = 0; i < osb->max_slots; i++, slot++) {\n\t\tif (slot == osb->max_slots)\n\t\t\tslot = 0;\n\n\t\tif (slot == osb->slot_num)\n\t\t\tcontinue;\n\n\t\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t\t     type,\n\t\t\t\t\t\t     (u32)slot, NULL,\n\t\t\t\t\t\t     NOT_ALLOC_NEW_GROUP);\n\t\tif (status >= 0) {\n\t\t\t__ocfs2_set_steal_slot(osb, slot, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_free_ac_resource(ac);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define NOT_ALLOC_NEW_GROUP\t\t0"
    ],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_ac_resource",
          "args": [
            "ac"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_ac_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "136-156",
          "snippet": "void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_set_steal_slot",
          "args": [
            "osb",
            "slot",
            "type"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_set_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "910-918",
          "snippet": "static void __ocfs2_set_steal_slot(struct ocfs2_super *osb, int slot, int type)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tosb->s_inode_steal_slot = slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tosb->s_meta_steal_slot = slot;\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void __ocfs2_set_steal_slot(struct ocfs2_super *osb, int slot, int type)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tosb->s_inode_steal_slot = slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tosb->s_meta_steal_slot = slot;\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_suballoc_bits",
          "args": [
            "osb",
            "ac",
            "type",
            "(u32)slot",
            "NULL",
            "NOT_ALLOC_NEW_GROUP"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "796-886",
          "snippet": "static int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_get_steal_slot",
          "args": [
            "osb",
            "type"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_get_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "920-932",
          "snippet": "static int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define NOT_ALLOC_NEW_GROUP\t\t0\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_steal_resource(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tint type)\n{\n\tint i, status = -ENOSPC;\n\tint slot = __ocfs2_get_steal_slot(osb, type);\n\n\t/* Start to steal resource from the first slot after ours. */\n\tif (slot == OCFS2_INVALID_SLOT)\n\t\tslot = osb->slot_num + 1;\n\n\tfor (i = 0; i < osb->max_slots; i++, slot++) {\n\t\tif (slot == osb->max_slots)\n\t\t\tslot = 0;\n\n\t\tif (slot == osb->slot_num)\n\t\t\tcontinue;\n\n\t\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t\t     type,\n\t\t\t\t\t\t     (u32)slot, NULL,\n\t\t\t\t\t\t     NOT_ALLOC_NEW_GROUP);\n\t\tif (status >= 0) {\n\t\t\t__ocfs2_set_steal_slot(osb, slot, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_free_ac_resource(ac);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_meta_steal_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "939-942",
    "snippet": "static int ocfs2_get_meta_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, EXTENT_ALLOC_SYSTEM_INODE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_get_steal_slot",
          "args": [
            "osb",
            "EXTENT_ALLOC_SYSTEM_INODE"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_get_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "920-932",
          "snippet": "static int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_meta_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, EXTENT_ALLOC_SYSTEM_INODE);\n}"
  },
  {
    "function_name": "ocfs2_get_inode_steal_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "934-937",
    "snippet": "static int ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, INODE_ALLOC_SYSTEM_INODE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_get_steal_slot",
          "args": [
            "osb",
            "INODE_ALLOC_SYSTEM_INODE"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_get_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "920-932",
          "snippet": "static int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_get_steal_slot(osb, INODE_ALLOC_SYSTEM_INODE);\n}"
  },
  {
    "function_name": "__ocfs2_get_steal_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "920-932",
    "snippet": "static int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_get_steal_slot(struct ocfs2_super *osb, int type)\n{\n\tint slot = OCFS2_INVALID_SLOT;\n\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_inode_steal_slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tslot = osb->s_meta_steal_slot;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}"
  },
  {
    "function_name": "__ocfs2_set_steal_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "910-918",
    "snippet": "static void __ocfs2_set_steal_slot(struct ocfs2_super *osb, int slot, int type)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tosb->s_inode_steal_slot = slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tosb->s_meta_steal_slot = slot;\n\tspin_unlock(&osb->osb_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void __ocfs2_set_steal_slot(struct ocfs2_super *osb, int slot, int type)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (type == INODE_ALLOC_SYSTEM_INODE)\n\t\tosb->s_inode_steal_slot = slot;\n\telse if (type == EXTENT_ALLOC_SYSTEM_INODE)\n\t\tosb->s_meta_steal_slot = slot;\n\tspin_unlock(&osb->osb_lock);\n}"
  },
  {
    "function_name": "ocfs2_init_steal_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "904-908",
    "snippet": "void ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_init_meta_steal_slot",
          "args": [
            "osb"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_meta_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "896-902",
          "snippet": "static void ocfs2_init_meta_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_meta_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_init_meta_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_meta_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_inode_steal_slot",
          "args": [
            "osb"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_inode_steal_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "888-894",
          "snippet": "static void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_inode_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_inode_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}"
  },
  {
    "function_name": "ocfs2_init_meta_steal_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "896-902",
    "snippet": "static void ocfs2_init_meta_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_meta_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->s_num_meta_stolen",
            "0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_init_meta_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_meta_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n}"
  },
  {
    "function_name": "ocfs2_init_inode_steal_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "888-894",
    "snippet": "static void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_inode_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->s_num_inodes_stolen",
            "0"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->s_inode_steal_slot = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\tatomic_set(&osb->s_num_inodes_stolen, 0);\n}"
  },
  {
    "function_name": "ocfs2_reserve_suballoc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "796-886",
    "snippet": "static int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ALLOC_NEW_GROUP\t\t\t0x1"
    ],
    "globals_used": [
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
      "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used))"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->id1.bitmap1.i_used"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&osb->alloc_stats.bg_extends"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_alloc",
          "args": [
            "osb",
            "alloc_inode",
            "bh",
            "ac->ac_max_block",
            "last_alloc_group",
            "flags"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "685-794",
          "snippet": "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags)\n{\n\tint status, credits;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\thandle_t *handle = NULL;\n\tu16 alloc_rec;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\n\tBUG_ON(ocfs2_is_cluster_bitmap(alloc_inode));\n\n\tcl = &fe->id2.i_chain;\n\tstatus = ocfs2_reserve_clusters_with_limit(osb,\n\t\t\t\t\t\t   le16_to_cpu(cl->cl_cpg),\n\t\t\t\t\t\t   max_block, flags, &ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tcredits = ocfs2_calc_group_alloc_credits(osb->sb,\n\t\t\t\t\t\t le16_to_cpu(cl->cl_cpg));\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (last_alloc_group && *last_alloc_group != 0) {\n\t\ttrace_ocfs2_block_group_alloc(\n\t\t\t\t(unsigned long long)*last_alloc_group);\n\t\tac->ac_last_group = *last_alloc_group;\n\t}\n\n\tbg_bh = ocfs2_block_group_alloc_contig(osb, handle, alloc_inode,\n\t\t\t\t\t       ac, cl);\n\tif (IS_ERR(bg_bh) && (PTR_ERR(bg_bh) == -ENOSPC))\n\t\tbg_bh = ocfs2_block_group_alloc_discontig(handle,\n\t\t\t\t\t\t\t  alloc_inode,\n\t\t\t\t\t\t\t  ac, cl);\n\tif (IS_ERR(bg_bh)) {\n\t\tstatus = PTR_ERR(bg_bh);\n\t\tbg_bh = NULL;\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc_rec = le16_to_cpu(bg->bg_chain);\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_free,\n\t\t     le16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_total,\n\t\t     le16_to_cpu(bg->bg_bits));\n\tcl->cl_recs[alloc_rec].c_blkno = bg->bg_blkno;\n\tif (le16_to_cpu(cl->cl_next_free_rec) < le16_to_cpu(cl->cl_count))\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_used, le16_to_cpu(bg->bg_bits) -\n\t\t\t\t\tle16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, le16_to_cpu(bg->bg_bits));\n\tle32_add_cpu(&fe->i_clusters, le16_to_cpu(cl->cl_cpg));\n\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(alloc_inode)->ip_lock);\n\tOCFS2_I(alloc_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tfe->i_size = cpu_to_le64(ocfs2_clusters_to_bytes(alloc_inode->i_sb,\n\t\t\t\t\t     le32_to_cpu(fe->i_clusters)));\n\tspin_unlock(&OCFS2_I(alloc_inode)->ip_lock);\n\ti_size_write(alloc_inode, le64_to_cpu(fe->i_size));\n\talloc_inode->i_blocks = ocfs2_inode_sector_count(alloc_inode);\n\tocfs2_update_inode_fsync_trans(handle, alloc_inode, 0);\n\n\tstatus = 0;\n\n\t/* save the new last alloc group so that the caller can cache it. */\n\tif (last_alloc_group)\n\t\t*last_alloc_group = ac->ac_last_group;\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tbrelse(bg_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags)\n{\n\tint status, credits;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\thandle_t *handle = NULL;\n\tu16 alloc_rec;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\n\tBUG_ON(ocfs2_is_cluster_bitmap(alloc_inode));\n\n\tcl = &fe->id2.i_chain;\n\tstatus = ocfs2_reserve_clusters_with_limit(osb,\n\t\t\t\t\t\t   le16_to_cpu(cl->cl_cpg),\n\t\t\t\t\t\t   max_block, flags, &ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tcredits = ocfs2_calc_group_alloc_credits(osb->sb,\n\t\t\t\t\t\t le16_to_cpu(cl->cl_cpg));\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (last_alloc_group && *last_alloc_group != 0) {\n\t\ttrace_ocfs2_block_group_alloc(\n\t\t\t\t(unsigned long long)*last_alloc_group);\n\t\tac->ac_last_group = *last_alloc_group;\n\t}\n\n\tbg_bh = ocfs2_block_group_alloc_contig(osb, handle, alloc_inode,\n\t\t\t\t\t       ac, cl);\n\tif (IS_ERR(bg_bh) && (PTR_ERR(bg_bh) == -ENOSPC))\n\t\tbg_bh = ocfs2_block_group_alloc_discontig(handle,\n\t\t\t\t\t\t\t  alloc_inode,\n\t\t\t\t\t\t\t  ac, cl);\n\tif (IS_ERR(bg_bh)) {\n\t\tstatus = PTR_ERR(bg_bh);\n\t\tbg_bh = NULL;\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc_rec = le16_to_cpu(bg->bg_chain);\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_free,\n\t\t     le16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_total,\n\t\t     le16_to_cpu(bg->bg_bits));\n\tcl->cl_recs[alloc_rec].c_blkno = bg->bg_blkno;\n\tif (le16_to_cpu(cl->cl_next_free_rec) < le16_to_cpu(cl->cl_count))\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_used, le16_to_cpu(bg->bg_bits) -\n\t\t\t\t\tle16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, le16_to_cpu(bg->bg_bits));\n\tle32_add_cpu(&fe->i_clusters, le16_to_cpu(cl->cl_cpg));\n\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(alloc_inode)->ip_lock);\n\tOCFS2_I(alloc_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tfe->i_size = cpu_to_le64(ocfs2_clusters_to_bytes(alloc_inode->i_sb,\n\t\t\t\t\t     le32_to_cpu(fe->i_clusters)));\n\tspin_unlock(&OCFS2_I(alloc_inode)->ip_lock);\n\ti_size_write(alloc_inode, le64_to_cpu(fe->i_size));\n\talloc_inode->i_blocks = ocfs2_inode_sector_count(alloc_inode);\n\tocfs2_update_inode_fsync_trans(handle, alloc_inode, 0);\n\n\tstatus = 0;\n\n\t/* save the new last alloc group so that the caller can cache it. */\n\tif (last_alloc_group)\n\t\t*last_alloc_group = ac->ac_last_group;\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tbrelse(bg_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reserve_suballoc_bits_no_new_group",
          "args": [
            "slot",
            "bits_wanted",
            "free_bits"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reserve_suballoc_bits_nospc",
          "args": [
            "bits_wanted",
            "free_bits"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "alloc_inode"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "alloc_inode->i_sb",
            "\"Invalid chain allocator %llu\"",
            "(unsigned long long)le64_to_cpu(fe->i_blkno)"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_blkno"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_CHAIN_FL"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(fe)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "fe"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "alloc_inode"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&alloc_inode->i_mutex"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "alloc_inode",
            "&bh",
            "1"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&alloc_inode->i_mutex"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-EINVAL"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "type",
            "slot"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_suballoc_bits(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t\t       int type,\n\t\t\t\t       u32 slot,\n\t\t\t\t       u64 *last_alloc_group,\n\t\t\t\t       int flags)\n{\n\tint status;\n\tu32 bits_wanted = ac->ac_bits_wanted;\n\tstruct inode *alloc_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe;\n\tu32 free_bits;\n\n\talloc_inode = ocfs2_get_system_file_inode(osb, type, slot);\n\tif (!alloc_inode) {\n\t\tmlog_errno(-EINVAL);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(alloc_inode, &bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tac->ac_inode = alloc_inode;\n\tac->ac_alloc_slot = slot;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\t/* The bh was validated by the inode read inside\n\t * ocfs2_inode_lock().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (!(fe->i_flags & cpu_to_le32(OCFS2_CHAIN_FL))) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Invalid chain allocator %llu\",\n\t\t\t    (unsigned long long)le64_to_cpu(fe->i_blkno));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tfree_bits = le32_to_cpu(fe->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(fe->id1.bitmap1.i_used);\n\n\tif (bits_wanted > free_bits) {\n\t\t/* cluster bitmap never grows */\n\t\tif (ocfs2_is_cluster_bitmap(alloc_inode)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_nospc(bits_wanted,\n\t\t\t\t\t\t\t\tfree_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!(flags & ALLOC_NEW_GROUP)) {\n\t\t\ttrace_ocfs2_reserve_suballoc_bits_no_new_group(\n\t\t\t\t\t\tslot, bits_wanted, free_bits);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_block_group_alloc(osb, alloc_inode, bh,\n\t\t\t\t\t\t ac->ac_max_block,\n\t\t\t\t\t\t last_alloc_group, flags);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tatomic_inc(&osb->alloc_stats.bg_extends);\n\n\t\t/* You should never ask for this much metadata */\n\t\tBUG_ON(bits_wanted >\n\t\t       (le32_to_cpu(fe->id1.bitmap1.i_total)\n\t\t\t- le32_to_cpu(fe->id1.bitmap1.i_used)));\n\t}\n\n\tget_bh(bh);\n\tac->ac_bh = bh;\nbail:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_group_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "685-794",
    "snippet": "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags)\n{\n\tint status, credits;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\thandle_t *handle = NULL;\n\tu16 alloc_rec;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\n\tBUG_ON(ocfs2_is_cluster_bitmap(alloc_inode));\n\n\tcl = &fe->id2.i_chain;\n\tstatus = ocfs2_reserve_clusters_with_limit(osb,\n\t\t\t\t\t\t   le16_to_cpu(cl->cl_cpg),\n\t\t\t\t\t\t   max_block, flags, &ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tcredits = ocfs2_calc_group_alloc_credits(osb->sb,\n\t\t\t\t\t\t le16_to_cpu(cl->cl_cpg));\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (last_alloc_group && *last_alloc_group != 0) {\n\t\ttrace_ocfs2_block_group_alloc(\n\t\t\t\t(unsigned long long)*last_alloc_group);\n\t\tac->ac_last_group = *last_alloc_group;\n\t}\n\n\tbg_bh = ocfs2_block_group_alloc_contig(osb, handle, alloc_inode,\n\t\t\t\t\t       ac, cl);\n\tif (IS_ERR(bg_bh) && (PTR_ERR(bg_bh) == -ENOSPC))\n\t\tbg_bh = ocfs2_block_group_alloc_discontig(handle,\n\t\t\t\t\t\t\t  alloc_inode,\n\t\t\t\t\t\t\t  ac, cl);\n\tif (IS_ERR(bg_bh)) {\n\t\tstatus = PTR_ERR(bg_bh);\n\t\tbg_bh = NULL;\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc_rec = le16_to_cpu(bg->bg_chain);\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_free,\n\t\t     le16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_total,\n\t\t     le16_to_cpu(bg->bg_bits));\n\tcl->cl_recs[alloc_rec].c_blkno = bg->bg_blkno;\n\tif (le16_to_cpu(cl->cl_next_free_rec) < le16_to_cpu(cl->cl_count))\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_used, le16_to_cpu(bg->bg_bits) -\n\t\t\t\t\tle16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, le16_to_cpu(bg->bg_bits));\n\tle32_add_cpu(&fe->i_clusters, le16_to_cpu(cl->cl_cpg));\n\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(alloc_inode)->ip_lock);\n\tOCFS2_I(alloc_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tfe->i_size = cpu_to_le64(ocfs2_clusters_to_bytes(alloc_inode->i_sb,\n\t\t\t\t\t     le32_to_cpu(fe->i_clusters)));\n\tspin_unlock(&OCFS2_I(alloc_inode)->ip_lock);\n\ti_size_write(alloc_inode, le64_to_cpu(fe->i_size));\n\talloc_inode->i_blocks = ocfs2_inode_sector_count(alloc_inode);\n\tocfs2_update_inode_fsync_trans(handle, alloc_inode, 0);\n\n\tstatus = 0;\n\n\t/* save the new last alloc group so that the caller can cache it. */\n\tif (last_alloc_group)\n\t\t*last_alloc_group = ac->ac_last_group;\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tbrelse(bg_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bg_bh"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ac"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "alloc_inode",
            "0"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "alloc_inode"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "alloc_inode",
            "le64_to_cpu(fe->i_size)"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_size"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(alloc_inode)->ip_lock"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "alloc_inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ocfs2_clusters_to_bytes(alloc_inode->i_sb,\n\t\t\t\t\t     le32_to_cpu(fe->i_clusters))"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "alloc_inode->i_sb",
            "le32_to_cpu(fe->i_clusters)"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_clusters"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(alloc_inode)->ip_lock"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->i_clusters",
            "le16_to_cpu(cl->cl_cpg)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_cpg"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->id1.bitmap1.i_total",
            "le16_to_cpu(bg->bg_bits)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->id1.bitmap1.i_used",
            "le16_to_cpu(bg->bg_bits) -\n\t\t\t\t\tle16_to_cpu(bg->bg_free_bits_count)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&cl->cl_next_free_rec",
            "1"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cl->cl_recs[alloc_rec].c_total",
            "le16_to_cpu(bg->bg_bits)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cl->cl_recs[alloc_rec].c_free",
            "le16_to_cpu(bg->bg_free_bits_count)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bg_bh"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bg_bh"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_alloc_discontig",
          "args": [
            "handle",
            "alloc_inode",
            "ac",
            "cl"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_alloc_discontig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "607-680",
          "snippet": "static struct buffer_head *\nocfs2_block_group_alloc_discontig(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tunsigned int min_bits = le16_to_cpu(cl->cl_cpg) >> 1;\n\tstruct buffer_head *bg_bh = NULL;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\n\tif (!ocfs2_supports_discontig_bg(osb)) {\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t    ocfs2_calc_bg_discontig_credits(osb->sb));\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We're going to be grabbing from multiple cluster groups.\n\t * We don't have enough credits to relink them all, and the\n\t * cluster groups will be staying in cache for the duration of\n\t * this operation.\n\t */\n\tac->ac_disable_chain_relink = 1;\n\n\t/* Claim the first region */\n\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac, min_bits,\n\t\t\t\t\t      &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmin_bits = num_bits;\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_discontig(\n\t\t\t\t(unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_grow_discontig(handle, alloc_inode,\n\t\t\t\t\t\t  bg_bh, ac, cl, min_bits);\n\tif (status)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status)\n\t\tocfs2_bg_alloc_cleanup(handle, ac, alloc_inode, bg_bh);\n\treturn status ? ERR_PTR(status) : bg_bh;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic struct buffer_head *\nocfs2_block_group_alloc_discontig(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tunsigned int min_bits = le16_to_cpu(cl->cl_cpg) >> 1;\n\tstruct buffer_head *bg_bh = NULL;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\n\tif (!ocfs2_supports_discontig_bg(osb)) {\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t    ocfs2_calc_bg_discontig_credits(osb->sb));\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We're going to be grabbing from multiple cluster groups.\n\t * We don't have enough credits to relink them all, and the\n\t * cluster groups will be staying in cache for the duration of\n\t * this operation.\n\t */\n\tac->ac_disable_chain_relink = 1;\n\n\t/* Claim the first region */\n\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac, min_bits,\n\t\t\t\t\t      &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmin_bits = num_bits;\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_discontig(\n\t\t\t\t(unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_grow_discontig(handle, alloc_inode,\n\t\t\t\t\t\t  bg_bh, ac, cl, min_bits);\n\tif (status)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status)\n\t\tocfs2_bg_alloc_cleanup(handle, ac, alloc_inode, bg_bh);\n\treturn status ? ERR_PTR(status) : bg_bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bg_bh"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bg_bh"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_alloc_contig",
          "args": [
            "osb",
            "handle",
            "alloc_inode",
            "ac",
            "cl"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_alloc_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "450-493",
          "snippet": "static struct buffer_head *\nocfs2_block_group_alloc_contig(struct ocfs2_super *osb, handle_t *handle,\n\t\t\t       struct inode *alloc_inode,\n\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t       struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tstruct buffer_head *bg_bh;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\n\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t      le16_to_cpu(cl->cl_cpg), &bit_off,\n\t\t\t\t      &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_contig(\n\t     (unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tbrelse(bg_bh);\n\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status ? ERR_PTR(status) : bg_bh;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic struct buffer_head *\nocfs2_block_group_alloc_contig(struct ocfs2_super *osb, handle_t *handle,\n\t\t\t       struct inode *alloc_inode,\n\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t       struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tstruct buffer_head *bg_bh;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\n\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t      le16_to_cpu(cl->cl_cpg), &bit_off,\n\t\t\t\t      &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_contig(\n\t     (unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tbrelse(bg_bh);\n\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status ? ERR_PTR(status) : bg_bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_block_group_alloc",
          "args": [
            "(unsigned long long)*last_alloc_group"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_group_alloc_credits",
          "args": [
            "osb->sb",
            "le16_to_cpu(cl->cl_cpg)"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_group_alloc_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "569-578",
          "snippet": "static inline int ocfs2_calc_group_alloc_credits(struct super_block *sb,\n\t\t\t\t\t\t unsigned int cpg)\n{\n\tint blocks;\n\tint bitmap_blocks = OCFS2_SUBALLOC_ALLOC + 1;\n\t/* parent inode update + new block group header + bitmap inode update\n\t   + bitmap blocks affected */\n\tblocks = 1 + 1 + 1 + bitmap_blocks;\n\treturn blocks;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_group_alloc_credits(struct super_block *sb,\n\t\t\t\t\t\t unsigned int cpg)\n{\n\tint blocks;\n\tint bitmap_blocks = OCFS2_SUBALLOC_ALLOC + 1;\n\t/* parent inode update + new block group header + bitmap inode update\n\t   + bitmap blocks affected */\n\tblocks = 1 + 1 + 1 + bitmap_blocks;\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters_with_limit",
          "args": [
            "osb",
            "le16_to_cpu(cl->cl_cpg)",
            "max_block",
            "flags",
            "&ac"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters_with_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1178-1226",
          "snippet": "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = bits_wanted;\n\t(*ac)->ac_max_block = max_block;\n\n\tstatus = -ENOSPC;\n\tif (!(flags & ALLOC_GROUPS_FROM_GLOBAL) &&\n\t    ocfs2_alloc_should_use_local(osb, bits_wanted)) {\n\t\tstatus = ocfs2_reserve_local_alloc_bits(osb,\n\t\t\t\t\t\t\tbits_wanted,\n\t\t\t\t\t\t\t*ac);\n\t\tif ((status < 0) && (status != -ENOSPC)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (status == -ENOSPC) {\n\t\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2"
          ],
          "globals_used": [
            "static int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = bits_wanted;\n\t(*ac)->ac_max_block = max_block;\n\n\tstatus = -ENOSPC;\n\tif (!(flags & ALLOC_GROUPS_FROM_GLOBAL) &&\n\t    ocfs2_alloc_should_use_local(osb, bits_wanted)) {\n\t\tstatus = ocfs2_reserve_local_alloc_bits(osb,\n\t\t\t\t\t\t\tbits_wanted,\n\t\t\t\t\t\t\t*ac);\n\t\tif ((status < 0) && (status != -ENOSPC)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (status == -ENOSPC) {\n\t\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_is_cluster_bitmap(alloc_inode)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_cluster_bitmap",
          "args": [
            "alloc_inode"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_cluster_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "179-183",
          "snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_cluster_bitmap(struct inode *inode)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\treturn osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_alloc(struct ocfs2_super *osb,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   u64 max_block,\n\t\t\t\t   u64 *last_alloc_group,\n\t\t\t\t   int flags)\n{\n\tint status, credits;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\thandle_t *handle = NULL;\n\tu16 alloc_rec;\n\tstruct buffer_head *bg_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\n\tBUG_ON(ocfs2_is_cluster_bitmap(alloc_inode));\n\n\tcl = &fe->id2.i_chain;\n\tstatus = ocfs2_reserve_clusters_with_limit(osb,\n\t\t\t\t\t\t   le16_to_cpu(cl->cl_cpg),\n\t\t\t\t\t\t   max_block, flags, &ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tcredits = ocfs2_calc_group_alloc_credits(osb->sb,\n\t\t\t\t\t\t le16_to_cpu(cl->cl_cpg));\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (last_alloc_group && *last_alloc_group != 0) {\n\t\ttrace_ocfs2_block_group_alloc(\n\t\t\t\t(unsigned long long)*last_alloc_group);\n\t\tac->ac_last_group = *last_alloc_group;\n\t}\n\n\tbg_bh = ocfs2_block_group_alloc_contig(osb, handle, alloc_inode,\n\t\t\t\t\t       ac, cl);\n\tif (IS_ERR(bg_bh) && (PTR_ERR(bg_bh) == -ENOSPC))\n\t\tbg_bh = ocfs2_block_group_alloc_discontig(handle,\n\t\t\t\t\t\t\t  alloc_inode,\n\t\t\t\t\t\t\t  ac, cl);\n\tif (IS_ERR(bg_bh)) {\n\t\tstatus = PTR_ERR(bg_bh);\n\t\tbg_bh = NULL;\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tbg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc_rec = le16_to_cpu(bg->bg_chain);\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_free,\n\t\t     le16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&cl->cl_recs[alloc_rec].c_total,\n\t\t     le16_to_cpu(bg->bg_bits));\n\tcl->cl_recs[alloc_rec].c_blkno = bg->bg_blkno;\n\tif (le16_to_cpu(cl->cl_next_free_rec) < le16_to_cpu(cl->cl_count))\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_used, le16_to_cpu(bg->bg_bits) -\n\t\t\t\t\tle16_to_cpu(bg->bg_free_bits_count));\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, le16_to_cpu(bg->bg_bits));\n\tle32_add_cpu(&fe->i_clusters, le16_to_cpu(cl->cl_cpg));\n\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(alloc_inode)->ip_lock);\n\tOCFS2_I(alloc_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tfe->i_size = cpu_to_le64(ocfs2_clusters_to_bytes(alloc_inode->i_sb,\n\t\t\t\t\t     le32_to_cpu(fe->i_clusters)));\n\tspin_unlock(&OCFS2_I(alloc_inode)->ip_lock);\n\ti_size_write(alloc_inode, le64_to_cpu(fe->i_size));\n\talloc_inode->i_blocks = ocfs2_inode_sector_count(alloc_inode);\n\tocfs2_update_inode_fsync_trans(handle, alloc_inode, 0);\n\n\tstatus = 0;\n\n\t/* save the new last alloc group so that the caller can cache it. */\n\tif (last_alloc_group)\n\t\t*last_alloc_group = ac->ac_last_group;\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tbrelse(bg_bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_group_alloc_discontig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "607-680",
    "snippet": "static struct buffer_head *\nocfs2_block_group_alloc_discontig(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tunsigned int min_bits = le16_to_cpu(cl->cl_cpg) >> 1;\n\tstruct buffer_head *bg_bh = NULL;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\n\tif (!ocfs2_supports_discontig_bg(osb)) {\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t    ocfs2_calc_bg_discontig_credits(osb->sb));\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We're going to be grabbing from multiple cluster groups.\n\t * We don't have enough credits to relink them all, and the\n\t * cluster groups will be staying in cache for the duration of\n\t * this operation.\n\t */\n\tac->ac_disable_chain_relink = 1;\n\n\t/* Claim the first region */\n\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac, min_bits,\n\t\t\t\t\t      &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmin_bits = num_bits;\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_discontig(\n\t\t\t\t(unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_grow_discontig(handle, alloc_inode,\n\t\t\t\t\t\t  bg_bh, ac, cl, min_bits);\n\tif (status)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status)\n\t\tocfs2_bg_alloc_cleanup(handle, ac, alloc_inode, bg_bh);\n\treturn status ? ERR_PTR(status) : bg_bh;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_bg_alloc_cleanup",
          "args": [
            "handle",
            "ac",
            "alloc_inode",
            "bg_bh"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bg_alloc_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "577-605",
          "snippet": "static void ocfs2_bg_alloc_cleanup(handle_t *handle,\n\t\t\t\t   struct ocfs2_alloc_context *cluster_ac,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bg_bh)\n{\n\tint i, ret;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (!bg_bh)\n\t\treturn;\n\n\tbg = (struct ocfs2_group_desc *)bg_bh->b_data;\n\tel = &bg->bg_list;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\t\tret = ocfs2_free_clusters(handle, cluster_ac->ac_inode,\n\t\t\t\t\t  cluster_ac->ac_bh,\n\t\t\t\t\t  le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t  le16_to_cpu(rec->e_leaf_clusters));\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/* Try all the clusters to free */\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(alloc_inode), bg_bh);\n\tbrelse(bg_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nstatic void ocfs2_bg_alloc_cleanup(handle_t *handle,\n\t\t\t\t   struct ocfs2_alloc_context *cluster_ac,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bg_bh)\n{\n\tint i, ret;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (!bg_bh)\n\t\treturn;\n\n\tbg = (struct ocfs2_group_desc *)bg_bh->b_data;\n\tel = &bg->bg_list;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\t\tret = ocfs2_free_clusters(handle, cluster_ac->ac_inode,\n\t\t\t\t\t  cluster_ac->ac_bh,\n\t\t\t\t\t  le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t  le16_to_cpu(rec->e_leaf_clusters));\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/* Try all the clusters to free */\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(alloc_inode), bg_bh);\n\tbrelse(bg_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_grow_discontig",
          "args": [
            "handle",
            "alloc_inode",
            "bg_bh",
            "ac",
            "cl",
            "min_bits"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_grow_discontig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "515-575",
          "snippet": "static int ocfs2_block_group_grow_discontig(handle_t *handle,\n\t\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t\t    struct ocfs2_alloc_context *ac,\n\t\t\t\t\t    struct ocfs2_chain_list *cl,\n\t\t\t\t\t    unsigned int min_bits)\n{\n\tint status;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg =\n\t\t(struct ocfs2_group_desc *)bg_bh->b_data;\n\tunsigned int needed = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\tu32 p_cpos, clusters;\n\tu64 p_blkno;\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile ((needed > 0) && (le16_to_cpu(el->l_next_free_rec) <\n\t\t\t\tle16_to_cpu(el->l_count))) {\n\t\tif (min_bits > needed)\n\t\t\tmin_bits = needed;\n\t\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac,\n\t\t\t\t\t\t      min_bits, &p_cpos,\n\t\t\t\t\t\t      &clusters);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tp_blkno = ocfs2_clusters_to_blocks(osb->sb, p_cpos);\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, p_blkno,\n\t\t\t\t\t      clusters);\n\n\t\tmin_bits = clusters;\n\t\tneeded = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\t}\n\n\tif (needed > 0) {\n\t\t/*\n\t\t * We have used up all the extent rec but can't fill up\n\t\t * the cpg. So bail out.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_grow_discontig(handle_t *handle,\n\t\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t\t    struct ocfs2_alloc_context *ac,\n\t\t\t\t\t    struct ocfs2_chain_list *cl,\n\t\t\t\t\t    unsigned int min_bits)\n{\n\tint status;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg =\n\t\t(struct ocfs2_group_desc *)bg_bh->b_data;\n\tunsigned int needed = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\tu32 p_cpos, clusters;\n\tu64 p_blkno;\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile ((needed > 0) && (le16_to_cpu(el->l_next_free_rec) <\n\t\t\t\tle16_to_cpu(el->l_count))) {\n\t\tif (min_bits > needed)\n\t\t\tmin_bits = needed;\n\t\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac,\n\t\t\t\t\t\t      min_bits, &p_cpos,\n\t\t\t\t\t\t      &clusters);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tp_blkno = ocfs2_clusters_to_blocks(osb->sb, p_cpos);\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, p_blkno,\n\t\t\t\t\t      clusters);\n\n\t\tmin_bits = clusters;\n\t\tneeded = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\t}\n\n\tif (needed > 0) {\n\t\t/*\n\t\t * We have used up all the extent rec but can't fill up\n\t\t * the cpg. So bail out.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_fill",
          "args": [
            "handle",
            "alloc_inode",
            "bg_bh",
            "bg_blkno",
            "num_bits",
            "alloc_rec",
            "cl"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "373-434",
          "snippet": "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct super_block * sb = alloc_inode->i_sb;\n\n\tif (((unsigned long long) bg_bh->b_blocknr) != group_blkno) {\n\t\tocfs2_error(alloc_inode->i_sb, \"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\",\n\t\t\t    (unsigned long long)group_blkno,\n\t\t\t    (unsigned long long) bg_bh->b_blocknr);\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmemset(bg, 0, sb->s_blocksize);\n\tstrcpy(bg->bg_signature, OCFS2_GROUP_DESC_SIGNATURE);\n\tbg->bg_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tbg->bg_size = cpu_to_le16(ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat));\n\tbg->bg_chain = cpu_to_le16(my_chain);\n\tbg->bg_next_group = cl->cl_recs[my_chain].c_blkno;\n\tbg->bg_parent_dinode = cpu_to_le64(OCFS2_I(alloc_inode)->ip_blkno);\n\tbg->bg_blkno = cpu_to_le64(group_blkno);\n\tif (group_clusters == le16_to_cpu(cl->cl_cpg))\n\t\tbg->bg_bits = cpu_to_le16(ocfs2_bits_per_group(cl));\n\telse\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, group_blkno,\n\t\t\t\t\t      group_clusters);\n\n\t/* set the 1st bit in the bitmap to account for the descriptor block */\n\tocfs2_set_bit(0, (unsigned long *)bg->bg_bitmap);\n\tbg->bg_free_bits_count = cpu_to_le16(le16_to_cpu(bg->bg_bits) - 1);\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\t/* There is no need to zero out or otherwise initialize the\n\t * other blocks in a group - All valid FS metadata in a block\n\t * group stores the superblock fs_generation value at\n\t * allocation time. */\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct super_block * sb = alloc_inode->i_sb;\n\n\tif (((unsigned long long) bg_bh->b_blocknr) != group_blkno) {\n\t\tocfs2_error(alloc_inode->i_sb, \"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\",\n\t\t\t    (unsigned long long)group_blkno,\n\t\t\t    (unsigned long long) bg_bh->b_blocknr);\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmemset(bg, 0, sb->s_blocksize);\n\tstrcpy(bg->bg_signature, OCFS2_GROUP_DESC_SIGNATURE);\n\tbg->bg_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tbg->bg_size = cpu_to_le16(ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat));\n\tbg->bg_chain = cpu_to_le16(my_chain);\n\tbg->bg_next_group = cl->cl_recs[my_chain].c_blkno;\n\tbg->bg_parent_dinode = cpu_to_le64(OCFS2_I(alloc_inode)->ip_blkno);\n\tbg->bg_blkno = cpu_to_le64(group_blkno);\n\tif (group_clusters == le16_to_cpu(cl->cl_cpg))\n\t\tbg->bg_bits = cpu_to_le16(ocfs2_bits_per_group(cl));\n\telse\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, group_blkno,\n\t\t\t\t\t      group_clusters);\n\n\t/* set the 1st bit in the bitmap to account for the descriptor block */\n\tocfs2_set_bit(0, (unsigned long *)bg->bg_bitmap);\n\tbg->bg_free_bits_count = cpu_to_le16(le16_to_cpu(bg->bg_bits) - 1);\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\t/* There is no need to zero out or otherwise initialize the\n\t * other blocks in a group - All valid FS metadata in a block\n\t * group stores the superblock fs_generation value at\n\t * allocation time. */\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(alloc_inode)",
            "bg_bh"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "bg_blkno"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_block_group_alloc_discontig",
          "args": [
            "(unsigned long long)bg_blkno",
            "alloc_rec"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_claim_bits",
          "args": [
            "osb",
            "handle",
            "ac",
            "min_bits",
            "&bit_off",
            "&num_bits"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_claim_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "495-513",
          "snippet": "static int ocfs2_block_group_claim_bits(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\t\tunsigned int min_bits,\n\t\t\t\t\tu32 *bit_off, u32 *num_bits)\n{\n\tint status = 0;\n\n\twhile (min_bits) {\n\t\tstatus = ocfs2_claim_clusters(handle, ac, min_bits,\n\t\t\t\t\t      bit_off, num_bits);\n\t\tif (status != -ENOSPC)\n\t\t\tbreak;\n\n\t\tmin_bits >>= 1;\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_claim_bits(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\t\tunsigned int min_bits,\n\t\t\t\t\tu32 *bit_off, u32 *num_bits)\n{\n\tint status = 0;\n\n\twhile (min_bits) {\n\t\tstatus = ocfs2_claim_clusters(handle, ac, min_bits,\n\t\t\t\t\t      bit_off, num_bits);\n\t\tif (status != -ENOSPC)\n\t\t\tbreak;\n\n\t\tmin_bits >>= 1;\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "ocfs2_calc_bg_discontig_credits(osb->sb)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_bg_discontig_credits",
          "args": [
            "osb->sb"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_bg_discontig_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "587-590",
          "snippet": "static inline int ocfs2_calc_bg_discontig_credits(struct super_block *sb)\n{\n\treturn ocfs2_extent_recs_per_gd(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_calc_bg_discontig_credits(struct super_block *sb)\n{\n\treturn ocfs2_extent_recs_per_gd(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_discontig_bg",
          "args": [
            "osb"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_discontig_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "539-544",
          "snippet": "static inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "alloc_inode->i_sb"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_smallest_chain",
          "args": [
            "cl"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_smallest_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "436-448",
          "snippet": "static inline u16 ocfs2_find_smallest_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_count)) {\n\t\tif (le32_to_cpu(cl->cl_recs[best].c_total) >\n\t\t    le32_to_cpu(cl->cl_recs[curr].c_total))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic inline u16 ocfs2_find_smallest_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_count)) {\n\t\tif (le32_to_cpu(cl->cl_recs[best].c_total) >\n\t\t    le32_to_cpu(cl->cl_recs[curr].c_total))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\treturn best;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_cpg"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic struct buffer_head *\nocfs2_block_group_alloc_discontig(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct ocfs2_alloc_context *ac,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tunsigned int min_bits = le16_to_cpu(cl->cl_cpg) >> 1;\n\tstruct buffer_head *bg_bh = NULL;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\n\tif (!ocfs2_supports_discontig_bg(osb)) {\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t    ocfs2_calc_bg_discontig_credits(osb->sb));\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * We're going to be grabbing from multiple cluster groups.\n\t * We don't have enough credits to relink them all, and the\n\t * cluster groups will be staying in cache for the duration of\n\t * this operation.\n\t */\n\tac->ac_disable_chain_relink = 1;\n\n\t/* Claim the first region */\n\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac, min_bits,\n\t\t\t\t\t      &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmin_bits = num_bits;\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_discontig(\n\t\t\t\t(unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_block_group_grow_discontig(handle, alloc_inode,\n\t\t\t\t\t\t  bg_bh, ac, cl, min_bits);\n\tif (status)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status)\n\t\tocfs2_bg_alloc_cleanup(handle, ac, alloc_inode, bg_bh);\n\treturn status ? ERR_PTR(status) : bg_bh;\n}"
  },
  {
    "function_name": "ocfs2_bg_alloc_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "577-605",
    "snippet": "static void ocfs2_bg_alloc_cleanup(handle_t *handle,\n\t\t\t\t   struct ocfs2_alloc_context *cluster_ac,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bg_bh)\n{\n\tint i, ret;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (!bg_bh)\n\t\treturn;\n\n\tbg = (struct ocfs2_group_desc *)bg_bh->b_data;\n\tel = &bg->bg_list;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\t\tret = ocfs2_free_clusters(handle, cluster_ac->ac_inode,\n\t\t\t\t\t  cluster_ac->ac_bh,\n\t\t\t\t\t  le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t  le16_to_cpu(rec->e_leaf_clusters));\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/* Try all the clusters to free */\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(alloc_inode), bg_bh);\n\tbrelse(bg_bh);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bg_bh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_from_cache",
          "args": [
            "INODE_CACHE(alloc_inode)",
            "bg_bh"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "603-609",
          "snippet": "void ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "cluster_ac->ac_inode",
            "cluster_ac->ac_bh",
            "le64_to_cpu(rec->e_blkno)",
            "le16_to_cpu(rec->e_leaf_clusters)"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2591-2600",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nstatic void ocfs2_bg_alloc_cleanup(handle_t *handle,\n\t\t\t\t   struct ocfs2_alloc_context *cluster_ac,\n\t\t\t\t   struct inode *alloc_inode,\n\t\t\t\t   struct buffer_head *bg_bh)\n{\n\tint i, ret;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (!bg_bh)\n\t\treturn;\n\n\tbg = (struct ocfs2_group_desc *)bg_bh->b_data;\n\tel = &bg->bg_list;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\t\tret = ocfs2_free_clusters(handle, cluster_ac->ac_inode,\n\t\t\t\t\t  cluster_ac->ac_bh,\n\t\t\t\t\t  le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t  le16_to_cpu(rec->e_leaf_clusters));\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\t/* Try all the clusters to free */\n\t}\n\n\tocfs2_remove_from_cache(INODE_CACHE(alloc_inode), bg_bh);\n\tbrelse(bg_bh);\n}"
  },
  {
    "function_name": "ocfs2_block_group_grow_discontig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "515-575",
    "snippet": "static int ocfs2_block_group_grow_discontig(handle_t *handle,\n\t\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t\t    struct ocfs2_alloc_context *ac,\n\t\t\t\t\t    struct ocfs2_chain_list *cl,\n\t\t\t\t\t    unsigned int min_bits)\n{\n\tint status;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg =\n\t\t(struct ocfs2_group_desc *)bg_bh->b_data;\n\tunsigned int needed = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\tu32 p_cpos, clusters;\n\tu64 p_blkno;\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile ((needed > 0) && (le16_to_cpu(el->l_next_free_rec) <\n\t\t\t\tle16_to_cpu(el->l_count))) {\n\t\tif (min_bits > needed)\n\t\t\tmin_bits = needed;\n\t\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac,\n\t\t\t\t\t\t      min_bits, &p_cpos,\n\t\t\t\t\t\t      &clusters);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tp_blkno = ocfs2_clusters_to_blocks(osb->sb, p_cpos);\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, p_blkno,\n\t\t\t\t\t      clusters);\n\n\t\tmin_bits = clusters;\n\t\tneeded = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\t}\n\n\tif (needed > 0) {\n\t\t/*\n\t\t * We have used up all the extent rec but can't fill up\n\t\t * the cpg. So bail out.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bg_bh"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_bpc"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bg_discontig_add_extent",
          "args": [
            "osb",
            "bg",
            "cl",
            "p_blkno",
            "clusters"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bg_discontig_add_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "351-371",
          "snippet": "static void ocfs2_bg_discontig_add_extent(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_chain_list *cl,\n\t\t\t\t\t  u64 p_blkno, unsigned int clusters)\n{\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(!ocfs2_supports_discontig_bg(osb));\n\tif (!el->l_next_free_rec)\n\t\tel->l_count = cpu_to_le16(ocfs2_extent_recs_per_gd(osb->sb));\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec)];\n\trec->e_blkno = cpu_to_le64(p_blkno);\n\trec->e_cpos = cpu_to_le32(le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc));\n\trec->e_leaf_clusters = cpu_to_le16(clusters);\n\tle16_add_cpu(&bg->bg_bits, clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&bg->bg_free_bits_count,\n\t\t     clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic void ocfs2_bg_discontig_add_extent(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_chain_list *cl,\n\t\t\t\t\t  u64 p_blkno, unsigned int clusters)\n{\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(!ocfs2_supports_discontig_bg(osb));\n\tif (!el->l_next_free_rec)\n\t\tel->l_count = cpu_to_le16(ocfs2_extent_recs_per_gd(osb->sb));\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec)];\n\trec->e_blkno = cpu_to_le64(p_blkno);\n\trec->e_cpos = cpu_to_le32(le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc));\n\trec->e_leaf_clusters = cpu_to_le16(clusters);\n\tle16_add_cpu(&bg->bg_bits, clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&bg->bg_free_bits_count,\n\t\t     clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "p_cpos"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_claim_bits",
          "args": [
            "osb",
            "handle",
            "ac",
            "min_bits",
            "&p_cpos",
            "&clusters"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_claim_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "495-513",
          "snippet": "static int ocfs2_block_group_claim_bits(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\t\tunsigned int min_bits,\n\t\t\t\t\tu32 *bit_off, u32 *num_bits)\n{\n\tint status = 0;\n\n\twhile (min_bits) {\n\t\tstatus = ocfs2_claim_clusters(handle, ac, min_bits,\n\t\t\t\t\t      bit_off, num_bits);\n\t\tif (status != -ENOSPC)\n\t\t\tbreak;\n\n\t\tmin_bits >>= 1;\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_claim_bits(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\t\tunsigned int min_bits,\n\t\t\t\t\tu32 *bit_off, u32 *num_bits)\n{\n\tint status = 0;\n\n\twhile (min_bits) {\n\t\tstatus = ocfs2_claim_clusters(handle, ac, min_bits,\n\t\t\t\t\t      bit_off, num_bits);\n\t\tif (status != -ENOSPC)\n\t\t\tbreak;\n\n\t\tmin_bits >>= 1;\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "bg_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "alloc_inode->i_sb"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_grow_discontig(handle_t *handle,\n\t\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t\t    struct ocfs2_alloc_context *ac,\n\t\t\t\t\t    struct ocfs2_chain_list *cl,\n\t\t\t\t\t    unsigned int min_bits)\n{\n\tint status;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg =\n\t\t(struct ocfs2_group_desc *)bg_bh->b_data;\n\tunsigned int needed = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\tu32 p_cpos, clusters;\n\tu64 p_blkno;\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile ((needed > 0) && (le16_to_cpu(el->l_next_free_rec) <\n\t\t\t\tle16_to_cpu(el->l_count))) {\n\t\tif (min_bits > needed)\n\t\t\tmin_bits = needed;\n\t\tstatus = ocfs2_block_group_claim_bits(osb, handle, ac,\n\t\t\t\t\t\t      min_bits, &p_cpos,\n\t\t\t\t\t\t      &clusters);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tp_blkno = ocfs2_clusters_to_blocks(osb->sb, p_cpos);\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, p_blkno,\n\t\t\t\t\t      clusters);\n\n\t\tmin_bits = clusters;\n\t\tneeded = le16_to_cpu(cl->cl_cpg) -\n\t\t\t le16_to_cpu(bg->bg_bits) / le16_to_cpu(cl->cl_bpc);\n\t}\n\n\tif (needed > 0) {\n\t\t/*\n\t\t * We have used up all the extent rec but can't fill up\n\t\t * the cpg. So bail out.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_group_claim_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "495-513",
    "snippet": "static int ocfs2_block_group_claim_bits(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\t\tunsigned int min_bits,\n\t\t\t\t\tu32 *bit_off, u32 *num_bits)\n{\n\tint status = 0;\n\n\twhile (min_bits) {\n\t\tstatus = ocfs2_claim_clusters(handle, ac, min_bits,\n\t\t\t\t\t      bit_off, num_bits);\n\t\tif (status != -ENOSPC)\n\t\t\tbreak;\n\n\t\tmin_bits >>= 1;\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "ac",
            "min_bits",
            "bit_off",
            "num_bits"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2373-2383",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic int ocfs2_block_group_claim_bits(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\t\tunsigned int min_bits,\n\t\t\t\t\tu32 *bit_off, u32 *num_bits)\n{\n\tint status = 0;\n\n\twhile (min_bits) {\n\t\tstatus = ocfs2_claim_clusters(handle, ac, min_bits,\n\t\t\t\t\t      bit_off, num_bits);\n\t\tif (status != -ENOSPC)\n\t\t\tbreak;\n\n\t\tmin_bits >>= 1;\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_block_group_alloc_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "450-493",
    "snippet": "static struct buffer_head *\nocfs2_block_group_alloc_contig(struct ocfs2_super *osb, handle_t *handle,\n\t\t\t       struct inode *alloc_inode,\n\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t       struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tstruct buffer_head *bg_bh;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\n\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t      le16_to_cpu(cl->cl_cpg), &bit_off,\n\t\t\t\t      &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_contig(\n\t     (unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tbrelse(bg_bh);\n\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status ? ERR_PTR(status) : bg_bh;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bg_bh"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_fill",
          "args": [
            "handle",
            "alloc_inode",
            "bg_bh",
            "bg_blkno",
            "num_bits",
            "alloc_rec",
            "cl"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "373-434",
          "snippet": "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct super_block * sb = alloc_inode->i_sb;\n\n\tif (((unsigned long long) bg_bh->b_blocknr) != group_blkno) {\n\t\tocfs2_error(alloc_inode->i_sb, \"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\",\n\t\t\t    (unsigned long long)group_blkno,\n\t\t\t    (unsigned long long) bg_bh->b_blocknr);\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmemset(bg, 0, sb->s_blocksize);\n\tstrcpy(bg->bg_signature, OCFS2_GROUP_DESC_SIGNATURE);\n\tbg->bg_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tbg->bg_size = cpu_to_le16(ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat));\n\tbg->bg_chain = cpu_to_le16(my_chain);\n\tbg->bg_next_group = cl->cl_recs[my_chain].c_blkno;\n\tbg->bg_parent_dinode = cpu_to_le64(OCFS2_I(alloc_inode)->ip_blkno);\n\tbg->bg_blkno = cpu_to_le64(group_blkno);\n\tif (group_clusters == le16_to_cpu(cl->cl_cpg))\n\t\tbg->bg_bits = cpu_to_le16(ocfs2_bits_per_group(cl));\n\telse\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, group_blkno,\n\t\t\t\t\t      group_clusters);\n\n\t/* set the 1st bit in the bitmap to account for the descriptor block */\n\tocfs2_set_bit(0, (unsigned long *)bg->bg_bitmap);\n\tbg->bg_free_bits_count = cpu_to_le16(le16_to_cpu(bg->bg_bits) - 1);\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\t/* There is no need to zero out or otherwise initialize the\n\t * other blocks in a group - All valid FS metadata in a block\n\t * group stores the superblock fs_generation value at\n\t * allocation time. */\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct super_block * sb = alloc_inode->i_sb;\n\n\tif (((unsigned long long) bg_bh->b_blocknr) != group_blkno) {\n\t\tocfs2_error(alloc_inode->i_sb, \"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\",\n\t\t\t    (unsigned long long)group_blkno,\n\t\t\t    (unsigned long long) bg_bh->b_blocknr);\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmemset(bg, 0, sb->s_blocksize);\n\tstrcpy(bg->bg_signature, OCFS2_GROUP_DESC_SIGNATURE);\n\tbg->bg_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tbg->bg_size = cpu_to_le16(ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat));\n\tbg->bg_chain = cpu_to_le16(my_chain);\n\tbg->bg_next_group = cl->cl_recs[my_chain].c_blkno;\n\tbg->bg_parent_dinode = cpu_to_le64(OCFS2_I(alloc_inode)->ip_blkno);\n\tbg->bg_blkno = cpu_to_le64(group_blkno);\n\tif (group_clusters == le16_to_cpu(cl->cl_cpg))\n\t\tbg->bg_bits = cpu_to_le16(ocfs2_bits_per_group(cl));\n\telse\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, group_blkno,\n\t\t\t\t\t      group_clusters);\n\n\t/* set the 1st bit in the bitmap to account for the descriptor block */\n\tocfs2_set_bit(0, (unsigned long *)bg->bg_bitmap);\n\tbg->bg_free_bits_count = cpu_to_le16(le16_to_cpu(bg->bg_bits) - 1);\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\t/* There is no need to zero out or otherwise initialize the\n\t * other blocks in a group - All valid FS metadata in a block\n\t * group stores the superblock fs_generation value at\n\t * allocation time. */\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(alloc_inode)",
            "bg_bh"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "bg_blkno"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_block_group_alloc_contig",
          "args": [
            "(unsigned long long)bg_blkno",
            "alloc_rec"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "ac",
            "le16_to_cpu(cl->cl_cpg)",
            "&bit_off",
            "&num_bits"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2373-2383",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_cpg"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_smallest_chain",
          "args": [
            "cl"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_smallest_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "436-448",
          "snippet": "static inline u16 ocfs2_find_smallest_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_count)) {\n\t\tif (le32_to_cpu(cl->cl_recs[best].c_total) >\n\t\t    le32_to_cpu(cl->cl_recs[curr].c_total))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic inline u16 ocfs2_find_smallest_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_count)) {\n\t\tif (le32_to_cpu(cl->cl_recs[best].c_total) >\n\t\t    le32_to_cpu(cl->cl_recs[curr].c_total))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\treturn best;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nstatic struct buffer_head *\nocfs2_block_group_alloc_contig(struct ocfs2_super *osb, handle_t *handle,\n\t\t\t       struct inode *alloc_inode,\n\t\t\t       struct ocfs2_alloc_context *ac,\n\t\t\t       struct ocfs2_chain_list *cl)\n{\n\tint status;\n\tu32 bit_off, num_bits;\n\tu64 bg_blkno;\n\tstruct buffer_head *bg_bh;\n\tunsigned int alloc_rec = ocfs2_find_smallest_chain(cl);\n\n\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t      le16_to_cpu(cl->cl_cpg), &bit_off,\n\t\t\t\t      &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* setup the group */\n\tbg_blkno = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_block_group_alloc_contig(\n\t     (unsigned long long)bg_blkno, alloc_rec);\n\n\tbg_bh = sb_getblk(osb->sb, bg_blkno);\n\tif (!bg_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(alloc_inode), bg_bh);\n\n\tstatus = ocfs2_block_group_fill(handle, alloc_inode, bg_bh,\n\t\t\t\t\tbg_blkno, num_bits, alloc_rec, cl);\n\tif (status < 0) {\n\t\tbrelse(bg_bh);\n\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status ? ERR_PTR(status) : bg_bh;\n}"
  },
  {
    "function_name": "ocfs2_find_smallest_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "436-448",
    "snippet": "static inline u16 ocfs2_find_smallest_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_count)) {\n\t\tif (le32_to_cpu(cl->cl_recs[best].c_total) >\n\t\t    le32_to_cpu(cl->cl_recs[curr].c_total))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\treturn best;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cl->cl_recs[curr].c_total"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_count"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic inline u16 ocfs2_find_smallest_chain(struct ocfs2_chain_list *cl)\n{\n\tu16 curr, best;\n\n\tbest = curr = 0;\n\twhile (curr < le16_to_cpu(cl->cl_count)) {\n\t\tif (le32_to_cpu(cl->cl_recs[best].c_total) >\n\t\t    le32_to_cpu(cl->cl_recs[curr].c_total))\n\t\t\tbest = curr;\n\t\tcurr++;\n\t}\n\treturn best;\n}"
  },
  {
    "function_name": "ocfs2_block_group_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "373-434",
    "snippet": "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct super_block * sb = alloc_inode->i_sb;\n\n\tif (((unsigned long long) bg_bh->b_blocknr) != group_blkno) {\n\t\tocfs2_error(alloc_inode->i_sb, \"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\",\n\t\t\t    (unsigned long long)group_blkno,\n\t\t\t    (unsigned long long) bg_bh->b_blocknr);\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmemset(bg, 0, sb->s_blocksize);\n\tstrcpy(bg->bg_signature, OCFS2_GROUP_DESC_SIGNATURE);\n\tbg->bg_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tbg->bg_size = cpu_to_le16(ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat));\n\tbg->bg_chain = cpu_to_le16(my_chain);\n\tbg->bg_next_group = cl->cl_recs[my_chain].c_blkno;\n\tbg->bg_parent_dinode = cpu_to_le64(OCFS2_I(alloc_inode)->ip_blkno);\n\tbg->bg_blkno = cpu_to_le64(group_blkno);\n\tif (group_clusters == le16_to_cpu(cl->cl_cpg))\n\t\tbg->bg_bits = cpu_to_le16(ocfs2_bits_per_group(cl));\n\telse\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, group_blkno,\n\t\t\t\t\t      group_clusters);\n\n\t/* set the 1st bit in the bitmap to account for the descriptor block */\n\tocfs2_set_bit(0, (unsigned long *)bg->bg_bitmap);\n\tbg->bg_free_bits_count = cpu_to_le16(le16_to_cpu(bg->bg_bits) - 1);\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\t/* There is no need to zero out or otherwise initialize the\n\t * other blocks in a group - All valid FS metadata in a block\n\t * group stores the superblock fs_generation value at\n\t * allocation time. */\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bg_bh"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(bg->bg_bits) - 1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_bits"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_bit",
          "args": [
            "0",
            "(unsigned long *)bg->bg_bitmap"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bg_discontig_add_extent",
          "args": [
            "osb",
            "bg",
            "cl",
            "group_blkno",
            "group_clusters"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bg_discontig_add_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "351-371",
          "snippet": "static void ocfs2_bg_discontig_add_extent(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_chain_list *cl,\n\t\t\t\t\t  u64 p_blkno, unsigned int clusters)\n{\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(!ocfs2_supports_discontig_bg(osb));\n\tif (!el->l_next_free_rec)\n\t\tel->l_count = cpu_to_le16(ocfs2_extent_recs_per_gd(osb->sb));\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec)];\n\trec->e_blkno = cpu_to_le64(p_blkno);\n\trec->e_cpos = cpu_to_le32(le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc));\n\trec->e_leaf_clusters = cpu_to_le16(clusters);\n\tle16_add_cpu(&bg->bg_bits, clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&bg->bg_free_bits_count,\n\t\t     clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic void ocfs2_bg_discontig_add_extent(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_chain_list *cl,\n\t\t\t\t\t  u64 p_blkno, unsigned int clusters)\n{\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(!ocfs2_supports_discontig_bg(osb));\n\tif (!el->l_next_free_rec)\n\t\tel->l_count = cpu_to_le16(ocfs2_extent_recs_per_gd(osb->sb));\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec)];\n\trec->e_blkno = cpu_to_le64(p_blkno);\n\trec->e_cpos = cpu_to_le32(le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc));\n\trec->e_leaf_clusters = cpu_to_le16(clusters);\n\tle16_add_cpu(&bg->bg_bits, clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&bg->bg_free_bits_count,\n\t\t     clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_bits_per_group(cl)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_bits_per_group",
          "args": [
            "cl"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bits_per_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "164-167",
          "snippet": "static u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "group_blkno"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "OCFS2_I(alloc_inode)->ip_blkno"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "alloc_inode"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "my_chain"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_group_bitmap_size",
          "args": [
            "sb",
            "1",
            "osb->s_feature_incompat"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1547-1565",
          "snippet": "static inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BG_BITMAP_SIZE\t256",
            "#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BG_BITMAP_SIZE\t256\n#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000\n\nstatic inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_SB(sb)->fs_generation"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bg->bg_signature",
            "OCFS2_GROUP_DESC_SIGNATURE"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bg",
            "0",
            "sb->s_blocksize"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(alloc_inode)",
            "bg_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "alloc_inode"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "alloc_inode->i_sb",
            "\"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\"",
            "(unsigned long long)group_blkno",
            "(unsigned long long) bg_bh->b_blocknr"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "alloc_inode->i_sb"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(alloc_inode->i_sb);\n\tstruct ocfs2_group_desc *bg = (struct ocfs2_group_desc *) bg_bh->b_data;\n\tstruct super_block * sb = alloc_inode->i_sb;\n\n\tif (((unsigned long long) bg_bh->b_blocknr) != group_blkno) {\n\t\tocfs2_error(alloc_inode->i_sb, \"group block (%llu) != \"\n\t\t\t    \"b_blocknr (%llu)\",\n\t\t\t    (unsigned long long)group_blkno,\n\t\t\t    (unsigned long long) bg_bh->b_blocknr);\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t bg_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmemset(bg, 0, sb->s_blocksize);\n\tstrcpy(bg->bg_signature, OCFS2_GROUP_DESC_SIGNATURE);\n\tbg->bg_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tbg->bg_size = cpu_to_le16(ocfs2_group_bitmap_size(sb, 1,\n\t\t\t\t\t\tosb->s_feature_incompat));\n\tbg->bg_chain = cpu_to_le16(my_chain);\n\tbg->bg_next_group = cl->cl_recs[my_chain].c_blkno;\n\tbg->bg_parent_dinode = cpu_to_le64(OCFS2_I(alloc_inode)->ip_blkno);\n\tbg->bg_blkno = cpu_to_le64(group_blkno);\n\tif (group_clusters == le16_to_cpu(cl->cl_cpg))\n\t\tbg->bg_bits = cpu_to_le16(ocfs2_bits_per_group(cl));\n\telse\n\t\tocfs2_bg_discontig_add_extent(osb, bg, cl, group_blkno,\n\t\t\t\t\t      group_clusters);\n\n\t/* set the 1st bit in the bitmap to account for the descriptor block */\n\tocfs2_set_bit(0, (unsigned long *)bg->bg_bitmap);\n\tbg->bg_free_bits_count = cpu_to_le16(le16_to_cpu(bg->bg_bits) - 1);\n\n\tocfs2_journal_dirty(handle, bg_bh);\n\n\t/* There is no need to zero out or otherwise initialize the\n\t * other blocks in a group - All valid FS metadata in a block\n\t * group stores the superblock fs_generation value at\n\t * allocation time. */\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_bg_discontig_add_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "351-371",
    "snippet": "static void ocfs2_bg_discontig_add_extent(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_chain_list *cl,\n\t\t\t\t\t  u64 p_blkno, unsigned int clusters)\n{\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(!ocfs2_supports_discontig_bg(osb));\n\tif (!el->l_next_free_rec)\n\t\tel->l_count = cpu_to_le16(ocfs2_extent_recs_per_gd(osb->sb));\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec)];\n\trec->e_blkno = cpu_to_le64(p_blkno);\n\trec->e_cpos = cpu_to_le32(le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc));\n\trec->e_leaf_clusters = cpu_to_le16(clusters);\n\tle16_add_cpu(&bg->bg_bits, clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&bg->bg_free_bits_count,\n\t\t     clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);",
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&bg->bg_free_bits_count",
            "clusters * le16_to_cpu(cl->cl_bpc)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_bpc"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&bg->bg_bits",
            "clusters * le16_to_cpu(cl->cl_bpc)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "clusters"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "p_blkno"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_gd(osb->sb)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_gd",
          "args": [
            "osb->sb"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1527-1535",
          "snippet": "static inline int ocfs2_extent_recs_per_gd(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extent_recs_per_gd(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_supports_discontig_bg(osb)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_discontig_bg",
          "args": [
            "osb"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_discontig_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "539-544",
          "snippet": "static inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic void ocfs2_bg_discontig_add_extent(struct ocfs2_super *osb,\n\t\t\t\t\t  struct ocfs2_group_desc *bg,\n\t\t\t\t\t  struct ocfs2_chain_list *cl,\n\t\t\t\t\t  u64 p_blkno, unsigned int clusters)\n{\n\tstruct ocfs2_extent_list *el = &bg->bg_list;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(!ocfs2_supports_discontig_bg(osb));\n\tif (!el->l_next_free_rec)\n\t\tel->l_count = cpu_to_le16(ocfs2_extent_recs_per_gd(osb->sb));\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec)];\n\trec->e_blkno = cpu_to_le64(p_blkno);\n\trec->e_cpos = cpu_to_le32(le16_to_cpu(bg->bg_bits) /\n\t\t\t\t  le16_to_cpu(cl->cl_bpc));\n\trec->e_leaf_clusters = cpu_to_le16(clusters);\n\tle16_add_cpu(&bg->bg_bits, clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&bg->bg_free_bits_count,\n\t\t     clusters * le16_to_cpu(cl->cl_bpc));\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n}"
  },
  {
    "function_name": "ocfs2_read_group_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "326-349",
    "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tmp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_gd_parent",
          "args": [
            "inode->i_sb",
            "di",
            "tmp",
            "0"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_gd_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "227-264",
          "snippet": "static int ocfs2_validate_gd_parent(struct super_block *sb,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int resize)\n{\n\tunsigned int max_bits;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (di->i_blkno != gd->bg_parent_dinode) {\n\t\tdo_error(\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_parent_dinode),\n\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tmax_bits = le16_to_cpu(di->id2.i_chain.cl_cpg) * le16_to_cpu(di->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(gd->bg_bits) > max_bits) {\n\t\tdo_error(\"Group descriptor #%llu has bit count of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits));\n\t\treturn -EINVAL;\n\t}\n\n\t/* In resize, we may meet the case bg_chain == cl_next_free_rec. */\n\tif ((le16_to_cpu(gd->bg_chain) >\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) ||\n\t    ((le16_to_cpu(gd->bg_chain) ==\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) && !resize)) {\n\t\tdo_error(\"Group descriptor #%llu has bad chain %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_chain));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nstatic int ocfs2_validate_gd_parent(struct super_block *sb,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int resize)\n{\n\tunsigned int max_bits;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (di->i_blkno != gd->bg_parent_dinode) {\n\t\tdo_error(\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_parent_dinode),\n\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tmax_bits = le16_to_cpu(di->id2.i_chain.cl_cpg) * le16_to_cpu(di->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(gd->bg_bits) > max_bits) {\n\t\tdo_error(\"Group descriptor #%llu has bit count of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits));\n\t\treturn -EINVAL;\n\t}\n\n\t/* In resize, we may meet the case bg_chain == cl_next_free_rec. */\n\tif ((le16_to_cpu(gd->bg_chain) >\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) ||\n\t    ((le16_to_cpu(gd->bg_chain) ==\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) && !resize)) {\n\t\tdo_error(\"Group descriptor #%llu has bad chain %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_chain));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(inode)",
            "gd_blkno",
            "&tmp",
            "ocfs2_validate_group_descriptor"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_group_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "299-324",
    "snippet": "static int ocfs2_validate_group_descriptor(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\ttrace_ocfs2_validate_group_descriptor(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &gd->bg_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\treturn ocfs2_validate_gd_self(sb, bh, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_validate_gd_self",
          "args": [
            "sb",
            "bh",
            "0"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_gd_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "177-225",
          "snippet": "static int ocfs2_validate_gd_self(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int resize)\n{\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (!OCFS2_IS_VALID_GROUP_DESC(gd)) {\n\t\tdo_error(\"Group descriptor #%llu has bad signature %.*s\",\n\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t gd->bg_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(gd->bg_blkno) != bh->b_blocknr) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(gd->bg_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le32_to_cpu(gd->bg_generation));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) > le16_to_cpu(gd->bg_bits)) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t le16_to_cpu(gd->bg_free_bits_count));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_bits) > (8 * le16_to_cpu(gd->bg_size))) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t 8 * le16_to_cpu(gd->bg_size));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_gd_self(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int resize)\n{\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (!OCFS2_IS_VALID_GROUP_DESC(gd)) {\n\t\tdo_error(\"Group descriptor #%llu has bad signature %.*s\",\n\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t gd->bg_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(gd->bg_blkno) != bh->b_blocknr) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(gd->bg_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le32_to_cpu(gd->bg_generation));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) > le16_to_cpu(gd->bg_bits)) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t le16_to_cpu(gd->bg_free_bits_count));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_bits) > (8 * le16_to_cpu(gd->bg_size))) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t 8 * le16_to_cpu(gd->bg_size));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&gd->bg_check"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_group_descriptor",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_group_descriptor(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\ttrace_ocfs2_validate_group_descriptor(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &gd->bg_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\treturn ocfs2_validate_gd_self(sb, bh, 0);\n}"
  },
  {
    "function_name": "ocfs2_check_group_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "272-297",
    "snippet": "int ocfs2_check_group_descriptor(struct super_block *sb,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &gd->bg_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for group descriptor %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t} else\n\t\trc = ocfs2_validate_gd_self(sb, bh, 1);\n\tif (!rc)\n\t\trc = ocfs2_validate_gd_parent(sb, di, bh, 1);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_validate_gd_parent",
          "args": [
            "sb",
            "di",
            "bh",
            "1"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_gd_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "227-264",
          "snippet": "static int ocfs2_validate_gd_parent(struct super_block *sb,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int resize)\n{\n\tunsigned int max_bits;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (di->i_blkno != gd->bg_parent_dinode) {\n\t\tdo_error(\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_parent_dinode),\n\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tmax_bits = le16_to_cpu(di->id2.i_chain.cl_cpg) * le16_to_cpu(di->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(gd->bg_bits) > max_bits) {\n\t\tdo_error(\"Group descriptor #%llu has bit count of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits));\n\t\treturn -EINVAL;\n\t}\n\n\t/* In resize, we may meet the case bg_chain == cl_next_free_rec. */\n\tif ((le16_to_cpu(gd->bg_chain) >\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) ||\n\t    ((le16_to_cpu(gd->bg_chain) ==\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) && !resize)) {\n\t\tdo_error(\"Group descriptor #%llu has bad chain %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_chain));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nstatic int ocfs2_validate_gd_parent(struct super_block *sb,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int resize)\n{\n\tunsigned int max_bits;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (di->i_blkno != gd->bg_parent_dinode) {\n\t\tdo_error(\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_parent_dinode),\n\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tmax_bits = le16_to_cpu(di->id2.i_chain.cl_cpg) * le16_to_cpu(di->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(gd->bg_bits) > max_bits) {\n\t\tdo_error(\"Group descriptor #%llu has bit count of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits));\n\t\treturn -EINVAL;\n\t}\n\n\t/* In resize, we may meet the case bg_chain == cl_next_free_rec. */\n\tif ((le16_to_cpu(gd->bg_chain) >\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) ||\n\t    ((le16_to_cpu(gd->bg_chain) ==\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) && !resize)) {\n\t\tdo_error(\"Group descriptor #%llu has bad chain %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_chain));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_gd_self",
          "args": [
            "sb",
            "bh",
            "1"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_gd_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "177-225",
          "snippet": "static int ocfs2_validate_gd_self(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int resize)\n{\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (!OCFS2_IS_VALID_GROUP_DESC(gd)) {\n\t\tdo_error(\"Group descriptor #%llu has bad signature %.*s\",\n\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t gd->bg_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(gd->bg_blkno) != bh->b_blocknr) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(gd->bg_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le32_to_cpu(gd->bg_generation));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) > le16_to_cpu(gd->bg_bits)) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t le16_to_cpu(gd->bg_free_bits_count));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_bits) > (8 * le16_to_cpu(gd->bg_size))) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t 8 * le16_to_cpu(gd->bg_size));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_gd_self(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int resize)\n{\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (!OCFS2_IS_VALID_GROUP_DESC(gd)) {\n\t\tdo_error(\"Group descriptor #%llu has bad signature %.*s\",\n\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t gd->bg_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(gd->bg_blkno) != bh->b_blocknr) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(gd->bg_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le32_to_cpu(gd->bg_generation));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) > le16_to_cpu(gd->bg_bits)) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t le16_to_cpu(gd->bg_free_bits_count));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_bits) > (8 * le16_to_cpu(gd->bg_size))) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t 8 * le16_to_cpu(gd->bg_size));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for group descriptor %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&gd->bg_check"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_check_group_descriptor(struct super_block *sb,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &gd->bg_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for group descriptor %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t} else\n\t\trc = ocfs2_validate_gd_self(sb, bh, 1);\n\tif (!rc)\n\t\trc = ocfs2_validate_gd_parent(sb, di, bh, 1);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_gd_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "227-264",
    "snippet": "static int ocfs2_validate_gd_parent(struct super_block *sb,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int resize)\n{\n\tunsigned int max_bits;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (di->i_blkno != gd->bg_parent_dinode) {\n\t\tdo_error(\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_parent_dinode),\n\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tmax_bits = le16_to_cpu(di->id2.i_chain.cl_cpg) * le16_to_cpu(di->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(gd->bg_bits) > max_bits) {\n\t\tdo_error(\"Group descriptor #%llu has bit count of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits));\n\t\treturn -EINVAL;\n\t}\n\n\t/* In resize, we may meet the case bg_chain == cl_next_free_rec. */\n\tif ((le16_to_cpu(gd->bg_chain) >\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) ||\n\t    ((le16_to_cpu(gd->bg_chain) ==\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) && !resize)) {\n\t\tdo_error(\"Group descriptor #%llu has bad chain %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_chain));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has bad chain %u\"",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(gd->bg_chain)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_chain"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has bit count of %u\"",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(gd->bg_bits)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\"",
            "(unsigned long long)bh->b_blocknr",
            "(unsigned long long)le64_to_cpu(gd->bg_parent_dinode)",
            "(unsigned long long)le64_to_cpu(di->i_blkno)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_blkno"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nstatic int ocfs2_validate_gd_parent(struct super_block *sb,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int resize)\n{\n\tunsigned int max_bits;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (di->i_blkno != gd->bg_parent_dinode) {\n\t\tdo_error(\"Group descriptor #%llu has bad parent \"\n\t\t\t \"pointer (%llu, expected %llu)\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_parent_dinode),\n\t\t\t (unsigned long long)le64_to_cpu(di->i_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tmax_bits = le16_to_cpu(di->id2.i_chain.cl_cpg) * le16_to_cpu(di->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(gd->bg_bits) > max_bits) {\n\t\tdo_error(\"Group descriptor #%llu has bit count of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits));\n\t\treturn -EINVAL;\n\t}\n\n\t/* In resize, we may meet the case bg_chain == cl_next_free_rec. */\n\tif ((le16_to_cpu(gd->bg_chain) >\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) ||\n\t    ((le16_to_cpu(gd->bg_chain) ==\n\t     le16_to_cpu(di->id2.i_chain.cl_next_free_rec)) && !resize)) {\n\t\tdo_error(\"Group descriptor #%llu has bad chain %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_chain));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_validate_gd_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "177-225",
    "snippet": "static int ocfs2_validate_gd_self(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int resize)\n{\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (!OCFS2_IS_VALID_GROUP_DESC(gd)) {\n\t\tdo_error(\"Group descriptor #%llu has bad signature %.*s\",\n\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t gd->bg_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(gd->bg_blkno) != bh->b_blocknr) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(gd->bg_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le32_to_cpu(gd->bg_generation));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) > le16_to_cpu(gd->bg_bits)) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t le16_to_cpu(gd->bg_free_bits_count));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_bits) > (8 * le16_to_cpu(gd->bg_size))) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t 8 * le16_to_cpu(gd->bg_size));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\"",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(gd->bg_bits)",
            "8 * le16_to_cpu(gd->bg_size)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_size"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\"",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(gd->bg_bits)",
            "le16_to_cpu(gd->bg_free_bits_count)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\"",
            "(unsigned long long)bh->b_blocknr",
            "le32_to_cpu(gd->bg_generation)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gd->bg_generation"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\"",
            "(unsigned long long)bh->b_blocknr",
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_error",
          "args": [
            "\"Group descriptor #%llu has bad signature %.*s\"",
            "(unsigned long long)bh->b_blocknr",
            "7",
            "gd->bg_signature"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_GROUP_DESC",
          "args": [
            "gd"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_gd_self(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int resize)\n{\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tif (!OCFS2_IS_VALID_GROUP_DESC(gd)) {\n\t\tdo_error(\"Group descriptor #%llu has bad signature %.*s\",\n\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t gd->bg_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(gd->bg_blkno) != bh->b_blocknr) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid bg_blkno \"\n\t\t\t \"of %llu\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t (unsigned long long)le64_to_cpu(gd->bg_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(gd->bg_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tdo_error(\"Group descriptor #%llu has an invalid \"\n\t\t\t \"fs_generation of #%u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le32_to_cpu(gd->bg_generation));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) > le16_to_cpu(gd->bg_bits)) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"claims that %u are free\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t le16_to_cpu(gd->bg_free_bits_count));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(gd->bg_bits) > (8 * le16_to_cpu(gd->bg_size))) {\n\t\tdo_error(\"Group descriptor #%llu has bit count %u but \"\n\t\t\t \"max bitmap bits of %u\",\n\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t le16_to_cpu(gd->bg_bits),\n\t\t\t 8 * le16_to_cpu(gd->bg_size));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_bits_per_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "164-167",
    "snippet": "static u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
      "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_bpc"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\n\nstatic u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)\n{\n\treturn (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);\n}"
  },
  {
    "function_name": "ocfs2_free_alloc_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "158-162",
    "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ac"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_ac_resource",
          "args": [
            "ac"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_ac_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "136-156",
          "snippet": "void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
  },
  {
    "function_name": "ocfs2_free_ac_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "136-156",
    "snippet": "void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ac->ac_find_loc_priv"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ac->ac_bh"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_group_from_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
    "lines": "71-80",
    "snippet": "static u64 ocfs2_group_from_res(struct ocfs2_suballoc_result *res)\n{\n\tif (res->sr_blkno == 0)\n\t\treturn 0;\n\n\tif (res->sr_bg_blkno)\n\t\treturn res->sr_bg_blkno;\n\n\treturn ocfs2_which_suballoc_group(res->sr_blkno, res->sr_bit_offset);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
      "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
      "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "res->sr_blkno",
            "res->sr_bit_offset"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\n\nstatic u64 ocfs2_group_from_res(struct ocfs2_suballoc_result *res)\n{\n\tif (res->sr_blkno == 0)\n\t\treturn 0;\n\n\tif (res->sr_bg_blkno)\n\t\treturn res->sr_bg_blkno;\n\n\treturn ocfs2_which_suballoc_group(res->sr_blkno, res->sr_bit_offset);\n}"
  }
]