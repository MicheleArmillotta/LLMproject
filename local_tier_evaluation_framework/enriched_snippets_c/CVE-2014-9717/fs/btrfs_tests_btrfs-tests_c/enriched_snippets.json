[
  {
    "function_name": "btrfs_free_dummy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "161-170",
    "snippet": "void btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_dummy_fs_info",
          "args": [
            "root->fs_info"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_dummy_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "128-159",
          "snippet": "static void btrfs_free_dummy_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tstruct radix_tree_iter iter;\n\tvoid **slot;\n\n\tspin_lock(&fs_info->buffer_lock);\nrestart:\n\tradix_tree_for_each_slot(slot, &fs_info->buffer_radix, &iter, 0) {\n\t\tstruct extent_buffer *eb;\n\n\t\teb = radix_tree_deref_slot_protected(slot, &fs_info->buffer_lock);\n\t\tif (!eb)\n\t\t\tcontinue;\n\t\t/* Shouldn't happen but that kind of thinking creates CVE's */\n\t\tif (radix_tree_exception(eb)) {\n\t\t\tif (radix_tree_deref_retry(eb))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->buffer_lock);\n\t\tfree_extent_buffer_stale(eb);\n\t\tspin_lock(&fs_info->buffer_lock);\n\t}\n\tspin_unlock(&fs_info->buffer_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\tbtrfs_free_fs_roots(fs_info);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->fs_devices);\n\tkfree(fs_info);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void btrfs_free_dummy_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tstruct radix_tree_iter iter;\n\tvoid **slot;\n\n\tspin_lock(&fs_info->buffer_lock);\nrestart:\n\tradix_tree_for_each_slot(slot, &fs_info->buffer_radix, &iter, 0) {\n\t\tstruct extent_buffer *eb;\n\n\t\teb = radix_tree_deref_slot_protected(slot, &fs_info->buffer_lock);\n\t\tif (!eb)\n\t\t\tcontinue;\n\t\t/* Shouldn't happen but that kind of thinking creates CVE's */\n\t\tif (radix_tree_exception(eb)) {\n\t\t\tif (radix_tree_deref_retry(eb))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->buffer_lock);\n\t\tfree_extent_buffer_stale(eb);\n\t\tspin_lock(&fs_info->buffer_lock);\n\t}\n\tspin_unlock(&fs_info->buffer_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\tbtrfs_free_fs_roots(fs_info);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->fs_devices);\n\tkfree(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "root->node"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}"
  },
  {
    "function_name": "btrfs_free_dummy_fs_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "128-159",
    "snippet": "static void btrfs_free_dummy_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tstruct radix_tree_iter iter;\n\tvoid **slot;\n\n\tspin_lock(&fs_info->buffer_lock);\nrestart:\n\tradix_tree_for_each_slot(slot, &fs_info->buffer_radix, &iter, 0) {\n\t\tstruct extent_buffer *eb;\n\n\t\teb = radix_tree_deref_slot_protected(slot, &fs_info->buffer_lock);\n\t\tif (!eb)\n\t\t\tcontinue;\n\t\t/* Shouldn't happen but that kind of thinking creates CVE's */\n\t\tif (radix_tree_exception(eb)) {\n\t\t\tif (radix_tree_deref_retry(eb))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->buffer_lock);\n\t\tfree_extent_buffer_stale(eb);\n\t\tspin_lock(&fs_info->buffer_lock);\n\t}\n\tspin_unlock(&fs_info->buffer_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\tbtrfs_free_fs_roots(fs_info);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->fs_devices);\n\tkfree(fs_info);\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info->fs_devices"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_fs_roots",
          "args": [
            "fs_info"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_fs_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2112-2147",
          "snippet": "void btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\n\nvoid btrfs_free_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\n\twhile (!list_empty(&fs_info->dead_roots)) {\n\t\tgang[0] = list_entry(fs_info->dead_roots.next,\n\t\t\t\t     struct btrfs_root, root_list);\n\t\tlist_del(&gang[0]->root_list);\n\n\t\tif (test_bit(BTRFS_ROOT_IN_RADIX, &gang[0]->state)) {\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[0]);\n\t\t} else {\n\t\t\tfree_extent_buffer(gang[0]->node);\n\t\t\tfree_extent_buffer(gang[0]->commit_root);\n\t\t\tbtrfs_put_fs_root(gang[0]);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, 0,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tbtrfs_drop_and_free_fs_root(fs_info, gang[i]);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tbtrfs_free_log_root_tree(NULL, fs_info);\n\t\tbtrfs_destroy_pinned_extent(fs_info->tree_root,\n\t\t\t\t\t    fs_info->pinned_extents);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_qgroup_config",
          "args": [
            "fs_info"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_qgroup_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "458-475",
          "snippet": "void btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer_stale",
          "args": [
            "eb"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_deref_retry",
          "args": [
            "eb"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_exception",
          "args": [
            "eb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_deref_slot_protected",
          "args": [
            "slot",
            "&fs_info->buffer_lock"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_for_each_slot",
          "args": [
            "slot",
            "&fs_info->buffer_radix",
            "&iter",
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void btrfs_free_dummy_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tstruct radix_tree_iter iter;\n\tvoid **slot;\n\n\tspin_lock(&fs_info->buffer_lock);\nrestart:\n\tradix_tree_for_each_slot(slot, &fs_info->buffer_radix, &iter, 0) {\n\t\tstruct extent_buffer *eb;\n\n\t\teb = radix_tree_deref_slot_protected(slot, &fs_info->buffer_lock);\n\t\tif (!eb)\n\t\t\tcontinue;\n\t\t/* Shouldn't happen but that kind of thinking creates CVE's */\n\t\tif (radix_tree_exception(eb)) {\n\t\t\tif (radix_tree_deref_retry(eb))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->buffer_lock);\n\t\tfree_extent_buffer_stale(eb);\n\t\tspin_lock(&fs_info->buffer_lock);\n\t}\n\tspin_unlock(&fs_info->buffer_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\tbtrfs_free_fs_roots(fs_info);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->fs_devices);\n\tkfree(fs_info);\n}"
  },
  {
    "function_name": "btrfs_alloc_dummy_fs_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "79-126",
    "snippet": "struct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&fs_info->fs_roots_radix",
            "GFP_ATOMIC"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&fs_info->buffer_radix",
            "GFP_ATOMIC"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->tree_mod_seq_list"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->dead_roots"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fs_info->dirty_qgroups"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&fs_info->tree_mod_seq",
            "0"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&fs_info->tree_mod_log_lock"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->super_lock"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info->fs_devices"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info->fs_devices"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct btrfs_super_block)",
            "GFP_NOFS"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_info"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct btrfs_fs_devices)",
            "GFP_NOFS"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct btrfs_fs_info)",
            "GFP_NOFS"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}"
  },
  {
    "function_name": "btrfs_destroy_test_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "73-77",
    "snippet": "void btrfs_destroy_test_fs(void)\n{\n\tkern_unmount(test_mnt);\n\tunregister_filesystem(&test_type);\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *test_mnt = NULL;",
      "static struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&test_type"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kern_unmount",
          "args": [
            "test_mnt"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "kern_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3100-3108",
          "snippet": "void kern_unmount(struct vfsmount *mnt)\n{\n\t/* release long term mount so mount point can be released */\n\tif (!IS_ERR_OR_NULL(mnt)) {\n\t\treal_mount(mnt)->mnt_ns = NULL;\n\t\tsynchronize_rcu();\t/* yecchhh... */\n\t\tmntput(mnt);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid kern_unmount(struct vfsmount *mnt)\n{\n\t/* release long term mount so mount point can be released */\n\tif (!IS_ERR_OR_NULL(mnt)) {\n\t\treal_mount(mnt)->mnt_ns = NULL;\n\t\tsynchronize_rcu();\t/* yecchhh... */\n\t\tmntput(mnt);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\nstatic struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nvoid btrfs_destroy_test_fs(void)\n{\n\tkern_unmount(test_mnt);\n\tunregister_filesystem(&test_type);\n}"
  },
  {
    "function_name": "btrfs_init_test_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "54-71",
    "snippet": "int btrfs_init_test_fs(void)\n{\n\tint ret;\n\n\tret = register_filesystem(&test_type);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"btrfs: cannot register test file system\\n\");\n\t\treturn ret;\n\t}\n\n\ttest_mnt = kern_mount(&test_type);\n\tif (IS_ERR(test_mnt)) {\n\t\tprintk(KERN_ERR \"btrfs: cannot mount test file system\\n\");\n\t\tunregister_filesystem(&test_type);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *test_mnt = NULL;",
      "static struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&test_type"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"btrfs: cannot mount test file system\\n\""
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "test_mnt"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&test_type"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\nstatic struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nint btrfs_init_test_fs(void)\n{\n\tint ret;\n\n\tret = register_filesystem(&test_type);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"btrfs: cannot register test file system\\n\");\n\t\treturn ret;\n\t}\n\n\ttest_mnt = kern_mount(&test_type);\n\tif (IS_ERR(test_mnt)) {\n\t\tprintk(KERN_ERR \"btrfs: cannot mount test file system\\n\");\n\t\tunregister_filesystem(&test_type);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_new_test_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "49-52",
    "snippet": "struct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *test_mnt = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "test_mnt->mnt_sb"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\n\nstruct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}"
  },
  {
    "function_name": "btrfs_test_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
    "lines": "35-41",
    "snippet": "static struct dentry *btrfs_test_mount(struct file_system_type *fs_type,\n\t\t\t\t       int flags, const char *dev_name,\n\t\t\t\t       void *data)\n{\n\treturn mount_pseudo(fs_type, \"btrfs_test:\", &btrfs_test_super_ops,\n\t\t\t    NULL, BTRFS_TEST_MAGIC);\n}",
    "includes": [
      "#include \"../qgroup.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../volumes.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations btrfs_test_super_ops = {\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_test_destroy_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"btrfs_test:\"",
            "&btrfs_test_super_ops",
            "NULL",
            "BTRFS_TEST_MAGIC"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "mount_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "216-260",
          "snippet": "struct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nstruct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic const struct super_operations btrfs_test_super_ops = {\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_test_destroy_inode,\n};\n\nstatic struct dentry *btrfs_test_mount(struct file_system_type *fs_type,\n\t\t\t\t       int flags, const char *dev_name,\n\t\t\t\t       void *data)\n{\n\treturn mount_pseudo(fs_type, \"btrfs_test:\", &btrfs_test_super_ops,\n\t\t\t    NULL, BTRFS_TEST_MAGIC);\n}"
  }
]