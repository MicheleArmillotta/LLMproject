[
  {
    "function_name": "f2fs_destroy_root_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "394-401",
    "snippet": "void f2fs_destroy_root_stats(void)\n{\n\tif (!f2fs_debugfs_root)\n\t\treturn;\n\n\tdebugfs_remove_recursive(f2fs_debugfs_root);\n\tf2fs_debugfs_root = NULL;\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *f2fs_debugfs_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "f2fs_debugfs_root"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_recursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "580-641",
          "snippet": "void debugfs_remove_recursive(struct dentry *dentry)\n{\n\tstruct dentry *child, *parent;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tparent = dentry;\n down:\n\tmutex_lock(&parent->d_inode->i_mutex);\n loop:\n\t/*\n\t * The parent->d_subdirs is protected by the d_lock. Outside that\n\t * lock, the child can be unlinked and set to be freed which can\n\t * use the d_u.d_child as the rcu head and corrupt this list.\n\t */\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n\t\tif (!debugfs_positive(child))\n\t\t\tcontinue;\n\n\t\t/* perhaps simple_empty(child) makes more sense */\n\t\tif (!list_empty(&child->d_subdirs)) {\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\t\t\tparent = child;\n\t\t\tgoto down;\n\t\t}\n\n\t\tspin_unlock(&parent->d_lock);\n\n\t\tif (!__debugfs_remove(child, parent))\n\t\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\n\t\t/*\n\t\t * The parent->d_lock protects agaist child from unlinking\n\t\t * from d_subdirs. When releasing the parent->d_lock we can\n\t\t * no longer trust that the next pointer is valid.\n\t\t * Restart the loop. We'll skip this one with the\n\t\t * debugfs_positive() check.\n\t\t */\n\t\tgoto loop;\n\t}\n\tspin_unlock(&parent->d_lock);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tchild = parent;\n\tparent = parent->d_parent;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tif (child != dentry)\n\t\t/* go up */\n\t\tgoto loop;\n\n\tif (!__debugfs_remove(child, parent))\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nvoid debugfs_remove_recursive(struct dentry *dentry)\n{\n\tstruct dentry *child, *parent;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tparent = dentry;\n down:\n\tmutex_lock(&parent->d_inode->i_mutex);\n loop:\n\t/*\n\t * The parent->d_subdirs is protected by the d_lock. Outside that\n\t * lock, the child can be unlinked and set to be freed which can\n\t * use the d_u.d_child as the rcu head and corrupt this list.\n\t */\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n\t\tif (!debugfs_positive(child))\n\t\t\tcontinue;\n\n\t\t/* perhaps simple_empty(child) makes more sense */\n\t\tif (!list_empty(&child->d_subdirs)) {\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\t\t\tparent = child;\n\t\t\tgoto down;\n\t\t}\n\n\t\tspin_unlock(&parent->d_lock);\n\n\t\tif (!__debugfs_remove(child, parent))\n\t\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\n\t\t/*\n\t\t * The parent->d_lock protects agaist child from unlinking\n\t\t * from d_subdirs. When releasing the parent->d_lock we can\n\t\t * no longer trust that the next pointer is valid.\n\t\t * Restart the loop. We'll skip this one with the\n\t\t * debugfs_positive() check.\n\t\t */\n\t\tgoto loop;\n\t}\n\tspin_unlock(&parent->d_lock);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tchild = parent;\n\tparent = parent->d_parent;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tif (child != dentry)\n\t\t/* go up */\n\t\tgoto loop;\n\n\tif (!__debugfs_remove(child, parent))\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct dentry *f2fs_debugfs_root;\n\nvoid f2fs_destroy_root_stats(void)\n{\n\tif (!f2fs_debugfs_root)\n\t\treturn;\n\n\tdebugfs_remove_recursive(f2fs_debugfs_root);\n\tf2fs_debugfs_root = NULL;\n}"
  },
  {
    "function_name": "f2fs_create_root_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "378-392",
    "snippet": "void __init f2fs_create_root_stats(void)\n{\n\tstruct dentry *file;\n\n\tf2fs_debugfs_root = debugfs_create_dir(\"f2fs\", NULL);\n\tif (!f2fs_debugfs_root)\n\t\treturn;\n\n\tfile = debugfs_create_file(\"status\", S_IRUGO, f2fs_debugfs_root,\n\t\t\tNULL, &stat_fops);\n\tif (!file) {\n\t\tdebugfs_remove(f2fs_debugfs_root);\n\t\tf2fs_debugfs_root = NULL;\n\t}\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *f2fs_debugfs_root;",
      "static const struct file_operations stat_fops = {\n\t.open = stat_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "f2fs_debugfs_root"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"status\"",
            "S_IRUGO",
            "f2fs_debugfs_root",
            "NULL",
            "&stat_fops"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"f2fs\"",
            "NULL"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct dentry *f2fs_debugfs_root;\nstatic const struct file_operations stat_fops = {\n\t.open = stat_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nvoid __init f2fs_create_root_stats(void)\n{\n\tstruct dentry *file;\n\n\tf2fs_debugfs_root = debugfs_create_dir(\"f2fs\", NULL);\n\tif (!f2fs_debugfs_root)\n\t\treturn;\n\n\tfile = debugfs_create_file(\"status\", S_IRUGO, f2fs_debugfs_root,\n\t\t\tNULL, &stat_fops);\n\tif (!file) {\n\t\tdebugfs_remove(f2fs_debugfs_root);\n\t\tf2fs_debugfs_root = NULL;\n\t}\n}"
  },
  {
    "function_name": "f2fs_destroy_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "367-376",
    "snippet": "void f2fs_destroy_stats(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\n\tmutex_lock(&f2fs_stat_mutex);\n\tlist_del(&si->stat_list);\n\tmutex_unlock(&f2fs_stat_mutex);\n\n\tkfree(si);\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(f2fs_stat_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "si"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&f2fs_stat_mutex"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&si->stat_list"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&f2fs_stat_mutex"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_STAT",
          "args": [
            "sbi"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_STAT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1580-1583",
          "snippet": "static inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic DEFINE_MUTEX(f2fs_stat_mutex);\n\nvoid f2fs_destroy_stats(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\n\tmutex_lock(&f2fs_stat_mutex);\n\tlist_del(&si->stat_list);\n\tmutex_unlock(&f2fs_stat_mutex);\n\n\tkfree(si);\n}"
  },
  {
    "function_name": "f2fs_build_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "336-365",
    "snippet": "int f2fs_build_stats(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_stat_info *si;\n\n\tsi = kzalloc(sizeof(struct f2fs_stat_info), GFP_KERNEL);\n\tif (!si)\n\t\treturn -ENOMEM;\n\n\tsi->all_area_segs = le32_to_cpu(raw_super->segment_count);\n\tsi->sit_area_segs = le32_to_cpu(raw_super->segment_count_sit);\n\tsi->nat_area_segs = le32_to_cpu(raw_super->segment_count_nat);\n\tsi->ssa_area_segs = le32_to_cpu(raw_super->segment_count_ssa);\n\tsi->main_area_segs = le32_to_cpu(raw_super->segment_count_main);\n\tsi->main_area_sections = le32_to_cpu(raw_super->section_count);\n\tsi->main_area_zones = si->main_area_sections /\n\t\t\t\tle32_to_cpu(raw_super->secs_per_zone);\n\tsi->sbi = sbi;\n\tsbi->stat_info = si;\n\n\tatomic_set(&sbi->inline_inode, 0);\n\tatomic_set(&sbi->inline_dir, 0);\n\tatomic_set(&sbi->inplace_count, 0);\n\n\tmutex_lock(&f2fs_stat_mutex);\n\tlist_add_tail(&si->stat_list, &f2fs_stat_list);\n\tmutex_unlock(&f2fs_stat_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(f2fs_stat_list);",
      "static DEFINE_MUTEX(f2fs_stat_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&f2fs_stat_mutex"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&si->stat_list",
            "&f2fs_stat_list"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&f2fs_stat_mutex"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->inplace_count",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->inline_dir",
            "0"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->inline_inode",
            "0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_super->secs_per_zone"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct f2fs_stat_info)",
            "GFP_KERNEL"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(f2fs_stat_list);\nstatic DEFINE_MUTEX(f2fs_stat_mutex);\n\nint f2fs_build_stats(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_stat_info *si;\n\n\tsi = kzalloc(sizeof(struct f2fs_stat_info), GFP_KERNEL);\n\tif (!si)\n\t\treturn -ENOMEM;\n\n\tsi->all_area_segs = le32_to_cpu(raw_super->segment_count);\n\tsi->sit_area_segs = le32_to_cpu(raw_super->segment_count_sit);\n\tsi->nat_area_segs = le32_to_cpu(raw_super->segment_count_nat);\n\tsi->ssa_area_segs = le32_to_cpu(raw_super->segment_count_ssa);\n\tsi->main_area_segs = le32_to_cpu(raw_super->segment_count_main);\n\tsi->main_area_sections = le32_to_cpu(raw_super->section_count);\n\tsi->main_area_zones = si->main_area_sections /\n\t\t\t\tle32_to_cpu(raw_super->secs_per_zone);\n\tsi->sbi = sbi;\n\tsbi->stat_info = si;\n\n\tatomic_set(&sbi->inline_inode, 0);\n\tatomic_set(&sbi->inline_dir, 0);\n\tatomic_set(&sbi->inplace_count, 0);\n\n\tmutex_lock(&f2fs_stat_mutex);\n\tlist_add_tail(&si->stat_list, &f2fs_stat_list);\n\tmutex_unlock(&f2fs_stat_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stat_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "324-327",
    "snippet": "static int stat_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, stat_show, inode->i_private);\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "stat_show",
            "inode->i_private"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int stat_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, stat_show, inode->i_private);\n}"
  },
  {
    "function_name": "stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "196-322",
    "snippet": "static int stat_show(struct seq_file *s, void *v)\n{\n\tstruct f2fs_stat_info *si;\n\tint i = 0;\n\tint j;\n\n\tmutex_lock(&f2fs_stat_mutex);\n\tlist_for_each_entry(si, &f2fs_stat_list, stat_list) {\n\t\tchar devname[BDEVNAME_SIZE];\n\n\t\tupdate_general_status(si->sbi);\n\n\t\tseq_printf(s, \"\\n=====[ partition info(%s). #%d ]=====\\n\",\n\t\t\tbdevname(si->sbi->sb->s_bdev, devname), i++);\n\t\tseq_printf(s, \"[SB: 1] [CP: 2] [SIT: %d] [NAT: %d] \",\n\t\t\t   si->sit_area_segs, si->nat_area_segs);\n\t\tseq_printf(s, \"[SSA: %d] [MAIN: %d\",\n\t\t\t   si->ssa_area_segs, si->main_area_segs);\n\t\tseq_printf(s, \"(OverProv:%d Resv:%d)]\\n\\n\",\n\t\t\t   si->overp_segs, si->rsvd_segs);\n\t\tseq_printf(s, \"Utilization: %d%% (%d valid blocks)\\n\",\n\t\t\t   si->utilization, si->valid_count);\n\t\tseq_printf(s, \"  - Node: %u (Inode: %u, \",\n\t\t\t   si->valid_node_count, si->valid_inode_count);\n\t\tseq_printf(s, \"Other: %u)\\n  - Data: %u\\n\",\n\t\t\t   si->valid_node_count - si->valid_inode_count,\n\t\t\t   si->valid_count - si->valid_node_count);\n\t\tseq_printf(s, \"  - Inline_data Inode: %u\\n\",\n\t\t\t   si->inline_inode);\n\t\tseq_printf(s, \"  - Inline_dentry Inode: %u\\n\",\n\t\t\t   si->inline_dir);\n\t\tseq_printf(s, \"\\nMain area: %d segs, %d secs %d zones\\n\",\n\t\t\t   si->main_area_segs, si->main_area_sections,\n\t\t\t   si->main_area_zones);\n\t\tseq_printf(s, \"  - COLD  data: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_DATA],\n\t\t\t   si->cursec[CURSEG_COLD_DATA],\n\t\t\t   si->curzone[CURSEG_COLD_DATA]);\n\t\tseq_printf(s, \"  - WARM  data: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_WARM_DATA],\n\t\t\t   si->cursec[CURSEG_WARM_DATA],\n\t\t\t   si->curzone[CURSEG_WARM_DATA]);\n\t\tseq_printf(s, \"  - HOT   data: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_HOT_DATA],\n\t\t\t   si->cursec[CURSEG_HOT_DATA],\n\t\t\t   si->curzone[CURSEG_HOT_DATA]);\n\t\tseq_printf(s, \"  - Dir   dnode: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_HOT_NODE],\n\t\t\t   si->cursec[CURSEG_HOT_NODE],\n\t\t\t   si->curzone[CURSEG_HOT_NODE]);\n\t\tseq_printf(s, \"  - File   dnode: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_WARM_NODE],\n\t\t\t   si->cursec[CURSEG_WARM_NODE],\n\t\t\t   si->curzone[CURSEG_WARM_NODE]);\n\t\tseq_printf(s, \"  - Indir nodes: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_NODE],\n\t\t\t   si->cursec[CURSEG_COLD_NODE],\n\t\t\t   si->curzone[CURSEG_COLD_NODE]);\n\t\tseq_printf(s, \"\\n  - Valid: %d\\n  - Dirty: %d\\n\",\n\t\t\t   si->main_area_segs - si->dirty_count -\n\t\t\t   si->prefree_count - si->free_segs,\n\t\t\t   si->dirty_count);\n\t\tseq_printf(s, \"  - Prefree: %d\\n  - Free: %d (%d)\\n\\n\",\n\t\t\t   si->prefree_count, si->free_segs, si->free_secs);\n\t\tseq_printf(s, \"CP calls: %d\\n\", si->cp_count);\n\t\tseq_printf(s, \"GC calls: %d (BG: %d)\\n\",\n\t\t\t   si->call_count, si->bg_gc);\n\t\tseq_printf(s, \"  - data segments : %d\\n\", si->data_segs);\n\t\tseq_printf(s, \"  - node segments : %d\\n\", si->node_segs);\n\t\tseq_printf(s, \"Try to move %d blocks\\n\", si->tot_blks);\n\t\tseq_printf(s, \"  - data blocks : %d\\n\", si->data_blks);\n\t\tseq_printf(s, \"  - node blocks : %d\\n\", si->node_blks);\n\t\tseq_printf(s, \"\\nExtent Hit Ratio: %d / %d\\n\",\n\t\t\t   si->hit_ext, si->total_ext);\n\t\tseq_puts(s, \"\\nBalancing F2FS Async:\\n\");\n\t\tseq_printf(s, \"  - inmem: %4d, wb: %4d\\n\",\n\t\t\t   si->inmem_pages, si->wb_pages);\n\t\tseq_printf(s, \"  - nodes: %4d in %4d\\n\",\n\t\t\t   si->ndirty_node, si->node_pages);\n\t\tseq_printf(s, \"  - dents: %4d in dirs:%4d\\n\",\n\t\t\t   si->ndirty_dent, si->ndirty_dirs);\n\t\tseq_printf(s, \"  - meta: %4d in %4d\\n\",\n\t\t\t   si->ndirty_meta, si->meta_pages);\n\t\tseq_printf(s, \"  - NATs: %9d/%9d\\n  - SITs: %9d/%9d\\n\",\n\t\t\t   si->dirty_nats, si->nats, si->dirty_sits, si->sits);\n\t\tseq_printf(s, \"  - free_nids: %9d\\n\",\n\t\t\t   si->fnids);\n\t\tseq_puts(s, \"\\nDistribution of User Blocks:\");\n\t\tseq_puts(s, \" [ valid | invalid | free ]\\n\");\n\t\tseq_puts(s, \"  [\");\n\n\t\tfor (j = 0; j < si->util_valid; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_putc(s, '|');\n\n\t\tfor (j = 0; j < si->util_invalid; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_putc(s, '|');\n\n\t\tfor (j = 0; j < si->util_free; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_puts(s, \"]\\n\\n\");\n\t\tseq_printf(s, \"IPU: %u blocks\\n\", si->inplace_count);\n\t\tseq_printf(s, \"SSR: %u blocks in %u segments\\n\",\n\t\t\t   si->block_count[SSR], si->segment_count[SSR]);\n\t\tseq_printf(s, \"LFS: %u blocks in %u segments\\n\",\n\t\t\t   si->block_count[LFS], si->segment_count[LFS]);\n\n\t\t/* segment usage info */\n\t\tupdate_sit_info(si->sbi);\n\t\tseq_printf(s, \"\\nBDF: %u, avg. vblocks: %u\\n\",\n\t\t\t   si->bimodal, si->avg_vblocks);\n\n\t\t/* memory footprint */\n\t\tupdate_mem_info(si->sbi);\n\t\tseq_printf(s, \"\\nMemory: %u KB\\n\",\n\t\t\t(si->base_mem + si->cache_mem + si->page_mem) >> 10);\n\t\tseq_printf(s, \"  - static: %u KB\\n\",\n\t\t\t\tsi->base_mem >> 10);\n\t\tseq_printf(s, \"  - cached: %u KB\\n\",\n\t\t\t\tsi->cache_mem >> 10);\n\t\tseq_printf(s, \"  - paged : %u KB\\n\",\n\t\t\t\tsi->page_mem >> 10);\n\t}\n\tmutex_unlock(&f2fs_stat_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(f2fs_stat_list);",
      "static DEFINE_MUTEX(f2fs_stat_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&f2fs_stat_mutex"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"  - paged : %u KB\\n\"",
            "si->page_mem >> 10"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mem_info",
          "args": [
            "si->sbi"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "update_mem_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
          "lines": "124-194",
          "snippet": "static void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sit_info",
          "args": [
            "si->sbi"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "update_sit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
          "lines": "92-119",
          "snippet": "static void update_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned int blks_per_sec, hblks_per_sec, total_vblocks, bimodal, dist;\n\tunsigned int segno, vblocks;\n\tint ndirty = 0;\n\n\tbimodal = 0;\n\ttotal_vblocks = 0;\n\tblks_per_sec = sbi->segs_per_sec * (1 << sbi->log_blocks_per_seg);\n\thblks_per_sec = blks_per_sec / 2;\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\t\tdist = abs(vblocks - hblks_per_sec);\n\t\tbimodal += dist * dist;\n\n\t\tif (vblocks > 0 && vblocks < blks_per_sec) {\n\t\t\ttotal_vblocks += vblocks;\n\t\t\tndirty++;\n\t\t}\n\t}\n\tdist = MAIN_SECS(sbi) * hblks_per_sec * hblks_per_sec / 100;\n\tsi->bimodal = bimodal / dist;\n\tif (si->dirty_count)\n\t\tsi->avg_vblocks = total_vblocks / ndirty;\n\telse\n\t\tsi->avg_vblocks = 0;\n}",
          "includes": [
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned int blks_per_sec, hblks_per_sec, total_vblocks, bimodal, dist;\n\tunsigned int segno, vblocks;\n\tint ndirty = 0;\n\n\tbimodal = 0;\n\ttotal_vblocks = 0;\n\tblks_per_sec = sbi->segs_per_sec * (1 << sbi->log_blocks_per_seg);\n\thblks_per_sec = blks_per_sec / 2;\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\t\tdist = abs(vblocks - hblks_per_sec);\n\t\tbimodal += dist * dist;\n\n\t\tif (vblocks > 0 && vblocks < blks_per_sec) {\n\t\t\ttotal_vblocks += vblocks;\n\t\t\tndirty++;\n\t\t}\n\t}\n\tdist = MAIN_SECS(sbi) * hblks_per_sec * hblks_per_sec / 100;\n\tsi->bimodal = bimodal / dist;\n\tif (si->dirty_count)\n\t\tsi->avg_vblocks = total_vblocks / ndirty;\n\telse\n\t\tsi->avg_vblocks = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"]\\n\\n\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'-'"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "si->sbi->sb->s_bdev",
            "devname"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_general_status",
          "args": [
            "si->sbi"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "update_general_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
          "lines": "30-87",
          "snippet": "static void update_general_status(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tint i;\n\n\t/* validation check of the segment numbers */\n\tsi->hit_ext = sbi->read_hit_ext;\n\tsi->total_ext = sbi->total_hit_ext;\n\tsi->ndirty_node = get_pages(sbi, F2FS_DIRTY_NODES);\n\tsi->ndirty_dent = get_pages(sbi, F2FS_DIRTY_DENTS);\n\tsi->ndirty_dirs = sbi->n_dirty_dirs;\n\tsi->ndirty_meta = get_pages(sbi, F2FS_DIRTY_META);\n\tsi->inmem_pages = get_pages(sbi, F2FS_INMEM_PAGES);\n\tsi->wb_pages = get_pages(sbi, F2FS_WRITEBACK);\n\tsi->total_count = (int)sbi->user_block_count / sbi->blocks_per_seg;\n\tsi->rsvd_segs = reserved_segments(sbi);\n\tsi->overp_segs = overprovision_segments(sbi);\n\tsi->valid_count = valid_user_blocks(sbi);\n\tsi->valid_node_count = valid_node_count(sbi);\n\tsi->valid_inode_count = valid_inode_count(sbi);\n\tsi->inline_inode = atomic_read(&sbi->inline_inode);\n\tsi->inline_dir = atomic_read(&sbi->inline_dir);\n\tsi->utilization = utilization(sbi);\n\n\tsi->free_segs = free_segments(sbi);\n\tsi->free_secs = free_sections(sbi);\n\tsi->prefree_count = prefree_segments(sbi);\n\tsi->dirty_count = dirty_segments(sbi);\n\tsi->node_pages = NODE_MAPPING(sbi)->nrpages;\n\tsi->meta_pages = META_MAPPING(sbi)->nrpages;\n\tsi->nats = NM_I(sbi)->nat_cnt;\n\tsi->dirty_nats = NM_I(sbi)->dirty_nat_cnt;\n\tsi->sits = MAIN_SEGS(sbi);\n\tsi->dirty_sits = SIT_I(sbi)->dirty_sentries;\n\tsi->fnids = NM_I(sbi)->fcnt;\n\tsi->bg_gc = sbi->bg_gc;\n\tsi->util_free = (int)(free_user_blocks(sbi) >> sbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_valid = (int)(written_block_count(sbi) >>\n\t\t\t\t\t\tsbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_invalid = 50 - si->util_free - si->util_valid;\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_NODE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tsi->curseg[i] = curseg->segno;\n\t\tsi->cursec[i] = curseg->segno / sbi->segs_per_sec;\n\t\tsi->curzone[i] = si->cursec[i] / sbi->secs_per_zone;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsi->segment_count[i] = sbi->segment_count[i];\n\t\tsi->block_count[i] = sbi->block_count[i];\n\t}\n\n\tsi->inplace_count = atomic_read(&sbi->inplace_count);\n}",
          "includes": [
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_general_status(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tint i;\n\n\t/* validation check of the segment numbers */\n\tsi->hit_ext = sbi->read_hit_ext;\n\tsi->total_ext = sbi->total_hit_ext;\n\tsi->ndirty_node = get_pages(sbi, F2FS_DIRTY_NODES);\n\tsi->ndirty_dent = get_pages(sbi, F2FS_DIRTY_DENTS);\n\tsi->ndirty_dirs = sbi->n_dirty_dirs;\n\tsi->ndirty_meta = get_pages(sbi, F2FS_DIRTY_META);\n\tsi->inmem_pages = get_pages(sbi, F2FS_INMEM_PAGES);\n\tsi->wb_pages = get_pages(sbi, F2FS_WRITEBACK);\n\tsi->total_count = (int)sbi->user_block_count / sbi->blocks_per_seg;\n\tsi->rsvd_segs = reserved_segments(sbi);\n\tsi->overp_segs = overprovision_segments(sbi);\n\tsi->valid_count = valid_user_blocks(sbi);\n\tsi->valid_node_count = valid_node_count(sbi);\n\tsi->valid_inode_count = valid_inode_count(sbi);\n\tsi->inline_inode = atomic_read(&sbi->inline_inode);\n\tsi->inline_dir = atomic_read(&sbi->inline_dir);\n\tsi->utilization = utilization(sbi);\n\n\tsi->free_segs = free_segments(sbi);\n\tsi->free_secs = free_sections(sbi);\n\tsi->prefree_count = prefree_segments(sbi);\n\tsi->dirty_count = dirty_segments(sbi);\n\tsi->node_pages = NODE_MAPPING(sbi)->nrpages;\n\tsi->meta_pages = META_MAPPING(sbi)->nrpages;\n\tsi->nats = NM_I(sbi)->nat_cnt;\n\tsi->dirty_nats = NM_I(sbi)->dirty_nat_cnt;\n\tsi->sits = MAIN_SEGS(sbi);\n\tsi->dirty_sits = SIT_I(sbi)->dirty_sentries;\n\tsi->fnids = NM_I(sbi)->fcnt;\n\tsi->bg_gc = sbi->bg_gc;\n\tsi->util_free = (int)(free_user_blocks(sbi) >> sbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_valid = (int)(written_block_count(sbi) >>\n\t\t\t\t\t\tsbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_invalid = 50 - si->util_free - si->util_valid;\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_NODE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tsi->curseg[i] = curseg->segno;\n\t\tsi->cursec[i] = curseg->segno / sbi->segs_per_sec;\n\t\tsi->curzone[i] = si->cursec[i] / sbi->secs_per_zone;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsi->segment_count[i] = sbi->segment_count[i];\n\t\tsi->block_count[i] = sbi->block_count[i];\n\t}\n\n\tsi->inplace_count = atomic_read(&sbi->inplace_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "si",
            "&f2fs_stat_list",
            "stat_list"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&f2fs_stat_mutex"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(f2fs_stat_list);\nstatic DEFINE_MUTEX(f2fs_stat_mutex);\n\nstatic int stat_show(struct seq_file *s, void *v)\n{\n\tstruct f2fs_stat_info *si;\n\tint i = 0;\n\tint j;\n\n\tmutex_lock(&f2fs_stat_mutex);\n\tlist_for_each_entry(si, &f2fs_stat_list, stat_list) {\n\t\tchar devname[BDEVNAME_SIZE];\n\n\t\tupdate_general_status(si->sbi);\n\n\t\tseq_printf(s, \"\\n=====[ partition info(%s). #%d ]=====\\n\",\n\t\t\tbdevname(si->sbi->sb->s_bdev, devname), i++);\n\t\tseq_printf(s, \"[SB: 1] [CP: 2] [SIT: %d] [NAT: %d] \",\n\t\t\t   si->sit_area_segs, si->nat_area_segs);\n\t\tseq_printf(s, \"[SSA: %d] [MAIN: %d\",\n\t\t\t   si->ssa_area_segs, si->main_area_segs);\n\t\tseq_printf(s, \"(OverProv:%d Resv:%d)]\\n\\n\",\n\t\t\t   si->overp_segs, si->rsvd_segs);\n\t\tseq_printf(s, \"Utilization: %d%% (%d valid blocks)\\n\",\n\t\t\t   si->utilization, si->valid_count);\n\t\tseq_printf(s, \"  - Node: %u (Inode: %u, \",\n\t\t\t   si->valid_node_count, si->valid_inode_count);\n\t\tseq_printf(s, \"Other: %u)\\n  - Data: %u\\n\",\n\t\t\t   si->valid_node_count - si->valid_inode_count,\n\t\t\t   si->valid_count - si->valid_node_count);\n\t\tseq_printf(s, \"  - Inline_data Inode: %u\\n\",\n\t\t\t   si->inline_inode);\n\t\tseq_printf(s, \"  - Inline_dentry Inode: %u\\n\",\n\t\t\t   si->inline_dir);\n\t\tseq_printf(s, \"\\nMain area: %d segs, %d secs %d zones\\n\",\n\t\t\t   si->main_area_segs, si->main_area_sections,\n\t\t\t   si->main_area_zones);\n\t\tseq_printf(s, \"  - COLD  data: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_DATA],\n\t\t\t   si->cursec[CURSEG_COLD_DATA],\n\t\t\t   si->curzone[CURSEG_COLD_DATA]);\n\t\tseq_printf(s, \"  - WARM  data: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_WARM_DATA],\n\t\t\t   si->cursec[CURSEG_WARM_DATA],\n\t\t\t   si->curzone[CURSEG_WARM_DATA]);\n\t\tseq_printf(s, \"  - HOT   data: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_HOT_DATA],\n\t\t\t   si->cursec[CURSEG_HOT_DATA],\n\t\t\t   si->curzone[CURSEG_HOT_DATA]);\n\t\tseq_printf(s, \"  - Dir   dnode: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_HOT_NODE],\n\t\t\t   si->cursec[CURSEG_HOT_NODE],\n\t\t\t   si->curzone[CURSEG_HOT_NODE]);\n\t\tseq_printf(s, \"  - File   dnode: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_WARM_NODE],\n\t\t\t   si->cursec[CURSEG_WARM_NODE],\n\t\t\t   si->curzone[CURSEG_WARM_NODE]);\n\t\tseq_printf(s, \"  - Indir nodes: %d, %d, %d\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_NODE],\n\t\t\t   si->cursec[CURSEG_COLD_NODE],\n\t\t\t   si->curzone[CURSEG_COLD_NODE]);\n\t\tseq_printf(s, \"\\n  - Valid: %d\\n  - Dirty: %d\\n\",\n\t\t\t   si->main_area_segs - si->dirty_count -\n\t\t\t   si->prefree_count - si->free_segs,\n\t\t\t   si->dirty_count);\n\t\tseq_printf(s, \"  - Prefree: %d\\n  - Free: %d (%d)\\n\\n\",\n\t\t\t   si->prefree_count, si->free_segs, si->free_secs);\n\t\tseq_printf(s, \"CP calls: %d\\n\", si->cp_count);\n\t\tseq_printf(s, \"GC calls: %d (BG: %d)\\n\",\n\t\t\t   si->call_count, si->bg_gc);\n\t\tseq_printf(s, \"  - data segments : %d\\n\", si->data_segs);\n\t\tseq_printf(s, \"  - node segments : %d\\n\", si->node_segs);\n\t\tseq_printf(s, \"Try to move %d blocks\\n\", si->tot_blks);\n\t\tseq_printf(s, \"  - data blocks : %d\\n\", si->data_blks);\n\t\tseq_printf(s, \"  - node blocks : %d\\n\", si->node_blks);\n\t\tseq_printf(s, \"\\nExtent Hit Ratio: %d / %d\\n\",\n\t\t\t   si->hit_ext, si->total_ext);\n\t\tseq_puts(s, \"\\nBalancing F2FS Async:\\n\");\n\t\tseq_printf(s, \"  - inmem: %4d, wb: %4d\\n\",\n\t\t\t   si->inmem_pages, si->wb_pages);\n\t\tseq_printf(s, \"  - nodes: %4d in %4d\\n\",\n\t\t\t   si->ndirty_node, si->node_pages);\n\t\tseq_printf(s, \"  - dents: %4d in dirs:%4d\\n\",\n\t\t\t   si->ndirty_dent, si->ndirty_dirs);\n\t\tseq_printf(s, \"  - meta: %4d in %4d\\n\",\n\t\t\t   si->ndirty_meta, si->meta_pages);\n\t\tseq_printf(s, \"  - NATs: %9d/%9d\\n  - SITs: %9d/%9d\\n\",\n\t\t\t   si->dirty_nats, si->nats, si->dirty_sits, si->sits);\n\t\tseq_printf(s, \"  - free_nids: %9d\\n\",\n\t\t\t   si->fnids);\n\t\tseq_puts(s, \"\\nDistribution of User Blocks:\");\n\t\tseq_puts(s, \" [ valid | invalid | free ]\\n\");\n\t\tseq_puts(s, \"  [\");\n\n\t\tfor (j = 0; j < si->util_valid; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_putc(s, '|');\n\n\t\tfor (j = 0; j < si->util_invalid; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_putc(s, '|');\n\n\t\tfor (j = 0; j < si->util_free; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_puts(s, \"]\\n\\n\");\n\t\tseq_printf(s, \"IPU: %u blocks\\n\", si->inplace_count);\n\t\tseq_printf(s, \"SSR: %u blocks in %u segments\\n\",\n\t\t\t   si->block_count[SSR], si->segment_count[SSR]);\n\t\tseq_printf(s, \"LFS: %u blocks in %u segments\\n\",\n\t\t\t   si->block_count[LFS], si->segment_count[LFS]);\n\n\t\t/* segment usage info */\n\t\tupdate_sit_info(si->sbi);\n\t\tseq_printf(s, \"\\nBDF: %u, avg. vblocks: %u\\n\",\n\t\t\t   si->bimodal, si->avg_vblocks);\n\n\t\t/* memory footprint */\n\t\tupdate_mem_info(si->sbi);\n\t\tseq_printf(s, \"\\nMemory: %u KB\\n\",\n\t\t\t(si->base_mem + si->cache_mem + si->page_mem) >> 10);\n\t\tseq_printf(s, \"  - static: %u KB\\n\",\n\t\t\t\tsi->base_mem >> 10);\n\t\tseq_printf(s, \"  - cached: %u KB\\n\",\n\t\t\t\tsi->cache_mem >> 10);\n\t\tseq_printf(s, \"  - paged : %u KB\\n\",\n\t\t\t\tsi->page_mem >> 10);\n\t}\n\tmutex_unlock(&f2fs_stat_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "update_mem_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "124-194",
    "snippet": "static void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bitmap_size",
          "args": [
            "sbi",
            "NAT_BITMAP"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "910-921",
          "snippet": "static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SECS(sbi)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SEGS(sbi)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SECS(sbi)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SEGS(sbi)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bitmap_size",
          "args": [
            "MAIN_SEGS(sbi)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_STAT",
          "args": [
            "sbi"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_STAT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1580-1583",
          "snippet": "static inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}"
  },
  {
    "function_name": "update_sit_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "92-119",
    "snippet": "static void update_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned int blks_per_sec, hblks_per_sec, total_vblocks, bimodal, dist;\n\tunsigned int segno, vblocks;\n\tint ndirty = 0;\n\n\tbimodal = 0;\n\ttotal_vblocks = 0;\n\tblks_per_sec = sbi->segs_per_sec * (1 << sbi->log_blocks_per_seg);\n\thblks_per_sec = blks_per_sec / 2;\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\t\tdist = abs(vblocks - hblks_per_sec);\n\t\tbimodal += dist * dist;\n\n\t\tif (vblocks > 0 && vblocks < blks_per_sec) {\n\t\t\ttotal_vblocks += vblocks;\n\t\t\tndirty++;\n\t\t}\n\t}\n\tdist = MAIN_SECS(sbi) * hblks_per_sec * hblks_per_sec / 100;\n\tsi->bimodal = bimodal / dist;\n\tif (si->dirty_count)\n\t\tsi->avg_vblocks = total_vblocks / ndirty;\n\telse\n\t\tsi->avg_vblocks = 0;\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "vblocks - hblks_per_sec"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "sbi->segs_per_sec"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_STAT",
          "args": [
            "sbi"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_STAT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1580-1583",
          "snippet": "static inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned int blks_per_sec, hblks_per_sec, total_vblocks, bimodal, dist;\n\tunsigned int segno, vblocks;\n\tint ndirty = 0;\n\n\tbimodal = 0;\n\ttotal_vblocks = 0;\n\tblks_per_sec = sbi->segs_per_sec * (1 << sbi->log_blocks_per_seg);\n\thblks_per_sec = blks_per_sec / 2;\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\t\tdist = abs(vblocks - hblks_per_sec);\n\t\tbimodal += dist * dist;\n\n\t\tif (vblocks > 0 && vblocks < blks_per_sec) {\n\t\t\ttotal_vblocks += vblocks;\n\t\t\tndirty++;\n\t\t}\n\t}\n\tdist = MAIN_SECS(sbi) * hblks_per_sec * hblks_per_sec / 100;\n\tsi->bimodal = bimodal / dist;\n\tif (si->dirty_count)\n\t\tsi->avg_vblocks = total_vblocks / ndirty;\n\telse\n\t\tsi->avg_vblocks = 0;\n}"
  },
  {
    "function_name": "update_general_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
    "lines": "30-87",
    "snippet": "static void update_general_status(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tint i;\n\n\t/* validation check of the segment numbers */\n\tsi->hit_ext = sbi->read_hit_ext;\n\tsi->total_ext = sbi->total_hit_ext;\n\tsi->ndirty_node = get_pages(sbi, F2FS_DIRTY_NODES);\n\tsi->ndirty_dent = get_pages(sbi, F2FS_DIRTY_DENTS);\n\tsi->ndirty_dirs = sbi->n_dirty_dirs;\n\tsi->ndirty_meta = get_pages(sbi, F2FS_DIRTY_META);\n\tsi->inmem_pages = get_pages(sbi, F2FS_INMEM_PAGES);\n\tsi->wb_pages = get_pages(sbi, F2FS_WRITEBACK);\n\tsi->total_count = (int)sbi->user_block_count / sbi->blocks_per_seg;\n\tsi->rsvd_segs = reserved_segments(sbi);\n\tsi->overp_segs = overprovision_segments(sbi);\n\tsi->valid_count = valid_user_blocks(sbi);\n\tsi->valid_node_count = valid_node_count(sbi);\n\tsi->valid_inode_count = valid_inode_count(sbi);\n\tsi->inline_inode = atomic_read(&sbi->inline_inode);\n\tsi->inline_dir = atomic_read(&sbi->inline_dir);\n\tsi->utilization = utilization(sbi);\n\n\tsi->free_segs = free_segments(sbi);\n\tsi->free_secs = free_sections(sbi);\n\tsi->prefree_count = prefree_segments(sbi);\n\tsi->dirty_count = dirty_segments(sbi);\n\tsi->node_pages = NODE_MAPPING(sbi)->nrpages;\n\tsi->meta_pages = META_MAPPING(sbi)->nrpages;\n\tsi->nats = NM_I(sbi)->nat_cnt;\n\tsi->dirty_nats = NM_I(sbi)->dirty_nat_cnt;\n\tsi->sits = MAIN_SEGS(sbi);\n\tsi->dirty_sits = SIT_I(sbi)->dirty_sentries;\n\tsi->fnids = NM_I(sbi)->fcnt;\n\tsi->bg_gc = sbi->bg_gc;\n\tsi->util_free = (int)(free_user_blocks(sbi) >> sbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_valid = (int)(written_block_count(sbi) >>\n\t\t\t\t\t\tsbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_invalid = 50 - si->util_free - si->util_valid;\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_NODE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tsi->curseg[i] = curseg->segno;\n\t\tsi->cursec[i] = curseg->segno / sbi->segs_per_sec;\n\t\tsi->curzone[i] = si->cursec[i] / sbi->secs_per_zone;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsi->segment_count[i] = sbi->segment_count[i];\n\t\tsi->block_count[i] = sbi->block_count[i];\n\t}\n\n\tsi->inplace_count = atomic_read(&sbi->inplace_count);\n}",
    "includes": [
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->inplace_count"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "i"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "written_block_count",
          "args": [
            "sbi"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "written_block_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "401-404",
          "snippet": "static inline block_t written_block_count(struct f2fs_sb_info *sbi)\n{\n\treturn SIT_I(sbi)->written_valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline block_t written_block_count(struct f2fs_sb_info *sbi)\n{\n\treturn SIT_I(sbi)->written_valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_user_blocks",
          "args": [
            "sbi"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "limit_free_user_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.h",
          "lines": "60-65",
          "snippet": "static inline block_t limit_free_user_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t reclaimable_user_blocks = sbi->user_block_count -\n\t\twritten_block_count(sbi);\n\treturn (long)(reclaimable_user_blocks * LIMIT_FREE_BLOCK) / 100;\n}",
          "includes": [],
          "macros_used": [
            "#define LIMIT_FREE_BLOCK\t40 /* percentage over invalid + free space */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define LIMIT_FREE_BLOCK\t40 /* percentage over invalid + free space */\n\nstatic inline block_t limit_free_user_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t reclaimable_user_blocks = sbi->user_block_count -\n\t\twritten_block_count(sbi);\n\treturn (long)(reclaimable_user_blocks * LIMIT_FREE_BLOCK) / 100;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_segments",
          "args": [
            "sbi"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "426-434",
          "snippet": "static inline unsigned int dirty_segments(struct f2fs_sb_info *sbi)\n{\n\treturn DIRTY_I(sbi)->nr_dirty[DIRTY_HOT_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_WARM_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_COLD_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_HOT_NODE] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_WARM_NODE] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_COLD_NODE];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int dirty_segments(struct f2fs_sb_info *sbi)\n{\n\treturn DIRTY_I(sbi)->nr_dirty[DIRTY_HOT_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_WARM_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_COLD_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_HOT_NODE] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_WARM_NODE] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_COLD_NODE];\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefree_segments",
          "args": [
            "sbi"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "clear_prefree_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "585-623",
          "snippet": "void clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nvoid clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_sections",
          "args": [
            "sbi"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "free_sections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "416-419",
          "snippet": "static inline unsigned int free_sections(struct f2fs_sb_info *sbi)\n{\n\treturn FREE_I(sbi)->free_sections;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int free_sections(struct f2fs_sb_info *sbi)\n{\n\treturn FREE_I(sbi)->free_sections;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utilization",
          "args": [
            "sbi"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "utilization",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "476-480",
          "snippet": "static inline int utilization(struct f2fs_sb_info *sbi)\n{\n\treturn div_u64((u64)valid_user_blocks(sbi) * 100,\n\t\t\t\t\tsbi->user_block_count);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline int utilization(struct f2fs_sb_info *sbi)\n{\n\treturn div_u64((u64)valid_user_blocks(sbi) * 100,\n\t\t\t\t\tsbi->user_block_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->inline_dir"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->inline_inode"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_inode_count",
          "args": [
            "sbi"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "valid_inode_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1031-1034",
          "snippet": "static inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_inode_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_inode_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_node_count",
          "args": [
            "sbi"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1010-1013",
          "snippet": "static inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_node_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_node_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_user_blocks",
          "args": [
            "sbi"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "valid_user_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "905-908",
          "snippet": "static inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "overprovision_segments",
          "args": [
            "sbi"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "overprovision_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "436-439",
          "snippet": "static inline int overprovision_segments(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->ovp_segments;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline int overprovision_segments(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->ovp_segments;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserved_segments",
          "args": [
            "sbi"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "reserved_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "411-414",
          "snippet": "static inline int reserved_segments(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->reserved_segments;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline int reserved_segments(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->reserved_segments;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_WRITEBACK"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_STAT",
          "args": [
            "sbi"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_STAT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1580-1583",
          "snippet": "static inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_general_status(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tint i;\n\n\t/* validation check of the segment numbers */\n\tsi->hit_ext = sbi->read_hit_ext;\n\tsi->total_ext = sbi->total_hit_ext;\n\tsi->ndirty_node = get_pages(sbi, F2FS_DIRTY_NODES);\n\tsi->ndirty_dent = get_pages(sbi, F2FS_DIRTY_DENTS);\n\tsi->ndirty_dirs = sbi->n_dirty_dirs;\n\tsi->ndirty_meta = get_pages(sbi, F2FS_DIRTY_META);\n\tsi->inmem_pages = get_pages(sbi, F2FS_INMEM_PAGES);\n\tsi->wb_pages = get_pages(sbi, F2FS_WRITEBACK);\n\tsi->total_count = (int)sbi->user_block_count / sbi->blocks_per_seg;\n\tsi->rsvd_segs = reserved_segments(sbi);\n\tsi->overp_segs = overprovision_segments(sbi);\n\tsi->valid_count = valid_user_blocks(sbi);\n\tsi->valid_node_count = valid_node_count(sbi);\n\tsi->valid_inode_count = valid_inode_count(sbi);\n\tsi->inline_inode = atomic_read(&sbi->inline_inode);\n\tsi->inline_dir = atomic_read(&sbi->inline_dir);\n\tsi->utilization = utilization(sbi);\n\n\tsi->free_segs = free_segments(sbi);\n\tsi->free_secs = free_sections(sbi);\n\tsi->prefree_count = prefree_segments(sbi);\n\tsi->dirty_count = dirty_segments(sbi);\n\tsi->node_pages = NODE_MAPPING(sbi)->nrpages;\n\tsi->meta_pages = META_MAPPING(sbi)->nrpages;\n\tsi->nats = NM_I(sbi)->nat_cnt;\n\tsi->dirty_nats = NM_I(sbi)->dirty_nat_cnt;\n\tsi->sits = MAIN_SEGS(sbi);\n\tsi->dirty_sits = SIT_I(sbi)->dirty_sentries;\n\tsi->fnids = NM_I(sbi)->fcnt;\n\tsi->bg_gc = sbi->bg_gc;\n\tsi->util_free = (int)(free_user_blocks(sbi) >> sbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_valid = (int)(written_block_count(sbi) >>\n\t\t\t\t\t\tsbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_invalid = 50 - si->util_free - si->util_valid;\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_NODE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tsi->curseg[i] = curseg->segno;\n\t\tsi->cursec[i] = curseg->segno / sbi->segs_per_sec;\n\t\tsi->curzone[i] = si->cursec[i] / sbi->secs_per_zone;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsi->segment_count[i] = sbi->segment_count[i];\n\t\tsi->block_count[i] = sbi->block_count[i];\n\t}\n\n\tsi->inplace_count = atomic_read(&sbi->inplace_count);\n}"
  }
]