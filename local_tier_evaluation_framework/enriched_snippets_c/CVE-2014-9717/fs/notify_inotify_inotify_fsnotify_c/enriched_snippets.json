[
  {
    "function_name": "inotify_free_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "174-177",
    "snippet": "static void inotify_free_event(struct fsnotify_event *fsn_event)\n{\n\tkfree(INOTIFY_E(fsn_event));\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "INOTIFY_E(fsn_event)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INOTIFY_E",
          "args": [
            "fsn_event"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "INOTIFY_E",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify.h",
          "lines": "18-21",
          "snippet": "static inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}",
          "includes": [
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/inotify.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic void inotify_free_event(struct fsnotify_event *fsn_event)\n{\n\tkfree(INOTIFY_E(fsn_event));\n}"
  },
  {
    "function_name": "inotify_free_group_priv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "163-172",
    "snippet": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\t/* ideally the idr is empty and we won't hit the BUG in the callback */\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_destroy(&group->inotify_data.idr);\n\tif (group->inotify_data.user) {\n\t\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\t\tfree_uid(group->inotify_data.user);\n\t}\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "group->inotify_data.user"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&group->inotify_data.user->inotify_devs"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&group->inotify_data.idr"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each",
          "args": [
            "&group->inotify_data.idr",
            "idr_callback",
            "group"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\t/* ideally the idr is empty and we won't hit the BUG in the callback */\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_destroy(&group->inotify_data.idr);\n\tif (group->inotify_data.user) {\n\t\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\t\tfree_uid(group->inotify_data.user);\n\t}\n}"
  },
  {
    "function_name": "idr_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "135-161",
    "snippet": "static int idr_callback(int id, void *p, void *data)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\tstatic bool warned = false;\n\n\tif (warned)\n\t\treturn 0;\n\n\twarned = true;\n\tfsn_mark = p;\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tWARN(1, \"inotify closing but id=%d for fsn_mark=%p in group=%p still in \"\n\t\t\"idr.  Probably leaking memory\\n\", id, p, data);\n\n\t/*\n\t * I'm taking the liberty of assuming that the mark in question is a\n\t * valid address and I'm dereferencing it.  This might help to figure\n\t * out why we got here and the panic is no worse than the original\n\t * BUG() that was here.\n\t */\n\tif (fsn_mark)\n\t\tprintk(KERN_WARNING \"fsn_mark->group=%p inode=%p wd=%d\\n\",\n\t\t\tfsn_mark->group, fsn_mark->inode, i_mark->wd);\n\treturn 0;\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"fsn_mark->group=%p inode=%p wd=%d\\n\"",
            "fsn_mark->group",
            "fsn_mark->inode",
            "i_mark->wd"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"inotify closing but id=%d for fsn_mark=%p in group=%p still in \"\n\t\t\"idr.  Probably leaking memory\\n\"",
            "id",
            "p",
            "data"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fsn_mark",
            "structinotify_inode_mark",
            "fsn_mark"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic int idr_callback(int id, void *p, void *data)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\tstatic bool warned = false;\n\n\tif (warned)\n\t\treturn 0;\n\n\twarned = true;\n\tfsn_mark = p;\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tWARN(1, \"inotify closing but id=%d for fsn_mark=%p in group=%p still in \"\n\t\t\"idr.  Probably leaking memory\\n\", id, p, data);\n\n\t/*\n\t * I'm taking the liberty of assuming that the mark in question is a\n\t * valid address and I'm dereferencing it.  This might help to figure\n\t * out why we got here and the panic is no worse than the original\n\t * BUG() that was here.\n\t */\n\tif (fsn_mark)\n\t\tprintk(KERN_WARNING \"fsn_mark->group=%p inode=%p wd=%d\\n\",\n\t\t\tfsn_mark->group, fsn_mark->inode, i_mark->wd);\n\treturn 0;\n}"
  },
  {
    "function_name": "inotify_freeing_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "123-126",
    "snippet": "static void inotify_freeing_mark(struct fsnotify_mark *fsn_mark, struct fsnotify_group *group)\n{\n\tinotify_ignored_and_remove_idr(fsn_mark, group);\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inotify_ignored_and_remove_idr",
          "args": [
            "fsn_mark",
            "group"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_ignored_and_remove_idr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "490-504",
          "snippet": "void inotify_ignored_and_remove_idr(struct fsnotify_mark *fsn_mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\t/* Queue ignore event for the watch */\n\tinotify_handle_event(group, NULL, fsn_mark, NULL, FS_IN_IGNORED,\n\t\t\t     NULL, FSNOTIFY_EVENT_NONE, NULL, 0);\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\t/* remove this mark from the idr */\n\tinotify_remove_from_idr(group, i_mark);\n\n\tatomic_dec(&group->inotify_data.user->inotify_watches);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nvoid inotify_ignored_and_remove_idr(struct fsnotify_mark *fsn_mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\t/* Queue ignore event for the watch */\n\tinotify_handle_event(group, NULL, fsn_mark, NULL, FS_IN_IGNORED,\n\t\t\t     NULL, FSNOTIFY_EVENT_NONE, NULL, 0);\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\t/* remove this mark from the idr */\n\tinotify_remove_from_idr(group, i_mark);\n\n\tatomic_dec(&group->inotify_data.user->inotify_watches);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic void inotify_freeing_mark(struct fsnotify_mark *fsn_mark, struct fsnotify_group *group)\n{\n\tinotify_ignored_and_remove_idr(fsn_mark, group);\n}"
  },
  {
    "function_name": "inotify_handle_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "65-121",
    "snippet": "int inotify_handle_event(struct fsnotify_group *group,\n\t\t\t struct inode *inode,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t u32 mask, void *data, int data_type,\n\t\t\t const unsigned char *file_name, u32 cookie)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tstruct inotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\tint ret;\n\tint len = 0;\n\tint alloc_len = sizeof(struct inotify_event_info);\n\n\tBUG_ON(vfsmount_mark);\n\n\tif ((inode_mark->mask & FS_EXCL_UNLINK) &&\n\t    (data_type == FSNOTIFY_EVENT_PATH)) {\n\t\tstruct path *path = data;\n\n\t\tif (d_unlinked(path->dentry))\n\t\t\treturn 0;\n\t}\n\tif (file_name) {\n\t\tlen = strlen(file_name);\n\t\talloc_len += len + 1;\n\t}\n\n\tpr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode,\n\t\t mask);\n\n\ti_mark = container_of(inode_mark, struct inotify_inode_mark,\n\t\t\t      fsn_mark);\n\n\tevent = kmalloc(alloc_len, GFP_KERNEL);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tfsnotify_init_event(fsn_event, inode, mask);\n\tevent->wd = i_mark->wd;\n\tevent->sync_cookie = cookie;\n\tevent->name_len = len;\n\tif (len)\n\t\tstrcpy(event->name, file_name);\n\n\tret = fsnotify_add_event(group, fsn_event, inotify_merge);\n\tif (ret) {\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n\n\tif (inode_mark->mask & IN_ONESHOT)\n\t\tfsnotify_destroy_mark(inode_mark, group);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "inode_mark",
            "group"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "198-204",
          "snippet": "void fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tfsnotify_destroy_mark_locked(mark, group);\n\tmutex_unlock(&group->mark_mutex);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tfsnotify_destroy_mark_locked(mark, group);\n\tmutex_unlock(&group->mark_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_event",
          "args": [
            "group",
            "fsn_event"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "70-79",
          "snippet": "void fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_event",
          "args": [
            "group",
            "fsn_event",
            "inotify_merge"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "87-126",
          "snippet": "int fsnotify_add_event(struct fsnotify_group *group,\n\t\t       struct fsnotify_event *event,\n\t\t       int (*merge)(struct list_head *,\n\t\t\t\t    struct fsnotify_event *))\n{\n\tint ret = 0;\n\tstruct list_head *list = &group->notification_list;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tmutex_lock(&group->notification_mutex);\n\n\tif (group->q_len >= group->max_events) {\n\t\tret = 2;\n\t\t/* Queue overflow event only if it isn't already queued */\n\t\tif (!list_empty(&group->overflow_event->list)) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tevent = group->overflow_event;\n\t\tgoto queue;\n\t}\n\n\tif (!list_empty(list) && merge) {\n\t\tret = merge(list, event);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nqueue:\n\tgroup->q_len++;\n\tlist_add_tail(&event->list, list);\n\tmutex_unlock(&group->notification_mutex);\n\n\twake_up(&group->notification_waitq);\n\tkill_fasync(&group->fsn_fa, SIGIO, POLL_IN);\n\treturn ret;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_event(struct fsnotify_group *group,\n\t\t       struct fsnotify_event *event,\n\t\t       int (*merge)(struct list_head *,\n\t\t\t\t    struct fsnotify_event *))\n{\n\tint ret = 0;\n\tstruct list_head *list = &group->notification_list;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tmutex_lock(&group->notification_mutex);\n\n\tif (group->q_len >= group->max_events) {\n\t\tret = 2;\n\t\t/* Queue overflow event only if it isn't already queued */\n\t\tif (!list_empty(&group->overflow_event->list)) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tevent = group->overflow_event;\n\t\tgoto queue;\n\t}\n\n\tif (!list_empty(list) && merge) {\n\t\tret = merge(list, event);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nqueue:\n\tgroup->q_len++;\n\tlist_add_tail(&event->list, list);\n\tmutex_unlock(&group->notification_mutex);\n\n\twake_up(&group->notification_waitq);\n\tkill_fasync(&group->fsn_fa, SIGIO, POLL_IN);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "event->name",
            "file_name"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_init_event",
          "args": [
            "fsn_event",
            "inode",
            "mask"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_init_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "207-213",
          "snippet": "void fsnotify_init_event(struct fsnotify_event *event, struct inode *inode,\n\t\t\t u32 mask)\n{\n\tINIT_LIST_HEAD(&event->list);\n\tevent->inode = inode;\n\tevent->mask = mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_init_event(struct fsnotify_event *event, struct inode *inode,\n\t\t\t u32 mask)\n{\n\tINIT_LIST_HEAD(&event->list);\n\tevent->inode = inode;\n\tevent->mask = mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "alloc_len",
            "GFP_KERNEL"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode_mark",
            "structinotify_inode_mark",
            "fsn_mark"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p inode=%p mask=%x\\n\"",
            "__func__",
            "group",
            "inode",
            "mask"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "file_name"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "path->dentry"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vfsmount_mark"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nint inotify_handle_event(struct fsnotify_group *group,\n\t\t\t struct inode *inode,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t u32 mask, void *data, int data_type,\n\t\t\t const unsigned char *file_name, u32 cookie)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tstruct inotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\tint ret;\n\tint len = 0;\n\tint alloc_len = sizeof(struct inotify_event_info);\n\n\tBUG_ON(vfsmount_mark);\n\n\tif ((inode_mark->mask & FS_EXCL_UNLINK) &&\n\t    (data_type == FSNOTIFY_EVENT_PATH)) {\n\t\tstruct path *path = data;\n\n\t\tif (d_unlinked(path->dentry))\n\t\t\treturn 0;\n\t}\n\tif (file_name) {\n\t\tlen = strlen(file_name);\n\t\talloc_len += len + 1;\n\t}\n\n\tpr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode,\n\t\t mask);\n\n\ti_mark = container_of(inode_mark, struct inotify_inode_mark,\n\t\t\t      fsn_mark);\n\n\tevent = kmalloc(alloc_len, GFP_KERNEL);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tfsnotify_init_event(fsn_event, inode, mask);\n\tevent->wd = i_mark->wd;\n\tevent->sync_cookie = cookie;\n\tevent->name_len = len;\n\tif (len)\n\t\tstrcpy(event->name, file_name);\n\n\tret = fsnotify_add_event(group, fsn_event, inotify_merge);\n\tif (ret) {\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n\n\tif (inode_mark->mask & IN_ONESHOT)\n\t\tfsnotify_destroy_mark(inode_mark, group);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "inotify_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "56-63",
    "snippet": "static int inotify_merge(struct list_head *list,\n\t\t\t  struct fsnotify_event *event)\n{\n\tstruct fsnotify_event *last_event;\n\n\tlast_event = list_entry(list->prev, struct fsnotify_event, list);\n\treturn event_compare(last_event, event);\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_compare",
          "args": [
            "last_event",
            "event"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "event_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
          "lines": "39-54",
          "snippet": "static bool event_compare(struct fsnotify_event *old_fsn,\n\t\t\t  struct fsnotify_event *new_fsn)\n{\n\tstruct inotify_event_info *old, *new;\n\n\tif (old_fsn->mask & FS_IN_IGNORED)\n\t\treturn false;\n\told = INOTIFY_E(old_fsn);\n\tnew = INOTIFY_E(new_fsn);\n\tif ((old_fsn->mask == new_fsn->mask) &&\n\t    (old_fsn->inode == new_fsn->inode) &&\n\t    (old->name_len == new->name_len) &&\n\t    (!old->name_len || !strcmp(old->name, new->name)))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"inotify.h\"",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h> /* kmem_* */",
            "#include <linux/path.h> /* struct path */",
            "#include <linux/inotify.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/dcache.h> /* d_unlinked */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic bool event_compare(struct fsnotify_event *old_fsn,\n\t\t\t  struct fsnotify_event *new_fsn)\n{\n\tstruct inotify_event_info *old, *new;\n\n\tif (old_fsn->mask & FS_IN_IGNORED)\n\t\treturn false;\n\told = INOTIFY_E(old_fsn);\n\tnew = INOTIFY_E(new_fsn);\n\tif ((old_fsn->mask == new_fsn->mask) &&\n\t    (old_fsn->inode == new_fsn->inode) &&\n\t    (old->name_len == new->name_len) &&\n\t    (!old->name_len || !strcmp(old->name, new->name)))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->prev",
            "structfsnotify_event",
            "list"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic int inotify_merge(struct list_head *list,\n\t\t\t  struct fsnotify_event *event)\n{\n\tstruct fsnotify_event *last_event;\n\n\tlast_event = list_entry(list->prev, struct fsnotify_event, list);\n\treturn event_compare(last_event, event);\n}"
  },
  {
    "function_name": "event_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
    "lines": "39-54",
    "snippet": "static bool event_compare(struct fsnotify_event *old_fsn,\n\t\t\t  struct fsnotify_event *new_fsn)\n{\n\tstruct inotify_event_info *old, *new;\n\n\tif (old_fsn->mask & FS_IN_IGNORED)\n\t\treturn false;\n\told = INOTIFY_E(old_fsn);\n\tnew = INOTIFY_E(new_fsn);\n\tif ((old_fsn->mask == new_fsn->mask) &&\n\t    (old_fsn->inode == new_fsn->inode) &&\n\t    (old->name_len == new->name_len) &&\n\t    (!old->name_len || !strcmp(old->name, new->name)))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"inotify.h\"",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h> /* kmem_* */",
      "#include <linux/path.h> /* struct path */",
      "#include <linux/inotify.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/dcache.h> /* d_unlinked */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "old->name",
            "new->name"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOTIFY_E",
          "args": [
            "new_fsn"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "INOTIFY_E",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify.h",
          "lines": "18-21",
          "snippet": "static inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}",
          "includes": [
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/inotify.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nstatic bool event_compare(struct fsnotify_event *old_fsn,\n\t\t\t  struct fsnotify_event *new_fsn)\n{\n\tstruct inotify_event_info *old, *new;\n\n\tif (old_fsn->mask & FS_IN_IGNORED)\n\t\treturn false;\n\told = INOTIFY_E(old_fsn);\n\tnew = INOTIFY_E(new_fsn);\n\tif ((old_fsn->mask == new_fsn->mask) &&\n\t    (old_fsn->inode == new_fsn->inode) &&\n\t    (old->name_len == new->name_len) &&\n\t    (!old->name_len || !strcmp(old->name, new->name)))\n\t\treturn true;\n\treturn false;\n}"
  }
]