[
  {
    "function_name": "fat_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "306-353",
    "snippet": "int fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\tsector_t last_block;\n\tint cluster, offset;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlast_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= last_block) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * ->mmu_private can access on only allocation path.\n\t\t * (caller must hold ->i_mutex)\n\t\t */\n\t\tlast_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*phys = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_clus_to_blknr",
          "args": [
            "sbi",
            "cluster"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "fat_clus_to_blknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "219-223",
          "snippet": "static inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_bmap_cluster",
          "args": [
            "inode",
            "cluster"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "fat_bmap_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "287-304",
          "snippet": "static int fat_bmap_cluster(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret, fclus, dclus;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, cluster, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == FAT_ENT_EOF) {\n\t\tfat_fs_error(sb, \"%s: request beyond EOF (i_pos %lld)\",\n\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\treturn -EIO;\n\t}\n\treturn dclus;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int fat_bmap_cluster(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret, fclus, dclus;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, cluster, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == FAT_ENT_EOF) {\n\t\tfat_fs_error(sb, \"%s: request beyond EOF (i_pos %lld)\",\n\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\treturn -EIO;\n\t}\n\treturn dclus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_bmap(struct inode *inode, sector_t sector, sector_t *phys,\n\t     unsigned long *mapped_blocks, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tconst unsigned long blocksize = sb->s_blocksize;\n\tconst unsigned char blocksize_bits = sb->s_blocksize_bits;\n\tsector_t last_block;\n\tint cluster, offset;\n\n\t*phys = 0;\n\t*mapped_blocks = 0;\n\tif ((sbi->fat_bits != 32) && (inode->i_ino == MSDOS_ROOT_INO)) {\n\t\tif (sector < (sbi->dir_entries >> sbi->dir_per_block_bits)) {\n\t\t\t*phys = sector + sbi->dir_start;\n\t\t\t*mapped_blocks = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlast_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;\n\tif (sector >= last_block) {\n\t\tif (!create)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * ->mmu_private can access on only allocation path.\n\t\t * (caller must hold ->i_mutex)\n\t\t */\n\t\tlast_block = (MSDOS_I(inode)->mmu_private + (blocksize - 1))\n\t\t\t>> blocksize_bits;\n\t\tif (sector >= last_block)\n\t\t\treturn 0;\n\t}\n\n\tcluster = sector >> (sbi->cluster_bits - sb->s_blocksize_bits);\n\toffset  = sector & (sbi->sec_per_clus - 1);\n\tcluster = fat_bmap_cluster(inode, cluster);\n\tif (cluster < 0)\n\t\treturn cluster;\n\telse if (cluster) {\n\t\t*phys = fat_clus_to_blknr(sbi, cluster) + offset;\n\t\t*mapped_blocks = sbi->sec_per_clus - offset;\n\t\tif (*mapped_blocks > last_block - sector)\n\t\t\t*mapped_blocks = last_block - sector;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_bmap_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "287-304",
    "snippet": "static int fat_bmap_cluster(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret, fclus, dclus;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, cluster, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == FAT_ENT_EOF) {\n\t\tfat_fs_error(sb, \"%s: request beyond EOF (i_pos %lld)\",\n\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\treturn -EIO;\n\t}\n\treturn dclus;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"%s: request beyond EOF (i_pos %lld)\"",
            "__func__",
            "MSDOS_I(inode)->i_pos"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_cluster",
          "args": [
            "inode",
            "cluster",
            "&fclus",
            "&dclus"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "226-285",
          "snippet": "int fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int fat_bmap_cluster(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret, fclus, dclus;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tret = fat_get_cluster(inode, cluster, &fclus, &dclus);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == FAT_ENT_EOF) {\n\t\tfat_fs_error(sb, \"%s: request beyond EOF (i_pos %lld)\",\n\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\treturn -EIO;\n\t}\n\treturn dclus;\n}"
  },
  {
    "function_name": "fat_get_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "226-285",
    "snippet": "int fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatent_brelse",
          "args": [
            "&fatent"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_add",
          "args": [
            "inode",
            "&cid"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "135-181",
          "snippet": "static void fat_cache_add(struct inode *inode, struct fat_cache_id *new)\n{\n\tstruct fat_cache *cache, *tmp;\n\n\tif (new->fcluster == -1) /* dummy cache */\n\t\treturn;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tif (new->id != FAT_CACHE_VALID &&\n\t    new->id != MSDOS_I(inode)->cache_valid_id)\n\t\tgoto out;\t/* this cache was invalidated */\n\n\tcache = fat_cache_merge(inode, new);\n\tif (cache == NULL) {\n\t\tif (MSDOS_I(inode)->nr_caches < fat_max_cache(inode)) {\n\t\t\tMSDOS_I(inode)->nr_caches++;\n\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\t\t\ttmp = fat_cache_alloc(inode);\n\t\t\tif (!tmp) {\n\t\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\tcache = fat_cache_merge(inode, new);\n\t\t\tif (cache != NULL) {\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tfat_cache_free(tmp);\n\t\t\t\tgoto out_update_lru;\n\t\t\t}\n\t\t\tcache = tmp;\n\t\t} else {\n\t\t\tstruct list_head *p = MSDOS_I(inode)->cache_lru.prev;\n\t\t\tcache = list_entry(p, struct fat_cache, cache_list);\n\t\t}\n\t\tcache->fcluster = new->fcluster;\n\t\tcache->dcluster = new->dcluster;\n\t\tcache->nr_contig = new->nr_contig;\n\t}\nout_update_lru:\n\tfat_cache_update_lru(inode, cache);\nout:\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void fat_cache_add(struct inode *inode, struct fat_cache_id *new)\n{\n\tstruct fat_cache *cache, *tmp;\n\n\tif (new->fcluster == -1) /* dummy cache */\n\t\treturn;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tif (new->id != FAT_CACHE_VALID &&\n\t    new->id != MSDOS_I(inode)->cache_valid_id)\n\t\tgoto out;\t/* this cache was invalidated */\n\n\tcache = fat_cache_merge(inode, new);\n\tif (cache == NULL) {\n\t\tif (MSDOS_I(inode)->nr_caches < fat_max_cache(inode)) {\n\t\t\tMSDOS_I(inode)->nr_caches++;\n\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\t\t\ttmp = fat_cache_alloc(inode);\n\t\t\tif (!tmp) {\n\t\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\tcache = fat_cache_merge(inode, new);\n\t\t\tif (cache != NULL) {\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tfat_cache_free(tmp);\n\t\t\t\tgoto out_update_lru;\n\t\t\t}\n\t\t\tcache = tmp;\n\t\t} else {\n\t\t\tstruct list_head *p = MSDOS_I(inode)->cache_lru.prev;\n\t\t\tcache = list_entry(p, struct fat_cache, cache_list);\n\t\t}\n\t\tcache->fcluster = new->fcluster;\n\t\tcache->dcluster = new->dcluster;\n\t\tcache->nr_contig = new->nr_contig;\n\t}\nout_update_lru:\n\tfat_cache_update_lru(inode, cache);\nout:\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_init",
          "args": [
            "&cid",
            "*fclus",
            "*dclus"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "218-224",
          "snippet": "static inline void cache_init(struct fat_cache_id *cid, int fclus, int dclus)\n{\n\tcid->id = FAT_CACHE_VALID;\n\tcid->fcluster = fclus;\n\tcid->dcluster = dclus;\n\tcid->nr_contig = 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void cache_init(struct fat_cache_id *cid, int fclus, int dclus)\n{\n\tcid->id = FAT_CACHE_VALID;\n\tcid->fcluster = fclus;\n\tcid->dcluster = dclus;\n\tcid->nr_contig = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_contiguous",
          "args": [
            "&cid",
            "*dclus"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "cache_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "212-216",
          "snippet": "static inline int cache_contiguous(struct fat_cache_id *cid, int dclus)\n{\n\tcid->nr_contig++;\n\treturn ((cid->dcluster + cid->nr_contig) == dclus);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int cache_contiguous(struct fat_cache_id *cid, int dclus)\n{\n\tcid->nr_contig++;\n\treturn ((cid->dcluster + cid->nr_contig) == dclus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error_ratelimit",
          "args": [
            "sb",
            "\"%s: invalid cluster chain (i_pos %lld)\"",
            "__func__",
            "MSDOS_I(inode)->i_pos"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_read",
          "args": [
            "inode",
            "&fatent",
            "*dclus"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_reada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "639-650",
          "snippet": "static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error_ratelimit",
          "args": [
            "sb",
            "\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\"",
            "__func__",
            "MSDOS_I(inode)->i_pos"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatent_init",
          "args": [
            "&fatent"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "324-331",
          "snippet": "static inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_lookup",
          "args": [
            "inode",
            "cluster",
            "&cid",
            "fclus",
            "dclus"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "81-116",
          "snippet": "static int fat_cache_lookup(struct inode *inode, int fclus,\n\t\t\t    struct fat_cache_id *cid,\n\t\t\t    int *cached_fclus, int *cached_dclus)\n{\n\tstatic struct fat_cache nohit = { .fcluster = 0, };\n\n\tstruct fat_cache *hit = &nohit, *p;\n\tint offset = -1;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the cache of \"fclus\" or nearest cache. */\n\t\tif (p->fcluster <= fclus && hit->fcluster < p->fcluster) {\n\t\t\thit = p;\n\t\t\tif ((hit->fcluster + hit->nr_contig) < fclus) {\n\t\t\t\toffset = hit->nr_contig;\n\t\t\t} else {\n\t\t\t\toffset = fclus - hit->fcluster;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hit != &nohit) {\n\t\tfat_cache_update_lru(inode, hit);\n\n\t\tcid->id = MSDOS_I(inode)->cache_valid_id;\n\t\tcid->nr_contig = hit->nr_contig;\n\t\tcid->fcluster = hit->fcluster;\n\t\tcid->dcluster = hit->dcluster;\n\t\t*cached_fclus = cid->fcluster + offset;\n\t\t*cached_dclus = cid->dcluster + offset;\n\t}\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\treturn offset;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int fat_cache_lookup(struct inode *inode, int fclus,\n\t\t\t    struct fat_cache_id *cid,\n\t\t\t    int *cached_fclus, int *cached_dclus)\n{\n\tstatic struct fat_cache nohit = { .fcluster = 0, };\n\n\tstruct fat_cache *hit = &nohit, *p;\n\tint offset = -1;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the cache of \"fclus\" or nearest cache. */\n\t\tif (p->fcluster <= fclus && hit->fcluster < p->fcluster) {\n\t\t\thit = p;\n\t\t\tif ((hit->fcluster + hit->nr_contig) < fclus) {\n\t\t\t\toffset = hit->nr_contig;\n\t\t\t} else {\n\t\t\t\toffset = fclus - hit->fcluster;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hit != &nohit) {\n\t\tfat_cache_update_lru(inode, hit);\n\n\t\tcid->id = MSDOS_I(inode)->cache_valid_id;\n\t\tcid->nr_contig = hit->nr_contig;\n\t\tcid->fcluster = hit->fcluster;\n\t\tcid->dcluster = hit->dcluster;\n\t\t*cached_fclus = cid->fcluster + offset;\n\t\t*cached_dclus = cid->dcluster + offset;\n\t}\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "MSDOS_I(inode)->i_start == 0"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}"
  },
  {
    "function_name": "cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "218-224",
    "snippet": "static inline void cache_init(struct fat_cache_id *cid, int fclus, int dclus)\n{\n\tcid->id = FAT_CACHE_VALID;\n\tcid->fcluster = fclus;\n\tcid->dcluster = dclus;\n\tcid->nr_contig = 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void cache_init(struct fat_cache_id *cid, int fclus, int dclus)\n{\n\tcid->id = FAT_CACHE_VALID;\n\tcid->fcluster = fclus;\n\tcid->dcluster = dclus;\n\tcid->nr_contig = 0;\n}"
  },
  {
    "function_name": "cache_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "212-216",
    "snippet": "static inline int cache_contiguous(struct fat_cache_id *cid, int dclus)\n{\n\tcid->nr_contig++;\n\treturn ((cid->dcluster + cid->nr_contig) == dclus);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int cache_contiguous(struct fat_cache_id *cid, int dclus)\n{\n\tcid->nr_contig++;\n\treturn ((cid->dcluster + cid->nr_contig) == dclus);\n}"
  },
  {
    "function_name": "fat_cache_inval_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "205-210",
    "snippet": "void fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&MSDOS_I(inode)->cache_lru_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fat_cache_inval_inode",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_cache_inval_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "187-203",
          "snippet": "static void __fat_cache_inval_inode(struct inode *inode)\n{\n\tstruct msdos_inode_info *i = MSDOS_I(inode);\n\tstruct fat_cache *cache;\n\n\twhile (!list_empty(&i->cache_lru)) {\n\t\tcache = list_entry(i->cache_lru.next,\n\t\t\t\t   struct fat_cache, cache_list);\n\t\tlist_del_init(&cache->cache_list);\n\t\ti->nr_caches--;\n\t\tfat_cache_free(cache);\n\t}\n\t/* Update. The copy of caches before this id is discarded. */\n\ti->cache_valid_id++;\n\tif (i->cache_valid_id == FAT_CACHE_VALID)\n\t\ti->cache_valid_id++;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void __fat_cache_inval_inode(struct inode *inode)\n{\n\tstruct msdos_inode_info *i = MSDOS_I(inode);\n\tstruct fat_cache *cache;\n\n\twhile (!list_empty(&i->cache_lru)) {\n\t\tcache = list_entry(i->cache_lru.next,\n\t\t\t\t   struct fat_cache, cache_list);\n\t\tlist_del_init(&cache->cache_list);\n\t\ti->nr_caches--;\n\t\tfat_cache_free(cache);\n\t}\n\t/* Update. The copy of caches before this id is discarded. */\n\ti->cache_valid_id++;\n\tif (i->cache_valid_id == FAT_CACHE_VALID)\n\t\ti->cache_valid_id++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&MSDOS_I(inode)->cache_lru_lock"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}"
  },
  {
    "function_name": "__fat_cache_inval_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "187-203",
    "snippet": "static void __fat_cache_inval_inode(struct inode *inode)\n{\n\tstruct msdos_inode_info *i = MSDOS_I(inode);\n\tstruct fat_cache *cache;\n\n\twhile (!list_empty(&i->cache_lru)) {\n\t\tcache = list_entry(i->cache_lru.next,\n\t\t\t\t   struct fat_cache, cache_list);\n\t\tlist_del_init(&cache->cache_list);\n\t\ti->nr_caches--;\n\t\tfat_cache_free(cache);\n\t}\n\t/* Update. The copy of caches before this id is discarded. */\n\ti->cache_valid_id++;\n\tif (i->cache_valid_id == FAT_CACHE_VALID)\n\t\ti->cache_valid_id++;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_cache_free",
          "args": [
            "cache"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "68-72",
          "snippet": "static inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_cache_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nstatic inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cache->cache_list"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "i->cache_lru.next",
            "structfat_cache",
            "cache_list"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&i->cache_lru"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void __fat_cache_inval_inode(struct inode *inode)\n{\n\tstruct msdos_inode_info *i = MSDOS_I(inode);\n\tstruct fat_cache *cache;\n\n\twhile (!list_empty(&i->cache_lru)) {\n\t\tcache = list_entry(i->cache_lru.next,\n\t\t\t\t   struct fat_cache, cache_list);\n\t\tlist_del_init(&cache->cache_list);\n\t\ti->nr_caches--;\n\t\tfat_cache_free(cache);\n\t}\n\t/* Update. The copy of caches before this id is discarded. */\n\ti->cache_valid_id++;\n\tif (i->cache_valid_id == FAT_CACHE_VALID)\n\t\ti->cache_valid_id++;\n}"
  },
  {
    "function_name": "fat_cache_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "135-181",
    "snippet": "static void fat_cache_add(struct inode *inode, struct fat_cache_id *new)\n{\n\tstruct fat_cache *cache, *tmp;\n\n\tif (new->fcluster == -1) /* dummy cache */\n\t\treturn;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tif (new->id != FAT_CACHE_VALID &&\n\t    new->id != MSDOS_I(inode)->cache_valid_id)\n\t\tgoto out;\t/* this cache was invalidated */\n\n\tcache = fat_cache_merge(inode, new);\n\tif (cache == NULL) {\n\t\tif (MSDOS_I(inode)->nr_caches < fat_max_cache(inode)) {\n\t\t\tMSDOS_I(inode)->nr_caches++;\n\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\t\t\ttmp = fat_cache_alloc(inode);\n\t\t\tif (!tmp) {\n\t\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\tcache = fat_cache_merge(inode, new);\n\t\t\tif (cache != NULL) {\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tfat_cache_free(tmp);\n\t\t\t\tgoto out_update_lru;\n\t\t\t}\n\t\t\tcache = tmp;\n\t\t} else {\n\t\t\tstruct list_head *p = MSDOS_I(inode)->cache_lru.prev;\n\t\t\tcache = list_entry(p, struct fat_cache, cache_list);\n\t\t}\n\t\tcache->fcluster = new->fcluster;\n\t\tcache->dcluster = new->dcluster;\n\t\tcache->nr_contig = new->nr_contig;\n\t}\nout_update_lru:\n\tfat_cache_update_lru(inode, cache);\nout:\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&MSDOS_I(inode)->cache_lru_lock"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_update_lru",
          "args": [
            "inode",
            "cache"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_update_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "74-79",
          "snippet": "static inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structfat_cache",
            "cache_list"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_cache_free",
          "args": [
            "tmp"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "68-72",
          "snippet": "static inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_cache_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nstatic inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_merge",
          "args": [
            "inode",
            "new"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "118-133",
          "snippet": "static struct fat_cache *fat_cache_merge(struct inode *inode,\n\t\t\t\t\t struct fat_cache_id *new)\n{\n\tstruct fat_cache *p;\n\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the same part as \"new\" in cluster-chain. */\n\t\tif (p->fcluster == new->fcluster) {\n\t\t\tBUG_ON(p->dcluster != new->dcluster);\n\t\t\tif (new->nr_contig > p->nr_contig)\n\t\t\t\tp->nr_contig = new->nr_contig;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct fat_cache *fat_cache_merge(struct inode *inode,\n\t\t\t\t\t struct fat_cache_id *new)\n{\n\tstruct fat_cache *p;\n\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the same part as \"new\" in cluster-chain. */\n\t\tif (p->fcluster == new->fcluster) {\n\t\t\tBUG_ON(p->dcluster != new->dcluster);\n\t\t\tif (new->nr_contig > p->nr_contig)\n\t\t\t\tp->nr_contig = new->nr_contig;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&MSDOS_I(inode)->cache_lru_lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_alloc",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "63-66",
          "snippet": "static inline struct fat_cache *fat_cache_alloc(struct inode *inode)\n{\n\treturn kmem_cache_alloc(fat_cache_cachep, GFP_NOFS);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fat_cache_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nstatic inline struct fat_cache *fat_cache_alloc(struct inode *inode)\n{\n\treturn kmem_cache_alloc(fat_cache_cachep, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_max_cache",
          "args": [
            "inode"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fat_max_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "33-36",
          "snippet": "static inline int fat_max_cache(struct inode *inode)\n{\n\treturn FAT_MAX_CACHE;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_CACHE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define FAT_MAX_CACHE\t8\n\nstatic inline int fat_max_cache(struct inode *inode)\n{\n\treturn FAT_MAX_CACHE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void fat_cache_add(struct inode *inode, struct fat_cache_id *new)\n{\n\tstruct fat_cache *cache, *tmp;\n\n\tif (new->fcluster == -1) /* dummy cache */\n\t\treturn;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tif (new->id != FAT_CACHE_VALID &&\n\t    new->id != MSDOS_I(inode)->cache_valid_id)\n\t\tgoto out;\t/* this cache was invalidated */\n\n\tcache = fat_cache_merge(inode, new);\n\tif (cache == NULL) {\n\t\tif (MSDOS_I(inode)->nr_caches < fat_max_cache(inode)) {\n\t\t\tMSDOS_I(inode)->nr_caches++;\n\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\t\t\ttmp = fat_cache_alloc(inode);\n\t\t\tif (!tmp) {\n\t\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t\t\tcache = fat_cache_merge(inode, new);\n\t\t\tif (cache != NULL) {\n\t\t\t\tMSDOS_I(inode)->nr_caches--;\n\t\t\t\tfat_cache_free(tmp);\n\t\t\t\tgoto out_update_lru;\n\t\t\t}\n\t\t\tcache = tmp;\n\t\t} else {\n\t\t\tstruct list_head *p = MSDOS_I(inode)->cache_lru.prev;\n\t\t\tcache = list_entry(p, struct fat_cache, cache_list);\n\t\t}\n\t\tcache->fcluster = new->fcluster;\n\t\tcache->dcluster = new->dcluster;\n\t\tcache->nr_contig = new->nr_contig;\n\t}\nout_update_lru:\n\tfat_cache_update_lru(inode, cache);\nout:\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}"
  },
  {
    "function_name": "fat_cache_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "118-133",
    "snippet": "static struct fat_cache *fat_cache_merge(struct inode *inode,\n\t\t\t\t\t struct fat_cache_id *new)\n{\n\tstruct fat_cache *p;\n\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the same part as \"new\" in cluster-chain. */\n\t\tif (p->fcluster == new->fcluster) {\n\t\t\tBUG_ON(p->dcluster != new->dcluster);\n\t\t\tif (new->nr_contig > p->nr_contig)\n\t\t\t\tp->nr_contig = new->nr_contig;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p->dcluster != new->dcluster"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&MSDOS_I(inode)->cache_lru",
            "cache_list"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct fat_cache *fat_cache_merge(struct inode *inode,\n\t\t\t\t\t struct fat_cache_id *new)\n{\n\tstruct fat_cache *p;\n\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the same part as \"new\" in cluster-chain. */\n\t\tif (p->fcluster == new->fcluster) {\n\t\t\tBUG_ON(p->dcluster != new->dcluster);\n\t\t\tif (new->nr_contig > p->nr_contig)\n\t\t\t\tp->nr_contig = new->nr_contig;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "fat_cache_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "81-116",
    "snippet": "static int fat_cache_lookup(struct inode *inode, int fclus,\n\t\t\t    struct fat_cache_id *cid,\n\t\t\t    int *cached_fclus, int *cached_dclus)\n{\n\tstatic struct fat_cache nohit = { .fcluster = 0, };\n\n\tstruct fat_cache *hit = &nohit, *p;\n\tint offset = -1;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the cache of \"fclus\" or nearest cache. */\n\t\tif (p->fcluster <= fclus && hit->fcluster < p->fcluster) {\n\t\t\thit = p;\n\t\t\tif ((hit->fcluster + hit->nr_contig) < fclus) {\n\t\t\t\toffset = hit->nr_contig;\n\t\t\t} else {\n\t\t\t\toffset = fclus - hit->fcluster;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hit != &nohit) {\n\t\tfat_cache_update_lru(inode, hit);\n\n\t\tcid->id = MSDOS_I(inode)->cache_valid_id;\n\t\tcid->nr_contig = hit->nr_contig;\n\t\tcid->fcluster = hit->fcluster;\n\t\tcid->dcluster = hit->dcluster;\n\t\t*cached_fclus = cid->fcluster + offset;\n\t\t*cached_dclus = cid->dcluster + offset;\n\t}\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\treturn offset;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&MSDOS_I(inode)->cache_lru_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cache_update_lru",
          "args": [
            "inode",
            "hit"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_update_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "74-79",
          "snippet": "static inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&MSDOS_I(inode)->cache_lru",
            "cache_list"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&MSDOS_I(inode)->cache_lru_lock"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int fat_cache_lookup(struct inode *inode, int fclus,\n\t\t\t    struct fat_cache_id *cid,\n\t\t\t    int *cached_fclus, int *cached_dclus)\n{\n\tstatic struct fat_cache nohit = { .fcluster = 0, };\n\n\tstruct fat_cache *hit = &nohit, *p;\n\tint offset = -1;\n\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\tlist_for_each_entry(p, &MSDOS_I(inode)->cache_lru, cache_list) {\n\t\t/* Find the cache of \"fclus\" or nearest cache. */\n\t\tif (p->fcluster <= fclus && hit->fcluster < p->fcluster) {\n\t\t\thit = p;\n\t\t\tif ((hit->fcluster + hit->nr_contig) < fclus) {\n\t\t\t\toffset = hit->nr_contig;\n\t\t\t} else {\n\t\t\t\toffset = fclus - hit->fcluster;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (hit != &nohit) {\n\t\tfat_cache_update_lru(inode, hit);\n\n\t\tcid->id = MSDOS_I(inode)->cache_valid_id;\n\t\tcid->nr_contig = hit->nr_contig;\n\t\tcid->fcluster = hit->fcluster;\n\t\tcid->dcluster = hit->dcluster;\n\t\t*cached_fclus = cid->fcluster + offset;\n\t\t*cached_dclus = cid->dcluster + offset;\n\t}\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n\n\treturn offset;\n}"
  },
  {
    "function_name": "fat_cache_update_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "74-79",
    "snippet": "static inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&cache->cache_list",
            "&MSDOS_I(inode)->cache_lru"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void fat_cache_update_lru(struct inode *inode,\n\t\t\t\t\tstruct fat_cache *cache)\n{\n\tif (MSDOS_I(inode)->cache_lru.next != &cache->cache_list)\n\t\tlist_move(&cache->cache_list, &MSDOS_I(inode)->cache_lru);\n}"
  },
  {
    "function_name": "fat_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "68-72",
    "snippet": "static inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_cache_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fat_cache_cachep",
            "cache"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cache->cache_list)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cache->cache_list"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nstatic inline void fat_cache_free(struct fat_cache *cache)\n{\n\tBUG_ON(!list_empty(&cache->cache_list));\n\tkmem_cache_free(fat_cache_cachep, cache);\n}"
  },
  {
    "function_name": "fat_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "63-66",
    "snippet": "static inline struct fat_cache *fat_cache_alloc(struct inode *inode)\n{\n\treturn kmem_cache_alloc(fat_cache_cachep, GFP_NOFS);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_cache_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fat_cache_cachep",
            "GFP_NOFS"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nstatic inline struct fat_cache *fat_cache_alloc(struct inode *inode)\n{\n\treturn kmem_cache_alloc(fat_cache_cachep, GFP_NOFS);\n}"
  },
  {
    "function_name": "fat_cache_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "58-61",
    "snippet": "void fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_cache_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fat_cache_cachep"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nvoid fat_cache_destroy(void)\n{\n\tkmem_cache_destroy(fat_cache_cachep);\n}"
  },
  {
    "function_name": "fat_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "47-56",
    "snippet": "int __init fat_cache_init(void)\n{\n\tfat_cache_cachep = kmem_cache_create(\"fat_cache\",\n\t\t\t\tsizeof(struct fat_cache),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (fat_cache_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fat_cache_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"fat_cache\"",
            "sizeof(struct fat_cache)",
            "0",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD",
            "init_once"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fat_cache_cachep;\n\nint __init fat_cache_init(void)\n{\n\tfat_cache_cachep = kmem_cache_create(\"fat_cache\",\n\t\t\t\tsizeof(struct fat_cache),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (fat_cache_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "40-45",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct fat_cache *cache = (struct fat_cache *)foo;\n\n\tINIT_LIST_HEAD(&cache->cache_list);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->cache_list"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct fat_cache *cache = (struct fat_cache *)foo;\n\n\tINIT_LIST_HEAD(&cache->cache_list);\n}"
  },
  {
    "function_name": "fat_max_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
    "lines": "33-36",
    "snippet": "static inline int fat_max_cache(struct inode *inode)\n{\n\treturn FAT_MAX_CACHE;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define FAT_MAX_CACHE\t8"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define FAT_MAX_CACHE\t8\n\nstatic inline int fat_max_cache(struct inode *inode)\n{\n\treturn FAT_MAX_CACHE;\n}"
  }
]