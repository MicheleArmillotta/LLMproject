[
  {
    "function_name": "squashfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "481-484",
    "snippet": "static void squashfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, squashfs_i_callback);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "squashfs_i_callback"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic void squashfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, squashfs_i_callback);\n}"
  },
  {
    "function_name": "squashfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "475-479",
    "snippet": "static void squashfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(squashfs_inode_cachep, squashfs_i(inode));\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *squashfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "squashfs_inode_cachep",
            "squashfs_i(inode)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
          "lines": "475-479",
          "snippet": "static void squashfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(squashfs_inode_cachep, squashfs_i(inode));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic void squashfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(squashfs_inode_cachep, squashfs_i(inode));\n}"
  },
  {
    "function_name": "squashfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "466-472",
    "snippet": "static struct inode *squashfs_alloc_inode(struct super_block *sb)\n{\n\tstruct squashfs_inode_info *ei =\n\t\tkmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);\n\n\treturn ei ? &ei->vfs_inode : NULL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *squashfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "squashfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic struct inode *squashfs_alloc_inode(struct super_block *sb)\n{\n\tstruct squashfs_inode_info *ei =\n\t\tkmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);\n\n\treturn ei ? &ei->vfs_inode : NULL;\n}"
  },
  {
    "function_name": "exit_squashfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "459-463",
    "snippet": "static void __exit exit_squashfs_fs(void)\n{\n\tunregister_filesystem(&squashfs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type squashfs_fs_type;",
      "static struct file_system_type squashfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"squashfs\",\n\t.mount = squashfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
          "lines": "429-437",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/magic.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *squashfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&squashfs_fs_type"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type squashfs_fs_type;\nstatic struct file_system_type squashfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"squashfs\",\n\t.mount = squashfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV\n};\n\nstatic void __exit exit_squashfs_fs(void)\n{\n\tunregister_filesystem(&squashfs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_squashfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "440-456",
    "snippet": "static int __init init_squashfs_fs(void)\n{\n\tint err = init_inodecache();\n\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&squashfs_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tpr_info(\"version 4.0 (2009/01/31) Phillip Lougher\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type squashfs_fs_type;",
      "static struct file_system_type squashfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"squashfs\",\n\t.mount = squashfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"version 4.0 (2009/01/31) Phillip Lougher\\n\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
          "lines": "429-437",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/magic.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *squashfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&squashfs_fs_type"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
          "lines": "419-426",
          "snippet": "static int __init init_inodecache(void)\n{\n\tsquashfs_inode_cachep = kmem_cache_create(\"squashfs_inode_cache\",\n\t\tsizeof(struct squashfs_inode_info), 0,\n\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);\n\n\treturn squashfs_inode_cachep ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/magic.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *squashfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tsquashfs_inode_cachep = kmem_cache_create(\"squashfs_inode_cache\",\n\t\tsizeof(struct squashfs_inode_info), 0,\n\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);\n\n\treturn squashfs_inode_cachep ? 0 : -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type squashfs_fs_type;\nstatic struct file_system_type squashfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"squashfs\",\n\t.mount = squashfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV\n};\n\nstatic int __init init_squashfs_fs(void)\n{\n\tint err = init_inodecache();\n\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&squashfs_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tpr_info(\"version 4.0 (2009/01/31) Phillip Lougher\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "429-437",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *squashfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "squashfs_inode_cachep"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "419-426",
    "snippet": "static int __init init_inodecache(void)\n{\n\tsquashfs_inode_cachep = kmem_cache_create(\"squashfs_inode_cache\",\n\t\tsizeof(struct squashfs_inode_info), 0,\n\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);\n\n\treturn squashfs_inode_cachep ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *squashfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"squashfs_inode_cache\"",
            "sizeof(struct squashfs_inode_info)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT",
            "init_once"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tsquashfs_inode_cachep = kmem_cache_create(\"squashfs_inode_cache\",\n\t\tsizeof(struct squashfs_inode_info), 0,\n\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);\n\n\treturn squashfs_inode_cachep ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "411-416",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct squashfs_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct squashfs_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "squashfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "401-405",
    "snippet": "static struct dentry *squashfs_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, squashfs_fill_super);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "squashfs_fill_super"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct dentry *squashfs_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, squashfs_fill_super);\n}"
  },
  {
    "function_name": "squashfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "382-398",
    "snippet": "static void squashfs_put_super(struct super_block *sb)\n{\n\tif (sb->s_fs_info) {\n\t\tstruct squashfs_sb_info *sbi = sb->s_fs_info;\n\t\tsquashfs_cache_delete(sbi->block_cache);\n\t\tsquashfs_cache_delete(sbi->fragment_cache);\n\t\tsquashfs_cache_delete(sbi->read_page);\n\t\tsquashfs_decompressor_destroy(sbi);\n\t\tkfree(sbi->id_table);\n\t\tkfree(sbi->fragment_index);\n\t\tkfree(sbi->meta_index);\n\t\tkfree(sbi->inode_lookup_table);\n\t\tkfree(sbi->xattr_id_table);\n\t\tkfree(sb->s_fs_info);\n\t\tsb->s_fs_info = NULL;\n\t}\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->xattr_id_table"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->inode_lookup_table"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->meta_index"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->fragment_index"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->id_table"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_decompressor_destroy",
          "args": [
            "sbi"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_decompressor_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi_percpu.c",
          "lines": "61-75",
          "snippet": "void squashfs_decompressor_destroy(struct squashfs_sb_info *msblk)\n{\n\tstruct squashfs_stream __percpu *percpu =\n\t\t\t(struct squashfs_stream __percpu *) msblk->stream;\n\tstruct squashfs_stream *stream;\n\tint cpu;\n\n\tif (msblk->stream) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t\t}\n\t\tfree_percpu(percpu);\n\t}\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid squashfs_decompressor_destroy(struct squashfs_sb_info *msblk)\n{\n\tstruct squashfs_stream __percpu *percpu =\n\t\t\t(struct squashfs_stream __percpu *) msblk->stream;\n\tstruct squashfs_stream *stream;\n\tint cpu;\n\n\tif (msblk->stream) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t\t}\n\t\tfree_percpu(percpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_cache_delete",
          "args": [
            "sbi->read_page"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "210-228",
          "snippet": "void squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic void squashfs_put_super(struct super_block *sb)\n{\n\tif (sb->s_fs_info) {\n\t\tstruct squashfs_sb_info *sbi = sb->s_fs_info;\n\t\tsquashfs_cache_delete(sbi->block_cache);\n\t\tsquashfs_cache_delete(sbi->fragment_cache);\n\t\tsquashfs_cache_delete(sbi->read_page);\n\t\tsquashfs_decompressor_destroy(sbi);\n\t\tkfree(sbi->id_table);\n\t\tkfree(sbi->fragment_index);\n\t\tkfree(sbi->meta_index);\n\t\tkfree(sbi->inode_lookup_table);\n\t\tkfree(sbi->xattr_id_table);\n\t\tkfree(sb->s_fs_info);\n\t\tsb->s_fs_info = NULL;\n\t}\n}"
  },
  {
    "function_name": "squashfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "374-379",
    "snippet": "static int squashfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}"
  },
  {
    "function_name": "squashfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "353-371",
    "snippet": "static int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;\n\tu64 id = huge_encode_dev(dentry->d_sb->s_bdev->bd_dev);\n\n\tTRACE(\"Entered squashfs_statfs\\n\");\n\n\tbuf->f_type = SQUASHFS_MAGIC;\n\tbuf->f_bsize = msblk->block_size;\n\tbuf->f_blocks = ((msblk->bytes_used - 1) >> msblk->block_log) + 1;\n\tbuf->f_bfree = buf->f_bavail = 0;\n\tbuf->f_files = msblk->inodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = SQUASHFS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_statfs\\n\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "dentry->d_sb->s_bdev->bd_dev"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;\n\tu64 id = huge_encode_dev(dentry->d_sb->s_bdev->bd_dev);\n\n\tTRACE(\"Entered squashfs_statfs\\n\");\n\n\tbuf->f_type = SQUASHFS_MAGIC;\n\tbuf->f_bsize = msblk->block_size;\n\tbuf->f_blocks = ((msblk->bytes_used - 1) >> msblk->block_log) + 1;\n\tbuf->f_bfree = buf->f_bavail = 0;\n\tbuf->f_files = msblk->inodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = SQUASHFS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "squashfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "79-350",
    "snippet": "static int squashfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct squashfs_sb_info *msblk;\n\tstruct squashfs_super_block *sblk = NULL;\n\tchar b[BDEVNAME_SIZE];\n\tstruct inode *root;\n\tlong long root_inode;\n\tunsigned short flags;\n\tunsigned int fragments;\n\tu64 lookup_table_start, xattr_id_table_start, next_table;\n\tint err;\n\n\tTRACE(\"Entered squashfs_fill_superblock\\n\");\n\n\tsb->s_fs_info = kzalloc(sizeof(*msblk), GFP_KERNEL);\n\tif (sb->s_fs_info == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_sb_info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmsblk = sb->s_fs_info;\n\n\tmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);\n\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);\n\n\tmutex_init(&msblk->meta_index_mutex);\n\n\t/*\n\t * msblk->bytes_used is checked in squashfs_read_table to ensure reads\n\t * are not beyond filesystem end.  But as we're using\n\t * squashfs_read_table here to read the superblock (including the value\n\t * of bytes_used) we need to set it to an initial sensible dummy value\n\t */\n\tmsblk->bytes_used = sizeof(*sblk);\n\tsblk = squashfs_read_table(sb, SQUASHFS_START, sizeof(*sblk));\n\n\tif (IS_ERR(sblk)) {\n\t\tERROR(\"unable to read squashfs_super_block\\n\");\n\t\terr = PTR_ERR(sblk);\n\t\tsblk = NULL;\n\t\tgoto failed_mount;\n\t}\n\n\terr = -EINVAL;\n\n\t/* Check it is a SQUASHFS superblock */\n\tsb->s_magic = le32_to_cpu(sblk->s_magic);\n\tif (sb->s_magic != SQUASHFS_MAGIC) {\n\t\tif (!silent)\n\t\t\tERROR(\"Can't find a SQUASHFS superblock on %s\\n\",\n\t\t\t\t\t\tbdevname(sb->s_bdev, b));\n\t\tgoto failed_mount;\n\t}\n\n\t/* Check the MAJOR & MINOR versions and lookup compression type */\n\tmsblk->decompressor = supported_squashfs_filesystem(\n\t\t\tle16_to_cpu(sblk->s_major),\n\t\t\tle16_to_cpu(sblk->s_minor),\n\t\t\tle16_to_cpu(sblk->compression));\n\tif (msblk->decompressor == NULL)\n\t\tgoto failed_mount;\n\n\t/* Check the filesystem does not extend beyond the end of the\n\t   block device */\n\tmsblk->bytes_used = le64_to_cpu(sblk->bytes_used);\n\tif (msblk->bytes_used < 0 || msblk->bytes_used >\n\t\t\ti_size_read(sb->s_bdev->bd_inode))\n\t\tgoto failed_mount;\n\n\t/* Check block size for sanity */\n\tmsblk->block_size = le32_to_cpu(sblk->block_size);\n\tif (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)\n\t\tgoto failed_mount;\n\n\t/*\n\t * Check the system page size is not larger than the filesystem\n\t * block size (by default 128K).  This is currently not supported.\n\t */\n\tif (PAGE_CACHE_SIZE > msblk->block_size) {\n\t\tERROR(\"Page size > filesystem block size (%d).  This is \"\n\t\t\t\"currently not supported!\\n\", msblk->block_size);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Check block log for sanity */\n\tmsblk->block_log = le16_to_cpu(sblk->block_log);\n\tif (msblk->block_log > SQUASHFS_FILE_MAX_LOG)\n\t\tgoto failed_mount;\n\n\t/* Check that block_size and block_log match */\n\tif (msblk->block_size != (1 << msblk->block_log))\n\t\tgoto failed_mount;\n\n\t/* Check the root inode for sanity */\n\troot_inode = le64_to_cpu(sblk->root_inode);\n\tif (SQUASHFS_INODE_OFFSET(root_inode) > SQUASHFS_METADATA_SIZE)\n\t\tgoto failed_mount;\n\n\tmsblk->inode_table = le64_to_cpu(sblk->inode_table_start);\n\tmsblk->directory_table = le64_to_cpu(sblk->directory_table_start);\n\tmsblk->inodes = le32_to_cpu(sblk->inodes);\n\tflags = le16_to_cpu(sblk->flags);\n\n\tTRACE(\"Found valid superblock on %s\\n\", bdevname(sb->s_bdev, b));\n\tTRACE(\"Inodes are %scompressed\\n\", SQUASHFS_UNCOMPRESSED_INODES(flags)\n\t\t\t\t? \"un\" : \"\");\n\tTRACE(\"Data is %scompressed\\n\", SQUASHFS_UNCOMPRESSED_DATA(flags)\n\t\t\t\t? \"un\" : \"\");\n\tTRACE(\"Filesystem size %lld bytes\\n\", msblk->bytes_used);\n\tTRACE(\"Block size %d\\n\", msblk->block_size);\n\tTRACE(\"Number of inodes %d\\n\", msblk->inodes);\n\tTRACE(\"Number of fragments %d\\n\", le32_to_cpu(sblk->fragments));\n\tTRACE(\"Number of ids %d\\n\", le16_to_cpu(sblk->no_ids));\n\tTRACE(\"sblk->inode_table_start %llx\\n\", msblk->inode_table);\n\tTRACE(\"sblk->directory_table_start %llx\\n\", msblk->directory_table);\n\tTRACE(\"sblk->fragment_table_start %llx\\n\",\n\t\t(u64) le64_to_cpu(sblk->fragment_table_start));\n\tTRACE(\"sblk->id_table_start %llx\\n\",\n\t\t(u64) le64_to_cpu(sblk->id_table_start));\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_flags |= MS_RDONLY;\n\tsb->s_op = &squashfs_super_ops;\n\n\terr = -ENOMEM;\n\n\tmsblk->block_cache = squashfs_cache_init(\"metadata\",\n\t\t\tSQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);\n\tif (msblk->block_cache == NULL)\n\t\tgoto failed_mount;\n\n\t/* Allocate read_page block */\n\tmsblk->read_page = squashfs_cache_init(\"data\",\n\t\tsquashfs_max_decompressors(), msblk->block_size);\n\tif (msblk->read_page == NULL) {\n\t\tERROR(\"Failed to allocate read_page block\\n\");\n\t\tgoto failed_mount;\n\t}\n\n\tmsblk->stream = squashfs_decompressor_setup(sb, flags);\n\tif (IS_ERR(msblk->stream)) {\n\t\terr = PTR_ERR(msblk->stream);\n\t\tmsblk->stream = NULL;\n\t\tgoto failed_mount;\n\t}\n\n\t/* Handle xattrs */\n\tsb->s_xattr = squashfs_xattr_handlers;\n\txattr_id_table_start = le64_to_cpu(sblk->xattr_id_table_start);\n\tif (xattr_id_table_start == SQUASHFS_INVALID_BLK) {\n\t\tnext_table = msblk->bytes_used;\n\t\tgoto allocate_id_index_table;\n\t}\n\n\t/* Allocate and read xattr id lookup table */\n\tmsblk->xattr_id_table = squashfs_read_xattr_id_table(sb,\n\t\txattr_id_table_start, &msblk->xattr_table, &msblk->xattr_ids);\n\tif (IS_ERR(msblk->xattr_id_table)) {\n\t\tERROR(\"unable to read xattr id index table\\n\");\n\t\terr = PTR_ERR(msblk->xattr_id_table);\n\t\tmsblk->xattr_id_table = NULL;\n\t\tif (err != -ENOTSUPP)\n\t\t\tgoto failed_mount;\n\t}\n\tnext_table = msblk->xattr_table;\n\nallocate_id_index_table:\n\t/* Allocate and read id index table */\n\tmsblk->id_table = squashfs_read_id_index_table(sb,\n\t\tle64_to_cpu(sblk->id_table_start), next_table,\n\t\tle16_to_cpu(sblk->no_ids));\n\tif (IS_ERR(msblk->id_table)) {\n\t\tERROR(\"unable to read id index table\\n\");\n\t\terr = PTR_ERR(msblk->id_table);\n\t\tmsblk->id_table = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->id_table[0]);\n\n\t/* Handle inode lookup table */\n\tlookup_table_start = le64_to_cpu(sblk->lookup_table_start);\n\tif (lookup_table_start == SQUASHFS_INVALID_BLK)\n\t\tgoto handle_fragments;\n\n\t/* Allocate and read inode lookup table */\n\tmsblk->inode_lookup_table = squashfs_read_inode_lookup_table(sb,\n\t\tlookup_table_start, next_table, msblk->inodes);\n\tif (IS_ERR(msblk->inode_lookup_table)) {\n\t\tERROR(\"unable to read inode lookup table\\n\");\n\t\terr = PTR_ERR(msblk->inode_lookup_table);\n\t\tmsblk->inode_lookup_table = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->inode_lookup_table[0]);\n\n\tsb->s_export_op = &squashfs_export_ops;\n\nhandle_fragments:\n\tfragments = le32_to_cpu(sblk->fragments);\n\tif (fragments == 0)\n\t\tgoto check_directory_table;\n\n\tmsblk->fragment_cache = squashfs_cache_init(\"fragment\",\n\t\tSQUASHFS_CACHED_FRAGMENTS, msblk->block_size);\n\tif (msblk->fragment_cache == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\t/* Allocate and read fragment index table */\n\tmsblk->fragment_index = squashfs_read_fragment_index_table(sb,\n\t\tle64_to_cpu(sblk->fragment_table_start), next_table, fragments);\n\tif (IS_ERR(msblk->fragment_index)) {\n\t\tERROR(\"unable to read fragment index table\\n\");\n\t\terr = PTR_ERR(msblk->fragment_index);\n\t\tmsblk->fragment_index = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->fragment_index[0]);\n\ncheck_directory_table:\n\t/* Sanity check directory_table */\n\tif (msblk->directory_table > next_table) {\n\t\terr = -EINVAL;\n\t\tgoto failed_mount;\n\t}\n\n\t/* Sanity check inode_table */\n\tif (msblk->inode_table >= msblk->directory_table) {\n\t\terr = -EINVAL;\n\t\tgoto failed_mount;\n\t}\n\n\t/* allocate root */\n\troot = new_inode(sb);\n\tif (!root) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\terr = squashfs_read_inode(root, root_inode);\n\tif (err) {\n\t\tmake_bad_inode(root);\n\t\tiput(root);\n\t\tgoto failed_mount;\n\t}\n\tinsert_inode_hash(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (sb->s_root == NULL) {\n\t\tERROR(\"Root inode create failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tTRACE(\"Leaving squashfs_fill_super\\n\");\n\tkfree(sblk);\n\treturn 0;\n\nfailed_mount:\n\tsquashfs_cache_delete(msblk->block_cache);\n\tsquashfs_cache_delete(msblk->fragment_cache);\n\tsquashfs_cache_delete(msblk->read_page);\n\tsquashfs_decompressor_destroy(msblk);\n\tkfree(msblk->inode_lookup_table);\n\tkfree(msblk->fragment_index);\n\tkfree(msblk->id_table);\n\tkfree(msblk->xattr_id_table);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n\tkfree(sblk);\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations squashfs_super_ops;",
      "static const struct super_operations squashfs_super_ops = {\n\t.alloc_inode = squashfs_alloc_inode,\n\t.destroy_inode = squashfs_destroy_inode,\n\t.statfs = squashfs_statfs,\n\t.put_super = squashfs_put_super,\n\t.remount_fs = squashfs_remount\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sblk"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msblk->xattr_id_table"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msblk->id_table"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msblk->fragment_index"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msblk->inode_lookup_table"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_decompressor_destroy",
          "args": [
            "msblk"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_decompressor_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi_percpu.c",
          "lines": "61-75",
          "snippet": "void squashfs_decompressor_destroy(struct squashfs_sb_info *msblk)\n{\n\tstruct squashfs_stream __percpu *percpu =\n\t\t\t(struct squashfs_stream __percpu *) msblk->stream;\n\tstruct squashfs_stream *stream;\n\tint cpu;\n\n\tif (msblk->stream) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t\t}\n\t\tfree_percpu(percpu);\n\t}\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid squashfs_decompressor_destroy(struct squashfs_sb_info *msblk)\n{\n\tstruct squashfs_stream __percpu *percpu =\n\t\t\t(struct squashfs_stream __percpu *) msblk->stream;\n\tstruct squashfs_stream *stream;\n\tint cpu;\n\n\tif (msblk->stream) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstream = per_cpu_ptr(percpu, cpu);\n\t\t\tmsblk->decompressor->free(stream->stream);\n\t\t}\n\t\tfree_percpu(percpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_cache_delete",
          "args": [
            "msblk->read_page"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "210-228",
          "snippet": "void squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sblk"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Leaving squashfs_fill_super\\n\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Root inode create failed\\n\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "root"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "root"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_inode",
          "args": [
            "root",
            "root_inode"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
          "lines": "112-422",
          "snippet": "int squashfs_read_inode(struct inode *inode, long long ino)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 block = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\tint err, type, offset = SQUASHFS_INODE_OFFSET(ino);\n\tunion squashfs_inode squashfs_ino;\n\tstruct squashfs_base_inode *sqshb_ino = &squashfs_ino.base;\n\tint xattr_id = SQUASHFS_INVALID_XATTR;\n\n\tTRACE(\"Entered squashfs_read_inode\\n\");\n\n\t/*\n\t * Read inode base common to all inode types.\n\t */\n\terr = squashfs_read_metadata(sb, sqshb_ino, &block,\n\t\t\t\t&offset, sizeof(*sqshb_ino));\n\tif (err < 0)\n\t\tgoto failed_read;\n\n\terr = squashfs_new_inode(sb, inode, sqshb_ino);\n\tif (err)\n\t\tgoto failed_read;\n\n\tblock = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\toffset = SQUASHFS_INODE_OFFSET(ino);\n\n\ttype = le16_to_cpu(sqshb_ino->inode_type);\n\tswitch (type) {\n\tcase SQUASHFS_REG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_reg_inode *sqsh_ino = &squashfs_ino.reg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = ((inode->i_size - 1) >> 9) + 1;\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LREG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_lreg_inode *sqsh_ino = &squashfs_ino.lreg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le64_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = (inode->i_size -\n\t\t\t\tle64_to_cpu(sqsh_ino->sparse) + 511) >> 9;\n\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le64_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_DIR_TYPE: {\n\t\tstruct squashfs_dir_inode *sqsh_ino = &squashfs_ino.dir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le16_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_cnt = 0;\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Directory inode %x:%x, start_block %llx, offset %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LDIR_TYPE: {\n\t\tstruct squashfs_ldir_inode *sqsh_ino = &squashfs_ino.ldir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_start = block;\n\t\tsquashfs_i(inode)->dir_idx_offset = offset;\n\t\tsquashfs_i(inode)->dir_idx_cnt = le16_to_cpu(sqsh_ino->i_count);\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_SYMLINK_TYPE:\n\tcase SQUASHFS_LSYMLINK_TYPE: {\n\t\tstruct squashfs_symlink_inode *sqsh_ino = &squashfs_ino.symlink;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->symlink_size);\n\t\tinode->i_op = &squashfs_symlink_inode_ops;\n\t\tinode->i_data.a_ops = &squashfs_symlink_aops;\n\t\tinode->i_mode |= S_IFLNK;\n\t\tsquashfs_i(inode)->start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\n\t\tif (type == SQUASHFS_LSYMLINK_TYPE) {\n\t\t\t__le32 xattr;\n\n\t\t\terr = squashfs_read_metadata(sb, NULL, &block,\n\t\t\t\t\t\t&offset, inode->i_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\terr = squashfs_read_metadata(sb, &xattr, &block,\n\t\t\t\t\t\t&offset, sizeof(xattr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\txattr_id = le32_to_cpu(xattr);\n\t\t}\n\n\t\tTRACE(\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tblock, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_BLKDEV_TYPE:\n\tcase SQUASHFS_CHRDEV_TYPE: {\n\t\tstruct squashfs_dev_inode *sqsh_ino = &squashfs_ino.dev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_CHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LBLKDEV_TYPE:\n\tcase SQUASHFS_LCHRDEV_TYPE: {\n\t\tstruct squashfs_ldev_inode *sqsh_ino = &squashfs_ino.ldev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LCHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_FIFO_TYPE:\n\tcase SQUASHFS_SOCKET_TYPE: {\n\t\tstruct squashfs_ipc_inode *sqsh_ino = &squashfs_ino.ipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_FIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LFIFO_TYPE:\n\tcase SQUASHFS_LSOCKET_TYPE: {\n\t\tstruct squashfs_lipc_inode *sqsh_ino = &squashfs_ino.lipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LFIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tERROR(\"Unknown inode type %d in squashfs_iget!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xattr_id != SQUASHFS_INVALID_XATTR && msblk->xattr_id_table) {\n\t\terr = squashfs_xattr_lookup(sb, xattr_id,\n\t\t\t\t\t&squashfs_i(inode)->xattr_count,\n\t\t\t\t\t&squashfs_i(inode)->xattr_size,\n\t\t\t\t\t&squashfs_i(inode)->xattr);\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\t\tinode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)\n\t\t\t\t+ 1;\n\t} else\n\t\tsquashfs_i(inode)->xattr_count = 0;\n\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read inode 0x%llx\\n\", ino);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations squashfs_inode_ops = {\n\t.getxattr = generic_getxattr,\n\t.listxattr = squashfs_listxattr\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nconst struct inode_operations squashfs_inode_ops = {\n\t.getxattr = generic_getxattr,\n\t.listxattr = squashfs_listxattr\n};\n\nint squashfs_read_inode(struct inode *inode, long long ino)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 block = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\tint err, type, offset = SQUASHFS_INODE_OFFSET(ino);\n\tunion squashfs_inode squashfs_ino;\n\tstruct squashfs_base_inode *sqshb_ino = &squashfs_ino.base;\n\tint xattr_id = SQUASHFS_INVALID_XATTR;\n\n\tTRACE(\"Entered squashfs_read_inode\\n\");\n\n\t/*\n\t * Read inode base common to all inode types.\n\t */\n\terr = squashfs_read_metadata(sb, sqshb_ino, &block,\n\t\t\t\t&offset, sizeof(*sqshb_ino));\n\tif (err < 0)\n\t\tgoto failed_read;\n\n\terr = squashfs_new_inode(sb, inode, sqshb_ino);\n\tif (err)\n\t\tgoto failed_read;\n\n\tblock = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\toffset = SQUASHFS_INODE_OFFSET(ino);\n\n\ttype = le16_to_cpu(sqshb_ino->inode_type);\n\tswitch (type) {\n\tcase SQUASHFS_REG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_reg_inode *sqsh_ino = &squashfs_ino.reg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = ((inode->i_size - 1) >> 9) + 1;\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LREG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_lreg_inode *sqsh_ino = &squashfs_ino.lreg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le64_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = (inode->i_size -\n\t\t\t\tle64_to_cpu(sqsh_ino->sparse) + 511) >> 9;\n\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le64_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_DIR_TYPE: {\n\t\tstruct squashfs_dir_inode *sqsh_ino = &squashfs_ino.dir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le16_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_cnt = 0;\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Directory inode %x:%x, start_block %llx, offset %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LDIR_TYPE: {\n\t\tstruct squashfs_ldir_inode *sqsh_ino = &squashfs_ino.ldir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_start = block;\n\t\tsquashfs_i(inode)->dir_idx_offset = offset;\n\t\tsquashfs_i(inode)->dir_idx_cnt = le16_to_cpu(sqsh_ino->i_count);\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_SYMLINK_TYPE:\n\tcase SQUASHFS_LSYMLINK_TYPE: {\n\t\tstruct squashfs_symlink_inode *sqsh_ino = &squashfs_ino.symlink;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->symlink_size);\n\t\tinode->i_op = &squashfs_symlink_inode_ops;\n\t\tinode->i_data.a_ops = &squashfs_symlink_aops;\n\t\tinode->i_mode |= S_IFLNK;\n\t\tsquashfs_i(inode)->start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\n\t\tif (type == SQUASHFS_LSYMLINK_TYPE) {\n\t\t\t__le32 xattr;\n\n\t\t\terr = squashfs_read_metadata(sb, NULL, &block,\n\t\t\t\t\t\t&offset, inode->i_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\terr = squashfs_read_metadata(sb, &xattr, &block,\n\t\t\t\t\t\t&offset, sizeof(xattr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\txattr_id = le32_to_cpu(xattr);\n\t\t}\n\n\t\tTRACE(\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tblock, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_BLKDEV_TYPE:\n\tcase SQUASHFS_CHRDEV_TYPE: {\n\t\tstruct squashfs_dev_inode *sqsh_ino = &squashfs_ino.dev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_CHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LBLKDEV_TYPE:\n\tcase SQUASHFS_LCHRDEV_TYPE: {\n\t\tstruct squashfs_ldev_inode *sqsh_ino = &squashfs_ino.ldev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LCHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_FIFO_TYPE:\n\tcase SQUASHFS_SOCKET_TYPE: {\n\t\tstruct squashfs_ipc_inode *sqsh_ino = &squashfs_ino.ipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_FIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LFIFO_TYPE:\n\tcase SQUASHFS_LSOCKET_TYPE: {\n\t\tstruct squashfs_lipc_inode *sqsh_ino = &squashfs_ino.lipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LFIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tERROR(\"Unknown inode type %d in squashfs_iget!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xattr_id != SQUASHFS_INVALID_XATTR && msblk->xattr_id_table) {\n\t\terr = squashfs_xattr_lookup(sb, xattr_id,\n\t\t\t\t\t&squashfs_i(inode)->xattr_count,\n\t\t\t\t\t&squashfs_i(inode)->xattr_size,\n\t\t\t\t\t&squashfs_i(inode)->xattr);\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\t\tinode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)\n\t\t\t\t+ 1;\n\t} else\n\t\tsquashfs_i(inode)->xattr_count = 0;\n\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read inode 0x%llx\\n\", ino);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "msblk->fragment_index[0]"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msblk->fragment_index"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unable to read fragment index table\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msblk->fragment_index"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_fragment_index_table",
          "args": [
            "sb",
            "le64_to_cpu(sblk->fragment_table_start)",
            "next_table",
            "fragments"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_fragment_index_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/fragment.c",
          "lines": "73-99",
          "snippet": "__le64 *squashfs_read_fragment_index_table(struct super_block *sb,\n\tu64 fragment_table_start, u64 next_table, unsigned int fragments)\n{\n\tunsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(fragments);\n\t__le64 *table;\n\n\t/*\n\t * Sanity check, length bytes should not extend into the next table -\n\t * this check also traps instances where fragment_table_start is\n\t * incorrectly larger than the next table start\n\t */\n\tif (fragment_table_start + length > next_table)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, fragment_table_start, length);\n\n\t/*\n\t * table[0] points to the first fragment table metadata block, this\n\t * should be less than fragment_table_start\n\t */\n\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= fragment_table_start) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n__le64 *squashfs_read_fragment_index_table(struct super_block *sb,\n\tu64 fragment_table_start, u64 next_table, unsigned int fragments)\n{\n\tunsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(fragments);\n\t__le64 *table;\n\n\t/*\n\t * Sanity check, length bytes should not extend into the next table -\n\t * this check also traps instances where fragment_table_start is\n\t * incorrectly larger than the next table start\n\t */\n\tif (fragment_table_start + length > next_table)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, fragment_table_start, length);\n\n\t/*\n\t * table[0] points to the first fragment table metadata block, this\n\t * should be less than fragment_table_start\n\t */\n\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= fragment_table_start) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_cache_init",
          "args": [
            "\"fragment\"",
            "SQUASHFS_CACHED_FRAGMENTS",
            "msblk->block_size"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "236-298",
          "snippet": "struct squashfs_cache *squashfs_cache_init(char *name, int entries,\n\tint block_size)\n{\n\tint i, j;\n\tstruct squashfs_cache *cache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\n\tif (cache == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tcache->entry = kcalloc(entries, sizeof(*(cache->entry)), GFP_KERNEL);\n\tif (cache->entry == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\tgoto cleanup;\n\t}\n\n\tcache->curr_blk = 0;\n\tcache->next_blk = 0;\n\tcache->unused = entries;\n\tcache->entries = entries;\n\tcache->block_size = block_size;\n\tcache->pages = block_size >> PAGE_CACHE_SHIFT;\n\tcache->pages = cache->pages ? cache->pages : 1;\n\tcache->name = name;\n\tcache->num_waiters = 0;\n\tspin_lock_init(&cache->lock);\n\tinit_waitqueue_head(&cache->wait_queue);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct squashfs_cache_entry *entry = &cache->entry[i];\n\n\t\tinit_waitqueue_head(&cache->entry[i].wait_queue);\n\t\tentry->cache = cache;\n\t\tentry->block = SQUASHFS_INVALID_BLK;\n\t\tentry->data = kcalloc(cache->pages, sizeof(void *), GFP_KERNEL);\n\t\tif (entry->data == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tfor (j = 0; j < cache->pages; j++) {\n\t\t\tentry->data[j] = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\t\tif (entry->data[j] == NULL) {\n\t\t\t\tERROR(\"Failed to allocate %s buffer\\n\", name);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tentry->actor = squashfs_page_actor_init(entry->data,\n\t\t\t\t\t\tcache->pages, 0);\n\t\tif (entry->actor == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\treturn cache;\n\ncleanup:\n\tsquashfs_cache_delete(cache);\n\treturn NULL;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache *squashfs_cache_init(char *name, int entries,\n\tint block_size)\n{\n\tint i, j;\n\tstruct squashfs_cache *cache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\n\tif (cache == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tcache->entry = kcalloc(entries, sizeof(*(cache->entry)), GFP_KERNEL);\n\tif (cache->entry == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\tgoto cleanup;\n\t}\n\n\tcache->curr_blk = 0;\n\tcache->next_blk = 0;\n\tcache->unused = entries;\n\tcache->entries = entries;\n\tcache->block_size = block_size;\n\tcache->pages = block_size >> PAGE_CACHE_SHIFT;\n\tcache->pages = cache->pages ? cache->pages : 1;\n\tcache->name = name;\n\tcache->num_waiters = 0;\n\tspin_lock_init(&cache->lock);\n\tinit_waitqueue_head(&cache->wait_queue);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct squashfs_cache_entry *entry = &cache->entry[i];\n\n\t\tinit_waitqueue_head(&cache->entry[i].wait_queue);\n\t\tentry->cache = cache;\n\t\tentry->block = SQUASHFS_INVALID_BLK;\n\t\tentry->data = kcalloc(cache->pages, sizeof(void *), GFP_KERNEL);\n\t\tif (entry->data == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tfor (j = 0; j < cache->pages; j++) {\n\t\t\tentry->data[j] = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\t\t\tif (entry->data[j] == NULL) {\n\t\t\t\tERROR(\"Failed to allocate %s buffer\\n\", name);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tentry->actor = squashfs_page_actor_init(entry->data,\n\t\t\t\t\t\tcache->pages, 0);\n\t\tif (entry->actor == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\treturn cache;\n\ncleanup:\n\tsquashfs_cache_delete(cache);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sblk->fragments"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msblk->inode_lookup_table"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unable to read inode lookup table\\n\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msblk->inode_lookup_table"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_inode_lookup_table",
          "args": [
            "sb",
            "lookup_table_start",
            "next_table",
            "msblk->inodes"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_inode_lookup_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/export.c",
          "lines": "123-156",
          "snippet": "__le64 *squashfs_read_inode_lookup_table(struct super_block *sb,\n\t\tu64 lookup_table_start, u64 next_table, unsigned int inodes)\n{\n\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(inodes);\n\t__le64 *table;\n\n\tTRACE(\"In read_inode_lookup_table, length %d\\n\", length);\n\n\t/* Sanity check values */\n\n\t/* there should always be at least one inode */\n\tif (inodes == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* length bytes should not extend into the next table - this check\n\t * also traps instances where lookup_table_start is incorrectly larger\n\t * than the next table start\n\t */\n\tif (lookup_table_start + length > next_table)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, lookup_table_start, length);\n\n\t/*\n\t * table[0] points to the first inode lookup table metadata block,\n\t * this should be less than lookup_table_start\n\t */\n\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= lookup_table_start) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/dcache.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/dcache.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n__le64 *squashfs_read_inode_lookup_table(struct super_block *sb,\n\t\tu64 lookup_table_start, u64 next_table, unsigned int inodes)\n{\n\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(inodes);\n\t__le64 *table;\n\n\tTRACE(\"In read_inode_lookup_table, length %d\\n\", length);\n\n\t/* Sanity check values */\n\n\t/* there should always be at least one inode */\n\tif (inodes == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* length bytes should not extend into the next table - this check\n\t * also traps instances where lookup_table_start is incorrectly larger\n\t * than the next table start\n\t */\n\tif (lookup_table_start + length > next_table)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, lookup_table_start, length);\n\n\t/*\n\t * table[0] points to the first inode lookup table metadata block,\n\t * this should be less than lookup_table_start\n\t */\n\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= lookup_table_start) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msblk->id_table"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unable to read id index table\\n\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msblk->id_table"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_id_index_table",
          "args": [
            "sb",
            "le64_to_cpu(sblk->id_table_start)",
            "next_table",
            "le16_to_cpu(sblk->no_ids)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_id_index_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/id.c",
          "lines": "68-102",
          "snippet": "__le64 *squashfs_read_id_index_table(struct super_block *sb,\n\t\tu64 id_table_start, u64 next_table, unsigned short no_ids)\n{\n\tunsigned int length = SQUASHFS_ID_BLOCK_BYTES(no_ids);\n\t__le64 *table;\n\n\tTRACE(\"In read_id_index_table, length %d\\n\", length);\n\n\t/* Sanity check values */\n\n\t/* there should always be at least one id */\n\tif (no_ids == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * length bytes should not extend into the next table - this check\n\t * also traps instances where id_table_start is incorrectly larger\n\t * than the next table start\n\t */\n\tif (id_table_start + length > next_table)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, id_table_start, length);\n\n\t/*\n\t * table[0] points to the first id lookup table metadata block, this\n\t * should be less than id_table_start\n\t */\n\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= id_table_start) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n__le64 *squashfs_read_id_index_table(struct super_block *sb,\n\t\tu64 id_table_start, u64 next_table, unsigned short no_ids)\n{\n\tunsigned int length = SQUASHFS_ID_BLOCK_BYTES(no_ids);\n\t__le64 *table;\n\n\tTRACE(\"In read_id_index_table, length %d\\n\", length);\n\n\t/* Sanity check values */\n\n\t/* there should always be at least one id */\n\tif (no_ids == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * length bytes should not extend into the next table - this check\n\t * also traps instances where id_table_start is incorrectly larger\n\t * than the next table start\n\t */\n\tif (id_table_start + length > next_table)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, id_table_start, length);\n\n\t/*\n\t * table[0] points to the first id lookup table metadata block, this\n\t * should be less than id_table_start\n\t */\n\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= id_table_start) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sblk->no_ids"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msblk->xattr_id_table"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unable to read xattr id index table\\n\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msblk->xattr_id_table"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_xattr_id_table",
          "args": [
            "sb",
            "xattr_id_table_start",
            "&msblk->xattr_table",
            "&msblk->xattr_ids"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_xattr_id_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr_id.c",
          "lines": "66-95",
          "snippet": "__le64 *squashfs_read_xattr_id_table(struct super_block *sb, u64 start,\n\t\tu64 *xattr_table_start, int *xattr_ids)\n{\n\tunsigned int len;\n\tstruct squashfs_xattr_id_table *id_table;\n\n\tid_table = squashfs_read_table(sb, start, sizeof(*id_table));\n\tif (IS_ERR(id_table))\n\t\treturn (__le64 *) id_table;\n\n\t*xattr_table_start = le64_to_cpu(id_table->xattr_table_start);\n\t*xattr_ids = le32_to_cpu(id_table->xattr_ids);\n\tkfree(id_table);\n\n\t/* Sanity check values */\n\n\t/* there is always at least one xattr id */\n\tif (*xattr_ids == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* xattr_table should be less than start */\n\tif (*xattr_table_start >= start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = SQUASHFS_XATTR_BLOCK_BYTES(*xattr_ids);\n\n\tTRACE(\"In read_xattr_index_table, length %d\\n\", len);\n\n\treturn squashfs_read_table(sb, start + sizeof(*id_table), len);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n__le64 *squashfs_read_xattr_id_table(struct super_block *sb, u64 start,\n\t\tu64 *xattr_table_start, int *xattr_ids)\n{\n\tunsigned int len;\n\tstruct squashfs_xattr_id_table *id_table;\n\n\tid_table = squashfs_read_table(sb, start, sizeof(*id_table));\n\tif (IS_ERR(id_table))\n\t\treturn (__le64 *) id_table;\n\n\t*xattr_table_start = le64_to_cpu(id_table->xattr_table_start);\n\t*xattr_ids = le32_to_cpu(id_table->xattr_ids);\n\tkfree(id_table);\n\n\t/* Sanity check values */\n\n\t/* there is always at least one xattr id */\n\tif (*xattr_ids == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* xattr_table should be less than start */\n\tif (*xattr_table_start >= start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = SQUASHFS_XATTR_BLOCK_BYTES(*xattr_ids);\n\n\tTRACE(\"In read_xattr_index_table, length %d\\n\", len);\n\n\treturn squashfs_read_table(sb, start + sizeof(*id_table), len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msblk->stream"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msblk->stream"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_decompressor_setup",
          "args": [
            "sb",
            "flags"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_decompressor_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.c",
          "lines": "135-148",
          "snippet": "void *squashfs_decompressor_setup(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *stream, *comp_opts = get_comp_opts(sb, flags);\n\n\tif (IS_ERR(comp_opts))\n\t\treturn comp_opts;\n\n\tstream = squashfs_decompressor_create(msblk, comp_opts);\n\tif (IS_ERR(stream))\n\t\tkfree(comp_opts);\n\n\treturn stream;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nvoid *squashfs_decompressor_setup(struct super_block *sb, unsigned short flags)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tvoid *stream, *comp_opts = get_comp_opts(sb, flags);\n\n\tif (IS_ERR(comp_opts))\n\t\treturn comp_opts;\n\n\tstream = squashfs_decompressor_create(msblk, comp_opts);\n\tif (IS_ERR(stream))\n\t\tkfree(comp_opts);\n\n\treturn stream;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate read_page block\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_max_decompressors",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_max_decompressors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi_percpu.c",
          "lines": "94-97",
          "snippet": "int squashfs_max_decompressors(void)\n{\n\treturn num_possible_cpus();\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint squashfs_max_decompressors(void)\n{\n\treturn num_possible_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"sblk->id_table_start %llx\\n\"",
            "(u64) le64_to_cpu(sblk->id_table_start)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"sblk->fragment_table_start %llx\\n\"",
            "(u64) le64_to_cpu(sblk->fragment_table_start)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"sblk->directory_table_start %llx\\n\"",
            "msblk->directory_table"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"sblk->inode_table_start %llx\\n\"",
            "msblk->inode_table"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Number of ids %d\\n\"",
            "le16_to_cpu(sblk->no_ids)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Number of fragments %d\\n\"",
            "le32_to_cpu(sblk->fragments)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Number of inodes %d\\n\"",
            "msblk->inodes"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Block size %d\\n\"",
            "msblk->block_size"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Filesystem size %lld bytes\\n\"",
            "msblk->bytes_used"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Data is %scompressed\\n\"",
            "SQUASHFS_UNCOMPRESSED_DATA(flags)\n\t\t\t\t? \"un\" : \"\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_UNCOMPRESSED_DATA",
          "args": [
            "flags"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Inodes are %scompressed\\n\"",
            "SQUASHFS_UNCOMPRESSED_INODES(flags)\n\t\t\t\t? \"un\" : \"\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_UNCOMPRESSED_INODES",
          "args": [
            "flags"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Found valid superblock on %s\\n\"",
            "bdevname(sb->s_bdev, b)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "sb->s_bdev",
            "b"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_OFFSET",
          "args": [
            "root_inode"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Page size > filesystem block size (%d).  This is \"\n\t\t\t\"currently not supported!\\n\"",
            "msblk->block_size"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sb->s_bdev->bd_inode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supported_squashfs_filesystem",
          "args": [
            "le16_to_cpu(sblk->s_major)",
            "le16_to_cpu(sblk->s_minor)",
            "le16_to_cpu(sblk->compression)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "supported_squashfs_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
          "lines": "52-76",
          "snippet": "static const struct squashfs_decompressor *supported_squashfs_filesystem(short\n\tmajor, short minor, short id)\n{\n\tconst struct squashfs_decompressor *decompressor;\n\n\tif (major < SQUASHFS_MAJOR) {\n\t\tERROR(\"Major/Minor mismatch, older Squashfs %d.%d \"\n\t\t\t\"filesystems are unsupported\\n\", major, minor);\n\t\treturn NULL;\n\t} else if (major > SQUASHFS_MAJOR || minor > SQUASHFS_MINOR) {\n\t\tERROR(\"Major/Minor mismatch, trying to mount newer \"\n\t\t\t\"%d.%d filesystem\\n\", major, minor);\n\t\tERROR(\"Please update your kernel\\n\");\n\t\treturn NULL;\n\t}\n\n\tdecompressor = squashfs_lookup_decompressor(id);\n\tif (!decompressor->supported) {\n\t\tERROR(\"Filesystem uses \\\"%s\\\" compression. This is not \"\n\t\t\t\"supported\\n\", decompressor->name);\n\t\treturn NULL;\n\t}\n\n\treturn decompressor;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/magic.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic const struct squashfs_decompressor *supported_squashfs_filesystem(short\n\tmajor, short minor, short id)\n{\n\tconst struct squashfs_decompressor *decompressor;\n\n\tif (major < SQUASHFS_MAJOR) {\n\t\tERROR(\"Major/Minor mismatch, older Squashfs %d.%d \"\n\t\t\t\"filesystems are unsupported\\n\", major, minor);\n\t\treturn NULL;\n\t} else if (major > SQUASHFS_MAJOR || minor > SQUASHFS_MINOR) {\n\t\tERROR(\"Major/Minor mismatch, trying to mount newer \"\n\t\t\t\"%d.%d filesystem\\n\", major, minor);\n\t\tERROR(\"Please update your kernel\\n\");\n\t\treturn NULL;\n\t}\n\n\tdecompressor = squashfs_lookup_decompressor(id);\n\tif (!decompressor->supported) {\n\t\tERROR(\"Filesystem uses \\\"%s\\\" compression. This is not \"\n\t\t\t\"supported\\n\", decompressor->name);\n\t\treturn NULL;\n\t}\n\n\treturn decompressor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Can't find a SQUASHFS superblock on %s\\n\"",
            "bdevname(sb->s_bdev, b)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "sb->s_bdev",
            "b"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sblk"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unable to read squashfs_super_block\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sblk"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_table",
          "args": [
            "sb",
            "SQUASHFS_START",
            "sizeof(*sblk)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "416-458",
          "snippet": "void *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~msblk->devblksize"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "SQUASHFS_DEVBLK_SIZE"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate squashfs_sb_info\\n\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*msblk)",
            "GFP_KERNEL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_fill_superblock\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic const struct super_operations squashfs_super_ops;\nstatic const struct super_operations squashfs_super_ops = {\n\t.alloc_inode = squashfs_alloc_inode,\n\t.destroy_inode = squashfs_destroy_inode,\n\t.statfs = squashfs_statfs,\n\t.put_super = squashfs_put_super,\n\t.remount_fs = squashfs_remount\n};\n\nstatic int squashfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct squashfs_sb_info *msblk;\n\tstruct squashfs_super_block *sblk = NULL;\n\tchar b[BDEVNAME_SIZE];\n\tstruct inode *root;\n\tlong long root_inode;\n\tunsigned short flags;\n\tunsigned int fragments;\n\tu64 lookup_table_start, xattr_id_table_start, next_table;\n\tint err;\n\n\tTRACE(\"Entered squashfs_fill_superblock\\n\");\n\n\tsb->s_fs_info = kzalloc(sizeof(*msblk), GFP_KERNEL);\n\tif (sb->s_fs_info == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_sb_info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmsblk = sb->s_fs_info;\n\n\tmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);\n\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);\n\n\tmutex_init(&msblk->meta_index_mutex);\n\n\t/*\n\t * msblk->bytes_used is checked in squashfs_read_table to ensure reads\n\t * are not beyond filesystem end.  But as we're using\n\t * squashfs_read_table here to read the superblock (including the value\n\t * of bytes_used) we need to set it to an initial sensible dummy value\n\t */\n\tmsblk->bytes_used = sizeof(*sblk);\n\tsblk = squashfs_read_table(sb, SQUASHFS_START, sizeof(*sblk));\n\n\tif (IS_ERR(sblk)) {\n\t\tERROR(\"unable to read squashfs_super_block\\n\");\n\t\terr = PTR_ERR(sblk);\n\t\tsblk = NULL;\n\t\tgoto failed_mount;\n\t}\n\n\terr = -EINVAL;\n\n\t/* Check it is a SQUASHFS superblock */\n\tsb->s_magic = le32_to_cpu(sblk->s_magic);\n\tif (sb->s_magic != SQUASHFS_MAGIC) {\n\t\tif (!silent)\n\t\t\tERROR(\"Can't find a SQUASHFS superblock on %s\\n\",\n\t\t\t\t\t\tbdevname(sb->s_bdev, b));\n\t\tgoto failed_mount;\n\t}\n\n\t/* Check the MAJOR & MINOR versions and lookup compression type */\n\tmsblk->decompressor = supported_squashfs_filesystem(\n\t\t\tle16_to_cpu(sblk->s_major),\n\t\t\tle16_to_cpu(sblk->s_minor),\n\t\t\tle16_to_cpu(sblk->compression));\n\tif (msblk->decompressor == NULL)\n\t\tgoto failed_mount;\n\n\t/* Check the filesystem does not extend beyond the end of the\n\t   block device */\n\tmsblk->bytes_used = le64_to_cpu(sblk->bytes_used);\n\tif (msblk->bytes_used < 0 || msblk->bytes_used >\n\t\t\ti_size_read(sb->s_bdev->bd_inode))\n\t\tgoto failed_mount;\n\n\t/* Check block size for sanity */\n\tmsblk->block_size = le32_to_cpu(sblk->block_size);\n\tif (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)\n\t\tgoto failed_mount;\n\n\t/*\n\t * Check the system page size is not larger than the filesystem\n\t * block size (by default 128K).  This is currently not supported.\n\t */\n\tif (PAGE_CACHE_SIZE > msblk->block_size) {\n\t\tERROR(\"Page size > filesystem block size (%d).  This is \"\n\t\t\t\"currently not supported!\\n\", msblk->block_size);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Check block log for sanity */\n\tmsblk->block_log = le16_to_cpu(sblk->block_log);\n\tif (msblk->block_log > SQUASHFS_FILE_MAX_LOG)\n\t\tgoto failed_mount;\n\n\t/* Check that block_size and block_log match */\n\tif (msblk->block_size != (1 << msblk->block_log))\n\t\tgoto failed_mount;\n\n\t/* Check the root inode for sanity */\n\troot_inode = le64_to_cpu(sblk->root_inode);\n\tif (SQUASHFS_INODE_OFFSET(root_inode) > SQUASHFS_METADATA_SIZE)\n\t\tgoto failed_mount;\n\n\tmsblk->inode_table = le64_to_cpu(sblk->inode_table_start);\n\tmsblk->directory_table = le64_to_cpu(sblk->directory_table_start);\n\tmsblk->inodes = le32_to_cpu(sblk->inodes);\n\tflags = le16_to_cpu(sblk->flags);\n\n\tTRACE(\"Found valid superblock on %s\\n\", bdevname(sb->s_bdev, b));\n\tTRACE(\"Inodes are %scompressed\\n\", SQUASHFS_UNCOMPRESSED_INODES(flags)\n\t\t\t\t? \"un\" : \"\");\n\tTRACE(\"Data is %scompressed\\n\", SQUASHFS_UNCOMPRESSED_DATA(flags)\n\t\t\t\t? \"un\" : \"\");\n\tTRACE(\"Filesystem size %lld bytes\\n\", msblk->bytes_used);\n\tTRACE(\"Block size %d\\n\", msblk->block_size);\n\tTRACE(\"Number of inodes %d\\n\", msblk->inodes);\n\tTRACE(\"Number of fragments %d\\n\", le32_to_cpu(sblk->fragments));\n\tTRACE(\"Number of ids %d\\n\", le16_to_cpu(sblk->no_ids));\n\tTRACE(\"sblk->inode_table_start %llx\\n\", msblk->inode_table);\n\tTRACE(\"sblk->directory_table_start %llx\\n\", msblk->directory_table);\n\tTRACE(\"sblk->fragment_table_start %llx\\n\",\n\t\t(u64) le64_to_cpu(sblk->fragment_table_start));\n\tTRACE(\"sblk->id_table_start %llx\\n\",\n\t\t(u64) le64_to_cpu(sblk->id_table_start));\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_flags |= MS_RDONLY;\n\tsb->s_op = &squashfs_super_ops;\n\n\terr = -ENOMEM;\n\n\tmsblk->block_cache = squashfs_cache_init(\"metadata\",\n\t\t\tSQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);\n\tif (msblk->block_cache == NULL)\n\t\tgoto failed_mount;\n\n\t/* Allocate read_page block */\n\tmsblk->read_page = squashfs_cache_init(\"data\",\n\t\tsquashfs_max_decompressors(), msblk->block_size);\n\tif (msblk->read_page == NULL) {\n\t\tERROR(\"Failed to allocate read_page block\\n\");\n\t\tgoto failed_mount;\n\t}\n\n\tmsblk->stream = squashfs_decompressor_setup(sb, flags);\n\tif (IS_ERR(msblk->stream)) {\n\t\terr = PTR_ERR(msblk->stream);\n\t\tmsblk->stream = NULL;\n\t\tgoto failed_mount;\n\t}\n\n\t/* Handle xattrs */\n\tsb->s_xattr = squashfs_xattr_handlers;\n\txattr_id_table_start = le64_to_cpu(sblk->xattr_id_table_start);\n\tif (xattr_id_table_start == SQUASHFS_INVALID_BLK) {\n\t\tnext_table = msblk->bytes_used;\n\t\tgoto allocate_id_index_table;\n\t}\n\n\t/* Allocate and read xattr id lookup table */\n\tmsblk->xattr_id_table = squashfs_read_xattr_id_table(sb,\n\t\txattr_id_table_start, &msblk->xattr_table, &msblk->xattr_ids);\n\tif (IS_ERR(msblk->xattr_id_table)) {\n\t\tERROR(\"unable to read xattr id index table\\n\");\n\t\terr = PTR_ERR(msblk->xattr_id_table);\n\t\tmsblk->xattr_id_table = NULL;\n\t\tif (err != -ENOTSUPP)\n\t\t\tgoto failed_mount;\n\t}\n\tnext_table = msblk->xattr_table;\n\nallocate_id_index_table:\n\t/* Allocate and read id index table */\n\tmsblk->id_table = squashfs_read_id_index_table(sb,\n\t\tle64_to_cpu(sblk->id_table_start), next_table,\n\t\tle16_to_cpu(sblk->no_ids));\n\tif (IS_ERR(msblk->id_table)) {\n\t\tERROR(\"unable to read id index table\\n\");\n\t\terr = PTR_ERR(msblk->id_table);\n\t\tmsblk->id_table = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->id_table[0]);\n\n\t/* Handle inode lookup table */\n\tlookup_table_start = le64_to_cpu(sblk->lookup_table_start);\n\tif (lookup_table_start == SQUASHFS_INVALID_BLK)\n\t\tgoto handle_fragments;\n\n\t/* Allocate and read inode lookup table */\n\tmsblk->inode_lookup_table = squashfs_read_inode_lookup_table(sb,\n\t\tlookup_table_start, next_table, msblk->inodes);\n\tif (IS_ERR(msblk->inode_lookup_table)) {\n\t\tERROR(\"unable to read inode lookup table\\n\");\n\t\terr = PTR_ERR(msblk->inode_lookup_table);\n\t\tmsblk->inode_lookup_table = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->inode_lookup_table[0]);\n\n\tsb->s_export_op = &squashfs_export_ops;\n\nhandle_fragments:\n\tfragments = le32_to_cpu(sblk->fragments);\n\tif (fragments == 0)\n\t\tgoto check_directory_table;\n\n\tmsblk->fragment_cache = squashfs_cache_init(\"fragment\",\n\t\tSQUASHFS_CACHED_FRAGMENTS, msblk->block_size);\n\tif (msblk->fragment_cache == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\t/* Allocate and read fragment index table */\n\tmsblk->fragment_index = squashfs_read_fragment_index_table(sb,\n\t\tle64_to_cpu(sblk->fragment_table_start), next_table, fragments);\n\tif (IS_ERR(msblk->fragment_index)) {\n\t\tERROR(\"unable to read fragment index table\\n\");\n\t\terr = PTR_ERR(msblk->fragment_index);\n\t\tmsblk->fragment_index = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->fragment_index[0]);\n\ncheck_directory_table:\n\t/* Sanity check directory_table */\n\tif (msblk->directory_table > next_table) {\n\t\terr = -EINVAL;\n\t\tgoto failed_mount;\n\t}\n\n\t/* Sanity check inode_table */\n\tif (msblk->inode_table >= msblk->directory_table) {\n\t\terr = -EINVAL;\n\t\tgoto failed_mount;\n\t}\n\n\t/* allocate root */\n\troot = new_inode(sb);\n\tif (!root) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\terr = squashfs_read_inode(root, root_inode);\n\tif (err) {\n\t\tmake_bad_inode(root);\n\t\tiput(root);\n\t\tgoto failed_mount;\n\t}\n\tinsert_inode_hash(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (sb->s_root == NULL) {\n\t\tERROR(\"Root inode create failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tTRACE(\"Leaving squashfs_fill_super\\n\");\n\tkfree(sblk);\n\treturn 0;\n\nfailed_mount:\n\tsquashfs_cache_delete(msblk->block_cache);\n\tsquashfs_cache_delete(msblk->fragment_cache);\n\tsquashfs_cache_delete(msblk->read_page);\n\tsquashfs_decompressor_destroy(msblk);\n\tkfree(msblk->inode_lookup_table);\n\tkfree(msblk->fragment_index);\n\tkfree(msblk->id_table);\n\tkfree(msblk->xattr_id_table);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n\tkfree(sblk);\n\treturn err;\n}"
  },
  {
    "function_name": "supported_squashfs_filesystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/super.c",
    "lines": "52-76",
    "snippet": "static const struct squashfs_decompressor *supported_squashfs_filesystem(short\n\tmajor, short minor, short id)\n{\n\tconst struct squashfs_decompressor *decompressor;\n\n\tif (major < SQUASHFS_MAJOR) {\n\t\tERROR(\"Major/Minor mismatch, older Squashfs %d.%d \"\n\t\t\t\"filesystems are unsupported\\n\", major, minor);\n\t\treturn NULL;\n\t} else if (major > SQUASHFS_MAJOR || minor > SQUASHFS_MINOR) {\n\t\tERROR(\"Major/Minor mismatch, trying to mount newer \"\n\t\t\t\"%d.%d filesystem\\n\", major, minor);\n\t\tERROR(\"Please update your kernel\\n\");\n\t\treturn NULL;\n\t}\n\n\tdecompressor = squashfs_lookup_decompressor(id);\n\tif (!decompressor->supported) {\n\t\tERROR(\"Filesystem uses \\\"%s\\\" compression. This is not \"\n\t\t\t\"supported\\n\", decompressor->name);\n\t\treturn NULL;\n\t}\n\n\treturn decompressor;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/magic.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Filesystem uses \\\"%s\\\" compression. This is not \"\n\t\t\t\"supported\\n\"",
            "decompressor->name"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_lookup_decompressor",
          "args": [
            "id"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_lookup_decompressor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor.c",
          "lines": "82-91",
          "snippet": "const struct squashfs_decompressor *squashfs_lookup_decompressor(int id)\n{\n\tint i;\n\n\tfor (i = 0; decompressor[i]->id; i++)\n\t\tif (id == decompressor[i]->id)\n\t\t\tbreak;\n\n\treturn decompressor[i];\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nstatic const struct squashfs_decompressor *decompressor[] = {\n\t&squashfs_zlib_comp_ops,\n\t&squashfs_lz4_comp_ops,\n\t&squashfs_lzo_comp_ops,\n\t&squashfs_xz_comp_ops,\n\t&squashfs_lzma_unsupported_comp_ops,\n\t&squashfs_unknown_comp_ops\n};\n\nconst struct squashfs_decompressor *squashfs_lookup_decompressor(int id)\n{\n\tint i;\n\n\tfor (i = 0; decompressor[i]->id; i++)\n\t\tif (id == decompressor[i]->id)\n\t\t\tbreak;\n\n\treturn decompressor[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Please update your kernel\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Major/Minor mismatch, trying to mount newer \"\n\t\t\t\"%d.%d filesystem\\n\"",
            "major",
            "minor"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Major/Minor mismatch, older Squashfs %d.%d \"\n\t\t\t\"filesystems are unsupported\\n\"",
            "major",
            "minor"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic const struct squashfs_decompressor *supported_squashfs_filesystem(short\n\tmajor, short minor, short id)\n{\n\tconst struct squashfs_decompressor *decompressor;\n\n\tif (major < SQUASHFS_MAJOR) {\n\t\tERROR(\"Major/Minor mismatch, older Squashfs %d.%d \"\n\t\t\t\"filesystems are unsupported\\n\", major, minor);\n\t\treturn NULL;\n\t} else if (major > SQUASHFS_MAJOR || minor > SQUASHFS_MINOR) {\n\t\tERROR(\"Major/Minor mismatch, trying to mount newer \"\n\t\t\t\"%d.%d filesystem\\n\", major, minor);\n\t\tERROR(\"Please update your kernel\\n\");\n\t\treturn NULL;\n\t}\n\n\tdecompressor = squashfs_lookup_decompressor(id);\n\tif (!decompressor->supported) {\n\t\tERROR(\"Filesystem uses \\\"%s\\\" compression. This is not \"\n\t\t\t\"supported\\n\", decompressor->name);\n\t\treturn NULL;\n\t}\n\n\treturn decompressor;\n}"
  }
]