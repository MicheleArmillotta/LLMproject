[
  {
    "function_name": "make_empty_dir_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
    "lines": "315-346",
    "snippet": "void make_empty_dir_item(char *body, __le32 dirid, __le32 objid,\n\t\t\t __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE - ROUND_UP(strlen(\".\")));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - ROUND_UP(strlen(\"..\")));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body + deh_location(dotdot)",
            "\"..\"",
            "2"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "dotdot"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body + deh_location(dot)",
            "\".\"",
            "1"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "dot"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_visible",
          "args": [
            "dotdot"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "dotdot",
            "deh_location(dot) - ROUND_UP(strlen(\"..\"))"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "strlen(\"..\")"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"..\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "dot"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_offset",
          "args": [
            "dotdot",
            "DOT_DOT_OFFSET"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_visible",
          "args": [
            "dot"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "dot",
            "EMPTY_DIR_SIZE - ROUND_UP(strlen(\".\"))"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "strlen(\".\")"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_offset",
          "args": [
            "dot",
            "DOT_OFFSET"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "body",
            "0",
            "EMPTY_DIR_SIZE"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nvoid make_empty_dir_item(char *body, __le32 dirid, __le32 objid,\n\t\t\t __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE - ROUND_UP(strlen(\".\")));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - ROUND_UP(strlen(\"..\")));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}"
  },
  {
    "function_name": "make_empty_dir_item_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
    "lines": "281-312",
    "snippet": "void make_empty_dir_item_v1(char *body, __le32 dirid, __le32 objid,\n\t\t\t    __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE_V1);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE_V1 - strlen(\".\"));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - strlen(\"..\"));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body + deh_location(dotdot)",
            "\"..\"",
            "2"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "dotdot"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body + deh_location(dot)",
            "\".\"",
            "1"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "dot"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_visible",
          "args": [
            "dotdot"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "dotdot",
            "deh_location(dot) - strlen(\"..\")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"..\""
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "dot"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_offset",
          "args": [
            "dotdot",
            "DOT_DOT_OFFSET"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_visible",
          "args": [
            "dot"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_location",
          "args": [
            "dot",
            "EMPTY_DIR_SIZE_V1 - strlen(\".\")"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_offset",
          "args": [
            "dot",
            "DOT_OFFSET"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "body",
            "0",
            "EMPTY_DIR_SIZE_V1"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nvoid make_empty_dir_item_v1(char *body, __le32 dirid, __le32 objid,\n\t\t\t    __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE_V1);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE_V1 - strlen(\".\"));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - strlen(\"..\"));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}"
  },
  {
    "function_name": "reiserfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
    "lines": "272-275",
    "snippet": "static int reiserfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn reiserfs_readdir_inode(file_inode(file), ctx);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_readdir_inode",
          "args": [
            "file_inode(file)",
            "ctx"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_readdir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
          "lines": "60-270",
          "snippet": "int reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const struct reiserfs_key MIN_KEY;",
            "static int reiserfs_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nextern const struct reiserfs_key MIN_KEY;\nstatic int reiserfs_readdir(struct file *, struct dir_context *);\n\nint reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nstatic int reiserfs_readdir(struct file *, struct dir_context *);\n\nstatic int reiserfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn reiserfs_readdir_inode(file_inode(file), ctx);\n}"
  },
  {
    "function_name": "reiserfs_readdir_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
    "lines": "60-270",
    "snippet": "int reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const struct reiserfs_key MIN_KEY;",
      "static int reiserfs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path_to_entry"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path_to_entry"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&pos_key",
            "le_key_k_offset(KEY_FORMAT_3_5, rkey)"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "KEY_FORMAT_3_5",
            "rkey"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMP_SHORT_KEYS",
          "args": [
            "rkey",
            "&pos_key"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp_le_keys",
          "args": [
            "rkey",
            "&MIN_KEY"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "comp_le_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "131-135",
          "snippet": "inline int comp_le_keys(const struct reiserfs_key *k1,\n\t\t\tconst struct reiserfs_key *k2)\n{\n\treturn memcmp(k1, k2, sizeof(struct reiserfs_key));\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_le_keys(const struct reiserfs_key *k1,\n\t\t\tconst struct reiserfs_key *k2)\n{\n\treturn memcmp(k1, k2, sizeof(struct reiserfs_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rkey",
          "args": [
            "&path_to_entry",
            "inode->i_sb"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "get_rkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "261-309",
          "snippet": "inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not the last one.\n\t\t */\n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t/* Return MAX_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };",
            "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nconst struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\ninline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t\t   const struct super_block *sb)\n{\n\tint position, path_offset = chk_path->path_length;\n\tstruct buffer_head *parent;\n\n\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5030: invalid offset in the path\");\n\n\twhile (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(!buffer_uptodate\n\t\t       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),\n\t\t       \"PAP-5040: parent is not uptodate\");\n\n\t\t/* Parent at the path is not in the tree now. */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent =\n\t\t     PATH_OFFSET_PBUFFER(chk_path, path_offset)))\n\t\t\treturn &MIN_KEY;\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(chk_path,\n\t\t\t\t\t  path_offset)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn &MIN_KEY;\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(chk_path,\n\t\t\t\t\tpath_offset + 1)->b_blocknr)\n\t\t\treturn &MIN_KEY;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent\n\t\t * is not the last one.\n\t\t */\n\t\tif (position != B_NR_ITEMS(parent))\n\t\t\treturn internal_key(parent, position);\n\t}\n\n\t/* Return MAX_KEY if we are in the root of the buffer tree. */\n\tif (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->\n\t    b_blocknr == SB_ROOT_BLOCK(sb))\n\t\treturn &MAX_KEY;\n\treturn &MIN_KEY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path_to_entry"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "local_buf"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "local_buf"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "local_buf",
            "d_reclen",
            "d_ino",
            "DT_UNKNOWN"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "local_buf",
            "d_name",
            "d_reclen"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "local_buf"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path_to_entry"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "d_reclen",
            "GFP_NOFS"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_objectid",
          "args": [
            "deh"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_privroot_deh",
          "args": [
            "inode",
            "deh"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "is_privroot_deh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
          "lines": "53-58",
          "snippet": "static inline bool is_privroot_deh(struct inode *dir, struct reiserfs_de_head *deh)\n{\n\tstruct dentry *privroot = REISERFS_SB(dir->i_sb)->priv_root;\n\treturn (privroot->d_inode &&\n\t        deh->deh_objectid == INODE_PKEY(privroot->d_inode)->k_objectid);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nstatic inline bool is_privroot_deh(struct inode *dir, struct reiserfs_de_head *deh)\n{\n\tstruct dentry *privroot = REISERFS_SB(dir->i_sb)->priv_root;\n\treturn (privroot->d_inode &&\n\t        deh->deh_objectid == INODE_PKEY(privroot->d_inode)->k_objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_MAX_NAME",
          "args": [
            "inode->i_sb->\n\t\t\t\t\t\t      s_blocksize"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "d_name"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_I_DEH_ENTRY_FILE_NAME",
          "args": [
            "bh",
            "ih",
            "deh"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_length",
          "args": [
            "bh",
            "ih",
            "entry_num"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "entry_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2252-2262",
          "snippet": "static inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_visible",
          "args": [
            "deh"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "bh",
            "ih"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_entry_count(ih) < entry_num",
            "\"vs-9010: entry number is too big %d (%d)\"",
            "entry_num",
            "ih_entry_count(ih)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "item_num > B_NR_ITEMS(bh) - 1",
            "\"vs-9005 item_num == %d, item amount == %d\"",
            "item_num",
            "B_NR_ITEMS(bh)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "COMP_SHORT_KEYS(&ih->ih_key, &pos_key)",
            "\"vs-9000: found item %h does not match to dir we readdir %K\"",
            "ih",
            "&pos_key"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMP_SHORT_KEYS",
          "args": [
            "&ih->ih_key",
            "&pos_key"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_ih",
          "args": [
            "&tmp_ih",
            "ih"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_by_entry_key",
          "args": [
            "inode->i_sb",
            "&pos_key",
            "&path_to_entry",
            "&de"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "120-175",
          "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "&pos_key"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&pos_key",
            "inode",
            "ctx->pos ?: DOT_OFFSET",
            "TYPE_DIRENTRY",
            "3"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_check_lock_depth",
          "args": [
            "inode->i_sb",
            "\"readdir\""
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "86-91",
          "snippet": "void reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path_to_entry"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nextern const struct reiserfs_key MIN_KEY;\nstatic int reiserfs_readdir(struct file *, struct dir_context *);\n\nint reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_privroot_deh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
    "lines": "53-58",
    "snippet": "static inline bool is_privroot_deh(struct inode *dir, struct reiserfs_de_head *deh)\n{\n\tstruct dentry *privroot = REISERFS_SB(dir->i_sb)->priv_root;\n\treturn (privroot->d_inode &&\n\t        deh->deh_objectid == INODE_PKEY(privroot->d_inode)->k_objectid);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "privroot->d_inode"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nstatic inline bool is_privroot_deh(struct inode *dir, struct reiserfs_de_head *deh)\n{\n\tstruct dentry *privroot = REISERFS_SB(dir->i_sb)->priv_root;\n\treturn (privroot->d_inode &&\n\t        deh->deh_objectid == INODE_PKEY(privroot->d_inode)->k_objectid);\n}"
  },
  {
    "function_name": "reiserfs_dir_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
    "lines": "31-49",
    "snippet": "static int reiserfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint err;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\treiserfs_write_lock(inode->i_sb);\n\terr = reiserfs_commit_for_inode(inode);\n\treiserfs_write_unlock(inode->i_sb);\n\tmutex_unlock(&inode->i_mutex);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reiserfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_for_inode",
          "args": [
            "inode"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3902-3918",
          "snippet": "int reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t/*\n\t * for the whole inode, assume unset id means it was\n\t * changed in the current transaction.  More conservative\n\t */\n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t/* jl will be updated in __commit_trans_jl */\n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nint reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t/*\n\t * for the whole inode, assume unset id means it was\n\t * changed in the current transaction.  More conservative\n\t */\n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t/* jl will be updated in __commit_trans_jl */\n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nstatic int reiserfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync);\n\nstatic int reiserfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t      int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint err;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\treiserfs_write_lock(inode->i_sb);\n\terr = reiserfs_commit_for_inode(inode);\n\treiserfs_write_unlock(inode->i_sb);\n\tmutex_unlock(&inode->i_mutex);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}"
  }
]