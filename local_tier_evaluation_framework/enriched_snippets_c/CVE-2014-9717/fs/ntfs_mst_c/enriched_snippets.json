[
  {
    "function_name": "post_write_mst_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
    "lines": "179-203",
    "snippet": "void post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}",
    "includes": [
      "#include \"ntfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "b->usa_count"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n\nvoid post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}"
  },
  {
    "function_name": "pre_write_mst_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
    "lines": "123-169",
    "snippet": "int pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tle16 *usa_pos, *data_pos;\n\tu16 usa_ofs, usa_count, usn;\n\tle16 le_usn;\n\n\t/* Sanity check + only fixup if it makes sense. */\n\tif (!b || ntfs_is_baad_record(b->magic) ||\n\t\t\tntfs_is_hole_record(b->magic))\n\t\treturn -EINVAL;\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn -EINVAL;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)((u8*)b + usa_ofs);\n\t/*\n\t * Cyclically increment the update sequence number\n\t * (skipping 0 and -1, i.e. 0xffff).\n\t */\n\tusn = le16_to_cpup(usa_pos) + 1;\n\tif (usn == 0xffff || !usn)\n\t\tusn = 1;\n\tle_usn = cpu_to_le16(usn);\n\t*usa_pos = le_usn;\n\t/* Position in data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment the position in the usa and save the\n\t\t * original data from the data buffer into the usa.\n\t\t */\n\t\t*(++usa_pos) = *data_pos;\n\t\t/* Apply fixup to data. */\n\t\t*data_pos = le_usn;\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "usn"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpup",
          "args": [
            "usa_pos"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_hole_record",
          "args": [
            "b->magic"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_baad_record",
          "args": [
            "b->magic"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n\nint pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tle16 *usa_pos, *data_pos;\n\tu16 usa_ofs, usa_count, usn;\n\tle16 le_usn;\n\n\t/* Sanity check + only fixup if it makes sense. */\n\tif (!b || ntfs_is_baad_record(b->magic) ||\n\t\t\tntfs_is_hole_record(b->magic))\n\t\treturn -EINVAL;\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn -EINVAL;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)((u8*)b + usa_ofs);\n\t/*\n\t * Cyclically increment the update sequence number\n\t * (skipping 0 and -1, i.e. 0xffff).\n\t */\n\tusn = le16_to_cpup(usa_pos) + 1;\n\tif (usn == 0xffff || !usn)\n\t\tusn = 1;\n\tle_usn = cpu_to_le16(usn);\n\t*usa_pos = le_usn;\n\t/* Position in data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment the position in the usa and save the\n\t\t * original data from the data buffer into the usa.\n\t\t */\n\t\t*(++usa_pos) = *data_pos;\n\t\t/* Apply fixup to data. */\n\t\t*data_pos = le_usn;\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "post_read_mst_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
    "lines": "42-100",
    "snippet": "int post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "b->usa_count"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n\nint post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}"
  }
]