[
  {
    "function_name": "dlm_stop_lockspaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "894-916",
    "snippet": "void dlm_stop_lockspaces(void)\n{\n\tstruct dlm_ls *ls;\n\tint count;\n\n restart:\n\tcount = 0;\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (!test_bit(LSFL_RUNNING, &ls->ls_flags)) {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tlog_error(ls, \"no userland control daemon, stopping lockspace\");\n\t\tdlm_ls_stop(ls);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (count)\n\t\tlog_print(\"dlm user daemon left %d lockspaces\", count);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm user daemon left %d lockspaces\"",
            "count"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_ls_stop",
          "args": [
            "ls"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_ls_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "598-672",
          "snippet": "int dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t/*\n\t * Prevent dlm_recv from being in the middle of something when we do\n\t * the stop.  This includes ensuring dlm_recv isn't processing a\n\t * recovery message (rcom), while dlm_recoverd is aborting and\n\t * resetting things from an in-progress recovery.  i.e. we want\n\t * dlm_recoverd to abort its recovery without worrying about dlm_recv\n\t * processing an rcom at the same time.  Stopping dlm_recv also makes\n\t * it easy for dlm_receive_message() to check locking stopped and add a\n\t * message to the requestqueue without races.\n\t */\n\n\tdown_write(&ls->ls_recv_active);\n\n\t/*\n\t * Abort any recovery that's in progress (see RECOVER_STOP,\n\t * dlm_recovery_stopped()) and tell any other threads running in the\n\t * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).\n\t */\n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t/*\n\t * Let dlm_recv run again, now any normal messages will be saved on the\n\t * requestqueue for later.\n\t */\n\n\tup_write(&ls->ls_recv_active);\n\n\t/*\n\t * This in_recovery lock does two things:\n\t * 1) Keeps this function from returning until all threads are out\n\t *    of locking routines and locking is truly stopped.\n\t * 2) Keeps any new requests from being processed until it's unlocked\n\t *    when recovery is complete.\n\t */\n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t/*\n\t * The recoverd suspend/resume makes sure that dlm_recoverd (if\n\t * running) has noticed RECOVER_STOP above and quit processing the\n\t * previous recovery.\n\t */\n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\tdlm_lsop_recover_prep(ls);\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t/*\n\t * Prevent dlm_recv from being in the middle of something when we do\n\t * the stop.  This includes ensuring dlm_recv isn't processing a\n\t * recovery message (rcom), while dlm_recoverd is aborting and\n\t * resetting things from an in-progress recovery.  i.e. we want\n\t * dlm_recoverd to abort its recovery without worrying about dlm_recv\n\t * processing an rcom at the same time.  Stopping dlm_recv also makes\n\t * it easy for dlm_receive_message() to check locking stopped and add a\n\t * message to the requestqueue without races.\n\t */\n\n\tdown_write(&ls->ls_recv_active);\n\n\t/*\n\t * Abort any recovery that's in progress (see RECOVER_STOP,\n\t * dlm_recovery_stopped()) and tell any other threads running in the\n\t * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).\n\t */\n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t/*\n\t * Let dlm_recv run again, now any normal messages will be saved on the\n\t * requestqueue for later.\n\t */\n\n\tup_write(&ls->ls_recv_active);\n\n\t/*\n\t * This in_recovery lock does two things:\n\t * 1) Keeps this function from returning until all threads are out\n\t *    of locking routines and locking is truly stopped.\n\t * 2) Keeps any new requests from being processed until it's unlocked\n\t *    when recovery is complete.\n\t */\n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t/*\n\t * The recoverd suspend/resume makes sure that dlm_recoverd (if\n\t * running) has noticed RECOVER_STOP above and quit processing the\n\t * previous recovery.\n\t */\n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\tdlm_lsop_recover_prep(ls);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"no userland control daemon, stopping lockspace\""
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RUNNING",
            "&ls->ls_flags"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ls",
            "&lslist",
            "ls_list"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_stop_lockspaces(void)\n{\n\tstruct dlm_ls *ls;\n\tint count;\n\n restart:\n\tcount = 0;\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (!test_bit(LSFL_RUNNING, &ls->ls_flags)) {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tlog_error(ls, \"no userland control daemon, stopping lockspace\");\n\t\tdlm_ls_stop(ls);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (count)\n\t\tlog_print(\"dlm user daemon left %d lockspaces\", count);\n}"
  },
  {
    "function_name": "dlm_release_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "873-892",
    "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct mutex\t\tls_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls_lock"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "threads_stop",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "threads_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "416-420",
          "snippet": "static void threads_stop(void)\n{\n\tdlm_scand_stop();\n\tdlm_lowcomms_stop();\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void threads_stop(void)\n{\n\tdlm_scand_stop();\n\tdlm_lowcomms_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_lockspace",
          "args": [
            "ls",
            "force"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "873-892",
          "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls_lock"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}"
  },
  {
    "function_name": "release_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "761-857",
    "snippet": "static int release_lockspace(struct dlm_ls *ls, int force)\n{\n\tstruct dlm_rsb *rsb;\n\tstruct rb_node *n;\n\tint i, busy, rv;\n\n\tbusy = lockspace_busy(ls, force);\n\n\tspin_lock(&lslist_lock);\n\tif (ls->ls_create_count == 1) {\n\t\tif (busy) {\n\t\t\trv = -EBUSY;\n\t\t} else {\n\t\t\t/* remove_lockspace takes ls off lslist */\n\t\t\tls->ls_create_count = 0;\n\t\t\trv = 0;\n\t\t}\n\t} else if (ls->ls_create_count > 1) {\n\t\trv = --ls->ls_create_count;\n\t} else {\n\t\trv = -EINVAL;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (rv) {\n\t\tlog_debug(ls, \"release_lockspace no remove %d\", rv);\n\t\treturn rv;\n\t}\n\n\tdlm_device_deregister(ls);\n\n\tif (force < 3 && dlm_user_daemon_available())\n\t\tdo_uevent(ls, 0);\n\n\tdlm_recoverd_stop(ls);\n\n\tdlm_callback_stop(ls);\n\n\tremove_lockspace(ls);\n\n\tdlm_delete_debug_file(ls);\n\n\tkfree(ls->ls_recover_buf);\n\n\t/*\n\t * Free all lkb's in idr\n\t */\n\n\tidr_for_each(&ls->ls_lkbidr, lkb_idr_free, ls);\n\tidr_destroy(&ls->ls_lkbidr);\n\n\t/*\n\t * Free all rsb's on rsbtbl[] lists\n\t */\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\twhile ((n = rb_first(&ls->ls_rsbtbl[i].keep))) {\n\t\t\trsb = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].keep);\n\t\t\tdlm_free_rsb(rsb);\n\t\t}\n\n\t\twhile ((n = rb_first(&ls->ls_rsbtbl[i].toss))) {\n\t\t\trsb = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(rsb);\n\t\t}\n\t}\n\n\tvfree(ls->ls_rsbtbl);\n\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++)\n\t\tkfree(ls->ls_remove_names[i]);\n\n\twhile (!list_empty(&ls->ls_new_rsb)) {\n\t\trsb = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb,\n\t\t\t\t       res_hashchain);\n\t\tlist_del(&rsb->res_hashchain);\n\t\tdlm_free_rsb(rsb);\n\t}\n\n\t/*\n\t * Free structures on any other lists\n\t */\n\n\tdlm_purge_requestqueue(ls);\n\tkfree(ls->ls_recover_args);\n\tdlm_clear_members(ls);\n\tdlm_clear_members_gone(ls);\n\tkfree(ls->ls_node_array);\n\tlog_rinfo(ls, \"release_lockspace final free\");\n\tkobject_put(&ls->ls_kobj);\n\t/* The ls structure will be freed when the kobject is done with */\n\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&ls->ls_kobj"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"release_lockspace final free\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_node_array"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_clear_members_gone",
          "args": [
            "ls"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clear_members_gone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "382-385",
          "snippet": "void dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_args"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_purge_requestqueue",
          "args": [
            "ls"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_purge_requestqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
          "lines": "155-170",
          "snippet": "void dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
          "includes": [
            "#include \"requestqueue.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"member.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_rsb",
          "args": [
            "rsb"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "68-73",
          "snippet": "void dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nvoid dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rsb->res_hashchain"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ls->ls_new_rsb",
            "structdlm_rsb",
            "res_hashchain"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_new_rsb"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_remove_names[i]"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "ls->ls_rsbtbl"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&ls->ls_rsbtbl[i].toss"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[i].toss"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&ls->ls_rsbtbl[i].keep"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[i].keep"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&ls->ls_lkbidr"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each",
          "args": [
            "&ls->ls_lkbidr",
            "lkb_idr_free",
            "ls"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_buf"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_delete_debug_file",
          "args": [
            "ls"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_delete_debug_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "700-707",
          "snippet": "void dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nvoid dlm_delete_debug_file(struct dlm_ls *ls)\n{\n\tdebugfs_remove(ls->ls_debug_rsb_dentry);\n\tdebugfs_remove(ls->ls_debug_waiters_dentry);\n\tdebugfs_remove(ls->ls_debug_locks_dentry);\n\tdebugfs_remove(ls->ls_debug_all_dentry);\n\tdebugfs_remove(ls->ls_debug_toss_dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_lockspace",
          "args": [
            "ls"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "remove_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "376-389",
          "snippet": "static void remove_lockspace(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tspin_lock(&lslist_lock);\n\t\tif (ls->ls_count == 0) {\n\t\t\tWARN_ON(ls->ls_create_count != 0);\n\t\t\tlist_del(&ls->ls_list);\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tssleep(1);\n\t}\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nstatic void remove_lockspace(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tspin_lock(&lslist_lock);\n\t\tif (ls->ls_count == 0) {\n\t\t\tWARN_ON(ls->ls_create_count != 0);\n\t\t\tlist_del(&ls->ls_list);\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tssleep(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_callback_stop",
          "args": [
            "ls"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_callback_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "279-283",
          "snippet": "void dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recoverd_stop",
          "args": [
            "ls"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recoverd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "327-330",
          "snippet": "void dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_uevent",
          "args": [
            "ls",
            "0"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "do_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "197-225",
          "snippet": "static int do_uevent(struct dlm_ls *ls, int in)\n{\n\tint error;\n\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t/* dlm_controld will see the uevent, do the necessary group management\n\t   and then write to sysfs to wake us */\n\n\terror = wait_event_interruptible(ls->ls_uevent_wait,\n\t\t\ttest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d %d\", error, ls->ls_uevent_result);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = ls->ls_uevent_result;\n out:\n\tif (error)\n\t\tlog_error(ls, \"group %s failed %d %d\", in ? \"join\" : \"leave\",\n\t\t\t  error, ls->ls_uevent_result);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int do_uevent(struct dlm_ls *ls, int in)\n{\n\tint error;\n\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t/* dlm_controld will see the uevent, do the necessary group management\n\t   and then write to sysfs to wake us */\n\n\terror = wait_event_interruptible(ls->ls_uevent_wait,\n\t\t\ttest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d %d\", error, ls->ls_uevent_result);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = ls->ls_uevent_result;\n out:\n\tif (error)\n\t\tlog_error(ls, \"group %s failed %d %d\", in ? \"join\" : \"leave\",\n\t\t\t  error, ls->ls_uevent_result);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_daemon_available",
          "args": [],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_daemon_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "906-924",
          "snippet": "int dlm_user_daemon_available(void)\n{\n\t/* dlm_controld hasn't started (or, has started, but not\n\t   properly populated configfs) */\n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t/* This is to deal with versions of dlm_controld that don't\n\t   know about the monitor device.  We assume that if the\n\t   dlm_controld was started (above), but the monitor device\n\t   was never opened, that it's an old version.  dlm_controld\n\t   should open the monitor device before populating configfs. */\n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t dlm_monitor_opened;",
            "static int dlm_monitor_unused = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic atomic_t dlm_monitor_opened;\nstatic int dlm_monitor_unused = 1;\n\nint dlm_user_daemon_available(void)\n{\n\t/* dlm_controld hasn't started (or, has started, but not\n\t   properly populated configfs) */\n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t/* This is to deal with versions of dlm_controld that don't\n\t   know about the monitor device.  We assume that if the\n\t   dlm_controld was started (above), but the monitor device\n\t   was never opened, that it's an old version.  dlm_controld\n\t   should open the monitor device before populating configfs. */\n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_device_deregister",
          "args": [
            "ls"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_device_deregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "363-377",
          "snippet": "int dlm_device_deregister(struct dlm_ls *ls)\n{\n\tint error;\n\n\t/* The device is not registered.  This happens when the lockspace\n\t   was never used from userspace, or when device_create_lockspace()\n\t   calls dlm_release_lockspace() after the register fails. */\n\tif (!ls->ls_device.name)\n\t\treturn 0;\n\n\terror = misc_deregister(&ls->ls_device);\n\tif (!error)\n\t\tkfree(ls->ls_device.name);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nint dlm_device_deregister(struct dlm_ls *ls)\n{\n\tint error;\n\n\t/* The device is not registered.  This happens when the lockspace\n\t   was never used from userspace, or when device_create_lockspace()\n\t   calls dlm_release_lockspace() after the register fails. */\n\tif (!ls->ls_device.name)\n\t\treturn 0;\n\n\terror = misc_deregister(&ls->ls_device);\n\tif (!error)\n\t\tkfree(ls->ls_device.name);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"release_lockspace no remove %d\"",
            "rv"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockspace_busy",
          "args": [
            "ls",
            "force"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "lockspace_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "745-759",
          "snippet": "static int lockspace_busy(struct dlm_ls *ls, int force)\n{\n\tint rv;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (force == 0) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_any, ls);\n\t} else if (force == 1) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_local, ls);\n\t} else {\n\t\trv = 0;\n\t}\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\treturn rv;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int lockspace_busy(struct dlm_ls *ls, int force)\n{\n\tint rv;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (force == 0) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_any, ls);\n\t} else if (force == 1) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_local, ls);\n\t} else {\n\t\trv = 0;\n\t}\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstatic int release_lockspace(struct dlm_ls *ls, int force)\n{\n\tstruct dlm_rsb *rsb;\n\tstruct rb_node *n;\n\tint i, busy, rv;\n\n\tbusy = lockspace_busy(ls, force);\n\n\tspin_lock(&lslist_lock);\n\tif (ls->ls_create_count == 1) {\n\t\tif (busy) {\n\t\t\trv = -EBUSY;\n\t\t} else {\n\t\t\t/* remove_lockspace takes ls off lslist */\n\t\t\tls->ls_create_count = 0;\n\t\t\trv = 0;\n\t\t}\n\t} else if (ls->ls_create_count > 1) {\n\t\trv = --ls->ls_create_count;\n\t} else {\n\t\trv = -EINVAL;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (rv) {\n\t\tlog_debug(ls, \"release_lockspace no remove %d\", rv);\n\t\treturn rv;\n\t}\n\n\tdlm_device_deregister(ls);\n\n\tif (force < 3 && dlm_user_daemon_available())\n\t\tdo_uevent(ls, 0);\n\n\tdlm_recoverd_stop(ls);\n\n\tdlm_callback_stop(ls);\n\n\tremove_lockspace(ls);\n\n\tdlm_delete_debug_file(ls);\n\n\tkfree(ls->ls_recover_buf);\n\n\t/*\n\t * Free all lkb's in idr\n\t */\n\n\tidr_for_each(&ls->ls_lkbidr, lkb_idr_free, ls);\n\tidr_destroy(&ls->ls_lkbidr);\n\n\t/*\n\t * Free all rsb's on rsbtbl[] lists\n\t */\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\twhile ((n = rb_first(&ls->ls_rsbtbl[i].keep))) {\n\t\t\trsb = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].keep);\n\t\t\tdlm_free_rsb(rsb);\n\t\t}\n\n\t\twhile ((n = rb_first(&ls->ls_rsbtbl[i].toss))) {\n\t\t\trsb = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(rsb);\n\t\t}\n\t}\n\n\tvfree(ls->ls_rsbtbl);\n\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++)\n\t\tkfree(ls->ls_remove_names[i]);\n\n\twhile (!list_empty(&ls->ls_new_rsb)) {\n\t\trsb = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb,\n\t\t\t\t       res_hashchain);\n\t\tlist_del(&rsb->res_hashchain);\n\t\tdlm_free_rsb(rsb);\n\t}\n\n\t/*\n\t * Free structures on any other lists\n\t */\n\n\tdlm_purge_requestqueue(ls);\n\tkfree(ls->ls_recover_args);\n\tdlm_clear_members(ls);\n\tdlm_clear_members_gone(ls);\n\tkfree(ls->ls_node_array);\n\tlog_rinfo(ls, \"release_lockspace final free\");\n\tkobject_put(&ls->ls_kobj);\n\t/* The ls structure will be freed when the kobject is done with */\n\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}"
  },
  {
    "function_name": "lockspace_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "745-759",
    "snippet": "static int lockspace_busy(struct dlm_ls *ls, int force)\n{\n\tint rv;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (force == 0) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_any, ls);\n\t} else if (force == 1) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_local, ls);\n\t} else {\n\t\trv = 0;\n\t}\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\treturn rv;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_for_each",
          "args": [
            "&ls->ls_lkbidr",
            "lkb_idr_is_local",
            "ls"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each",
          "args": [
            "&ls->ls_lkbidr",
            "lkb_idr_is_any",
            "ls"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int lockspace_busy(struct dlm_ls *ls, int force)\n{\n\tint rv;\n\n\tspin_lock(&ls->ls_lkbidr_spin);\n\tif (force == 0) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_any, ls);\n\t} else if (force == 1) {\n\t\trv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_local, ls);\n\t} else {\n\t\trv = 0;\n\t}\n\tspin_unlock(&ls->ls_lkbidr_spin);\n\treturn rv;\n}"
  },
  {
    "function_name": "lkb_idr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "730-739",
    "snippet": "static int lkb_idr_free(int id, void *p, void *data)\n{\n\tstruct dlm_lkb *lkb = p;\n\n\tif (lkb->lkb_lvbptr && lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\n\tdlm_free_lkb(lkb);\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_free_lkb",
          "args": [
            "lkb"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "83-95",
          "snippet": "void dlm_free_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tstruct dlm_user_args *ua;\n\t\tua = lkb->lkb_ua;\n\t\tif (ua) {\n\t\t\tif (ua->lksb.sb_lvbptr)\n\t\t\t\tkfree(ua->lksb.sb_lvbptr);\n\t\t\tkfree(ua);\n\t\t}\n\t}\n\tkmem_cache_free(lkb_cache, lkb);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lkb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *lkb_cache;\n\nvoid dlm_free_lkb(struct dlm_lkb *lkb)\n{\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tstruct dlm_user_args *ua;\n\t\tua = lkb->lkb_ua;\n\t\tif (ua) {\n\t\t\tif (ua->lksb.sb_lvbptr)\n\t\t\t\tkfree(ua->lksb.sb_lvbptr);\n\t\t\tkfree(ua);\n\t\t}\n\t}\n\tkmem_cache_free(lkb_cache, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_lvb",
          "args": [
            "lkb->lkb_lvbptr"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "55-58",
          "snippet": "void dlm_free_lvb(char *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_free_lvb(char *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int lkb_idr_free(int id, void *p, void *data)\n{\n\tstruct dlm_lkb *lkb = p;\n\n\tif (lkb->lkb_lvbptr && lkb->lkb_flags & DLM_IFL_MSTCPY)\n\t\tdlm_free_lvb(lkb->lkb_lvbptr);\n\n\tdlm_free_lkb(lkb);\n\treturn 0;\n}"
  },
  {
    "function_name": "lkb_idr_is_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "725-728",
    "snippet": "static int lkb_idr_is_any(int id, void *p, void *data)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int lkb_idr_is_any(int id, void *p, void *data)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "lkb_idr_is_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "718-723",
    "snippet": "static int lkb_idr_is_local(int id, void *p, void *data)\n{\n\tstruct dlm_lkb *lkb = p;\n\n\treturn lkb->lkb_nodeid == 0 && lkb->lkb_grmode != DLM_LOCK_IV;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int lkb_idr_is_local(int id, void *p, void *data)\n{\n\tstruct dlm_lkb *lkb = p;\n\n\treturn lkb->lkb_nodeid == 0 && lkb->lkb_grmode != DLM_LOCK_IV;\n}"
  },
  {
    "function_name": "dlm_new_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "692-716",
    "snippet": "int dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct mutex\t\tls_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls_lock"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "threads_stop",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "threads_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "416-420",
          "snippet": "static void threads_stop(void)\n{\n\tdlm_scand_stop();\n\tdlm_lowcomms_stop();\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void threads_stop(void)\n{\n\tdlm_scand_stop();\n\tdlm_lowcomms_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_lockspace",
          "args": [
            "name",
            "cluster",
            "flags",
            "lvblen",
            "ops",
            "ops_arg",
            "ops_result",
            "lockspace"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "692-716",
          "snippet": "int dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "threads_start",
          "args": [],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "threads_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "391-414",
          "snippet": "static int threads_start(void)\n{\n\tint error;\n\n\terror = dlm_scand_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm_scand thread %d\", error);\n\t\tgoto fail;\n\t}\n\n\t/* Thread for sending/receiving messages for all lockspace's */\n\terror = dlm_lowcomms_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm lowcomms %d\", error);\n\t\tgoto scand_fail;\n\t}\n\n\treturn 0;\n\n scand_fail:\n\tdlm_scand_stop();\n fail:\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int threads_start(void)\n{\n\tint error;\n\n\terror = dlm_scand_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm_scand thread %d\", error);\n\t\tgoto fail;\n\t}\n\n\t/* Thread for sending/receiving messages for all lockspace's */\n\terror = dlm_lowcomms_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm lowcomms %d\", error);\n\t\tgoto scand_fail;\n\t}\n\n\treturn 0;\n\n scand_fail:\n\tdlm_scand_stop();\n fail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls_lock"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "new_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "422-690",
    "snippet": "static int new_lockspace(const char *name, const char *cluster,\n\t\t\t uint32_t flags, int lvblen,\n\t\t\t const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t\t int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tstruct dlm_ls *ls;\n\tint i, size, error;\n\tint do_unreg = 0;\n\tint namelen = strlen(name);\n\n\tif (namelen > DLM_LOCKSPACE_LEN)\n\t\treturn -EINVAL;\n\n\tif (!lvblen || (lvblen % 8))\n\t\treturn -EINVAL;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\tif (!dlm_user_daemon_available()) {\n\t\tlog_print(\"dlm user daemon not available\");\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tif (ops && ops_result) {\n\t       \tif (!dlm_config.ci_recover_callbacks)\n\t\t\t*ops_result = -EOPNOTSUPP;\n\t\telse\n\t\t\t*ops_result = 0;\n\t}\n\n\tif (dlm_config.ci_recover_callbacks && cluster &&\n\t    strncmp(cluster, dlm_config.ci_cluster_name, DLM_LOCKSPACE_LEN)) {\n\t\tlog_print(\"dlm cluster name %s mismatch %s\",\n\t\t\t  dlm_config.ci_cluster_name, cluster);\n\t\terror = -EBADR;\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tWARN_ON(ls->ls_create_count <= 0);\n\t\tif (ls->ls_namelen != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(ls->ls_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (flags & DLM_LSFL_NEWEXCL) {\n\t\t\terror = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t\tls->ls_create_count++;\n\t\t*lockspace = ls;\n\t\terror = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\n\tls = kzalloc(sizeof(struct dlm_ls) + namelen, GFP_NOFS);\n\tif (!ls)\n\t\tgoto out;\n\tmemcpy(ls->ls_name, name, namelen);\n\tls->ls_namelen = namelen;\n\tls->ls_lvblen = lvblen;\n\tls->ls_count = 0;\n\tls->ls_flags = 0;\n\tls->ls_scan_time = jiffies;\n\n\tif (ops && dlm_config.ci_recover_callbacks) {\n\t\tls->ls_ops = ops;\n\t\tls->ls_ops_arg = ops_arg;\n\t}\n\n\tif (flags & DLM_LSFL_TIMEWARN)\n\t\tset_bit(LSFL_TIMEWARN, &ls->ls_flags);\n\n\t/* ls_exflags are forced to match among nodes, and we don't\n\t   need to require all nodes to have some flags set */\n\tls->ls_exflags = (flags & ~(DLM_LSFL_TIMEWARN | DLM_LSFL_FS |\n\t\t\t\t    DLM_LSFL_NEWEXCL));\n\n\tsize = dlm_config.ci_rsbtbl_size;\n\tls->ls_rsbtbl_size = size;\n\n\tls->ls_rsbtbl = vmalloc(sizeof(struct dlm_rsbtable) * size);\n\tif (!ls->ls_rsbtbl)\n\t\tgoto out_lsfree;\n\tfor (i = 0; i < size; i++) {\n\t\tls->ls_rsbtbl[i].keep.rb_node = NULL;\n\t\tls->ls_rsbtbl[i].toss.rb_node = NULL;\n\t\tspin_lock_init(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tspin_lock_init(&ls->ls_remove_spin);\n\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\n\t\tls->ls_remove_names[i] = kzalloc(DLM_RESNAME_MAXLEN+1,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ls->ls_remove_names[i])\n\t\t\tgoto out_rsbtbl;\n\t}\n\n\tidr_init(&ls->ls_lkbidr);\n\tspin_lock_init(&ls->ls_lkbidr_spin);\n\n\tINIT_LIST_HEAD(&ls->ls_waiters);\n\tmutex_init(&ls->ls_waiters_mutex);\n\tINIT_LIST_HEAD(&ls->ls_orphans);\n\tmutex_init(&ls->ls_orphans_mutex);\n\tINIT_LIST_HEAD(&ls->ls_timeout);\n\tmutex_init(&ls->ls_timeout_mutex);\n\n\tINIT_LIST_HEAD(&ls->ls_new_rsb);\n\tspin_lock_init(&ls->ls_new_rsb_spin);\n\n\tINIT_LIST_HEAD(&ls->ls_nodes);\n\tINIT_LIST_HEAD(&ls->ls_nodes_gone);\n\tls->ls_num_nodes = 0;\n\tls->ls_low_nodeid = 0;\n\tls->ls_total_weight = 0;\n\tls->ls_node_array = NULL;\n\n\tmemset(&ls->ls_stub_rsb, 0, sizeof(struct dlm_rsb));\n\tls->ls_stub_rsb.res_ls = ls;\n\n\tls->ls_debug_rsb_dentry = NULL;\n\tls->ls_debug_waiters_dentry = NULL;\n\n\tinit_waitqueue_head(&ls->ls_uevent_wait);\n\tls->ls_uevent_result = 0;\n\tinit_completion(&ls->ls_members_done);\n\tls->ls_members_result = -1;\n\n\tmutex_init(&ls->ls_cb_mutex);\n\tINIT_LIST_HEAD(&ls->ls_cb_delay);\n\n\tls->ls_recoverd_task = NULL;\n\tmutex_init(&ls->ls_recoverd_active);\n\tspin_lock_init(&ls->ls_recover_lock);\n\tspin_lock_init(&ls->ls_rcom_spin);\n\tget_random_bytes(&ls->ls_rcom_seq, sizeof(uint64_t));\n\tls->ls_recover_status = 0;\n\tls->ls_recover_seq = 0;\n\tls->ls_recover_args = NULL;\n\tinit_rwsem(&ls->ls_in_recovery);\n\tinit_rwsem(&ls->ls_recv_active);\n\tINIT_LIST_HEAD(&ls->ls_requestqueue);\n\tmutex_init(&ls->ls_requestqueue_mutex);\n\tmutex_init(&ls->ls_clear_proc_locks);\n\n\tls->ls_recover_buf = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\n\tif (!ls->ls_recover_buf)\n\t\tgoto out_lkbidr;\n\n\tls->ls_slot = 0;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_slots = NULL;\n\n\tINIT_LIST_HEAD(&ls->ls_recover_list);\n\tspin_lock_init(&ls->ls_recover_list_lock);\n\tidr_init(&ls->ls_recover_idr);\n\tspin_lock_init(&ls->ls_recover_idr_lock);\n\tls->ls_recover_list_count = 0;\n\tls->ls_local_handle = ls;\n\tinit_waitqueue_head(&ls->ls_wait_general);\n\tINIT_LIST_HEAD(&ls->ls_root_list);\n\tinit_rwsem(&ls->ls_root_sem);\n\n\tspin_lock(&lslist_lock);\n\tls->ls_create_count = 1;\n\tlist_add(&ls->ls_list, &lslist);\n\tspin_unlock(&lslist_lock);\n\n\tif (flags & DLM_LSFL_FS) {\n\t\terror = dlm_callback_start(ls);\n\t\tif (error) {\n\t\t\tlog_error(ls, \"can't start dlm_callback %d\", error);\n\t\t\tgoto out_delist;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&ls->ls_recover_lock_wait);\n\n\t/*\n\t * Once started, dlm_recoverd first looks for ls in lslist, then\n\t * initializes ls_in_recovery as locked in \"down\" mode.  We need\n\t * to wait for the wakeup from dlm_recoverd because in_recovery\n\t * has to start out in down mode.\n\t */\n\n\terror = dlm_recoverd_start(ls);\n\tif (error) {\n\t\tlog_error(ls, \"can't start dlm_recoverd %d\", error);\n\t\tgoto out_callback;\n\t}\n\n\twait_event(ls->ls_recover_lock_wait,\n\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\n\tls->ls_kobj.kset = dlm_kset;\n\terror = kobject_init_and_add(&ls->ls_kobj, &dlm_ktype, NULL,\n\t\t\t\t     \"%s\", ls->ls_name);\n\tif (error)\n\t\tgoto out_recoverd;\n\tkobject_uevent(&ls->ls_kobj, KOBJ_ADD);\n\n\t/* let kobject handle freeing of ls if there's an error */\n\tdo_unreg = 1;\n\n\t/* This uevent triggers dlm_controld in userspace to add us to the\n\t   group of nodes that are members of this lockspace (managed by the\n\t   cluster infrastructure.)  Once it's done that, it tells us who the\n\t   current lockspace members are (via configfs) and then tells the\n\t   lockspace to start running (via sysfs) in dlm_ls_start(). */\n\n\terror = do_uevent(ls, 1);\n\tif (error)\n\t\tgoto out_recoverd;\n\n\twait_for_completion(&ls->ls_members_done);\n\terror = ls->ls_members_result;\n\tif (error)\n\t\tgoto out_members;\n\n\tdlm_create_debug_file(ls);\n\n\tlog_rinfo(ls, \"join complete\");\n\t*lockspace = ls;\n\treturn 0;\n\n out_members:\n\tdo_uevent(ls, 0);\n\tdlm_clear_members(ls);\n\tkfree(ls->ls_node_array);\n out_recoverd:\n\tdlm_recoverd_stop(ls);\n out_callback:\n\tdlm_callback_stop(ls);\n out_delist:\n\tspin_lock(&lslist_lock);\n\tlist_del(&ls->ls_list);\n\tspin_unlock(&lslist_lock);\n\tidr_destroy(&ls->ls_recover_idr);\n\tkfree(ls->ls_recover_buf);\n out_lkbidr:\n\tidr_destroy(&ls->ls_lkbidr);\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\n\t\tif (ls->ls_remove_names[i])\n\t\t\tkfree(ls->ls_remove_names[i]);\n\t}\n out_rsbtbl:\n\tvfree(ls->ls_rsbtbl);\n out_lsfree:\n\tif (do_unreg)\n\t\tkobject_put(&ls->ls_kobj);\n\telse\n\t\tkfree(ls);\n out:\n\tmodule_put(THIS_MODULE);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;",
      "static struct kobj_type dlm_ktype = {\n\t.default_attrs = dlm_attrs,\n\t.sysfs_ops     = &dlm_attr_ops,\n\t.release       = lockspace_kobj_release,\n};",
      "static struct kset *dlm_kset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&ls->ls_kobj"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "ls->ls_rsbtbl"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_remove_names[i]"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&ls->ls_lkbidr"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_buf"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&ls->ls_recover_idr"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ls->ls_list"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_callback_stop",
          "args": [
            "ls"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_callback_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "279-283",
          "snippet": "void dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recoverd_stop",
          "args": [
            "ls"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recoverd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "327-330",
          "snippet": "void dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_stop(struct dlm_ls *ls)\n{\n\tkthread_stop(ls->ls_recoverd_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_node_array"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_clear_members",
          "args": [
            "ls"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clear_members_gone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "382-385",
          "snippet": "void dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_uevent",
          "args": [
            "ls",
            "0"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "do_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "197-225",
          "snippet": "static int do_uevent(struct dlm_ls *ls, int in)\n{\n\tint error;\n\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t/* dlm_controld will see the uevent, do the necessary group management\n\t   and then write to sysfs to wake us */\n\n\terror = wait_event_interruptible(ls->ls_uevent_wait,\n\t\t\ttest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d %d\", error, ls->ls_uevent_result);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = ls->ls_uevent_result;\n out:\n\tif (error)\n\t\tlog_error(ls, \"group %s failed %d %d\", in ? \"join\" : \"leave\",\n\t\t\t  error, ls->ls_uevent_result);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int do_uevent(struct dlm_ls *ls, int in)\n{\n\tint error;\n\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t/* dlm_controld will see the uevent, do the necessary group management\n\t   and then write to sysfs to wake us */\n\n\terror = wait_event_interruptible(ls->ls_uevent_wait,\n\t\t\ttest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d %d\", error, ls->ls_uevent_result);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = ls->ls_uevent_result;\n out:\n\tif (error)\n\t\tlog_error(ls, \"group %s failed %d %d\", in ? \"join\" : \"leave\",\n\t\t\t  error, ls->ls_uevent_result);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"join complete\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_create_debug_file",
          "args": [
            "ls"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_create_debug_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/debug_fs.c",
          "lines": "709-778",
          "snippet": "int dlm_create_debug_file(struct dlm_ls *ls)\n{\n\tchar name[DLM_LOCKSPACE_LEN+8];\n\n\t/* format 1 */\n\n\tls->ls_debug_rsb_dentry = debugfs_create_file(ls->ls_name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format1_fops);\n\tif (!ls->ls_debug_rsb_dentry)\n\t\tgoto fail;\n\n\t/* format 2 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_locks\", ls->ls_name);\n\n\tls->ls_debug_locks_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tdlm_root,\n\t\t\t\t\t\t\tls,\n\t\t\t\t\t\t\t&format2_fops);\n\tif (!ls->ls_debug_locks_dentry)\n\t\tgoto fail;\n\n\t/* format 3 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_all\", ls->ls_name);\n\n\tls->ls_debug_all_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format3_fops);\n\tif (!ls->ls_debug_all_dentry)\n\t\tgoto fail;\n\n\t/* format 4 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_toss\", ls->ls_name);\n\n\tls->ls_debug_toss_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t       S_IFREG | S_IRUGO,\n\t\t\t\t\t\t       dlm_root,\n\t\t\t\t\t\t       ls,\n\t\t\t\t\t\t       &format4_fops);\n\tif (!ls->ls_debug_toss_dentry)\n\t\tgoto fail;\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_waiters\", ls->ls_name);\n\n\tls->ls_debug_waiters_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t  S_IFREG | S_IRUGO,\n\t\t\t\t\t\t\t  dlm_root,\n\t\t\t\t\t\t\t  ls,\n\t\t\t\t\t\t\t  &waiters_fops);\n\tif (!ls->ls_debug_waiters_dentry)\n\t\tgoto fail;\n\n\treturn 0;\n\n fail:\n\tdlm_delete_debug_file(ls);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *dlm_root;",
            "static const struct file_operations format1_fops;",
            "static const struct file_operations format2_fops;",
            "static const struct file_operations format3_fops;",
            "static const struct file_operations format4_fops;",
            "static const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
            "static const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
            "static const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
            "static const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};",
            "static const struct file_operations waiters_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = waiters_read,\n\t.llseek  = default_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lock.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n\nstatic struct dentry *dlm_root;\nstatic const struct file_operations format1_fops;\nstatic const struct file_operations format2_fops;\nstatic const struct file_operations format3_fops;\nstatic const struct file_operations format4_fops;\nstatic const struct file_operations format1_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format2_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format3_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations format4_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = table_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\nstatic const struct file_operations waiters_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = waiters_read,\n\t.llseek  = default_llseek,\n};\n\nint dlm_create_debug_file(struct dlm_ls *ls)\n{\n\tchar name[DLM_LOCKSPACE_LEN+8];\n\n\t/* format 1 */\n\n\tls->ls_debug_rsb_dentry = debugfs_create_file(ls->ls_name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format1_fops);\n\tif (!ls->ls_debug_rsb_dentry)\n\t\tgoto fail;\n\n\t/* format 2 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_locks\", ls->ls_name);\n\n\tls->ls_debug_locks_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tdlm_root,\n\t\t\t\t\t\t\tls,\n\t\t\t\t\t\t\t&format2_fops);\n\tif (!ls->ls_debug_locks_dentry)\n\t\tgoto fail;\n\n\t/* format 3 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_all\", ls->ls_name);\n\n\tls->ls_debug_all_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t      S_IFREG | S_IRUGO,\n\t\t\t\t\t\t      dlm_root,\n\t\t\t\t\t\t      ls,\n\t\t\t\t\t\t      &format3_fops);\n\tif (!ls->ls_debug_all_dentry)\n\t\tgoto fail;\n\n\t/* format 4 */\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_toss\", ls->ls_name);\n\n\tls->ls_debug_toss_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t       S_IFREG | S_IRUGO,\n\t\t\t\t\t\t       dlm_root,\n\t\t\t\t\t\t       ls,\n\t\t\t\t\t\t       &format4_fops);\n\tif (!ls->ls_debug_toss_dentry)\n\t\tgoto fail;\n\n\tmemset(name, 0, sizeof(name));\n\tsnprintf(name, DLM_LOCKSPACE_LEN+8, \"%s_waiters\", ls->ls_name);\n\n\tls->ls_debug_waiters_dentry = debugfs_create_file(name,\n\t\t\t\t\t\t\t  S_IFREG | S_IRUGO,\n\t\t\t\t\t\t\t  dlm_root,\n\t\t\t\t\t\t\t  ls,\n\t\t\t\t\t\t\t  &waiters_fops);\n\tif (!ls->ls_debug_waiters_dentry)\n\t\tgoto fail;\n\n\treturn 0;\n\n fail:\n\tdlm_delete_debug_file(ls);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ls->ls_members_done"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&ls->ls_kobj",
            "KOBJ_ADD"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&ls->ls_kobj",
            "&dlm_ktype",
            "NULL",
            "\"%s\"",
            "ls->ls_name"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "ls->ls_recover_lock_wait",
            "test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RECOVER_LOCK",
            "&ls->ls_flags"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"can't start dlm_recoverd %d\"",
            "error"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recoverd_start",
          "args": [
            "ls"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recoverd_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "314-325",
          "snippet": "int dlm_recoverd_start(struct dlm_ls *ls)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_recoverd, ls, \"dlm_recoverd\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n                ls->ls_recoverd_task = p;\n\treturn error;\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recoverd_start(struct dlm_ls *ls)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_recoverd, ls, \"dlm_recoverd\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n                ls->ls_recoverd_task = p;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ls->ls_recover_lock_wait"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"can't start dlm_callback %d\"",
            "error"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_callback_start",
          "args": [
            "ls"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_callback_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "268-277",
          "snippet": "int dlm_callback_start(struct dlm_ls *ls)\n{\n\tls->ls_callback_wq = alloc_workqueue(\"dlm_callback\",\n\t\t\t\t\t     WQ_UNBOUND | WQ_MEM_RECLAIM, 0);\n\tif (!ls->ls_callback_wq) {\n\t\tlog_print(\"can't start dlm_callback workqueue\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_callback_start(struct dlm_ls *ls)\n{\n\tls->ls_callback_wq = alloc_workqueue(\"dlm_callback\",\n\t\t\t\t\t     WQ_UNBOUND | WQ_MEM_RECLAIM, 0);\n\tif (!ls->ls_callback_wq) {\n\t\tlog_print(\"can't start dlm_callback workqueue\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ls->ls_list",
            "&lslist"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_root_list"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ls->ls_wait_general"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&ls->ls_recover_idr"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_recover_list"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "dlm_config.ci_buffer_size",
            "GFP_NOFS"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_requestqueue"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ls->ls_in_recovery"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&ls->ls_rcom_seq",
            "sizeof(uint64_t)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_recoverd_active"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_cb_delay"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_cb_mutex"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ls->ls_members_done"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ls->ls_uevent_wait"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ls->ls_stub_rsb",
            "0",
            "sizeof(struct dlm_rsb)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_nodes_gone"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_nodes"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_new_rsb_spin"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_new_rsb"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_timeout_mutex"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_timeout"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_orphans_mutex"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_orphans"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_waiters_mutex"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_waiters"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_lkbidr_spin"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&ls->ls_lkbidr"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "DLM_RESNAME_MAXLEN+1",
            "GFP_KERNEL"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_remove_spin"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "sizeof(struct dlm_rsbtable) * size"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_TIMEWARN",
            "&ls->ls_flags"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_name",
            "name",
            "namelen"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_ls) + namelen",
            "GFP_NOFS"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ls->ls_name",
            "name",
            "namelen"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ls->ls_create_count <= 0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ls",
            "&lslist",
            "ls_list"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm cluster name %s mismatch %s\"",
            "dlm_config.ci_cluster_name",
            "cluster"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cluster",
            "dlm_config.ci_cluster_name",
            "DLM_LOCKSPACE_LEN"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm user daemon not available\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_user_daemon_available",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_daemon_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "906-924",
          "snippet": "int dlm_user_daemon_available(void)\n{\n\t/* dlm_controld hasn't started (or, has started, but not\n\t   properly populated configfs) */\n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t/* This is to deal with versions of dlm_controld that don't\n\t   know about the monitor device.  We assume that if the\n\t   dlm_controld was started (above), but the monitor device\n\t   was never opened, that it's an old version.  dlm_controld\n\t   should open the monitor device before populating configfs. */\n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t dlm_monitor_opened;",
            "static int dlm_monitor_unused = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic atomic_t dlm_monitor_opened;\nstatic int dlm_monitor_unused = 1;\n\nint dlm_user_daemon_available(void)\n{\n\t/* dlm_controld hasn't started (or, has started, but not\n\t   properly populated configfs) */\n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t/* This is to deal with versions of dlm_controld that don't\n\t   know about the monitor device.  We assume that if the\n\t   dlm_controld was started (above), but the monitor device\n\t   was never opened, that it's an old version.  dlm_controld\n\t   should open the monitor device before populating configfs. */\n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "THIS_MODULE"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\nstatic struct kobj_type dlm_ktype = {\n\t.default_attrs = dlm_attrs,\n\t.sysfs_ops     = &dlm_attr_ops,\n\t.release       = lockspace_kobj_release,\n};\nstatic struct kset *dlm_kset;\n\nstatic int new_lockspace(const char *name, const char *cluster,\n\t\t\t uint32_t flags, int lvblen,\n\t\t\t const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t\t int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tstruct dlm_ls *ls;\n\tint i, size, error;\n\tint do_unreg = 0;\n\tint namelen = strlen(name);\n\n\tif (namelen > DLM_LOCKSPACE_LEN)\n\t\treturn -EINVAL;\n\n\tif (!lvblen || (lvblen % 8))\n\t\treturn -EINVAL;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EINVAL;\n\n\tif (!dlm_user_daemon_available()) {\n\t\tlog_print(\"dlm user daemon not available\");\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tif (ops && ops_result) {\n\t       \tif (!dlm_config.ci_recover_callbacks)\n\t\t\t*ops_result = -EOPNOTSUPP;\n\t\telse\n\t\t\t*ops_result = 0;\n\t}\n\n\tif (dlm_config.ci_recover_callbacks && cluster &&\n\t    strncmp(cluster, dlm_config.ci_cluster_name, DLM_LOCKSPACE_LEN)) {\n\t\tlog_print(\"dlm cluster name %s mismatch %s\",\n\t\t\t  dlm_config.ci_cluster_name, cluster);\n\t\terror = -EBADR;\n\t\tgoto out;\n\t}\n\n\terror = 0;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tWARN_ON(ls->ls_create_count <= 0);\n\t\tif (ls->ls_namelen != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(ls->ls_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (flags & DLM_LSFL_NEWEXCL) {\n\t\t\terror = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t\tls->ls_create_count++;\n\t\t*lockspace = ls;\n\t\terror = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\n\tls = kzalloc(sizeof(struct dlm_ls) + namelen, GFP_NOFS);\n\tif (!ls)\n\t\tgoto out;\n\tmemcpy(ls->ls_name, name, namelen);\n\tls->ls_namelen = namelen;\n\tls->ls_lvblen = lvblen;\n\tls->ls_count = 0;\n\tls->ls_flags = 0;\n\tls->ls_scan_time = jiffies;\n\n\tif (ops && dlm_config.ci_recover_callbacks) {\n\t\tls->ls_ops = ops;\n\t\tls->ls_ops_arg = ops_arg;\n\t}\n\n\tif (flags & DLM_LSFL_TIMEWARN)\n\t\tset_bit(LSFL_TIMEWARN, &ls->ls_flags);\n\n\t/* ls_exflags are forced to match among nodes, and we don't\n\t   need to require all nodes to have some flags set */\n\tls->ls_exflags = (flags & ~(DLM_LSFL_TIMEWARN | DLM_LSFL_FS |\n\t\t\t\t    DLM_LSFL_NEWEXCL));\n\n\tsize = dlm_config.ci_rsbtbl_size;\n\tls->ls_rsbtbl_size = size;\n\n\tls->ls_rsbtbl = vmalloc(sizeof(struct dlm_rsbtable) * size);\n\tif (!ls->ls_rsbtbl)\n\t\tgoto out_lsfree;\n\tfor (i = 0; i < size; i++) {\n\t\tls->ls_rsbtbl[i].keep.rb_node = NULL;\n\t\tls->ls_rsbtbl[i].toss.rb_node = NULL;\n\t\tspin_lock_init(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tspin_lock_init(&ls->ls_remove_spin);\n\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\n\t\tls->ls_remove_names[i] = kzalloc(DLM_RESNAME_MAXLEN+1,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ls->ls_remove_names[i])\n\t\t\tgoto out_rsbtbl;\n\t}\n\n\tidr_init(&ls->ls_lkbidr);\n\tspin_lock_init(&ls->ls_lkbidr_spin);\n\n\tINIT_LIST_HEAD(&ls->ls_waiters);\n\tmutex_init(&ls->ls_waiters_mutex);\n\tINIT_LIST_HEAD(&ls->ls_orphans);\n\tmutex_init(&ls->ls_orphans_mutex);\n\tINIT_LIST_HEAD(&ls->ls_timeout);\n\tmutex_init(&ls->ls_timeout_mutex);\n\n\tINIT_LIST_HEAD(&ls->ls_new_rsb);\n\tspin_lock_init(&ls->ls_new_rsb_spin);\n\n\tINIT_LIST_HEAD(&ls->ls_nodes);\n\tINIT_LIST_HEAD(&ls->ls_nodes_gone);\n\tls->ls_num_nodes = 0;\n\tls->ls_low_nodeid = 0;\n\tls->ls_total_weight = 0;\n\tls->ls_node_array = NULL;\n\n\tmemset(&ls->ls_stub_rsb, 0, sizeof(struct dlm_rsb));\n\tls->ls_stub_rsb.res_ls = ls;\n\n\tls->ls_debug_rsb_dentry = NULL;\n\tls->ls_debug_waiters_dentry = NULL;\n\n\tinit_waitqueue_head(&ls->ls_uevent_wait);\n\tls->ls_uevent_result = 0;\n\tinit_completion(&ls->ls_members_done);\n\tls->ls_members_result = -1;\n\n\tmutex_init(&ls->ls_cb_mutex);\n\tINIT_LIST_HEAD(&ls->ls_cb_delay);\n\n\tls->ls_recoverd_task = NULL;\n\tmutex_init(&ls->ls_recoverd_active);\n\tspin_lock_init(&ls->ls_recover_lock);\n\tspin_lock_init(&ls->ls_rcom_spin);\n\tget_random_bytes(&ls->ls_rcom_seq, sizeof(uint64_t));\n\tls->ls_recover_status = 0;\n\tls->ls_recover_seq = 0;\n\tls->ls_recover_args = NULL;\n\tinit_rwsem(&ls->ls_in_recovery);\n\tinit_rwsem(&ls->ls_recv_active);\n\tINIT_LIST_HEAD(&ls->ls_requestqueue);\n\tmutex_init(&ls->ls_requestqueue_mutex);\n\tmutex_init(&ls->ls_clear_proc_locks);\n\n\tls->ls_recover_buf = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\n\tif (!ls->ls_recover_buf)\n\t\tgoto out_lkbidr;\n\n\tls->ls_slot = 0;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_slots = NULL;\n\n\tINIT_LIST_HEAD(&ls->ls_recover_list);\n\tspin_lock_init(&ls->ls_recover_list_lock);\n\tidr_init(&ls->ls_recover_idr);\n\tspin_lock_init(&ls->ls_recover_idr_lock);\n\tls->ls_recover_list_count = 0;\n\tls->ls_local_handle = ls;\n\tinit_waitqueue_head(&ls->ls_wait_general);\n\tINIT_LIST_HEAD(&ls->ls_root_list);\n\tinit_rwsem(&ls->ls_root_sem);\n\n\tspin_lock(&lslist_lock);\n\tls->ls_create_count = 1;\n\tlist_add(&ls->ls_list, &lslist);\n\tspin_unlock(&lslist_lock);\n\n\tif (flags & DLM_LSFL_FS) {\n\t\terror = dlm_callback_start(ls);\n\t\tif (error) {\n\t\t\tlog_error(ls, \"can't start dlm_callback %d\", error);\n\t\t\tgoto out_delist;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&ls->ls_recover_lock_wait);\n\n\t/*\n\t * Once started, dlm_recoverd first looks for ls in lslist, then\n\t * initializes ls_in_recovery as locked in \"down\" mode.  We need\n\t * to wait for the wakeup from dlm_recoverd because in_recovery\n\t * has to start out in down mode.\n\t */\n\n\terror = dlm_recoverd_start(ls);\n\tif (error) {\n\t\tlog_error(ls, \"can't start dlm_recoverd %d\", error);\n\t\tgoto out_callback;\n\t}\n\n\twait_event(ls->ls_recover_lock_wait,\n\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\n\tls->ls_kobj.kset = dlm_kset;\n\terror = kobject_init_and_add(&ls->ls_kobj, &dlm_ktype, NULL,\n\t\t\t\t     \"%s\", ls->ls_name);\n\tif (error)\n\t\tgoto out_recoverd;\n\tkobject_uevent(&ls->ls_kobj, KOBJ_ADD);\n\n\t/* let kobject handle freeing of ls if there's an error */\n\tdo_unreg = 1;\n\n\t/* This uevent triggers dlm_controld in userspace to add us to the\n\t   group of nodes that are members of this lockspace (managed by the\n\t   cluster infrastructure.)  Once it's done that, it tells us who the\n\t   current lockspace members are (via configfs) and then tells the\n\t   lockspace to start running (via sysfs) in dlm_ls_start(). */\n\n\terror = do_uevent(ls, 1);\n\tif (error)\n\t\tgoto out_recoverd;\n\n\twait_for_completion(&ls->ls_members_done);\n\terror = ls->ls_members_result;\n\tif (error)\n\t\tgoto out_members;\n\n\tdlm_create_debug_file(ls);\n\n\tlog_rinfo(ls, \"join complete\");\n\t*lockspace = ls;\n\treturn 0;\n\n out_members:\n\tdo_uevent(ls, 0);\n\tdlm_clear_members(ls);\n\tkfree(ls->ls_node_array);\n out_recoverd:\n\tdlm_recoverd_stop(ls);\n out_callback:\n\tdlm_callback_stop(ls);\n out_delist:\n\tspin_lock(&lslist_lock);\n\tlist_del(&ls->ls_list);\n\tspin_unlock(&lslist_lock);\n\tidr_destroy(&ls->ls_recover_idr);\n\tkfree(ls->ls_recover_buf);\n out_lkbidr:\n\tidr_destroy(&ls->ls_lkbidr);\n\tfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\n\t\tif (ls->ls_remove_names[i])\n\t\t\tkfree(ls->ls_remove_names[i]);\n\t}\n out_rsbtbl:\n\tvfree(ls->ls_rsbtbl);\n out_lsfree:\n\tif (do_unreg)\n\t\tkobject_put(&ls->ls_kobj);\n\telse\n\t\tkfree(ls);\n out:\n\tmodule_put(THIS_MODULE);\n\treturn error;\n}"
  },
  {
    "function_name": "threads_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "416-420",
    "snippet": "static void threads_stop(void)\n{\n\tdlm_scand_stop();\n\tdlm_lowcomms_stop();\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lowcomms_stop",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1745-1764",
          "snippet": "void dlm_lowcomms_stop(void)\n{\n\t/* Set all the flags to prevent any\n\t   socket activity.\n\t*/\n\tmutex_lock(&connections_lock);\n\tdlm_allow_conn = 0;\n\tforeach_conn(stop_conn);\n\tmutex_unlock(&connections_lock);\n\n\twork_stop();\n\n\tmutex_lock(&connections_lock);\n\tclean_writequeues();\n\n\tforeach_conn(free_conn);\n\n\tmutex_unlock(&connections_lock);\n\tkmem_cache_destroy(con_cache);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_allow_conn;",
            "static DEFINE_MUTEX(connections_lock);",
            "static struct kmem_cache *con_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nstatic int dlm_allow_conn;\nstatic DEFINE_MUTEX(connections_lock);\nstatic struct kmem_cache *con_cache;\n\nvoid dlm_lowcomms_stop(void)\n{\n\t/* Set all the flags to prevent any\n\t   socket activity.\n\t*/\n\tmutex_lock(&connections_lock);\n\tdlm_allow_conn = 0;\n\tforeach_conn(stop_conn);\n\tmutex_unlock(&connections_lock);\n\n\twork_stop();\n\n\tmutex_lock(&connections_lock);\n\tclean_writequeues();\n\n\tforeach_conn(free_conn);\n\n\tmutex_unlock(&connections_lock);\n\tkmem_cache_destroy(con_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_scand_stop",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_scand_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "312-315",
          "snippet": "static void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *\tscand_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct task_struct *\tscand_task;\n\nstatic void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void threads_stop(void)\n{\n\tdlm_scand_stop();\n\tdlm_lowcomms_stop();\n}"
  },
  {
    "function_name": "threads_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "391-414",
    "snippet": "static int threads_start(void)\n{\n\tint error;\n\n\terror = dlm_scand_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm_scand thread %d\", error);\n\t\tgoto fail;\n\t}\n\n\t/* Thread for sending/receiving messages for all lockspace's */\n\terror = dlm_lowcomms_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm lowcomms %d\", error);\n\t\tgoto scand_fail;\n\t}\n\n\treturn 0;\n\n scand_fail:\n\tdlm_scand_stop();\n fail:\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_scand_stop",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_scand_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "312-315",
          "snippet": "static void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *\tscand_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct task_struct *\tscand_task;\n\nstatic void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"cannot start dlm lowcomms %d\"",
            "error"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_start",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1766-1816",
          "snippet": "int dlm_lowcomms_start(void)\n{\n\tint error = -EINVAL;\n\tstruct connection *con;\n\tint i;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&connection_hash[i]);\n\n\tinit_local();\n\tif (!dlm_local_count) {\n\t\terror = -ENOTCONN;\n\t\tlog_print(\"no local IP address has been set\");\n\t\tgoto fail;\n\t}\n\n\terror = -ENOMEM;\n\tcon_cache = kmem_cache_create(\"dlm_conn\", sizeof(struct connection),\n\t\t\t\t      __alignof__(struct connection), 0,\n\t\t\t\t      NULL);\n\tif (!con_cache)\n\t\tgoto fail;\n\n\terror = work_start();\n\tif (error)\n\t\tgoto fail_destroy;\n\n\tdlm_allow_conn = 1;\n\n\t/* Start listening */\n\tif (dlm_config.ci_protocol == 0)\n\t\terror = tcp_listen_for_all();\n\telse\n\t\terror = sctp_listen_for_all();\n\tif (error)\n\t\tgoto fail_unlisten;\n\n\treturn 0;\n\nfail_unlisten:\n\tdlm_allow_conn = 0;\n\tcon = nodeid2con(0,0);\n\tif (con) {\n\t\tclose_connection(con, false);\n\t\tkmem_cache_free(con_cache, con);\n\t}\nfail_destroy:\n\tkmem_cache_destroy(con_cache);\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CONN_HASH_SIZE 32"
          ],
          "globals_used": [
            "static int dlm_local_count;",
            "static int dlm_allow_conn;",
            "static struct hlist_head connection_hash[CONN_HASH_SIZE];",
            "static struct kmem_cache *con_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CONN_HASH_SIZE 32\n\nstatic int dlm_local_count;\nstatic int dlm_allow_conn;\nstatic struct hlist_head connection_hash[CONN_HASH_SIZE];\nstatic struct kmem_cache *con_cache;\n\nint dlm_lowcomms_start(void)\n{\n\tint error = -EINVAL;\n\tstruct connection *con;\n\tint i;\n\n\tfor (i = 0; i < CONN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&connection_hash[i]);\n\n\tinit_local();\n\tif (!dlm_local_count) {\n\t\terror = -ENOTCONN;\n\t\tlog_print(\"no local IP address has been set\");\n\t\tgoto fail;\n\t}\n\n\terror = -ENOMEM;\n\tcon_cache = kmem_cache_create(\"dlm_conn\", sizeof(struct connection),\n\t\t\t\t      __alignof__(struct connection), 0,\n\t\t\t\t      NULL);\n\tif (!con_cache)\n\t\tgoto fail;\n\n\terror = work_start();\n\tif (error)\n\t\tgoto fail_destroy;\n\n\tdlm_allow_conn = 1;\n\n\t/* Start listening */\n\tif (dlm_config.ci_protocol == 0)\n\t\terror = tcp_listen_for_all();\n\telse\n\t\terror = sctp_listen_for_all();\n\tif (error)\n\t\tgoto fail_unlisten;\n\n\treturn 0;\n\nfail_unlisten:\n\tdlm_allow_conn = 0;\n\tcon = nodeid2con(0,0);\n\tif (con) {\n\t\tclose_connection(con, false);\n\t\tkmem_cache_free(con_cache, con);\n\t}\nfail_destroy:\n\tkmem_cache_destroy(con_cache);\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_scand_start",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_scand_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "299-310",
          "snippet": "static int dlm_scand_start(void)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_scand, NULL, \"dlm_scand\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n\t\tscand_task = p;\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *\tscand_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct task_struct *\tscand_task;\n\nstatic int dlm_scand_start(void)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_scand, NULL, \"dlm_scand\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n\t\tscand_task = p;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int threads_start(void)\n{\n\tint error;\n\n\terror = dlm_scand_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm_scand thread %d\", error);\n\t\tgoto fail;\n\t}\n\n\t/* Thread for sending/receiving messages for all lockspace's */\n\terror = dlm_lowcomms_start();\n\tif (error) {\n\t\tlog_print(\"cannot start dlm lowcomms %d\", error);\n\t\tgoto scand_fail;\n\t}\n\n\treturn 0;\n\n scand_fail:\n\tdlm_scand_stop();\n fail:\n\treturn error;\n}"
  },
  {
    "function_name": "remove_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "376-389",
    "snippet": "static void remove_lockspace(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tspin_lock(&lslist_lock);\n\t\tif (ls->ls_count == 0) {\n\t\t\tWARN_ON(ls->ls_create_count != 0);\n\t\t\tlist_del(&ls->ls_list);\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tssleep(1);\n\t}\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ls->ls_list"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ls->ls_create_count != 0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nstatic void remove_lockspace(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tspin_lock(&lslist_lock);\n\t\tif (ls->ls_count == 0) {\n\t\t\tWARN_ON(ls->ls_create_count != 0);\n\t\t\tlist_del(&ls->ls_list);\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tssleep(1);\n\t}\n}"
  },
  {
    "function_name": "dlm_put_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "369-374",
    "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
  },
  {
    "function_name": "dlm_find_lockspace_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "352-367",
    "snippet": "struct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ls",
            "&lslist",
            "ls_list"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
  },
  {
    "function_name": "dlm_find_lockspace_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "335-350",
    "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ls",
            "&lslist",
            "ls_list"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
  },
  {
    "function_name": "dlm_find_lockspace_global",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "317-333",
    "snippet": "struct dlm_ls *dlm_find_lockspace_global(uint32_t id)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_global_id == id) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ls",
            "&lslist",
            "ls_list"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_global(uint32_t id)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_global_id == id) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
  },
  {
    "function_name": "dlm_scand_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "312-315",
    "snippet": "static void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *\tscand_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "scand_task"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct task_struct *\tscand_task;\n\nstatic void dlm_scand_stop(void)\n{\n\tkthread_stop(scand_task);\n}"
  },
  {
    "function_name": "dlm_scand_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "299-310",
    "snippet": "static int dlm_scand_start(void)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_scand, NULL, \"dlm_scand\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n\t\tscand_task = p;\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *\tscand_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "dlm_scand",
            "NULL",
            "\"dlm_scand\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct task_struct *\tscand_task;\n\nstatic int dlm_scand_start(void)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_run(dlm_scand, NULL, \"dlm_scand\");\n\tif (IS_ERR(p))\n\t\terror = PTR_ERR(p);\n\telse\n\t\tscand_task = p;\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_scand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "276-297",
    "snippet": "static int dlm_scand(void *data)\n{\n\tstruct dlm_ls *ls;\n\n\twhile (!kthread_should_stop()) {\n\t\tls = find_ls_to_scan();\n\t\tif (ls) {\n\t\t\tif (dlm_lock_recovery_try(ls)) {\n\t\t\t\tls->ls_scan_time = jiffies;\n\t\t\t\tdlm_scan_rsbs(ls);\n\t\t\t\tdlm_scan_timeout(ls);\n\t\t\t\tdlm_scan_waiters(ls);\n\t\t\t\tdlm_unlock_recovery(ls);\n\t\t\t} else {\n\t\t\t\tls->ls_scan_time += HZ;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(dlm_config.ci_scan_secs * HZ);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "dlm_config.ci_scan_secs * HZ"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_unlock_recovery",
          "args": [
            "ls"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "210-213",
          "snippet": "void dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\n{\n\tup_read(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_scan_waiters",
          "args": [
            "ls"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_scan_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1395-1448",
          "snippet": "void dlm_scan_waiters(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tktime_t zero = ktime_set(0, 0);\n\ts64 us;\n\ts64 debug_maxus = 0;\n\tu32 debug_scanned = 0;\n\tu32 debug_expired = 0;\n\tint num_nodes = 0;\n\tint *warned = NULL;\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_equal(lkb->lkb_wait_time, zero))\n\t\t\tcontinue;\n\n\t\tdebug_scanned++;\n\n\t\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_wait_time));\n\n\t\tif (us < dlm_config.ci_waitwarn_us)\n\t\t\tcontinue;\n\n\t\tlkb->lkb_wait_time = zero;\n\n\t\tdebug_expired++;\n\t\tif (us > debug_maxus)\n\t\t\tdebug_maxus = us;\n\n\t\tif (!num_nodes) {\n\t\t\tnum_nodes = ls->ls_num_nodes;\n\t\t\twarned = kzalloc(num_nodes * sizeof(int), GFP_KERNEL);\n\t\t}\n\t\tif (!warned)\n\t\t\tcontinue;\n\t\tif (nodeid_warned(lkb->lkb_wait_nodeid, num_nodes, warned))\n\t\t\tcontinue;\n\n\t\tlog_error(ls, \"waitwarn %x %lld %d us check connection to \"\n\t\t\t  \"node %d\", lkb->lkb_id, (long long)us,\n\t\t\t  dlm_config.ci_waitwarn_us, lkb->lkb_wait_nodeid);\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(warned);\n\n\tif (debug_expired)\n\t\tlog_debug(ls, \"scan_waiters %u warn %u over %d us max %lld us\",\n\t\t\t  debug_scanned, debug_expired,\n\t\t\t  dlm_config.ci_waitwarn_us, (long long)debug_maxus);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_scan_waiters(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb;\n\tktime_t zero = ktime_set(0, 0);\n\ts64 us;\n\ts64 debug_maxus = 0;\n\tu32 debug_scanned = 0;\n\tu32 debug_expired = 0;\n\tint num_nodes = 0;\n\tint *warned = NULL;\n\n\tif (!dlm_config.ci_waitwarn_us)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_waiters_mutex);\n\n\tlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\n\t\tif (ktime_equal(lkb->lkb_wait_time, zero))\n\t\t\tcontinue;\n\n\t\tdebug_scanned++;\n\n\t\tus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_wait_time));\n\n\t\tif (us < dlm_config.ci_waitwarn_us)\n\t\t\tcontinue;\n\n\t\tlkb->lkb_wait_time = zero;\n\n\t\tdebug_expired++;\n\t\tif (us > debug_maxus)\n\t\t\tdebug_maxus = us;\n\n\t\tif (!num_nodes) {\n\t\t\tnum_nodes = ls->ls_num_nodes;\n\t\t\twarned = kzalloc(num_nodes * sizeof(int), GFP_KERNEL);\n\t\t}\n\t\tif (!warned)\n\t\t\tcontinue;\n\t\tif (nodeid_warned(lkb->lkb_wait_nodeid, num_nodes, warned))\n\t\t\tcontinue;\n\n\t\tlog_error(ls, \"waitwarn %x %lld %d us check connection to \"\n\t\t\t  \"node %d\", lkb->lkb_id, (long long)us,\n\t\t\t  dlm_config.ci_waitwarn_us, lkb->lkb_wait_nodeid);\n\t}\n\tmutex_unlock(&ls->ls_waiters_mutex);\n\tkfree(warned);\n\n\tif (debug_expired)\n\t\tlog_debug(ls, \"scan_waiters %u warn %u over %d us max %lld us\",\n\t\t\t  debug_scanned, debug_expired,\n\t\t\t  dlm_config.ci_waitwarn_us, (long long)debug_maxus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_scan_timeout",
          "args": [
            "ls"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_scan_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1857-1919",
          "snippet": "void dlm_scan_timeout(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tint do_cancel, do_warn;\n\ts64 wait_us;\n\n\tfor (;;) {\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\n\t\tdo_cancel = 0;\n\t\tdo_warn = 0;\n\t\tmutex_lock(&ls->ls_timeout_mutex);\n\t\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list) {\n\n\t\t\twait_us = ktime_to_us(ktime_sub(ktime_get(),\n\t\t\t\t\t      \t\tlkb->lkb_timestamp));\n\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_TIMEOUT) &&\n\t\t\t    wait_us >= (lkb->lkb_timeout_cs * 10000))\n\t\t\t\tdo_cancel = 1;\n\n\t\t\tif ((lkb->lkb_flags & DLM_IFL_WATCH_TIMEWARN) &&\n\t\t\t    wait_us >= dlm_config.ci_timewarn_cs * 10000)\n\t\t\t\tdo_warn = 1;\n\n\t\t\tif (!do_cancel && !do_warn)\n\t\t\t\tcontinue;\n\t\t\thold_lkb(lkb);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\t\tif (!do_cancel && !do_warn)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tif (do_warn) {\n\t\t\t/* clear flag so we only warn once */\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tif (!(lkb->lkb_exflags & DLM_LKF_TIMEOUT))\n\t\t\t\tdel_timeout(lkb);\n\t\t\tdlm_timeout_warn(lkb);\n\t\t}\n\n\t\tif (do_cancel) {\n\t\t\tlog_debug(ls, \"timeout cancel %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tlkb->lkb_flags |= DLM_IFL_TIMEOUT_CANCEL;\n\t\t\tdel_timeout(lkb);\n\t\t\t_cancel_lock(r, lkb);\n\t\t}\n\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_scan_timeout(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tint do_cancel, do_warn;\n\ts64 wait_us;\n\n\tfor (;;) {\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\n\t\tdo_cancel = 0;\n\t\tdo_warn = 0;\n\t\tmutex_lock(&ls->ls_timeout_mutex);\n\t\tlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list) {\n\n\t\t\twait_us = ktime_to_us(ktime_sub(ktime_get(),\n\t\t\t\t\t      \t\tlkb->lkb_timestamp));\n\n\t\t\tif ((lkb->lkb_exflags & DLM_LKF_TIMEOUT) &&\n\t\t\t    wait_us >= (lkb->lkb_timeout_cs * 10000))\n\t\t\t\tdo_cancel = 1;\n\n\t\t\tif ((lkb->lkb_flags & DLM_IFL_WATCH_TIMEWARN) &&\n\t\t\t    wait_us >= dlm_config.ci_timewarn_cs * 10000)\n\t\t\t\tdo_warn = 1;\n\n\t\t\tif (!do_cancel && !do_warn)\n\t\t\t\tcontinue;\n\t\t\thold_lkb(lkb);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ls->ls_timeout_mutex);\n\n\t\tif (!do_cancel && !do_warn)\n\t\t\tbreak;\n\n\t\tr = lkb->lkb_resource;\n\t\thold_rsb(r);\n\t\tlock_rsb(r);\n\n\t\tif (do_warn) {\n\t\t\t/* clear flag so we only warn once */\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tif (!(lkb->lkb_exflags & DLM_LKF_TIMEOUT))\n\t\t\t\tdel_timeout(lkb);\n\t\t\tdlm_timeout_warn(lkb);\n\t\t}\n\n\t\tif (do_cancel) {\n\t\t\tlog_debug(ls, \"timeout cancel %x node %d %s\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid, r->res_name);\n\t\t\tlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\n\t\t\tlkb->lkb_flags |= DLM_IFL_TIMEOUT_CANCEL;\n\t\t\tdel_timeout(lkb);\n\t\t\t_cancel_lock(r, lkb);\n\t\t}\n\n\t\tunlock_rsb(r);\n\t\tunhold_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_scan_rsbs",
          "args": [
            "ls"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_scan_rsbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1803-1813",
          "snippet": "void dlm_scan_rsbs(struct dlm_ls *ls)\n{\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tshrink_bucket(ls, i);\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nvoid dlm_scan_rsbs(struct dlm_ls *ls)\n{\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tshrink_bucket(ls, i);\n\t\tif (dlm_locking_stopped(ls))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_recovery_try",
          "args": [
            "ls"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_recovery_try",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "215-218",
          "snippet": "int dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nint dlm_lock_recovery_try(struct dlm_ls *ls)\n{\n\treturn down_read_trylock(&ls->ls_in_recovery);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_ls_to_scan",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "find_ls_to_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "260-274",
          "snippet": "static struct dlm_ls *find_ls_to_scan(void)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (time_after_eq(jiffies, ls->ls_scan_time +\n\t\t\t\t\t    dlm_config.ci_scan_secs * HZ)) {\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn ls;\n\t\t}\n\t}\n\tspin_unlock(&lslist_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstatic struct dlm_ls *find_ls_to_scan(void)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (time_after_eq(jiffies, ls->ls_scan_time +\n\t\t\t\t\t    dlm_config.ci_scan_secs * HZ)) {\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn ls;\n\t\t}\n\t}\n\tspin_unlock(&lslist_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int dlm_scand(void *data)\n{\n\tstruct dlm_ls *ls;\n\n\twhile (!kthread_should_stop()) {\n\t\tls = find_ls_to_scan();\n\t\tif (ls) {\n\t\t\tif (dlm_lock_recovery_try(ls)) {\n\t\t\t\tls->ls_scan_time = jiffies;\n\t\t\t\tdlm_scan_rsbs(ls);\n\t\t\t\tdlm_scan_timeout(ls);\n\t\t\t\tdlm_scan_waiters(ls);\n\t\t\t\tdlm_unlock_recovery(ls);\n\t\t\t} else {\n\t\t\t\tls->ls_scan_time += HZ;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(dlm_config.ci_scan_secs * HZ);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "find_ls_to_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "260-274",
    "snippet": "static struct dlm_ls *find_ls_to_scan(void)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (time_after_eq(jiffies, ls->ls_scan_time +\n\t\t\t\t\t    dlm_config.ci_scan_secs * HZ)) {\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn ls;\n\t\t}\n\t}\n\tspin_unlock(&lslist_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lslist_lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "ls->ls_scan_time +\n\t\t\t\t\t    dlm_config.ci_scan_secs * HZ"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ls",
            "&lslist",
            "ls_list"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lslist_lock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstatic struct dlm_ls *find_ls_to_scan(void)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (time_after_eq(jiffies, ls->ls_scan_time +\n\t\t\t\t\t    dlm_config.ci_scan_secs * HZ)) {\n\t\t\tspin_unlock(&lslist_lock);\n\t\t\treturn ls;\n\t\t}\n\t}\n\tspin_unlock(&lslist_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_lockspace_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "255-258",
    "snippet": "void dlm_lockspace_exit(void)\n{\n\tkset_unregister(dlm_kset);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kset *dlm_kset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "dlm_kset"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kset *dlm_kset;\n\nvoid dlm_lockspace_exit(void)\n{\n\tkset_unregister(dlm_kset);\n}"
  },
  {
    "function_name": "dlm_lockspace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "240-253",
    "snippet": "int __init dlm_lockspace_init(void)\n{\n\tls_count = 0;\n\tmutex_init(&ls_lock);\n\tINIT_LIST_HEAD(&lslist);\n\tspin_lock_init(&lslist_lock);\n\n\tdlm_kset = kset_create_and_add(\"dlm\", &dlm_uevent_ops, kernel_kobj);\n\tif (!dlm_kset) {\n\t\tprintk(KERN_WARNING \"%s: can not create kset\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tls_count;",
      "static struct mutex\t\tls_lock;",
      "static struct list_head\t\tlslist;",
      "static spinlock_t\t\tlslist_lock;",
      "static struct kset *dlm_kset;",
      "static struct kset_uevent_ops dlm_uevent_ops = {\n\t.uevent = dlm_uevent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: can not create kset\\n\"",
            "__func__"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"dlm\"",
            "&dlm_uevent_ops",
            "kernel_kobj"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&lslist_lock"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lslist"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls_lock"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\nstatic struct kset *dlm_kset;\nstatic struct kset_uevent_ops dlm_uevent_ops = {\n\t.uevent = dlm_uevent,\n};\n\nint __init dlm_lockspace_init(void)\n{\n\tls_count = 0;\n\tmutex_init(&ls_lock);\n\tINIT_LIST_HEAD(&lslist);\n\tspin_lock_init(&lslist_lock);\n\n\tdlm_kset = kset_create_and_add(\"dlm\", &dlm_uevent_ops, kernel_kobj);\n\tif (!dlm_kset) {\n\t\tprintk(KERN_WARNING \"%s: can not create kset\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_uevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "227-234",
    "snippet": "static int dlm_uevent(struct kset *kset, struct kobject *kobj,\n\t\t      struct kobj_uevent_env *env)\n{\n\tstruct dlm_ls *ls = container_of(kobj, struct dlm_ls, ls_kobj);\n\n\tadd_uevent_var(env, \"LOCKSPACE=%s\", ls->ls_name);\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_uevent_var",
          "args": [
            "env",
            "\"LOCKSPACE=%s\"",
            "ls->ls_name"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structdlm_ls",
            "ls_kobj"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int dlm_uevent(struct kset *kset, struct kobject *kobj,\n\t\t      struct kobj_uevent_env *env)\n{\n\tstruct dlm_ls *ls = container_of(kobj, struct dlm_ls, ls_kobj);\n\n\tadd_uevent_var(env, \"LOCKSPACE=%s\", ls->ls_name);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_uevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "197-225",
    "snippet": "static int do_uevent(struct dlm_ls *ls, int in)\n{\n\tint error;\n\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t/* dlm_controld will see the uevent, do the necessary group management\n\t   and then write to sysfs to wake us */\n\n\terror = wait_event_interruptible(ls->ls_uevent_wait,\n\t\t\ttest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d %d\", error, ls->ls_uevent_result);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = ls->ls_uevent_result;\n out:\n\tif (error)\n\t\tlog_error(ls, \"group %s failed %d %d\", in ? \"join\" : \"leave\",\n\t\t\t  error, ls->ls_uevent_result);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"group %s failed %d %d\"",
            "in ? \"join\" : \"leave\"",
            "error",
            "ls->ls_uevent_result"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"group event done %d %d\"",
            "error",
            "ls->ls_uevent_result"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "ls->ls_uevent_wait",
            "test_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "LSFL_UEVENT_WAIT",
            "&ls->ls_flags"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"%s the lockspace group...\"",
            "in ? \"joining\" : \"leaving\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&ls->ls_kobj",
            "KOBJ_OFFLINE"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int do_uevent(struct dlm_ls *ls, int in)\n{\n\tint error;\n\n\tif (in)\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\n\telse\n\t\tkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\n\n\tlog_rinfo(ls, \"%s the lockspace group...\", in ? \"joining\" : \"leaving\");\n\n\t/* dlm_controld will see the uevent, do the necessary group management\n\t   and then write to sysfs to wake us */\n\n\terror = wait_event_interruptible(ls->ls_uevent_wait,\n\t\t\ttest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\n\n\tlog_rinfo(ls, \"group event done %d %d\", error, ls->ls_uevent_result);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = ls->ls_uevent_result;\n out:\n\tif (error)\n\t\tlog_error(ls, \"group %s failed %d %d\", in ? \"join\" : \"leave\",\n\t\t\t  error, ls->ls_uevent_result);\n\treturn error;\n}"
  },
  {
    "function_name": "lockspace_kobj_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "178-182",
    "snippet": "static void lockspace_kobj_release(struct kobject *k)\n{\n\tstruct dlm_ls *ls  = container_of(k, struct dlm_ls, ls_kobj);\n\tkfree(ls);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "k",
            "structdlm_ls",
            "ls_kobj"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void lockspace_kobj_release(struct kobject *k)\n{\n\tstruct dlm_ls *ls  = container_of(k, struct dlm_ls, ls_kobj);\n\tkfree(ls);\n}"
  },
  {
    "function_name": "dlm_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "170-176",
    "snippet": "static ssize_t dlm_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct dlm_ls *ls  = container_of(kobj, struct dlm_ls, ls_kobj);\n\tstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\n\treturn a->store ? a->store(ls, buf, len) : len;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->store",
          "args": [
            "ls",
            "buf",
            "len"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structdlm_attr",
            "attr"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structdlm_ls",
            "ls_kobj"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct dlm_ls *ls  = container_of(kobj, struct dlm_ls, ls_kobj);\n\tstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\n\treturn a->store ? a->store(ls, buf, len) : len;\n}"
  },
  {
    "function_name": "dlm_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "162-168",
    "snippet": "static ssize_t dlm_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct dlm_ls *ls  = container_of(kobj, struct dlm_ls, ls_kobj);\n\tstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\n\treturn a->show ? a->show(ls, buf) : 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->show",
          "args": [
            "ls",
            "buf"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structdlm_attr",
            "attr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structdlm_ls",
            "ls_kobj"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct dlm_ls *ls  = container_of(kobj, struct dlm_ls, ls_kobj);\n\tstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\n\treturn a->show ? a->show(ls, buf) : 0;\n}"
  },
  {
    "function_name": "dlm_recover_nodeid_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "109-112",
    "snippet": "static ssize_t dlm_recover_nodeid_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ls->ls_recover_nodeid);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "ls->ls_recover_nodeid"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_recover_nodeid_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", ls->ls_recover_nodeid);\n}"
  },
  {
    "function_name": "dlm_recover_status_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "103-107",
    "snippet": "static ssize_t dlm_recover_status_show(struct dlm_ls *ls, char *buf)\n{\n\tuint32_t status = dlm_recover_status(ls);\n\treturn snprintf(buf, PAGE_SIZE, \"%x\\n\", status);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%x\\n\"",
            "status"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_status",
          "args": [
            "ls"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "72-79",
          "snippet": "uint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nuint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_recover_status_show(struct dlm_ls *ls, char *buf)\n{\n\tuint32_t status = dlm_recover_status(ls);\n\treturn snprintf(buf, PAGE_SIZE, \"%x\\n\", status);\n}"
  },
  {
    "function_name": "dlm_nodir_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "91-101",
    "snippet": "static ssize_t dlm_nodir_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint val;\n\tint rc = kstrtoint(buf, 0, &val);\n\n\tif (rc)\n\t\treturn rc;\n\tif (val == 1)\n\t\tset_bit(LSFL_NODIR, &ls->ls_flags);\n\treturn len;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_NODIR",
            "&ls->ls_flags"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&val"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_nodir_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint val;\n\tint rc = kstrtoint(buf, 0, &val);\n\n\tif (rc)\n\t\treturn rc;\n\tif (val == 1)\n\t\tset_bit(LSFL_NODIR, &ls->ls_flags);\n\treturn len;\n}"
  },
  {
    "function_name": "dlm_nodir_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "86-89",
    "snippet": "static ssize_t dlm_nodir_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", dlm_no_directory(ls));\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%u\\n\"",
            "dlm_no_directory(ls)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_nodir_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", dlm_no_directory(ls));\n}"
  },
  {
    "function_name": "dlm_id_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "77-84",
    "snippet": "static ssize_t dlm_id_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint rc = kstrtouint(buf, 0, &ls->ls_global_id);\n\n\tif (rc)\n\t\treturn rc;\n\treturn len;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "0",
            "&ls->ls_global_id"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_id_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint rc = kstrtouint(buf, 0, &ls->ls_global_id);\n\n\tif (rc)\n\t\treturn rc;\n\treturn len;\n}"
  },
  {
    "function_name": "dlm_id_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "72-75",
    "snippet": "static ssize_t dlm_id_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", ls->ls_global_id);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%u\\n\"",
            "ls->ls_global_id"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_id_show(struct dlm_ls *ls, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", ls->ls_global_id);\n}"
  },
  {
    "function_name": "dlm_event_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "61-70",
    "snippet": "static ssize_t dlm_event_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint rc = kstrtoint(buf, 0, &ls->ls_uevent_result);\n\n\tif (rc)\n\t\treturn rc;\n\tset_bit(LSFL_UEVENT_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_uevent_wait);\n\treturn len;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ls->ls_uevent_wait"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_UEVENT_WAIT",
            "&ls->ls_flags"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&ls->ls_uevent_result"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_event_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tint rc = kstrtoint(buf, 0, &ls->ls_uevent_result);\n\n\tif (rc)\n\t\treturn rc;\n\tset_bit(LSFL_UEVENT_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_uevent_wait);\n\treturn len;\n}"
  },
  {
    "function_name": "dlm_control_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
    "lines": "35-59",
    "snippet": "static ssize_t dlm_control_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tssize_t ret = len;\n\tint n;\n\tint rc = kstrtoint(buf, 0, &n);\n\n\tif (rc)\n\t\treturn rc;\n\tls = dlm_find_lockspace_local(ls->ls_local_handle);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tswitch (n) {\n\tcase 0:\n\t\tdlm_ls_stop(ls);\n\t\tbreak;\n\tcase 1:\n\t\tdlm_ls_start(ls);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tdlm_put_lockspace(ls);\n\treturn ret;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"requestqueue.h\"",
      "#include \"recover.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dir.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_ls_start",
          "args": [
            "ls"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_ls_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "674-721",
          "snippet": "int dlm_ls_start(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL, *rv_old;\n\tstruct dlm_config_node *nodes;\n\tint error, count;\n\n\trv = kzalloc(sizeof(struct dlm_recover), GFP_NOFS);\n\tif (!rv)\n\t\treturn -ENOMEM;\n\n\terror = dlm_config_nodes(ls->ls_name, &nodes, &count);\n\tif (error < 0)\n\t\tgoto fail;\n\n\tspin_lock(&ls->ls_recover_lock);\n\n\t/* the lockspace needs to be stopped before it can be started */\n\n\tif (!dlm_locking_stopped(ls)) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_error(ls, \"start ignored: lockspace running\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\trv->nodes = nodes;\n\trv->nodes_count = count;\n\trv->seq = ++ls->ls_recover_seq;\n\trv_old = ls->ls_recover_args;\n\tls->ls_recover_args = rv;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv_old) {\n\t\tlog_error(ls, \"unused recovery %llx %d\",\n\t\t\t  (unsigned long long)rv_old->seq, rv_old->nodes_count);\n\t\tkfree(rv_old->nodes);\n\t\tkfree(rv_old);\n\t}\n\n\tset_bit(LSFL_RECOVER_WORK, &ls->ls_flags);\n\twake_up_process(ls->ls_recoverd_task);\n\treturn 0;\n\n fail:\n\tkfree(rv);\n\tkfree(nodes);\n\treturn error;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_ls_start(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL, *rv_old;\n\tstruct dlm_config_node *nodes;\n\tint error, count;\n\n\trv = kzalloc(sizeof(struct dlm_recover), GFP_NOFS);\n\tif (!rv)\n\t\treturn -ENOMEM;\n\n\terror = dlm_config_nodes(ls->ls_name, &nodes, &count);\n\tif (error < 0)\n\t\tgoto fail;\n\n\tspin_lock(&ls->ls_recover_lock);\n\n\t/* the lockspace needs to be stopped before it can be started */\n\n\tif (!dlm_locking_stopped(ls)) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_error(ls, \"start ignored: lockspace running\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\trv->nodes = nodes;\n\trv->nodes_count = count;\n\trv->seq = ++ls->ls_recover_seq;\n\trv_old = ls->ls_recover_args;\n\tls->ls_recover_args = rv;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv_old) {\n\t\tlog_error(ls, \"unused recovery %llx %d\",\n\t\t\t  (unsigned long long)rv_old->seq, rv_old->nodes_count);\n\t\tkfree(rv_old->nodes);\n\t\tkfree(rv_old);\n\t}\n\n\tset_bit(LSFL_RECOVER_WORK, &ls->ls_flags);\n\twake_up_process(ls->ls_recoverd_task);\n\treturn 0;\n\n fail:\n\tkfree(rv);\n\tkfree(nodes);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_ls_stop",
          "args": [
            "ls"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_ls_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "598-672",
          "snippet": "int dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t/*\n\t * Prevent dlm_recv from being in the middle of something when we do\n\t * the stop.  This includes ensuring dlm_recv isn't processing a\n\t * recovery message (rcom), while dlm_recoverd is aborting and\n\t * resetting things from an in-progress recovery.  i.e. we want\n\t * dlm_recoverd to abort its recovery without worrying about dlm_recv\n\t * processing an rcom at the same time.  Stopping dlm_recv also makes\n\t * it easy for dlm_receive_message() to check locking stopped and add a\n\t * message to the requestqueue without races.\n\t */\n\n\tdown_write(&ls->ls_recv_active);\n\n\t/*\n\t * Abort any recovery that's in progress (see RECOVER_STOP,\n\t * dlm_recovery_stopped()) and tell any other threads running in the\n\t * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).\n\t */\n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t/*\n\t * Let dlm_recv run again, now any normal messages will be saved on the\n\t * requestqueue for later.\n\t */\n\n\tup_write(&ls->ls_recv_active);\n\n\t/*\n\t * This in_recovery lock does two things:\n\t * 1) Keeps this function from returning until all threads are out\n\t *    of locking routines and locking is truly stopped.\n\t * 2) Keeps any new requests from being processed until it's unlocked\n\t *    when recovery is complete.\n\t */\n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t/*\n\t * The recoverd suspend/resume makes sure that dlm_recoverd (if\n\t * running) has noticed RECOVER_STOP above and quit processing the\n\t * previous recovery.\n\t */\n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\tdlm_lsop_recover_prep(ls);\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t/*\n\t * Prevent dlm_recv from being in the middle of something when we do\n\t * the stop.  This includes ensuring dlm_recv isn't processing a\n\t * recovery message (rcom), while dlm_recoverd is aborting and\n\t * resetting things from an in-progress recovery.  i.e. we want\n\t * dlm_recoverd to abort its recovery without worrying about dlm_recv\n\t * processing an rcom at the same time.  Stopping dlm_recv also makes\n\t * it easy for dlm_receive_message() to check locking stopped and add a\n\t * message to the requestqueue without races.\n\t */\n\n\tdown_write(&ls->ls_recv_active);\n\n\t/*\n\t * Abort any recovery that's in progress (see RECOVER_STOP,\n\t * dlm_recovery_stopped()) and tell any other threads running in the\n\t * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).\n\t */\n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t/*\n\t * Let dlm_recv run again, now any normal messages will be saved on the\n\t * requestqueue for later.\n\t */\n\n\tup_write(&ls->ls_recv_active);\n\n\t/*\n\t * This in_recovery lock does two things:\n\t * 1) Keeps this function from returning until all threads are out\n\t *    of locking routines and locking is truly stopped.\n\t * 2) Keeps any new requests from being processed until it's unlocked\n\t *    when recovery is complete.\n\t */\n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t/*\n\t * The recoverd suspend/resume makes sure that dlm_recoverd (if\n\t * running) has noticed RECOVER_STOP above and quit processing the\n\t * previous recovery.\n\t */\n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\tdlm_lsop_recover_prep(ls);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "ls->ls_local_handle"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&n"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic ssize_t dlm_control_store(struct dlm_ls *ls, const char *buf, size_t len)\n{\n\tssize_t ret = len;\n\tint n;\n\tint rc = kstrtoint(buf, 0, &n);\n\n\tif (rc)\n\t\treturn rc;\n\tls = dlm_find_lockspace_local(ls->ls_local_handle);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tswitch (n) {\n\tcase 0:\n\t\tdlm_ls_stop(ls);\n\t\tbreak;\n\tcase 1:\n\t\tdlm_ls_start(ls);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tdlm_put_lockspace(ls);\n\treturn ret;\n}"
  }
]