[
  {
    "function_name": "affs_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
    "lines": "340-412",
    "snippet": "int\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_unlock_link",
          "args": [
            "inode"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "286-290",
          "snippet": "static inline void\naffs_unlock_link(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_link_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_link(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_link_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "sb",
            "block"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_unlock_dir",
          "args": [
            "dir"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "296-300",
          "snippet": "static inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_insert_hash",
          "args": [
            "dir",
            "bh"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "affs_insert_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "22-65",
          "snippet": "int\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_dir",
          "args": [
            "dir"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "291-295",
          "snippet": "static inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_adjust_checksum",
          "args": [
            "inode_bh",
            "block - be32_to_cpu(chain)"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "affs_adjust_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "268-273",
          "snippet": "static inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\n\nstatic inline void\naffs_adjust_checksum(struct buffer_head *bh, u32 val)\n{\n\tu32 tmp = be32_to_cpu(((__be32 *)bh->b_data)[5]);\n\t((__be32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "chain"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "block"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "inode_bh"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_ino"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "inode_bh"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dir->i_ino"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "type"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_copy_name",
          "args": [
            "AFFS_TAIL(sb, bh)->name",
            "dentry"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "affs_copy_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "507-515",
          "snippet": "int\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "T_SHORT"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_getzeroblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getzeroblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "463-480",
          "snippet": "static inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_alloc_block",
          "args": [
            "dir",
            "dir->i_ino"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "affs_alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "113-241",
          "snippet": "u32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_link",
          "args": [
            "inode"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "281-285",
          "snippet": "static inline void\naffs_lock_link(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_link_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_link(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_link_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\"",
            "__func__",
            "dir->i_ino",
            "inode->i_ino",
            "dentry",
            "type"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
  },
  {
    "function_name": "affs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
    "lines": "283-333",
    "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "sb",
            "block"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&AFFS_I(inode)->i_opencnt",
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_getzeroblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "affs_getzeroblk_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "463-480",
          "snippet": "static inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic inline struct buffer_head *\naffs_getzeroblk_ino(struct inode *inode, int block)\n{\n\tstruct buffer_head *bh, tmp_bh;\n\tint err;\n\n\ttmp_bh.b_state = 0;\n\terr = affs_get_block(inode, block, &tmp_bh, 1);\n\tif (!err) {\n\t\tbh = affs_getzeroblk(inode->i_sb, tmp_bh.b_blocknr);\n\t\tif (bh) {\n\t\t\tbh->b_state |= tmp_bh.b_state;\n\t\t\treturn bh;\n\t\t}\n\t\terr = -EIO;\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_alloc_block",
          "args": [
            "dir",
            "dir->i_ino"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "affs_alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "113-241",
          "snippet": "u32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_alloc_block(struct inode *inode, u32 goal)\n{\n\tstruct super_block *sb;\n\tstruct affs_sb_info *sbi;\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\t__be32 *data, *enddata;\n\tu32 blk, bmap, bit, mask, mask2, tmp;\n\tint i;\n\n\tsb = inode->i_sb;\n\tsbi = AFFS_SB(sb);\n\n\tpr_debug(\"balloc(inode=%lu,goal=%u): \", inode->i_ino, goal);\n\n\tif (AFFS_I(inode)->i_pa_cnt) {\n\t\tpr_debug(\"%d\\n\", AFFS_I(inode)->i_lastalloc+1);\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\treturn ++AFFS_I(inode)->i_lastalloc;\n\t}\n\n\tif (!goal || goal > sbi->s_partition_size) {\n\t\tif (goal)\n\t\t\taffs_warning(sb, \"affs_balloc\", \"invalid goal %d\", goal);\n\t\t//if (!AFFS_I(inode)->i_last_block)\n\t\t//\taffs_warning(sb, \"affs_balloc\", \"no last alloc block\");\n\t\tgoal = sbi->s_reserved;\n\t}\n\n\tblk = goal - sbi->s_reserved;\n\tbmap = blk / sbi->s_bmap_bits;\n\tbm = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tif (bm->bm_free)\n\t\tgoto find_bmap_bit;\n\nfind_bmap:\n\t/* search for the next bmap buffer with free bits */\n\ti = sbi->s_bmap_count;\n\tdo {\n\t\tif (--i < 0)\n\t\t\tgoto err_full;\n\t\tbmap++;\n\t\tbm++;\n\t\tif (bmap < sbi->s_bmap_count)\n\t\t\tcontinue;\n\t\t/* restart search at zero */\n\t\tbmap = 0;\n\t\tbm = sbi->s_bitmap;\n\t} while (!bm->bm_free);\n\tblk = bmap * sbi->s_bmap_bits;\n\nfind_bmap_bit:\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\t/* find an unused block in this bitmap block */\n\tbit = blk % sbi->s_bmap_bits;\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\tenddata = (__be32 *)((u8 *)bh->b_data + sb->s_blocksize);\n\tmask = ~0UL << (bit & 31);\n\tblk &= ~31UL;\n\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto find_bit;\n\n\t/* scan the rest of the buffer */\n\tdo {\n\t\tblk += 32;\n\t\tif (++data >= enddata)\n\t\t\t/* didn't find something, can only happen\n\t\t\t * if scan didn't start at 0, try next bmap\n\t\t\t */\n\t\t\tgoto find_bmap;\n\t} while (!*data);\n\ttmp = be32_to_cpu(*data);\n\tmask = ~0;\n\nfind_bit:\n\t/* finally look for a free bit in the word */\n\tbit = ffs(tmp & mask) - 1;\n\tblk += bit + sbi->s_reserved;\n\tmask2 = mask = 1 << (bit & 31);\n\tAFFS_I(inode)->i_lastalloc = blk;\n\n\t/* prealloc as much as possible within this word */\n\twhile ((mask2 <<= 1)) {\n\t\tif (!(tmp & mask2))\n\t\t\tbreak;\n\t\tAFFS_I(inode)->i_pa_cnt++;\n\t\tmask |= mask2;\n\t}\n\tbm->bm_free -= AFFS_I(inode)->i_pa_cnt + 1;\n\n\t*data = cpu_to_be32(tmp & ~mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\n\tmutex_unlock(&sbi->s_bmlock);\n\n\tpr_debug(\"%d\\n\", blk);\n\treturn blk;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_read_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\nerr_full:\n\tmutex_unlock(&sbi->s_bmlock);\n\tpr_debug(\"failed\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
  },
  {
    "function_name": "affs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
    "lines": "252-281",
    "snippet": "void\naffs_evict_inode(struct inode *inode)\n{\n\tunsigned long cache_page;\n\tpr_debug(\"evict_inode(ino=%lu, nlink=%u)\\n\",\n\t\t inode->i_ino, inode->i_nlink);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\taffs_truncate(inode);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\taffs_free_prealloc(inode);\n\tcache_page = (unsigned long)AFFS_I(inode)->i_lc;\n\tif (cache_page) {\n\t\tpr_debug(\"freeing ext cache\\n\");\n\t\tAFFS_I(inode)->i_lc = NULL;\n\t\tAFFS_I(inode)->i_ac = NULL;\n\t\tfree_page(cache_page);\n\t}\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\n\tif (!inode->i_nlink)\n\t\taffs_free_block(inode->i_sb, inode->i_ino);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_free_block",
          "args": [
            "inode->i_sb",
            "inode->i_ino"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "37-102",
          "snippet": "void\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid\naffs_free_block(struct super_block *sb, u32 block)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bh;\n\tu32 blk, bmap, bit, mask, tmp;\n\t__be32 *data;\n\n\tpr_debug(\"%s(%u)\\n\", __func__, block);\n\n\tif (block > sbi->s_partition_size)\n\t\tgoto err_range;\n\n\tblk     = block - sbi->s_reserved;\n\tbmap    = blk / sbi->s_bmap_bits;\n\tbit     = blk % sbi->s_bmap_bits;\n\tbm      = &sbi->s_bitmap[bmap];\n\n\tmutex_lock(&sbi->s_bmlock);\n\n\tbh = sbi->s_bmap_bh;\n\tif (sbi->s_last_bmap != bmap) {\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh)\n\t\t\tgoto err_bh_read;\n\t\tsbi->s_bmap_bh = bh;\n\t\tsbi->s_last_bmap = bmap;\n\t}\n\n\tmask = 1 << (bit & 31);\n\tdata = (__be32 *)bh->b_data + bit / 32 + 1;\n\n\t/* mark block free */\n\ttmp = be32_to_cpu(*data);\n\tif (tmp & mask)\n\t\tgoto err_free;\n\t*data = cpu_to_be32(tmp | mask);\n\n\t/* fix checksum */\n\ttmp = be32_to_cpu(*(__be32 *)bh->b_data);\n\t*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);\n\n\tmark_buffer_dirty(bh);\n\taffs_mark_sb_dirty(sb);\n\tbm->bm_free++;\n\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_free:\n\taffs_warning(sb,\"affs_free_block\",\"Trying to free block %u which is already free\", block);\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_bh_read:\n\taffs_error(sb,\"affs_free_block\",\"Cannot read bitmap block %u\", bm->bm_key);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tmutex_unlock(&sbi->s_bmlock);\n\treturn;\n\nerr_range:\n\taffs_error(sb, \"affs_free_block\",\"Block %u outside partition\", block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "AFFS_I(inode)->i_ext_bh"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "cache_page"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"freeing ext cache\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_free_prealloc",
          "args": [
            "inode"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "819-830",
          "snippet": "void\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nvoid\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_truncate",
          "args": [
            "inode"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "affs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "834-951",
          "snippet": "void\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nvoid\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"evict_inode(ino=%lu, nlink=%u)\\n\"",
            "inode->i_ino",
            "inode->i_nlink"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nvoid\naffs_evict_inode(struct inode *inode)\n{\n\tunsigned long cache_page;\n\tpr_debug(\"evict_inode(ino=%lu, nlink=%u)\\n\",\n\t\t inode->i_ino, inode->i_nlink);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\taffs_truncate(inode);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\taffs_free_prealloc(inode);\n\tcache_page = (unsigned long)AFFS_I(inode)->i_lc;\n\tif (cache_page) {\n\t\tpr_debug(\"freeing ext cache\\n\");\n\t\tAFFS_I(inode)->i_lc = NULL;\n\t\tAFFS_I(inode)->i_ac = NULL;\n\t\tfree_page(cache_page);\n\t}\n\taffs_brelse(AFFS_I(inode)->i_ext_bh);\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\n\tif (!inode->i_nlink)\n\t\taffs_free_block(inode->i_sb, inode->i_ino);\n}"
  },
  {
    "function_name": "affs_notify_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
    "lines": "212-250",
    "snippet": "int\naffs_notify_change(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tpr_debug(\"notify_change(%lu,0x%x)\\n\", inode->i_ino, attr->ia_valid);\n\n\terror = inode_change_ok(inode,attr);\n\tif (error)\n\t\tgoto out;\n\n\tif (((attr->ia_valid & ATTR_UID) && (AFFS_SB(inode->i_sb)->s_flags & SF_SETUID)) ||\n\t    ((attr->ia_valid & ATTR_GID) && (AFFS_SB(inode->i_sb)->s_flags & SF_SETGID)) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (AFFS_SB(inode->i_sb)->s_flags & (SF_SETMODE | SF_IMMUTABLE)))) {\n\t\tif (!(AFFS_SB(inode->i_sb)->s_flags & SF_QUIET))\n\t\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\taffs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\tmode_to_prot(inode);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mode_to_prot",
          "args": [
            "inode"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "mode_to_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "414-440",
          "snippet": "void\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_truncate",
          "args": [
            "inode"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "affs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "834-951",
          "snippet": "void\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nstatic struct buffer_head *affs_get_extblock_slow(struct inode *inode, u32 ext);\n\nvoid\naffs_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 ext, ext_key;\n\tu32 last_blk, blkcnt, blk;\n\tu32 size;\n\tstruct buffer_head *ext_bh;\n\tint i;\n\n\tpr_debug(\"truncate(inode=%lu, oldsize=%llu, newsize=%llu)\\n\",\n\t\t inode->i_ino, AFFS_I(inode)->mmu_private, inode->i_size);\n\n\tlast_blk = 0;\n\text = 0;\n\tif (inode->i_size) {\n\t\tlast_blk = ((u32)inode->i_size - 1) / AFFS_SB(sb)->s_data_blksize;\n\t\text = last_blk / AFFS_SB(sb)->s_hashsize;\n\t}\n\n\tif (inode->i_size > AFFS_I(inode)->mmu_private) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t isize = inode->i_size;\n\t\tint res;\n\n\t\tres = mapping->a_ops->write_begin(NULL, mapping, isize, 0, 0, &page, &fsdata);\n\t\tif (!res)\n\t\t\tres = mapping->a_ops->write_end(NULL, mapping, isize, 0, 0, page, fsdata);\n\t\telse\n\t\t\tinode->i_size = AFFS_I(inode)->mmu_private;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == AFFS_I(inode)->mmu_private)\n\t\treturn;\n\n\t// lock cache\n\text_bh = affs_get_extblock(inode, ext);\n\tif (IS_ERR(ext_bh)) {\n\t\taffs_warning(sb, \"truncate\",\n\t\t\t     \"unexpected read error for ext block %u (%ld)\",\n\t\t\t     ext, PTR_ERR(ext_bh));\n\t\treturn;\n\t}\n\tif (AFFS_I(inode)->i_lc) {\n\t\t/* clear linear cache */\n\t\ti = (ext + 1) >> AFFS_I(inode)->i_lc_shift;\n\t\tif (AFFS_I(inode)->i_lc_size > i) {\n\t\t\tAFFS_I(inode)->i_lc_size = i;\n\t\t\tfor (; i < AFFS_LC_SIZE; i++)\n\t\t\t\tAFFS_I(inode)->i_lc[i] = 0;\n\t\t}\n\t\t/* clear associative cache */\n\t\tfor (i = 0; i < AFFS_AC_SIZE; i++)\n\t\t\tif (AFFS_I(inode)->i_ac[i].ext >= ext)\n\t\t\t\tAFFS_I(inode)->i_ac[i].ext = 0;\n\t}\n\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\n\tblkcnt = AFFS_I(inode)->i_blkcnt;\n\ti = 0;\n\tblk = last_blk;\n\tif (inode->i_size) {\n\t\ti = last_blk % AFFS_SB(sb)->s_hashsize + 1;\n\t\tblk++;\n\t} else\n\t\tAFFS_HEAD(ext_bh)->first_data = 0;\n\tAFFS_HEAD(ext_bh)->block_count = cpu_to_be32(i);\n\tsize = AFFS_SB(sb)->s_hashsize;\n\tif (size > blkcnt - blk + i)\n\t\tsize = blkcnt - blk + i;\n\tfor (; i < size; i++, blk++) {\n\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\tAFFS_BLOCK(sb, ext_bh, i) = 0;\n\t}\n\tAFFS_TAIL(sb, ext_bh)->extension = 0;\n\taffs_fix_checksum(sb, ext_bh);\n\tmark_buffer_dirty_inode(ext_bh, inode);\n\taffs_brelse(ext_bh);\n\n\tif (inode->i_size) {\n\t\tAFFS_I(inode)->i_blkcnt = last_blk + 1;\n\t\tAFFS_I(inode)->i_extcnt = ext + 1;\n\t\tif (AFFS_SB(sb)->s_flags & SF_OFS) {\n\t\t\tstruct buffer_head *bh = affs_bread_ino(inode, last_blk, 0);\n\t\t\tu32 tmp;\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\taffs_warning(sb, \"truncate\",\n\t\t\t\t\t     \"unexpected read error for last block %u (%ld)\",\n\t\t\t\t\t     ext, PTR_ERR(bh));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = be32_to_cpu(AFFS_DATA_HEAD(bh)->next);\n\t\t\tAFFS_DATA_HEAD(bh)->next = 0;\n\t\t\taffs_adjust_checksum(bh, -tmp);\n\t\t\taffs_brelse(bh);\n\t\t}\n\t} else {\n\t\tAFFS_I(inode)->i_blkcnt = 0;\n\t\tAFFS_I(inode)->i_extcnt = 1;\n\t}\n\tAFFS_I(inode)->mmu_private = inode->i_size;\n\t// unlock cache\n\n\twhile (ext_key) {\n\t\text_bh = affs_bread(sb, ext_key);\n\t\tsize = AFFS_SB(sb)->s_hashsize;\n\t\tif (size > blkcnt - blk)\n\t\t\tsize = blkcnt - blk;\n\t\tfor (i = 0; i < size; i++, blk++)\n\t\t\taffs_free_block(sb, be32_to_cpu(AFFS_BLOCK(sb, ext_bh, i)));\n\t\taffs_free_block(sb, ext_key);\n\t\text_key = be32_to_cpu(AFFS_TAIL(sb, ext_bh)->extension);\n\t\taffs_brelse(ext_bh);\n\t}\n\taffs_free_prealloc(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"notify_change(%lu,0x%x)\\n\"",
            "inode->i_ino",
            "attr->ia_valid"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_notify_change(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tpr_debug(\"notify_change(%lu,0x%x)\\n\", inode->i_ino, attr->ia_valid);\n\n\terror = inode_change_ok(inode,attr);\n\tif (error)\n\t\tgoto out;\n\n\tif (((attr->ia_valid & ATTR_UID) && (AFFS_SB(inode->i_sb)->s_flags & SF_SETUID)) ||\n\t    ((attr->ia_valid & ATTR_GID) && (AFFS_SB(inode->i_sb)->s_flags & SF_SETGID)) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (AFFS_SB(inode->i_sb)->s_flags & (SF_SETMODE | SF_IMMUTABLE)))) {\n\t\tif (!(AFFS_SB(inode->i_sb)->s_flags & SF_QUIET))\n\t\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\taffs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\tmode_to_prot(inode);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "affs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
    "lines": "164-210",
    "snippet": "int\naffs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tuid_t\t\t\t uid;\n\tgid_t\t\t\t gid;\n\n\tpr_debug(\"write_inode(%lu)\\n\", inode->i_ino);\n\n\tif (!inode->i_nlink)\n\t\t// possibly free block\n\t\treturn 0;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\taffs_error(sb,\"write_inode\",\"Cannot read block %lu\",inode->i_ino);\n\t\treturn -EIO;\n\t}\n\ttail = AFFS_TAIL(sb, bh);\n\tif (tail->stype == cpu_to_be32(ST_ROOT)) {\n\t\tsecs_to_datestamp(inode->i_mtime.tv_sec,&AFFS_ROOT_TAIL(sb, bh)->root_change);\n\t} else {\n\t\ttail->protect = cpu_to_be32(AFFS_I(inode)->i_protect);\n\t\ttail->size = cpu_to_be32(inode->i_size);\n\t\tsecs_to_datestamp(inode->i_mtime.tv_sec,&tail->change);\n\t\tif (!(inode->i_ino == AFFS_SB(sb)->s_root_block)) {\n\t\t\tuid = i_uid_read(inode);\n\t\t\tgid = i_gid_read(inode);\n\t\t\tif (AFFS_SB(sb)->s_flags & SF_MUFS) {\n\t\t\t\tif (uid == 0 || uid == 0xFFFF)\n\t\t\t\t\tuid = uid ^ ~0;\n\t\t\t\tif (gid == 0 || gid == 0xFFFF)\n\t\t\t\t\tgid = gid ^ ~0;\n\t\t\t}\n\t\t\tif (!(AFFS_SB(sb)->s_flags & SF_SETUID))\n\t\t\t\ttail->uid = cpu_to_be16(uid);\n\t\t\tif (!(AFFS_SB(sb)->s_flags & SF_SETGID))\n\t\t\t\ttail->gid = cpu_to_be16(gid);\n\t\t}\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\taffs_free_prealloc(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_free_prealloc",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/file.c",
          "lines": "819-830",
          "snippet": "void\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/aio.h>\n\nvoid\naffs_free_prealloc(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tpr_debug(\"free_prealloc(ino=%lu)\\n\", inode->i_ino);\n\n\twhile (AFFS_I(inode)->i_pa_cnt) {\n\t\tAFFS_I(inode)->i_pa_cnt--;\n\t\taffs_free_block(sb, ++AFFS_I(inode)->i_lastalloc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "gid"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "uid"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secs_to_datestamp",
          "args": [
            "inode->i_mtime.tv_sec",
            "&tail->change"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "secs_to_datestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "368-385",
          "snippet": "void\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = secs / 86400;\n\tsecs   -= days * 86400;\n\tminute  = secs / 60;\n\tsecs   -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(secs * 50);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = secs / 86400;\n\tsecs   -= days * 86400;\n\tminute  = secs / 60;\n\tsecs   -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(secs * 50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_size"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "AFFS_I(inode)->i_protect"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ST_ROOT"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_error",
          "args": [
            "sb",
            "\"write_inode\"",
            "\"Cannot read block %lu\"",
            "inode->i_ino"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "affs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "442-456",
          "snippet": "void\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"write_inode(%lu)\\n\"",
            "inode->i_ino"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tuid_t\t\t\t uid;\n\tgid_t\t\t\t gid;\n\n\tpr_debug(\"write_inode(%lu)\\n\", inode->i_ino);\n\n\tif (!inode->i_nlink)\n\t\t// possibly free block\n\t\treturn 0;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\taffs_error(sb,\"write_inode\",\"Cannot read block %lu\",inode->i_ino);\n\t\treturn -EIO;\n\t}\n\ttail = AFFS_TAIL(sb, bh);\n\tif (tail->stype == cpu_to_be32(ST_ROOT)) {\n\t\tsecs_to_datestamp(inode->i_mtime.tv_sec,&AFFS_ROOT_TAIL(sb, bh)->root_change);\n\t} else {\n\t\ttail->protect = cpu_to_be32(AFFS_I(inode)->i_protect);\n\t\ttail->size = cpu_to_be32(inode->i_size);\n\t\tsecs_to_datestamp(inode->i_mtime.tv_sec,&tail->change);\n\t\tif (!(inode->i_ino == AFFS_SB(sb)->s_root_block)) {\n\t\t\tuid = i_uid_read(inode);\n\t\t\tgid = i_gid_read(inode);\n\t\t\tif (AFFS_SB(sb)->s_flags & SF_MUFS) {\n\t\t\t\tif (uid == 0 || uid == 0xFFFF)\n\t\t\t\t\tuid = uid ^ ~0;\n\t\t\t\tif (gid == 0 || gid == 0xFFFF)\n\t\t\t\t\tgid = gid ^ ~0;\n\t\t\t}\n\t\t\tif (!(AFFS_SB(sb)->s_flags & SF_SETUID))\n\t\t\t\ttail->uid = cpu_to_be16(uid);\n\t\t\tif (!(AFFS_SB(sb)->s_flags & SF_SETGID))\n\t\t\t\ttail->gid = cpu_to_be16(gid);\n\t\t}\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\taffs_free_prealloc(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
    "lines": "16-162",
    "snippet": "struct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->change.ticks"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->change.mins"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->change.days"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->size"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"read_inode\"",
            "\"inode is LINKFILE\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->stype"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->stype"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "id"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "tail->gid"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "id"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "tail->uid"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prot_to_mode",
          "args": [
            "prot"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "prot_to_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "387-412",
          "snippet": "umode_t\nprot_to_mode(u32 prot)\n{\n\tumode_t mode = 0;\n\n\tif (!(prot & FIBF_NOWRITE))\n\t\tmode |= S_IWUSR;\n\tif (!(prot & FIBF_NOREAD))\n\t\tmode |= S_IRUSR;\n\tif (!(prot & FIBF_NOEXECUTE))\n\t\tmode |= S_IXUSR;\n\tif (prot & FIBF_GRP_WRITE)\n\t\tmode |= S_IWGRP;\n\tif (prot & FIBF_GRP_READ)\n\t\tmode |= S_IRGRP;\n\tif (prot & FIBF_GRP_EXECUTE)\n\t\tmode |= S_IXGRP;\n\tif (prot & FIBF_OTR_WRITE)\n\t\tmode |= S_IWOTH;\n\tif (prot & FIBF_OTR_READ)\n\t\tmode |= S_IROTH;\n\tif (prot & FIBF_OTR_EXECUTE)\n\t\tmode |= S_IXOTH;\n\n\treturn mode;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\numode_t\nprot_to_mode(u32 prot)\n{\n\tumode_t mode = 0;\n\n\tif (!(prot & FIBF_NOWRITE))\n\t\tmode |= S_IWUSR;\n\tif (!(prot & FIBF_NOREAD))\n\t\tmode |= S_IRUSR;\n\tif (!(prot & FIBF_NOEXECUTE))\n\t\tmode |= S_IXUSR;\n\tif (prot & FIBF_GRP_WRITE)\n\t\tmode |= S_IWGRP;\n\tif (prot & FIBF_GRP_READ)\n\t\tmode |= S_IRGRP;\n\tif (prot & FIBF_GRP_EXECUTE)\n\t\tmode |= S_IXGRP;\n\tif (prot & FIBF_OTR_WRITE)\n\t\tmode |= S_IWOTH;\n\tif (prot & FIBF_OTR_READ)\n\t\tmode |= S_IROTH;\n\tif (prot & FIBF_OTR_EXECUTE)\n\t\tmode |= S_IXOTH;\n\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&AFFS_I(inode)->i_opencnt",
            "0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tail->protect"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(bh)->ptype"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_checksum_block",
          "args": [
            "sb",
            "bh"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "affs_checksum_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "335-346",
          "snippet": "u32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nu32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"affs_iget(%lu)\\n\"",
            "inode->i_ino"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
  }
]