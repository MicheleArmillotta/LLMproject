[
  {
    "function_name": "sysfs_remove_link_from_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "338-348",
    "snippet": "void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,\n\t\t\t\t  const char *link_name)\n{\n\tstruct kernfs_node *parent;\n\n\tparent = kernfs_find_and_get(kobj->sd, group_name);\n\tif (parent) {\n\t\tkernfs_remove_by_name(parent, link_name);\n\t\tkernfs_put(parent);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "link_name"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "group_name"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,\n\t\t\t\t  const char *link_name)\n{\n\tstruct kernfs_node *parent;\n\n\tparent = kernfs_find_and_get(kobj->sd, group_name);\n\tif (parent) {\n\t\tkernfs_remove_by_name(parent, link_name);\n\t\tkernfs_put(parent);\n\t}\n}"
  },
  {
    "function_name": "sysfs_add_link_to_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "315-329",
    "snippet": "int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,\n\t\t\t    struct kobject *target, const char *link_name)\n{\n\tstruct kernfs_node *parent;\n\tint error = 0;\n\n\tparent = kernfs_find_and_get(kobj->sd, group_name);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_create_link_sd(parent, target, link_name);\n\tkernfs_put(parent);\n\n\treturn error;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_link_sd",
          "args": [
            "parent",
            "target",
            "link_name"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_link_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "61-65",
          "snippet": "int sysfs_create_link_sd(struct kernfs_node *kn, struct kobject *target,\n\t\t\t const char *name)\n{\n\treturn sysfs_do_create_link_sd(kn, target, name, 1);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_create_link_sd(struct kernfs_node *kn, struct kobject *target,\n\t\t\t const char *name)\n{\n\treturn sysfs_do_create_link_sd(kn, target, name, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "group_name"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,\n\t\t\t    struct kobject *target, const char *link_name)\n{\n\tstruct kernfs_node *parent;\n\tint error = 0;\n\n\tparent = kernfs_find_and_get(kobj->sd, group_name);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_create_link_sd(parent, target, link_name);\n\tkernfs_put(parent);\n\n\treturn error;\n}"
  },
  {
    "function_name": "sysfs_unmerge_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "293-305",
    "snippet": "void sysfs_unmerge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent;\n\tstruct attribute *const *attr;\n\n\tparent = kernfs_find_and_get(kobj->sd, grp->name);\n\tif (parent) {\n\t\tfor (attr = grp->attrs; *attr; ++attr)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\tkernfs_put(parent);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "(*attr)->name"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "grp->name"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_unmerge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent;\n\tstruct attribute *const *attr;\n\n\tparent = kernfs_find_and_get(kobj->sd, grp->name);\n\tif (parent) {\n\t\tfor (attr = grp->attrs; *attr; ++attr)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\tkernfs_put(parent);\n\t}\n}"
  },
  {
    "function_name": "sysfs_merge_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "264-285",
    "snippet": "int sysfs_merge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent;\n\tint error = 0;\n\tstruct attribute *const *attr;\n\tint i;\n\n\tparent = kernfs_find_and_get(kobj->sd, grp->name);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tfor ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))\n\t\terror = sysfs_add_file(parent, *attr, false);\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tkernfs_remove_by_name(parent, (*--attr)->name);\n\t}\n\tkernfs_put(parent);\n\n\treturn error;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "(*--attr)->name"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_add_file",
          "args": [
            "parent",
            "*attr",
            "false"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_add_file_to_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "349-369",
          "snippet": "int sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nint sysfs_add_file_to_group(struct kobject *kobj,\n\t\tconst struct attribute *attr, const char *group)\n{\n\tstruct kernfs_node *parent;\n\tint error;\n\n\tif (group) {\n\t\tparent = kernfs_find_and_get(kobj->sd, group);\n\t} else {\n\t\tparent = kobj->sd;\n\t\tkernfs_get(parent);\n\t}\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\terror = sysfs_add_file(parent, attr, false);\n\tkernfs_put(parent);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "kobj->sd",
            "grp->name"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_merge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent;\n\tint error = 0;\n\tstruct attribute *const *attr;\n\tint i;\n\n\tparent = kernfs_find_and_get(kobj->sd, grp->name);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tfor ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))\n\t\terror = sysfs_add_file(parent, *attr, false);\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tkernfs_remove_by_name(parent, (*--attr)->name);\n\t}\n\tkernfs_put(parent);\n\n\treturn error;\n}"
  },
  {
    "function_name": "sysfs_remove_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "243-252",
    "snippet": "void sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "kobj",
            "groups[i]"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "243-252",
          "snippet": "void sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}"
  },
  {
    "function_name": "sysfs_remove_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "208-232",
    "snippet": "void sysfs_remove_group(struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\tstruct kernfs_node *kn;\n\n\tif (grp->name) {\n\t\tkn = kernfs_find_and_get(parent, grp->name);\n\t\tif (!kn) {\n\t\t\tWARN(!kn, KERN_WARNING\n\t\t\t     \"sysfs group %p not found for kobject '%s'\\n\",\n\t\t\t     grp, kobject_name(kobj));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tkn = parent;\n\t\tkernfs_get(kn);\n\t}\n\n\tremove_files(kn, grp);\n\tif (grp->name)\n\t\tkernfs_remove(kn);\n\n\tkernfs_put(kn);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1144-1193",
          "snippet": "bool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_files",
          "args": [
            "kn",
            "grp"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "remove_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "21-33",
          "snippet": "static void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!kn",
            "KERN_WARNING\n\t\t\t     \"sysfs group %p not found for kobject '%s'\\n\"",
            "grp",
            "kobject_name(kobj)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "kobj"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get",
          "args": [
            "parent",
            "grp->name"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_remove_group(struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp)\n{\n\tstruct kernfs_node *parent = kobj->sd;\n\tstruct kernfs_node *kn;\n\n\tif (grp->name) {\n\t\tkn = kernfs_find_and_get(parent, grp->name);\n\t\tif (!kn) {\n\t\t\tWARN(!kn, KERN_WARNING\n\t\t\t     \"sysfs group %p not found for kobject '%s'\\n\",\n\t\t\t     grp, kobject_name(kobj));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tkn = parent;\n\t\tkernfs_get(kn);\n\t}\n\n\tremove_files(kn, grp);\n\tif (grp->name)\n\t\tkernfs_remove(kn);\n\n\tkernfs_put(kn);\n}"
  },
  {
    "function_name": "sysfs_update_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "193-197",
    "snippet": "int sysfs_update_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\treturn internal_create_group(kobj, 1, grp);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_create_group",
          "args": [
            "kobj",
            "1",
            "grp"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "internal_create_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "89-123",
          "snippet": "static int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tWARN(1, \"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ?: \"\");\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\tkn = kernfs_create_dir(kobj->sd, grp->name,\n\t\t\t\t       S_IRWXU | S_IRUGO | S_IXUGO, kobj);\n\t\tif (IS_ERR(kn)) {\n\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\treturn PTR_ERR(kn);\n\t\t}\n\t} else\n\t\tkn = kobj->sd;\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\treturn error;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tWARN(1, \"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ?: \"\");\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\tkn = kernfs_create_dir(kobj->sd, grp->name,\n\t\t\t\t       S_IRWXU | S_IRUGO | S_IXUGO, kobj);\n\t\tif (IS_ERR(kn)) {\n\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\treturn PTR_ERR(kn);\n\t\t}\n\t} else\n\t\tkn = kobj->sd;\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_update_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\treturn internal_create_group(kobj, 1, grp);\n}"
  },
  {
    "function_name": "sysfs_create_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "155-173",
    "snippet": "int sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "kobj",
            "groups[i]"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "243-252",
          "snippet": "void sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "kobj",
            "groups[i]"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "155-173",
          "snippet": "int sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "sysfs_create_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "135-139",
    "snippet": "int sysfs_create_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\treturn internal_create_group(kobj, 0, grp);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_create_group",
          "args": [
            "kobj",
            "0",
            "grp"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "internal_create_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "89-123",
          "snippet": "static int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tWARN(1, \"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ?: \"\");\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\tkn = kernfs_create_dir(kobj->sd, grp->name,\n\t\t\t\t       S_IRWXU | S_IRUGO | S_IXUGO, kobj);\n\t\tif (IS_ERR(kn)) {\n\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\treturn PTR_ERR(kn);\n\t\t}\n\t} else\n\t\tkn = kobj->sd;\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\treturn error;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tWARN(1, \"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ?: \"\");\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\tkn = kernfs_create_dir(kobj->sd, grp->name,\n\t\t\t\t       S_IRWXU | S_IRUGO | S_IXUGO, kobj);\n\t\tif (IS_ERR(kn)) {\n\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\treturn PTR_ERR(kn);\n\t\t}\n\t} else\n\t\tkn = kobj->sd;\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_create_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\treturn internal_create_group(kobj, 0, grp);\n}"
  },
  {
    "function_name": "internal_create_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "89-123",
    "snippet": "static int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tWARN(1, \"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ?: \"\");\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\tkn = kernfs_create_dir(kobj->sd, grp->name,\n\t\t\t\t       S_IRWXU | S_IRUGO | S_IXUGO, kobj);\n\t\tif (IS_ERR(kn)) {\n\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\treturn PTR_ERR(kn);\n\t\t}\n\t} else\n\t\tkn = kobj->sd;\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\treturn error;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1144-1193",
          "snippet": "bool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_files",
          "args": [
            "kn",
            "kobj",
            "grp",
            "update"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "create_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "35-86",
          "snippet": "static int create_files(struct kernfs_node *parent, struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp, int update)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\tint error = 0, i;\n\n\tif (grp->attrs) {\n\t\tfor (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {\n\t\t\tumode_t mode = 0;\n\n\t\t\t/*\n\t\t\t * In update mode, we're changing the permissions or\n\t\t\t * visibility.  Do this by first removing then\n\t\t\t * re-adding (if required) the file.\n\t\t\t */\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\t\tif (grp->is_visible) {\n\t\t\t\tmode = grp->is_visible(kobj, *attr, i);\n\t\t\t\tif (!mode)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = sysfs_add_file_mode_ns(parent, *attr, false,\n\t\t\t\t\t\t       (*attr)->mode | mode,\n\t\t\t\t\t\t       NULL);\n\t\t\tif (unlikely(error))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error) {\n\t\t\tremove_files(parent, grp);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (grp->bin_attrs) {\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent,\n\t\t\t\t\t\t(*bin_attr)->attr.name);\n\t\t\terror = sysfs_add_file_mode_ns(parent,\n\t\t\t\t\t&(*bin_attr)->attr, true,\n\t\t\t\t\t(*bin_attr)->attr.mode, NULL);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\tremove_files(parent, grp);\n\t}\nexit:\n\treturn error;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic int create_files(struct kernfs_node *parent, struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp, int update)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\tint error = 0, i;\n\n\tif (grp->attrs) {\n\t\tfor (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {\n\t\t\tumode_t mode = 0;\n\n\t\t\t/*\n\t\t\t * In update mode, we're changing the permissions or\n\t\t\t * visibility.  Do this by first removing then\n\t\t\t * re-adding (if required) the file.\n\t\t\t */\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\t\tif (grp->is_visible) {\n\t\t\t\tmode = grp->is_visible(kobj, *attr, i);\n\t\t\t\tif (!mode)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = sysfs_add_file_mode_ns(parent, *attr, false,\n\t\t\t\t\t\t       (*attr)->mode | mode,\n\t\t\t\t\t\t       NULL);\n\t\t\tif (unlikely(error))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error) {\n\t\t\tremove_files(parent, grp);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (grp->bin_attrs) {\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent,\n\t\t\t\t\t\t(*bin_attr)->attr.name);\n\t\t\terror = sysfs_add_file_mode_ns(parent,\n\t\t\t\t\t&(*bin_attr)->attr, true,\n\t\t\t\t\t(*bin_attr)->attr.mode, NULL);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\tremove_files(parent, grp);\n\t}\nexit:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_warn_dup",
          "args": [
            "kobj->sd",
            "grp->name"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_warn_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
          "lines": "22-34",
          "snippet": "void sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nvoid sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_dir",
          "args": [
            "kobj->sd",
            "grp->name",
            "S_IRWXU | S_IRUGO | S_IXUGO",
            "kobj"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\"",
            "kobj->name",
            "grp->name ?: \"\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "update && !kobj->sd"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kobj || (!update && !kobj->sd)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic int internal_create_group(struct kobject *kobj, int update,\n\t\t\t\t const struct attribute_group *grp)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tBUG_ON(!kobj || (!update && !kobj->sd));\n\n\t/* Updates may happen before the object has been instantiated */\n\tif (unlikely(update && !kobj->sd))\n\t\treturn -EINVAL;\n\tif (!grp->attrs && !grp->bin_attrs) {\n\t\tWARN(1, \"sysfs: (bin_)attrs not set by subsystem for group: %s/%s\\n\",\n\t\t\tkobj->name, grp->name ?: \"\");\n\t\treturn -EINVAL;\n\t}\n\tif (grp->name) {\n\t\tkn = kernfs_create_dir(kobj->sd, grp->name,\n\t\t\t\t       S_IRWXU | S_IRUGO | S_IXUGO, kobj);\n\t\tif (IS_ERR(kn)) {\n\t\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\t\tsysfs_warn_dup(kobj->sd, grp->name);\n\t\t\treturn PTR_ERR(kn);\n\t\t}\n\t} else\n\t\tkn = kobj->sd;\n\tkernfs_get(kn);\n\terror = create_files(kn, kobj, grp, update);\n\tif (error) {\n\t\tif (grp->name)\n\t\t\tkernfs_remove(kn);\n\t}\n\tkernfs_put(kn);\n\treturn error;\n}"
  },
  {
    "function_name": "create_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "35-86",
    "snippet": "static int create_files(struct kernfs_node *parent, struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp, int update)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\tint error = 0, i;\n\n\tif (grp->attrs) {\n\t\tfor (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {\n\t\t\tumode_t mode = 0;\n\n\t\t\t/*\n\t\t\t * In update mode, we're changing the permissions or\n\t\t\t * visibility.  Do this by first removing then\n\t\t\t * re-adding (if required) the file.\n\t\t\t */\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\t\tif (grp->is_visible) {\n\t\t\t\tmode = grp->is_visible(kobj, *attr, i);\n\t\t\t\tif (!mode)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = sysfs_add_file_mode_ns(parent, *attr, false,\n\t\t\t\t\t\t       (*attr)->mode | mode,\n\t\t\t\t\t\t       NULL);\n\t\t\tif (unlikely(error))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error) {\n\t\t\tremove_files(parent, grp);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (grp->bin_attrs) {\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent,\n\t\t\t\t\t\t(*bin_attr)->attr.name);\n\t\t\terror = sysfs_add_file_mode_ns(parent,\n\t\t\t\t\t&(*bin_attr)->attr, true,\n\t\t\t\t\t(*bin_attr)->attr.mode, NULL);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\tremove_files(parent, grp);\n\t}\nexit:\n\treturn error;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_files",
          "args": [
            "parent",
            "grp"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "remove_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "21-33",
          "snippet": "static void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_add_file_mode_ns",
          "args": [
            "parent",
            "&(*bin_attr)->attr",
            "true",
            "(*bin_attr)->attr.mode",
            "NULL"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_add_file_mode_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/file.c",
          "lines": "238-305",
          "snippet": "int sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../kernfs/kernfs-internal.h\"",
            "#include \"sysfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kernfs_ops sysfs_file_kfops_empty = {\n};",
            "static const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};",
            "static const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};",
            "static const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};",
            "static const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../kernfs/kernfs-internal.h\"\n#include \"sysfs.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n\nstatic const struct kernfs_ops sysfs_file_kfops_empty = {\n};\nstatic const struct kernfs_ops sysfs_file_kfops_ro = {\n\t.seq_show\t= sysfs_kf_seq_show,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_file_kfops_rw = {\n\t.seq_show\t= sysfs_kf_seq_show,\n\t.write\t\t= sysfs_kf_write,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_ro = {\n\t.read\t\t= sysfs_kf_read,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_wo = {\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_prealloc_kfops_rw = {\n\t.read\t\t= sysfs_kf_read,\n\t.write\t\t= sysfs_kf_write,\n\t.prealloc\t= true,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_ro = {\n\t.read\t\t= sysfs_kf_bin_read,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_wo = {\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_rw = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n};\nstatic const struct kernfs_ops sysfs_bin_kfops_mmap = {\n\t.read\t\t= sysfs_kf_bin_read,\n\t.write\t\t= sysfs_kf_bin_write,\n\t.mmap\t\t= sysfs_kf_bin_mmap,\n};\n\nint sysfs_add_file_mode_ns(struct kernfs_node *parent,\n\t\t\t   const struct attribute *attr, bool is_bin,\n\t\t\t   umode_t mode, const void *ns)\n{\n\tstruct lock_class_key *key = NULL;\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_node *kn;\n\tloff_t size;\n\n\tif (!is_bin) {\n\t\tstruct kobject *kobj = parent->priv;\n\t\tconst struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;\n\n\t\t/* every kobject with an attribute needs a ktype assigned */\n\t\tif (WARN(!sysfs_ops, KERN_ERR\n\t\t\t \"missing sysfs attribute operations for kobject: %s\\n\",\n\t\t\t kobject_name(kobj)))\n\t\t\treturn -EINVAL;\n\n\t\tif (sysfs_ops->show && sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_rw;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_rw;\n\t\t} else if (sysfs_ops->show) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_ro;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_ro;\n\t\t} else if (sysfs_ops->store) {\n\t\t\tif (mode & SYSFS_PREALLOC)\n\t\t\t\tops = &sysfs_prealloc_kfops_wo;\n\t\t\telse\n\t\t\t\tops = &sysfs_file_kfops_wo;\n\t\t} else\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = PAGE_SIZE;\n\t} else {\n\t\tstruct bin_attribute *battr = (void *)attr;\n\n\t\tif (battr->mmap)\n\t\t\tops = &sysfs_bin_kfops_mmap;\n\t\telse if (battr->read && battr->write)\n\t\t\tops = &sysfs_bin_kfops_rw;\n\t\telse if (battr->read)\n\t\t\tops = &sysfs_bin_kfops_ro;\n\t\telse if (battr->write)\n\t\t\tops = &sysfs_bin_kfops_wo;\n\t\telse\n\t\t\tops = &sysfs_file_kfops_empty;\n\n\t\tsize = battr->size;\n\t}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (!attr->ignore_lockdep)\n\t\tkey = attr->key ?: (struct lock_class_key *)&attr->skey;\n#endif\n\tkn = __kernfs_create_file(parent, attr->name, mode & 0777, size, ops,\n\t\t\t\t  (void *)attr, ns, key);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, attr->name);\n\t\treturn PTR_ERR(kn);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "(*bin_attr)->attr.name"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grp->is_visible",
          "args": [
            "kobj",
            "*attr",
            "i"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "(*attr)->name"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic int create_files(struct kernfs_node *parent, struct kobject *kobj,\n\t\t\tconst struct attribute_group *grp, int update)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\tint error = 0, i;\n\n\tif (grp->attrs) {\n\t\tfor (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {\n\t\t\tumode_t mode = 0;\n\n\t\t\t/*\n\t\t\t * In update mode, we're changing the permissions or\n\t\t\t * visibility.  Do this by first removing then\n\t\t\t * re-adding (if required) the file.\n\t\t\t */\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\t\t\tif (grp->is_visible) {\n\t\t\t\tmode = grp->is_visible(kobj, *attr, i);\n\t\t\t\tif (!mode)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = sysfs_add_file_mode_ns(parent, *attr, false,\n\t\t\t\t\t\t       (*attr)->mode | mode,\n\t\t\t\t\t\t       NULL);\n\t\t\tif (unlikely(error))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error) {\n\t\t\tremove_files(parent, grp);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (grp->bin_attrs) {\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {\n\t\t\tif (update)\n\t\t\t\tkernfs_remove_by_name(parent,\n\t\t\t\t\t\t(*bin_attr)->attr.name);\n\t\t\terror = sysfs_add_file_mode_ns(parent,\n\t\t\t\t\t&(*bin_attr)->attr, true,\n\t\t\t\t\t(*bin_attr)->attr.mode, NULL);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error)\n\t\t\tremove_files(parent, grp);\n\t}\nexit:\n\treturn error;\n}"
  },
  {
    "function_name": "remove_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
    "lines": "21-33",
    "snippet": "static void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/err.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/module.h>",
      "#include <linux/kobject.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "(*bin_attr)->attr.name"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "parent",
            "(*attr)->name"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nstatic void remove_files(struct kernfs_node *parent,\n\t\t\t const struct attribute_group *grp)\n{\n\tstruct attribute *const *attr;\n\tstruct bin_attribute *const *bin_attr;\n\n\tif (grp->attrs)\n\t\tfor (attr = grp->attrs; *attr; attr++)\n\t\t\tkernfs_remove_by_name(parent, (*attr)->name);\n\tif (grp->bin_attrs)\n\t\tfor (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)\n\t\t\tkernfs_remove_by_name(parent, (*bin_attr)->attr.name);\n}"
  }
]